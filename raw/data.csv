repo,title,body,created_at,closed_at,issue_url,labels,additions,deletions,diff_file_name
ReactiveX/RxJava,2.x: Fix the error/race in Observable.repeatWhen due to flooding repeat signal,"This PR fixes a race condition in the `ObservableRepeatWhen` operator for the case when the repeat signal is not 1-for-1 and a new subscription may race with the clearing of the previous disposable because `active` is set to `false` too early. The fix is to swap the two operations. 

`Observable.retryWhen` and the `Flowable` versions do not have this bug. Unit tests were added to all 4 operators to verify the correct behavior regardless.

Fixes: #6358 ",2019-01-04 20:21:24,2019-01-04 23:39:21,https://api.github.com/repos/ReactiveX/RxJava/issues/6359,"['2.x', 'Bug']",229,1,ReactiveX_RxJava_pull_6359.diff
ReactiveX/RxJava,2.x: Disposable already set! using delaySubscription with takeUntil/repeatWhen,"When using a combination of `takeUntil`/`repeatWhen` operators on an `Observable` with `delaySubscription` operator applied, it is possible to encounter a `ProtocolViolationException: Disposable already set!` thrown by `RepeatWhenObserver#onSubscribe`. It appears that if `delaySubscription` uses an `ObservableSource` which rapidly/concurrently emits multiple notifications a rare race condition leads to a double subscription issue. 

I am not sure if this issue is a user error (`take(1)` on `ObservableSource` supplied to `delaySubscription` alleviates it) or a bug in RxJava hence me opening this PR with a slow test case that demonstrates this issue.
",2019-01-04 19:30:54,2019-01-04 19:39:29,https://api.github.com/repos/ReactiveX/RxJava/issues/6357,['Invalid'],59,0,ReactiveX_RxJava_pull_6357.diff
ReactiveX/RxJava,2.x: Improve TestScheduler Javadoc,"Resolves #6355 by improving TestScheduler Javadoc
",2019-01-04 01:37:31,2019-01-07 17:59:36,https://api.github.com/repos/ReactiveX/RxJava/issues/6356,"['2.x', 'Documentation']",54,3,ReactiveX_RxJava_pull_6356.diff
ReactiveX/RxJava,2.x: Update README,"This PR updates the [Converting to the desired type](https://github.com/ReactiveX/RxJava#converting-to-the-desired-type) section in the README to use [`Single::ignoreElement`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Single.html#ignoreElement--) instead of [`Single::toCompletable`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Single.html#toCompletable--) to convert a `Single` to a `Completable`. The reason for that is that the Javadoc mentions that `Single::toCompletable` is considered deprecated and `Single::ignoreElement` should be used instead.
",2019-01-02 15:47:17,2019-01-02 17:00:45,https://api.github.com/repos/ReactiveX/RxJava/issues/6353,"['2.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_6353.diff
ReactiveX/RxJava,Update outdated java example in wiki #6331,"Updated java example in docs/How-To-Use-RxJava.md file with java 8 version.

Resolves: #6331",2018-12-27 18:14:31,2018-12-28 22:11:53,https://api.github.com/repos/ReactiveX/RxJava/issues/6351,"['2.x', 'Documentation']",14,9,ReactiveX_RxJava_pull_6351.diff
ReactiveX/RxJava,Add peek operator like java 8 streams,I like the peek operator in Java 8 streams to provide a logging interface for streams or to apply to some static or global buffer etc.,2018-12-19 17:47:17,2018-12-19 18:48:47,https://api.github.com/repos/ReactiveX/RxJava/issues/6348,"['2.x', 'Feature-Request']",158,7,ReactiveX_RxJava_pull_6348.diff
ReactiveX/RxJava,Javadoc: fix examples using markdown instead of @code,"In javadoc, backtick has no meaning and caused javadoc compilation errors:

https://travis-ci.org/akarnokd/RxJava2_9/jobs/469904725#L516",2018-12-19 09:37:28,2018-12-24 14:40:50,https://api.github.com/repos/ReactiveX/RxJava/issues/6346,"['2.x', 'Documentation']",6,6,ReactiveX_RxJava_pull_6346.diff
ReactiveX/RxJava,Javadoc: Incorrect  Return Types in Javadoc Comments,"This PR fixes some mistakes in Javadoc comments of some methods inside `Flowable.java` and `Observable.java` where the actual return type differs from what is described in the documentation.

Relates to: #4535 
",2018-12-15 14:57:52,2018-12-19 09:57:55,https://api.github.com/repos/ReactiveX/RxJava/issues/6344,"['2.x', 'Documentation']",5,5,ReactiveX_RxJava_pull_6344.diff
ReactiveX/RxJava,2.x: Update Filtering Observables docs,"This PR updates the `Filtering-Observables.md` wiki page as per issue #6132:

- Update operator list
- Revised descriptions
- Add examples

The page now follows the structure that was defined in #6131.",2018-12-14 21:01:09,2018-12-19 09:41:10,https://api.github.com/repos/ReactiveX/RxJava/issues/6343,"['2.x', 'Documentation']",760,22,ReactiveX_RxJava_pull_6343.diff
ReactiveX/RxJava,[WIP] upgrade JDK9+,"Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [ ] Please give a description about what and why you are contributing, even if it's trivial.

  - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.
",2018-12-11 23:16:52,2018-12-11 23:41:14,https://api.github.com/repos/ReactiveX/RxJava/issues/6337,['Invalid'],12,6,ReactiveX_RxJava_pull_6337.diff
ReactiveX/RxJava,Replace indexed loop with for-each java5 syntax,"Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [ ] Please give a description about what and why you are contributing, even if it's trivial.

  - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.
",2018-12-09 23:05:13,2018-12-19 10:42:57,https://api.github.com/repos/ReactiveX/RxJava/issues/6335,"['2.x', 'Cleanup']",2,4,ReactiveX_RxJava_pull_6335.diff
ReactiveX/RxJava, #6323 Java 8 version for Problem-Solving-Examples-in-RxJava,"I am adding Java 8 version for Problem-Solving-Examples-in-RxJava. 
Please help me review. 
Thanks!
",2018-11-29 03:20:08,2018-12-10 09:18:16,https://api.github.com/repos/ReactiveX/RxJava/issues/6324,[],56,6,ReactiveX_RxJava_pull_6324.diff
ReactiveX/RxJava,Fix Flowable#toObservable backpressure support,Resolves #6320,2018-11-21 10:51:46,2018-11-23 07:41:08,https://api.github.com/repos/ReactiveX/RxJava/issues/6321,"['2.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_6321.diff
ReactiveX/RxJava,Change javadoc explanation for Mutable List,"As per [this](https://github.com/ReactiveX/RxJava/pull/6311#discussion_r234462497) discussion, change javadoc for `distinctUntilChanged()` method for Mutable List.",2018-11-19 10:29:15,2018-11-19 16:37:24,https://api.github.com/repos/ReactiveX/RxJava/issues/6314,[],6,6,ReactiveX_RxJava_pull_6314.diff
ReactiveX/RxJava,Adding NonNull annotations to Observable & Single,"Adding NonNull annotations in factory methods for improved code compilation

Resolves: #6309",2018-11-17 15:55:23,2018-12-19 10:23:44,https://api.github.com/repos/ReactiveX/RxJava/issues/6313,"['2.x', 'Enhancement']",503,0,ReactiveX_RxJava_pull_6313.diff
ReactiveX/RxJava,Javadoc: explain that distinctUntilChanged requires non-mutating data to work as expected,"- Add note in javadoc for all `distinctUntilChanged()` methods in `Flowable` and `Observable` class explaining about unexpected results to expect when using mutable data sources like **Mutable CharSequence** or **Lists**.

Resolves: #6290 ",2018-11-16 12:35:40,2018-11-16 17:00:18,https://api.github.com/repos/ReactiveX/RxJava/issues/6311,"['2.x', 'Documentation']",42,0,ReactiveX_RxJava_pull_6311.diff
ReactiveX/RxJava,Javadoc updates for RXJava Issue 6289,"Updates to io.reactivex.Flowable javadocs as per #6289. 
Updated docs for all 6 Flowable.groupBy(...) methods. 

",2018-11-16 06:39:12,2018-11-16 13:52:04,https://api.github.com/repos/ReactiveX/RxJava/issues/6308,"['2.x', 'Documentation']",47,0,ReactiveX_RxJava_pull_6308.diff
ReactiveX/RxJava,Javadoc : Explain explicitly about using Emitter interface methods synchronously,"Add note in Javadoc explicitly explaining about using Emitter interface methods synchronously.

- Add notes for `generate` methods in Observable and Flowable.
- Plus, add the similar note to Emitter interface.

Resolves: #6299 


",2018-11-13 13:13:18,2018-11-13 14:16:51,https://api.github.com/repos/ReactiveX/RxJava/issues/6305,"['2.x', 'Documentation']",55,0,ReactiveX_RxJava_pull_6305.diff
ReactiveX/RxJava,[Proposal] Remove CheckReturnValue on subscribe() overloads,"Proposal PR for my followup comment in https://github.com/ReactiveX/RxJava/issues/4878#issuecomment-437763406

Will close if the discussion raised there still settles on keeping them, just wanted to show a PoC of what the change scope would look like for reference.",2018-11-12 06:14:10,2018-12-03 03:46:52,https://api.github.com/repos/ReactiveX/RxJava/issues/6304,"['2.x', 'Discussion']",58,20,ReactiveX_RxJava_pull_6304.diff
ReactiveX/RxJava,Javadoc: Fix incorrect image placement,"Add `<p>` before image elements in Javadoc.

Resolves: #6302 
",2018-11-11 19:06:56,2018-11-11 20:58:03,https://api.github.com/repos/ReactiveX/RxJava/issues/6303,[],3,3,ReactiveX_RxJava_pull_6303.diff
ReactiveX/RxJava,Add missing onSubscribe null-checks to NPE docs on Flowable/Observable subscribe,Happened to notice these today,2018-11-11 05:54:25,2018-11-11 12:06:38,https://api.github.com/repos/ReactiveX/RxJava/issues/6301,[],4,2,ReactiveX_RxJava_pull_6301.diff
ReactiveX/RxJava,2.x: Fix refCount eager disconnect not resetting the connection,"This PR fixes the case when an observer/subscriber disposes/cancels immediately upon subscribing to a `refCount` operator before it establishes the connection and ends up with a disposed but non-reset connection, preventing further interactions with the connectable source.

The fix is to detect this case and reset the connection when the `connect()` method signals the dispose handler.

Both `ConnectableFlowable.refCount` and `ConnectableFlowable.refCount` is affected.

Fixes: #6296",2018-11-09 09:06:24,2018-11-12 09:26:15,https://api.github.com/repos/ReactiveX/RxJava/issues/6297,"['2.x', 'Bug']",55,2,ReactiveX_RxJava_pull_6297.diff
ReactiveX/RxJava,Fix the Multiple production threads cannot asynchronously invoke  synchronous delivery element methods at the same time,"When calling the generate method, when there are multiple threads that produce the delivery elements in the implementation logic of the Emitter, they cannot asynchronously call the synchronous delivery element method at the same time. Here, the error should be added to facilitate the developer to write the code bug. The problem is, a test is given later, temporarily written, you can refer to the operation.",2018-11-08 16:51:25,2018-11-08 17:19:10,https://api.github.com/repos/ReactiveX/RxJava/issues/6295,"['2.x', 'Invalid']",161,79,ReactiveX_RxJava_pull_6295.diff
ReactiveX/RxJava,2.x: Update Transforming Observables docs,"This PR updates the `Transforming-Observables.md` wiki page as per issue #6132:

- Add examples
- Revised descriptions
- Add more operators

The page now follows the structure that was defined in #6131 .
",2018-11-06 17:08:49,2018-11-12 08:54:07,https://api.github.com/repos/ReactiveX/RxJava/issues/6291,"['2.x', 'Documentation']",777,10,ReactiveX_RxJava_pull_6291.diff
ReactiveX/RxJava,2.x: Expose the Keep-Alive value of the IO Scheduler as System property. (#6279),"Configuring Keep-Alive through System property.

Resolves: #6279",2018-11-05 12:19:46,2018-11-05 12:41:01,https://api.github.com/repos/ReactiveX/RxJava/issues/6287,"['2.x', 'Enhancement']",10,1,ReactiveX_RxJava_pull_6287.diff
ReactiveX/RxJava,2.x: Fix Observable.flatMap to sustain concurrency level,"If the `Observable.flatMap` operator run in limited concurrency mode and multiple sources completed at the same time while the operator was in its drain loop, the operator only started with one new inner source instead of trying to run replace all the completed inner sources with new ones.

The solution is to count the completed sources and replenish them in a loop.

*(The `Flowable` variant works properly because it uses backpressure and inner source counting already to replenish those completed inner sources. The `Observable` doesn't have backpressure so it has to emulate it via the work-in-progress counting and the secondary queue for available inner sources.)*

Fixes: #6282",2018-11-01 22:56:21,2018-11-05 10:34:15,https://api.github.com/repos/ReactiveX/RxJava/issues/6283,"['2.x', 'Bug']",93,11,ReactiveX_RxJava_pull_6283.diff
ReactiveX/RxJava,"2.x: Add dematerialize(selector), deprecate old","This PR adds the `dematerialize(Function<T, Notification<R>> selector)` overload to allow type-safe dematerialization of `Notification` signals. The pre-existing `dematerialize()` forced the return type and assumed the items of the source are `Notification` objects, which could not be enforced via the type system. This selector variant establishes the type link from `T` to `Notification<R>` to `R` (where R == T is allowed).

The intended use is

```java
Observable<Notification<T>> source = ...

Observable<T> result = source.dematerialize(notification -> notification);
```

aka identity mapping.

The pre-existing `dematerialize()` methods are marked as deprecated now.

*(Also the actual operator were missing from the examples in the respective Javadocs).*",2018-11-01 21:35:41,2018-11-06 08:17:28,https://api.github.com/repos/ReactiveX/RxJava/issues/6281,"['2.x', 'Discussion', 'Enhancement']",335,41,ReactiveX_RxJava_pull_6281.diff
ReactiveX/RxJava,2.x: Improve the package docs of io.reactivex.schedulers,This adds some links to the important components within the package (allows faster navigation from the Overview page of the JavaDocs).,2018-11-01 20:09:47,2018-11-02 09:45:24,https://api.github.com/repos/ReactiveX/RxJava/issues/6280,"['2.x', 'Documentation']",4,2,ReactiveX_RxJava_pull_6280.diff
ReactiveX/RxJava, 2.x: Add materialize() and dematerialize(),"This PR adds the `materialize` operator to `Maybe`, `Single` and `Completable` to turn their signals into the corresponding `Notification` object. This operator has been available for `Observable`s (and `Flowable`s) from the beginning of the Rx API. The methods return `Single<Notification<T>>`.

To complement, the `dematerialize` operator is only defined for `Single` and results in a `Maybe`.

If accepted, I'll draw the correct marble diagrams for them in a separate PR.

Resolves: #6272",2018-11-01 14:25:08,2018-11-06 07:57:06,https://api.github.com/repos/ReactiveX/RxJava/issues/6278,"['2.x', 'Discussion', 'Enhancement']",685,1,ReactiveX_RxJava_pull_6278.diff
ReactiveX/RxJava,2.x: Improve the Observable/Flowable cache() operators,"This PR rewrites the `Observable.cache` and `Flowable.cache` operators to allocate less and be more up-to-date algorithmically.

I've also added comments to help understand its inner workings in case someone is interested.

Resolves: #6270",2018-10-31 10:51:18,2018-11-01 06:31:31,https://api.github.com/repos/ReactiveX/RxJava/issues/6275,"['2.x', 'Enhancement', 'Performance']",615,548,ReactiveX_RxJava_pull_6275.diff
ReactiveX/RxJava,Fix broken markdown,Fix broken mark down and change the link to CONTRIBUTING,2018-10-30 13:24:39,2018-10-30 14:44:24,https://api.github.com/repos/ReactiveX/RxJava/issues/6273,"['2.x', 'Documentation']",5,5,ReactiveX_RxJava_pull_6273.diff
ReactiveX/RxJava,2.x: Call the doOn{Dispose|Cancel} handler at most once,"This PR makes sure the `doOnDispose`, `doOnCancel` and `doOnLifecycle` execute their cancellation handler once.

Resolves: #6268.",2018-10-29 16:08:06,2018-10-29 17:17:14,https://api.github.com/repos/ReactiveX/RxJava/issues/6269,"['2.x', 'Shortcoming']",69,17,ReactiveX_RxJava_pull_6269.diff
ReactiveX/RxJava,2.x: Update Creating Observables docs,"This PR adds a link to the `generate` section to the outline and fixes a broken image link.

Relates to: #6260 
",2018-10-29 11:36:03,2018-10-29 12:30:47,https://api.github.com/repos/ReactiveX/RxJava/issues/6267,"['2.x', 'Documentation']",2,1,ReactiveX_RxJava_pull_6267.diff
ReactiveX/RxJava,2.x: Update Error Handling Operators docs,"This PR updates the `Error-Handling-Operators.md` wiki page as per issue #6132:

- Update operator list
- Add examples

The page now follows the structure that was defined in #6131.  
",2018-10-29 10:51:17,2018-10-30 15:20:47,https://api.github.com/repos/ReactiveX/RxJava/issues/6266,"['2.x', 'Documentation']",277,7,ReactiveX_RxJava_pull_6266.diff
ReactiveX/RxJava,Inline SubscriptionHelper.isCancelled(),Addresses https://github.com/ReactiveX/RxJava/pull/6258#discussion_r228725602,2018-10-28 04:12:34,2018-10-28 10:06:45,https://api.github.com/repos/ReactiveX/RxJava/issues/6263,[],12,20,ReactiveX_RxJava_pull_6263.diff
ReactiveX/RxJava,Use JUnit's assert format for assert messages to enable better suppor…,"This changes the message format of ""assert"" to match that of JUnit. This way IDEs like IntelliJ IDEA are able to parse it and offer functionality like ""compare values"".
",2018-10-26 12:08:08,2018-10-26 14:01:53,https://api.github.com/repos/ReactiveX/RxJava/issues/6262,"['2.x', 'Test']",10,10,ReactiveX_RxJava_pull_6262.diff
ReactiveX/RxJava,Add generate examples to Creating-Observables.md in Wiki,"Add documentation and example to the wiki for generate. 

Resolves: #6226
",2018-10-24 22:34:30,2018-10-26 07:32:27,https://api.github.com/repos/ReactiveX/RxJava/issues/6260,"['2.x', 'Documentation']",21,0,ReactiveX_RxJava_pull_6260.diff
ReactiveX/RxJava,2.x: Fix cancel/dispose upon upstream switch for some operators,"This PR extends the `SubscriptionArbiter` to optionally allow or disallow cancelling the current `Subscription` if it is replaced by a new one. Some operators do not need to cancel the current `Subscription`: `concat`, `concatMap`, `repeat`, `repeatWhen`, `retry` and `retryWhen`. 

In addition `repeatWhen` and `retryWhen` were cancelling when the handler sequence itself terminated. The code has been updated to disconnect the upstream upon the completion/failure but before signaling the handler.

The Reactive Streams specification also disallows synchronous cancellation after the terminal event anyway.

Others may actually need to cancel, such as `Timeout`. 

`Observable`s don't have a specific arbiter, they use the `DisposableHelper` methods and the relevant ones were changed to `replace()` instead of the disposing `set` call.

Some tests actually checking if the dispose/cancel happens and had to be updated.

The `Flowable.delaySubscription(Publisher)` also used `SubscriptionArbiter` but it was unnecessary. The code has been replaced with a more apt deferred requesting scheme as the downstream requests need to be delayed until the main subscription happens, the other publisher is always consumed unbounded.

Resolves: #6259",2018-10-24 13:33:59,2018-10-27 21:08:09,https://api.github.com/repos/ReactiveX/RxJava/issues/6258,"['2.x', 'Shortcoming']",920,98,ReactiveX_RxJava_pull_6258.diff
ReactiveX/RxJava,"2.x: Add Completable.delaySubscription marble, fix some javadoc","- Add marbles to the new `Completable.delaySubscription` operator.
- Fix the method name referenced in the `ConditionalSubscriber` javadoc.

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delaySubscription.t.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delaySubscription.ts.png)",2018-10-19 19:35:16,2018-10-19 20:16:33,https://api.github.com/repos/ReactiveX/RxJava/issues/6257,"['2.x', 'Documentation']",4,1,ReactiveX_RxJava_pull_6257.diff
ReactiveX/RxJava,"2.x: Cleanup code style, commas, spaces, docs","- Add missing spaces after commas and semicolons
- Add or fix first sentences without commas in javadocs",2018-10-19 09:29:11,2018-10-19 10:49:01,https://api.github.com/repos/ReactiveX/RxJava/issues/6255,"['2.x', 'Cleanup']",122,101,ReactiveX_RxJava_pull_6255.diff
ReactiveX/RxJava,"2.x: Fix flaky sample() backpressure test, improve coverage","Use processors to trigger the `MissingBackpressureException` case instead of the timer, which could fire prematurely and stop the sequence before the first item was sent by the `BehaviorProcessor`.

Also small improvements to the code coverage of `FlowableSample`.

Fixes #6253. ",2018-10-19 08:53:11,2018-10-19 10:26:01,https://api.github.com/repos/ReactiveX/RxJava/issues/6254,"['2.x', 'Coverage', 'Test']",29,5,ReactiveX_RxJava_pull_6254.diff
ReactiveX/RxJava,2.x: Expand and fix Completable.delaySubscription tests,"Expand, fix and move the tests of #6242 into a dedicated test file.",2018-10-19 08:32:44,2018-10-19 08:54:27,https://api.github.com/repos/ReactiveX/RxJava/issues/6252,"['2.x', 'Cleanup', 'Test']",169,65,ReactiveX_RxJava_pull_6252.diff
ReactiveX/RxJava,Add Nullable annotations for blocking methods in Completable,"
Just add @Nullable annotations to blockingGet() methods in Completable class.",2018-10-12 12:44:49,2018-10-12 17:07:35,https://api.github.com/repos/ReactiveX/RxJava/issues/6244,"['2.x', 'Cleanup']",2,0,ReactiveX_RxJava_pull_6244.diff
ReactiveX/RxJava,Add delaySubscription() methods to Completable #5081,"Since Observable, Single already have `delaySubscription()`, but Completable doesn't, I added these methods to the code.",2018-10-10 10:50:14,2018-10-19 08:16:05,https://api.github.com/repos/ReactiveX/RxJava/issues/6242,"['2.x', 'Enhancement']",119,2,ReactiveX_RxJava_pull_6242.diff
ReactiveX/RxJava,2.x Wiki: Remove mention of i.r.f.Functions,"The `io.reactivex.functions.Functions` utility method has been made internal a long ago and should not be mentioned.

Resolves: #6239",2018-10-09 12:39:56,2018-10-09 13:01:05,https://api.github.com/repos/ReactiveX/RxJava/issues/6241,"['2.x', 'Documentation']",1,3,ReactiveX_RxJava_pull_6241.diff
ReactiveX/RxJava,Implement ReplayBufferStrategy strategy for ReplaySubject,"With this pull request, I propose strategy design pattern for handling different policies to buffer onNext values of ReplaySubject. These strategies would be useful specifically in Android, and can replace LiveData behaviour on emitting buffered values to UI components after configuration changes. For instance, when a View is subscribed to its ViewModel, by ReplaySubject instead of LiveData, and user decide to rotate the View, the observers of View would be disposed and miss new events while rotating. Such event could be a response from server, then by ReplayBufferStrategy.NO_OBSERVER strategy after rotating, the View can be notified with the response of the server.  In this scenario, after subscribing all observers of View to ReplaySubject of ViewModel, the onNext must be called to clear the buffer.

Also there is ReplayBufferStrategy.NO_OBSERVER_EMIT_ONCE strategy, which is a consequence of adding ReplayBufferStrategy.NO_OBSERVER strategy. It would be useful if in the above example the View has exactly one observer, so after all subscription we don't need to call onNext to clear the buffer.

In case of any inappropriate or wrong code, please notify me to fix it. Thank you so much.",2018-10-05 09:02:12,2018-10-05 09:46:12,https://api.github.com/repos/ReactiveX/RxJava/issues/6238,[],897,21,ReactiveX_RxJava_pull_6238.diff
ReactiveX/RxJava,2.x: Adjust Undeliverable & OnErrorNotImpl message to use full inner exception,"With `UndeliverableException` and `OnErrorNotImplementedException`, the wrapped exception may not have a message and the top line simply contains an unhelpful `null`:

    io.reactivex.exceptions.UndeliverableException: The exception could not be delivered to the 
            consumer because it has already canceled/disposed the flow or the exception 
            has nowhere to go to begin with. Further reading: 
            https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling | null
        at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)
        at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter
            .onError(ObservableCreate.java:73)
        at io.reactivex.internal.operators.observable.ObservableCreate
            .subscribeActual(ObservableCreate.java:43)
        at io.reactivex.Observable.subscribe(Observable.java:12090)
     Caused by: java.io.InterruptedIOException
 
This PR adds the full `toString()` value of the wrapped exception to the main line. This is also more useful when the user posting the stacktrace doesn't provide the `Caused by:` part for some reason.",2018-10-03 16:43:07,2018-10-03 19:57:24,https://api.github.com/repos/ReactiveX/RxJava/issues/6236,"['2.x', 'Cleanup']",2,2,ReactiveX_RxJava_pull_6236.diff
ReactiveX/RxJava,Fix docs typos,"Fix typos in documentation.

~~I also fixed them in wiki, but since GitHub doesn't support wiki contributions I don't know how to proceed with the changes. They're in a separate [repo](https://github.com/m3sv/RxJava-wiki/commit/a1b88eb71bc68ca517cab11d1d5d68ed4c05a50d).~~
",2018-10-02 15:58:38,2018-10-02 16:16:16,https://api.github.com/repos/ReactiveX/RxJava/issues/6235,"['2.x', 'Cleanup', 'Documentation']",33,33,ReactiveX_RxJava_pull_6235.diff
ReactiveX/RxJava,Add timeout and unit to TimeoutException message,"This is a small enhancement to help with crash/log debugging.

Right now often times you get a stacktrace that points only to RxJava:

```java
java.util.concurrent.TimeoutException
        at
io.reactivex.internal.operators.flowable.FlowableTimeoutTimed$TimeoutSubscriber.onTimeout(FlowableTimeoutTimed.java:137)
        at
io.reactivex.internal.operators.flowable.FlowableTimeoutTimed$TimeoutTask.run(FlowableTimeoutTimed.java:169)
        at
io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)
        at
io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)
        at java.util.concurrent.FutureTask.run(FutureTask.java:266)
        at
java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
        at
java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
        at
java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at java.lang.Thread.run(Thread.java:748) 
```

Adding `timeout` and `unit` values can help find related user code faster.

I'm not advocating for particular message, it can be something even shorter, like `$timeout $unit`. 

It can also be extracted in a method if you see value in that. ",2018-10-01 08:32:16,2018-10-02 07:52:43,https://api.github.com/repos/ReactiveX/RxJava/issues/6234,"['2.x', 'Enhancement']",125,55,ReactiveX_RxJava_pull_6234.diff
ReactiveX/RxJava,2.x: Cleanup Observable.flatMap drain logic,"Cleanup the drain logic of `Observable.flatMap` by removing unnecessary loops and fixing the index management in case of a fused failure in one of the sources triggering another round over the same source unnecessarily.

Resolves: #6231",2018-09-30 09:08:16,2018-09-30 09:38:07,https://api.github.com/repos/ReactiveX/RxJava/issues/6232,"['2.x', 'Cleanup']",55,28,ReactiveX_RxJava_pull_6232.diff
ReactiveX/RxJava,Removed an unnecessary if statement.," I found this unnecessary if statement.
",2018-09-29 06:19:43,2018-09-29 08:16:13,https://api.github.com/repos/ReactiveX/RxJava/issues/6230,"['2.x', 'Invalid']",0,3,ReactiveX_RxJava_pull_6230.diff
ReactiveX/RxJava,Fix typos,- Remove space and semicolon on README.md page,2018-09-23 11:22:44,2018-09-23 12:12:57,https://api.github.com/repos/ReactiveX/RxJava/issues/6223,"['2.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_6223.diff
ReactiveX/RxJava,Fix typos,  - Remove space and semicolon on README.md page ,2018-09-23 10:47:04,2018-09-23 11:23:36,https://api.github.com/repos/ReactiveX/RxJava/issues/6222,"['2.x', 'Documentation']",1,2,ReactiveX_RxJava_pull_6222.diff
ReactiveX/RxJava,2.x JavaDocs: Remove unnecessary 's' from ConnectableObservable,Remove the unnecessary 's' from the JavaDocs of `ConnectableObservable.autoConnect`.,2018-09-21 17:38:36,2018-09-21 18:13:26,https://api.github.com/repos/ReactiveX/RxJava/issues/6220,"['2.x', 'Cleanup', 'Documentation']",3,3,ReactiveX_RxJava_pull_6220.diff
ReactiveX/RxJava,Zip and ZipWith across operators,"1. Adding zip with delayError for 3,4,5,6,7,8,9 source in Observable
2. Adding zip with delayError and bufferSize for 3,4,5,6,7,8,9 source in Observable
3. Adding zip with delayError for 3,4,5,6,7,8,9 source in Flowable
4. Adding zip with delayError and bufferSize for 3,4,5,6,7,8,9 source in Flowable
5. Adding zipWith with 2,3,4,5,6,7,8 source in Observable
6. Adding zipWith with 2,3,4,5,6,7,8 source in Flowable
7. Adding zipWith with 2,3,4,5,6,7,8 source in Single
8. Adding zipWith with 2,3,4,5,6,7,8 source in Maybe
9. Adding zipWith delayError with 2,3,4,5,6,7,8 source in Observable
10. Adding zipWith delayError and bufferSize with 2,3,4,5,6,7,8 source in Observable
11. Adding zipWith delayError with 2,3,4,5,6,7,8 source in Flowable
12. Adding zipWith delayError and bufferSize with 2,3,4,5,6,7,8 source in Flowable
13. Hope i helped with my contribution
14. Thank you for the opportunity",2018-09-18 19:12:35,2018-09-18 20:06:42,https://api.github.com/repos/ReactiveX/RxJava/issues/6217,"['2.x', 'Feature-Request']",1155,4,ReactiveX_RxJava_pull_6217.diff
ReactiveX/RxJava,Zip and ZipWith across operators ,"1. Adding zip with delayError for 3,4,5,6,7,8,9 source in Observable
2. Adding zip with delayError and bufferSize for 3,4,5,6,7,8,9 source in Observable
3. Adding zip with delayError for 3,4,5,6,7,8,9 source in Flowable
4. Adding zip with delayError and bufferSize for 3,4,5,6,7,8,9 source in Flowable
5. Adding zipWith with 2,3,4,5,6,7,8 source in Observable
6. Adding zipWith with 2,3,4,5,6,7,8 source in Flowable
7. Adding zipWith with 2,3,4,5,6,7,8 source in Single
8. Adding zipWith with 2,3,4,5,6,7,8 source in Maybe
9. Adding zipWith delayError with 2,3,4,5,6,7,8 source in Observable
10. Adding zipWith delayError and bufferSize with 2,3,4,5,6,7,8 source in Observable
11. Adding zipWith delayError with 2,3,4,5,6,7,8 source in Flowable
12. Adding zipWith delayError and bufferSize with 2,3,4,5,6,7,8 source in Flowable
Hope i helped with my contribution 
Thank you for the opportunity ",2018-09-18 17:57:34,2018-09-18 18:49:04,https://api.github.com/repos/ReactiveX/RxJava/issues/6216,[],1175,4,ReactiveX_RxJava_pull_6216.diff
ReactiveX/RxJava,2.x: Add Observable.distinctOfGroup(count) operator,"Add 2 operators for Observable:
- distinctOfGroup(int count):
- distinctOfGroup(int count, Function<? super T, K> keySelector):

Works as a distinctUntilChanged operator, but not for one last element, but for a group of last elements.

Based on fixed size queue-collection (Functions.java):

```
    static final class FixedQueueCallable<T>
            implements Callable<Queue<T>> {
        final int capacity;

        FixedQueueCallable(int capacity) {
            this.capacity = capacity;
        }

        @Override
        public Queue<T> call() throws Exception {
            return new LinkedList<T>() {
                @Override
                public boolean add(T t) {
                    boolean retVal = contains(t);

                    if (size() >= capacity) {
                        removeFirst();
                    }
                    addLast(t);

                    return !retVal;
                }
            };
        }
    }

    public static <T> Callable<Queue<T>> createFixedQueue(int capacity) {
        return new FixedQueueCallable<T>(capacity);
    }
```",2018-09-17 20:23:13,2018-09-17 21:58:35,https://api.github.com/repos/ReactiveX/RxJava/issues/6215,"['2.x', 'Feature-Request']",164,0,ReactiveX_RxJava_pull_6215.diff
ReactiveX/RxJava,Added 11 shortcuts for Completable.andThen operator,"Added 11 shortcuts for Completable.andThen operator:

1) Completable andThen(Action run)
2) Single<T> andThenSingle(Callable<T> callable)
3) Observable<T> andThenObservable(Iterable<T> iterable)
4) Observable<T> andThenObservable(ObservableOnSubscribe<T> source)
5) Observable<T> andThenObservable(Callable<T> callable)
6) Flowable<T> andThenFlowable(Iterable<T> iterable)
7) Flowable<T> andThenFlowable(BackpressureStrategy mode, FlowableOnSubscribe<T> source)
8) Flowable<T> andThenFlowable(Callable<T> callable)
9) Maybe<T> andThenMaybe(Callable<T> callable)
10) Maybe<T> andThenMaybe(Runnable run)
11) Maybe<T> andThenMaybe(Action run)

The purpose of this pull request is to shorten Completable sequences:

```
public Single<String> saveApiKey(String key, String secret) {
    return api.registerApi(key, secret)
            .andThen(Completable.fromAction(() -> {
                Preferences.saveApiKey(key);
                Preferences.saveApiSecret(secret);
            }))
            .andThen(Single.fromCallable(() -> {
                String encryptedKey = CryptoUtil.encrypt(key);
                String encryptedSecret = CryptoUtil.encrypt(secret);
					
                return encryptedKey + "":"" + encryptedSecret;
            }))
            .flatMap(api::registerApplication);
} 
```

Above code can be shortened:
```
public Single<String> saveApiKey(String key, String secret) {
    return api.registerApi(key, secret)
            .andThen(() -> {
                Preferences.saveApiKey(key);
                Preferences.saveApiSecret(secret);
            })
            .andThenSingle(() -> {
                String encryptedKey = CryptoUtil.encrypt(key);
                String encryptedSecret = CryptoUtil.encrypt(secret);
					
                return encryptedKey + "":"" + encryptedSecret;
            })
            .flatMap(api::registerApplication);
} 
```

In Kotlin this looks even more cleaner:
```
fun saveApiKey(key: String, secret: String): Single<String> 
    = api.registerApi(key, secret)
            .andThen {
                Preferences.saveApiKey(key)
                Preferences.saveApiSecret(secret)
            }
            .andThenSingle { ""${CryptoUtil.encrypt(key)}:${CryptoUtil.encrypt(secret)}"" }
            .flatMap(api::registerApplication)

```

Since this is only a shortcuts (no new logic is provided in this pull request) I don't think that unit test are necessary.
",2018-09-13 10:01:15,2018-09-13 10:06:07,https://api.github.com/repos/ReactiveX/RxJava/issues/6211,"['2.x', 'Feature-Request']",252,0,ReactiveX_RxJava_pull_6211.diff
ReactiveX/RxJava,2.x: Assert instead of print Undeliverable in some tests,Set plugin error tracking in some tests to avoid printing out `UndeliverableExceptions` (sometimes repeatedly in race tests) and assert the specific exception(s) instead.,2018-09-07 12:22:06,2018-09-07 13:00:31,https://api.github.com/repos/ReactiveX/RxJava/issues/6205,"['2.x', 'Cleanup', 'Test']",271,176,ReactiveX_RxJava_pull_6205.diff
ReactiveX/RxJava,2.x: Fix toFuture marbles and descriptions,"This PR fixes the marble diagrams of `Flowable.toFuture` and `Observable.toFuture` to indicate:

- multi-valued sources signal `IndexOutOfBoundsException`
- Source has to be finite for the `Future` to terminate.

![image](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/Flowable.toFuture.png)
![image](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/toFuture.o.png)


Resolves #6198

(also fixes the diagram for #5813).",2018-09-04 07:55:26,2018-09-04 08:28:24,https://api.github.com/repos/ReactiveX/RxJava/issues/6200,"['2.x', 'Documentation']",12,10,ReactiveX_RxJava_pull_6200.diff
ReactiveX/RxJava,Fix terminology of cancel/dispose in the JavaDocs,"Resolves #6196

Changing terminology from cancel -> dispose wherever appropriate in the following classes:

- `Observable.java`
- `Single.java`
- `Maybe.java`
- `Completable.java`

Areas where I did _not_ change from cancel -> disposal include: 

- where the cancellation was in reference to a `Flowable`, `Publisher`, or a `Future`
- `test()` methods where the `TestObserver` returned actually has a `cancel()` method",2018-09-03 22:32:53,2018-09-04 16:08:07,https://api.github.com/repos/ReactiveX/RxJava/issues/6199,"['2.x', 'Documentation']",92,92,ReactiveX_RxJava_pull_6199.diff
ReactiveX/RxJava,#6195 Fix Flowable.reduce(BiFunction) JavaDoc,"Empty source does not signal NoSuchElementException.

Resolves #6195 ",2018-09-03 11:50:13,2018-09-03 12:05:59,https://api.github.com/repos/ReactiveX/RxJava/issues/6197,"['2.x', 'Documentation']",0,2,ReactiveX_RxJava_pull_6197.diff
ReactiveX/RxJava,"Add ""error handling"" java docs section to from callable & co","Resolves #6179

Added JavaDocs describing the regular and canceled/disposed behavior for

- `Observable.fromCallable()`
- `Single.fromCallable()`
- `Maybe.fromAction()`
- `Completable.fromCallable()`
- `Completable.fromAction()`
- `Flowable.fromCallable()`

Did not alter `Maybe.fromCallable()` because the existing JavaDoc appears to be adequate.",2018-09-02 01:47:32,2018-09-03 12:33:37,https://api.github.com/repos/ReactiveX/RxJava/issues/6193,"['2.x', 'Documentation']",42,1,ReactiveX_RxJava_pull_6193.diff
ReactiveX/RxJava,2.x: Fix refCount termination-reconnect race,"This PR modifies the `refCount` operator (in both `Flowable` and `Observable` types) to avoid certain termination-reconnection races.

The original race could happen when the refCounted source terminated at the same time as new observers arrived, leaving those new observers hanging as they practically joined a dying connection and got possibly undercut by the `dispose` call.

The change involve a new internal interface `ResettableConnection` that will allow resetting the connection object inside the connectable source if it is equal to the connection object known by the initiator of the original `connect` call.

Fixes #6185 ",2018-08-30 10:28:40,2018-08-30 13:29:59,https://api.github.com/repos/ReactiveX/RxJava/issues/6187,"['2.x', 'Bug']",229,32,ReactiveX_RxJava_pull_6187.diff
ReactiveX/RxJava,Documentation and custom ErrorHandler for Single.fromCallable(.),"Relating to #6178, a proposal for a solution containing a custom ErrorHandler.

- Added doc for Single.fromCallable(.) to clarify on handling of
UndeliverableExceptions.
- Proposing custom ErrorHandler for Single.fromCallable to have a more
granular Interface than just to have some global RxJavaPlugins class,
which handles UndeliverableExceptions. They shouldn't be swallowed, if
they aren't expected, but for expected ones, it should be possible to
handle them individually.

If approved, this should be extended to Observable, etc.

Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [ ✔ ] Please give a description about what and why you are contributing, even if it's trivial.

  - [ ✔ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [ ✔ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.
",2018-08-28 15:10:00,2018-08-28 16:26:25,https://api.github.com/repos/ReactiveX/RxJava/issues/6183,"['2.x', 'Documentation', 'Feature-Request']",117,9,ReactiveX_RxJava_pull_6183.diff
ReactiveX/RxJava,2.x: Cleanup multiple empty lines in sources,Remove 2+ empty lines from the sources.,2018-08-28 14:30:08,2018-08-28 15:33:11,https://api.github.com/repos/ReactiveX/RxJava/issues/6182,"['2.x', 'Cleanup']",134,277,ReactiveX_RxJava_pull_6182.diff
ReactiveX/RxJava,Update Additional-Reading.md,"Check existing links, add new links about RxAndroid #6132
",2018-08-28 08:02:38,2018-08-28 08:54:20,https://api.github.com/repos/ReactiveX/RxJava/issues/6180,['Documentation'],27,15,ReactiveX_RxJava_pull_6180.diff
ReactiveX/RxJava,2.x: explain null observer/subscriber error reports in detail from RxJavaPlugins,"This PR is related to issue [#6172](https://github.com/ReactiveX/RxJava/issues/6172).
With these changes, all reactive types will emit detailed error message when `onSubscribe` hook installed using RxJavaPlugins returns null `observer/subscriber`:

**Observable**
> ""The RxJavaPlugins.onSubscribe hook returned a null Observer. Please check the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins""

**Flowable**
> The RxJavaPlugins.onSubscribe hook returned a null FlowableSubscriber. Please check the handler provided to RxJavaPlugins.setOnFlowableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins

**Single**
> The RxJavaPlugins.onSubscribe hook returned a null SingleObserver. Please check the handler provided to RxJavaPlugins.setOnSingleSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins

**Maybe**
> The RxJavaPlugins.onSubscribe hook returned a null MaybeObserver. Please check the handler provided to RxJavaPlugins.setOnMaybeSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins

**Completable**
> The RxJavaPlugins.onSubscribe hook returned a null CompletableObserver. Please check the handler provided to RxJavaPlugins.setOnCompletableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins


**Note :** 
There was no null check on `observer` returned from `RxJavaPlugins.onSubscribe(this, observer)` method call in `Completable`'s subscribe() method. 
So, I've added it in this PR. Is that fine? 
",2018-08-26 10:58:31,2018-08-26 11:14:52,https://api.github.com/repos/ReactiveX/RxJava/issues/6175,[],8,6,ReactiveX_RxJava_pull_6175.diff
ReactiveX/RxJava,Auto-clean up RxJavaPlugins JavaDocs HTML (#6173),"Add 'plugins/RxJavaPlugins.html' to the javadocCleanup task in javadoc_cleanup.gradle. 

Resolves: #6173 ",2018-08-25 23:14:54,2018-08-26 08:42:57,https://api.github.com/repos/ReactiveX/RxJava/issues/6174,[],1,0,ReactiveX_RxJava_pull_6174.diff
ReactiveX/RxJava,2.x: Add explanation text to Undeliverable & OnErrorNotImplemented exs,"This PR adds detailed error message to the `UndeliverableException` and `OnErrorNotImplementedException` as they are the most common exception-related questions around.

#### UndeliverableException

> The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with. Further reading: https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling | `<original exception message>`

#### OnErrorNotImplementedException

> The onError handler in the subscribe() method is not provided. Please specify it to avoid this type of exception. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | `<original exception message>`
",2018-08-24 09:31:30,2018-08-25 07:53:05,https://api.github.com/repos/ReactiveX/RxJava/issues/6171,"['2.x', 'Enhancement']",4,3,ReactiveX_RxJava_pull_6171.diff
ReactiveX/RxJava,2.x: cleanup newline separation,,2018-08-23 06:16:56,2018-08-23 07:56:15,https://api.github.com/repos/ReactiveX/RxJava/issues/6168,[],0,2,ReactiveX_RxJava_pull_6168.diff
ReactiveX/RxJava,2.x: Make observeOn not let worker.dispose() called prematurely,"Some operators may call `dispose()`/`cancel` from `onError`/`onComplete` which could trigger a permature call to `worker.dispose()` that was about to happen anyway. This PR prevents this by moving the operator into its disposed/cancelled state before signaling the terminal event, thus a downstream `cancel()`/`dispose()` call won't trigger this premature cleanup.

Such premature cleanups may cause unwanted `Schedulers.io()` reuse in some scenarios.

Related: #6146",2018-08-22 11:32:46,2018-08-22 14:58:18,https://api.github.com/repos/ReactiveX/RxJava/issues/6167,"['2.x', 'Shortcoming']",281,11,ReactiveX_RxJava_pull_6167.diff
ReactiveX/RxJava,Error handle on Completable.fromCallable with RxJavaPlugins,,2018-08-21 17:33:59,2018-08-21 17:56:59,https://api.github.com/repos/ReactiveX/RxJava/issues/6165,"['2.x', 'Shortcoming']",3,0,ReactiveX_RxJava_pull_6165.diff
ReactiveX/RxJava,2.x: Make Flowable.fromCallable consistent with the other fromCallables,"`Flowable.fromCallable` is one of [the oldest](https://github.com/ReactiveX/RxJava/commits/2.x/src/main/java/io/reactivex/internal/operators/flowable/FlowableFromCallable.java) 2.x operators and was overlooked when the handling of beyond-cancellation error delivery, aka the undeliverable exception handling was implemented across RxJava. This PR resolves this shortcoming by making it consistent with its sibling implementations.

Resolves: #6156",2018-08-14 11:59:25,2018-08-14 12:53:55,https://api.github.com/repos/ReactiveX/RxJava/issues/6158,"['2.x', 'Shortcoming']",34,2,ReactiveX_RxJava_pull_6158.diff
ReactiveX/RxJava,2.x: Fix marble of Maybe.flatMap events to MaybeSource,"Fix the marble diagram of the event-mapping [`Maybe.flatMap`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Maybe.html#flatMap-io.reactivex.functions.Function-io.reactivex.functions.Function-java.util.concurrent.Callable-) operator:

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMap.mmm.png)

Tracked in: #5806",2018-08-10 09:26:33,2018-08-10 10:08:24,https://api.github.com/repos/ReactiveX/RxJava/issues/6155,"['2.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_6155.diff
ReactiveX/RxJava,2.x: Add Maybe.flatMap that maps signal types to Singles,"This PR proposes a new `flatMap` overload for `Maybe` that maps the upstream event types, `onSuccess`, `onError` or `onComplete` into a `SingleSource` and relays its signal to the downstream.

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMap.sss.png)

There is already a variant for Maybe -> Maybe flatMapping of event types.

I'm not 100% convinced the need for such an operator and could lead to all sorts of cross-mapping operators `Maybe -> Completable`, `Maybe -> Observable`, `Maybe -> Flowable`, as well as operators on the other reactive classes.

The alternative is to convert either the upstream and/or convert the mapped inner source to the right type.

Requested in: #5973",2018-08-10 09:17:05,2018-08-20 20:44:40,https://api.github.com/repos/ReactiveX/RxJava/issues/6154,"['2.x', 'Feature-Request']",423,0,ReactiveX_RxJava_pull_6154.diff
ReactiveX/RxJava,2.x: Clarify TestObserver.assertValueSet in docs and via tests,"Clarify that `{TestObserver|TestSubscriber}.assertValueSet` checks for all received items to be in the provided set, but that set can contain additional elements that could have been received. Unit tests have been added to demonstrate the expected behavior.

Resolves: #6151.",2018-08-10 07:21:00,2018-08-10 08:15:22,https://api.github.com/repos/ReactiveX/RxJava/issues/6152,"['2.x', 'Documentation']",75,2,ReactiveX_RxJava_pull_6152.diff
ReactiveX/RxJava,"2.x: cleanup newline separation, some field namings","This PR cleans up some source code style inconsistencies:

- Rename some atomic-subscription fields to `upstream` (left out from #6129).
- Make sure `@Test` methods are separated by at most one empty newline
- Make sure a closing curly brace and an annotation is only followed by one empty newline.
- Add a test that checks for the above.",2018-08-09 13:49:31,2018-08-09 14:35:13,https://api.github.com/repos/ReactiveX/RxJava/issues/6150,"['2.x', 'Cleanup']",607,262,ReactiveX_RxJava_pull_6150.diff
ReactiveX/RxJava,Grammar fix in README Scheduler description,Scheduler description is grammatically error. Replaced **an unifrom** with **a uniform**.,2018-08-09 07:23:25,2018-08-09 07:54:36,https://api.github.com/repos/ReactiveX/RxJava/issues/6149,"['2.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_6149.diff
ReactiveX/RxJava,feat: add support for just operator,"just operator was overloaded to support maximum 10 items

replaced all the overloaded methods with a method which supports varargs so that just operator can take any number of value supported by java varargs, not just 10.",2018-08-08 13:58:51,2018-08-08 14:09:10,https://api.github.com/repos/ReactiveX/RxJava/issues/6148,['Invalid'],3405,4524,ReactiveX_RxJava_pull_6148.diff
ReactiveX/RxJava,2.x: Fix boundary fusion of concatMap and publish operator,"This PR fixes the lack of boundary fusion marker in the `concatMap` and `publish` operators that can break the thread-confinement expectation when using `observeOn` upstream and a thread-sensitive operator:

```java
source.observeOn(scheduler)
    .map(/* some thread-sensitive operation */)
    .publish() // or concatMap
```

By default, these operators may call `poll` from any of the participating threads which would otherwise dequeue `observeOn` and execute `map` on that thread.

The fix adds the necessary flag to both operator's `onSubscribe` logic. For a temporary workaround, one should use `hide()` before such operators to make sure fusion doesn't happen.

Fixes: #6144",2018-08-07 19:56:58,2018-08-08 07:42:26,https://api.github.com/repos/ReactiveX/RxJava/issues/6145,"['2.x', 'Bug']",164,9,ReactiveX_RxJava_pull_6145.diff
ReactiveX/RxJava,2.x: Add concatArrayEagerDelayError operator (expose feature),"This PR exposes the existing `delayError` capability of the `concatMapEager` operator as `concatArrayEagerDelayError` for both `Flowable` and `Observable`.

In addition, the `concatArrayEager` and these new methods receive marble diagrams:

#### Observable

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEager.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEager.nn.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEagerDelayError.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEagerDelayError.nn.png)

#### Flowable

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEager.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEager.nn.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEagerDelayError.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEagerDelayError.nn.png)

Resolves: #6082 

*(Sidenote: one of the validators had to be adjusted due to false positive it produced.)*",2018-08-06 09:42:58,2018-08-07 06:57:13,https://api.github.com/repos/ReactiveX/RxJava/issues/6143,"['2.x', 'Documentation', 'Enhancement']",348,11,ReactiveX_RxJava_pull_6143.diff
ReactiveX/RxJava,Add marble diagrams for various Single operators,"Here are marble diagrams for various Single operators that will close some of the #5788 

Marble for `concatEager(Publisher)`
![concateEagerP](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/concatEagerPublisher.png)

Marble for `concatEager(Iterable)`
![concateEagerI](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/concatEagerIterable.png)

Marble for `create`
![create](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/create.png)

Marble for `ambWith`
![ambWith](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/ambWith.png)

Marble for `equals`
![equals](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/equals.png)

Marble for `merge(source1, source2)`
![merge](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/mergeTwo.png)

Marble for `merge(source1, source2, source3)`
![mergeThree](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/mergeThree.png)

Marble for `merge(source1, source2, source3, source4)`
![mergeFour](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/mergeFour.png)

Marble for `merge(SingleSource<SingleSource>)`
![mergeSingleSource](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/mergeSingleSource.png)

Marble for `mergeWith`
![mergeWith](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/mergeWith.png)

Marble for `doAfterTerminate`
![doAfterTerminate](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/doAfterTerminate.png)

Marble for `to`
![to](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/to.png)

Marble for `as`
![as](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/as.png)

Marble for `compose`
![compose](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/compose.png)

Marble for `doAfterSuccess`
![doAfterSuccess](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/doAfterSuccess.png)

Marble for `merge(Publisher)`
![mergePublisher](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/mergePublisher.png)

Marble for `merge(Iterable)`
![mergeIterable](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/mergeIterable.png)",2018-08-05 20:05:00,2018-08-05 20:40:17,https://api.github.com/repos/ReactiveX/RxJava/issues/6141,"['2.x', 'Documentation']",34,9,ReactiveX_RxJava_pull_6141.diff
ReactiveX/RxJava,2.x: Update Mathematical and Aggregate Operators docs,"This PR updates the `Mathematical-and-Aggregate-Operators.md` wiki page as per issue #6132:
  
  - Remove obsolete operators
  - Link to the [RxJava2Extensions](https://github.com/akarnokd/RxJava2Extensions) project
  - Add examples

The page now follows the structure that was defined in #6131.

__Question__: Should __Available in__ in the *Mathematical Operators* section be renamed to something else (e.g. __Defined for__), because the operators are not part of the core RxJava operators?
",2018-08-05 14:44:18,2018-08-05 18:28:03,https://api.github.com/repos/ReactiveX/RxJava/issues/6140,"['2.x', 'Documentation']",366,25,ReactiveX_RxJava_pull_6140.diff
ReactiveX/RxJava,2.x: Add marbles for Single.concat operator,"Here are marbles for `concat(Iterable)`, `concat(Publisher)`, `concat(Publisher, prefetch)`, `concat(Observable)`,  `concat(source1, source2)`, `concat(source1, source2, source3)`, `concat(source1, source2, source3, source4)` and `concatArray` operators that should close them at #5788 .

Marble for `concat(Iterable)`
![concatIterable](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/concatIterable.png)

Marble for `concat(Publisher)`
![concatPublisher](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/concatPublisher.png)

Marble for `concat(Publisher, prefetch)`
![concatPublisherN](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/concatPublisherPrefetch.png)

Marble for `concat(Observable)`
![concatObservable](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/concatObservable.png)

Marble for `concat(source1, source2)`
![concat2](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/concatTwo.png)

Marble for `concat(source1, source2, source3)`
![concat3](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/concatThree.png)

Marble for `concat(source1, source2, source3, source4)`
![concat4](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/concatFour.png)

Marble for `concatArray`
![concatArray](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/concatArray.png)

Please pay attention to file names in javadoc as I was not sure how to name `concat(Iterable)` so I've added at the end `i`, for `concat(Observable)` I've added `o`. For `concat(source1, source2, source3)` and `concat(source1, source2, source3, source4)` I've used `n` and `m` as they are numerical values.

Also, is there an error in `concat(Publisher)` and `concat(Publisher, prefetch)` with `request()` commands? I did used as a reference `Completable.concat(Publisher)` marble but I do not understand why do we have `request(1)` after first event as we already requested prefetching of multiple ones. Is it because others are still not produced?

Thanks",2018-08-04 22:49:04,2018-08-05 12:31:08,https://api.github.com/repos/ReactiveX/RxJava/issues/6137,"['2.x', 'Documentation']",13,3,ReactiveX_RxJava_pull_6137.diff
ReactiveX/RxJava,2.x: Update Getting started docs,"This patch the following changes to the Getting started docs as per Issue No: #6132 
- Remove Troubleshooting guide
- Bump RxJava versions to 2.2.0 for Gradle, Maven etc.

Questions: 
- ~Looks like JFrog for RxJava 2 is broken or invalid now. Can we add Jitpack?~
- Need suggestions for `Getting started from readme.md`. Although, `How to use RxJava` or `Alphabetical List of Operators`, `Additional-Reading.md` can be great next steps. ",2018-08-04 18:43:19,2018-08-05 08:01:52,https://api.github.com/repos/ReactiveX/RxJava/issues/6136,"['2.x', 'Documentation']",24,39,ReactiveX_RxJava_pull_6136.diff
ReactiveX/RxJava,Initial clean up for Combining Observables docs,"This patch updates the style of the combining observables documentation to be similar to that of #6131 and adds examples for most of the operators therein. Refs #6132.

What's left for combining observables:
- documentation for `join`, `groupJoin`, and `rxjava-joins`
- add documentation for `concat`, `concatEager`, and `withLatestFrom`",2018-08-04 13:00:43,2018-08-04 16:33:03,https://api.github.com/repos/ReactiveX/RxJava/issues/6135,"['2.x', 'Documentation']",161,7,ReactiveX_RxJava_pull_6135.diff
ReactiveX/RxJava,Update RxJava Android Module documentation,This patch updates the RxJava Android wiki page to point to the RxAndroid project and the RxAndroid wiki page. This refs #6132.,2018-08-04 10:13:43,2018-08-04 17:21:32,https://api.github.com/repos/ReactiveX/RxJava/issues/6134,"['2.x', 'Documentation']",2,109,ReactiveX_RxJava_pull_6134.diff
ReactiveX/RxJava,2.x: Update _Sidebar.md with new order of topics,"Change the sidebar to support the v2 features and suggest new topic orderings.

Related tracking issue: #6132",2018-08-03 12:49:02,2018-08-03 20:37:06,https://api.github.com/repos/ReactiveX/RxJava/issues/6133,"['2.x', 'Documentation']",57,56,ReactiveX_RxJava_pull_6133.diff
ReactiveX/RxJava,2.x: Expand Creating-Observables.md wiki,"This PR expands and updates the `Creating-Observables.md` wiki page to 2.x terminology and feature set. 

This also serves as a discussion basis about how to detail the various operators. The PR suggests the following structure:

- Top outline with links to the family of operators
- Each operator lists:
  - an availability list for the various reactive types: ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png) available, ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_off.png) not available
  - ReactiveX documentation link if available
  - Short description
  - Example, named as `operator example` so that the heading generated can be linked to directly (i.e., `Creating-Observables.md#justexample`.

Related tracking issue: #6132",2018-08-03 09:21:50,2018-08-04 17:05:06,https://api.github.com/repos/ReactiveX/RxJava/issues/6131,"['2.x', 'Discussion', 'Documentation']",404,12,ReactiveX_RxJava_pull_6131.diff
ReactiveX/RxJava,2.x: Cleaunp - rename fields to upstream and downstream,"This PR cleans up the field namings and some local variable namings:

- Use `upstream` for the connection `Disposable` or `Subscription` instead of `d`, `s`, etc., including `AtomicReference<*>` declarations.
- Use `downstream` for the consumer field name in operators instead of `actual` for example.
- Fix one-two letter abbreviated naming to match the type, such as `Disposable s` -> `Disposable d`, etc.

The `CheckLocalVariablesInTests` has been extended with the relevant regexp checks.",2018-08-02 13:44:08,2018-08-05 19:14:22,https://api.github.com/repos/ReactiveX/RxJava/issues/6129,"['2.x', 'Cleanup']",5499,5325,ReactiveX_RxJava_pull_6129.diff
ReactiveX/RxJava,2.x: Remove fromEmitter() in wiki,Remove the mentions of `fromEmitter` from the `Creating-Observables.md` wiki page.,2018-08-02 10:56:30,2018-08-02 12:42:01,https://api.github.com/repos/ReactiveX/RxJava/issues/6128,"['2.x', 'Documentation']",1,2,ReactiveX_RxJava_pull_6128.diff
ReactiveX/RxJava,Fixed broken link under RxJS in docs/Additional-Reading.md,Fix outdated links in the wiki docs.,2018-08-01 14:42:34,2018-08-01 16:08:30,https://api.github.com/repos/ReactiveX/RxJava/issues/6125,"['2.x', 'Cleanup', 'Documentation']",3,3,ReactiveX_RxJava_pull_6125.diff
ReactiveX/RxJava,2.x: Improve Completable.onErrorResumeNext internals,"This PR improves the internals of the `Completable.onErrorResumeNext` operator:

- Inline the `Disposable` management.
- Reuse the same instance for observing the fallback `CompletableSource`.
- Report null return of the `errorMapper` the same way as a crash via `CompositeException`.
- The exceptions in the composite should be in the order **original** -> **mapper exception**.",2018-08-01 14:14:13,2018-08-01 20:20:37,https://api.github.com/repos/ReactiveX/RxJava/issues/6123,"['2.x', 'Enhancement']",104,40,ReactiveX_RxJava_pull_6123.diff
ReactiveX/RxJava,2.x: Flowable.onErrorResumeNext improvements,"This PR improves the structure of the `onErrorResumeNext` operator by inlining the subscription-arbiter and not updating the outstanding request amount one by one. The change reduces the per-item overhead, some indirection cost and the memory cost (+8 bytes for the field, -16/-28 bytes due to the inlined header+field)

In addition, the null-check has been inlined into the resume function call so that the crash will now include the original exception as well as the NPE in a `CompositeException`, just like almost all other cases throughout RxJava.",2018-08-01 12:27:37,2018-08-02 08:02:07,https://api.github.com/repos/ReactiveX/RxJava/issues/6121,"['2.x', 'Enhancement']",33,20,ReactiveX_RxJava_pull_6121.diff
ReactiveX/RxJava,2.x: Test cleanup,"This PR cleans up the tests:

- Reduce stacktrace printouts due to undeliverable errors and turn them into assertions instead.
- Rename local variables & arguments of `Subscriber`s from `o` and `observer` to the proper `subscriber`
- Rename local variables & arguments of `Flowable`s from `o` and `observable` to the more appropriate `f` and `flowable`
- Add more naming tests to `CheckLocalVariablesInTests` to support the previous two points.",2018-07-31 18:44:03,2018-08-01 08:23:12,https://api.github.com/repos/ReactiveX/RxJava/issues/6119,"['2.x', 'Cleanup']",8395,7778,ReactiveX_RxJava_pull_6119.diff
ReactiveX/RxJava,2.x: Update Readme.md about the parallel() operator,"Update wording on the now standard `parallel()` operator in the getting started.

Resolves: #6110",2018-07-31 07:48:55,2018-07-31 08:04:42,https://api.github.com/repos/ReactiveX/RxJava/issues/6117,"['2.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_6117.diff
ReactiveX/RxJava,6108 changed README to use Gradle's implementation instead of compile,"fixes #6108 

Changed `README.md` to reflect Gradle's more recent version of the [library plugin](https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_separation).

I believe that RxJava should be using `implementation`, but I'm not a Gradle expert, feel free to let me know if clients should be using `api`.",2018-07-30 12:02:02,2018-07-31 08:14:27,https://api.github.com/repos/ReactiveX/RxJava/issues/6116,"['2.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_6116.diff
ReactiveX/RxJava,Encoding Bug,Use InputStreamReader to specify encoding otherwise the default encoding will be used leading to strange bugs for some users.,2018-07-29 20:38:41,2018-08-01 08:33:15,https://api.github.com/repos/ReactiveX/RxJava/issues/6114,"['2.x', 'Tools']",1,1,ReactiveX_RxJava_pull_6114.diff
ReactiveX/RxJava,Encoding Bug,Use InputStreamReader to specify encoding otherwise the default encoding will be used leading to strange bugs for some users.,2018-07-29 20:36:58,2018-08-01 08:33:24,https://api.github.com/repos/ReactiveX/RxJava/issues/6113,"['2.x', 'Tools']",1,1,ReactiveX_RxJava_pull_6113.diff
ReactiveX/RxJava,2.2: Promote all Experimental/Beta API to standard,"This PR promotes all `@Experimental`/`@Beta` APIs to standard with version number **2.2**.

(In addition, it also fixes remnant markers from earlier promotions in internal files.)

### Operators

- **`Flowable`**: 
  - `as`
  - `blockingSubscribe(..., prefetch)` + 2
  - `concatMapCompletable` + 1
  - `concatMapCompletableDelayError` + 2
  - `concatMapMaybe` + 1
  - `concatMapMaybeDelayError` + 2
  - `concatMapSingle` + 1
  - `concatMapSingleDelayError` + 2
  - `concatWith` + 2
  - `groupBy(..., evictingMapFactory)`
  - `limit`
  - `mergeWith` + 2
  - `parallel` + 2
  - `subscribe(FlowableSubscriber)`
  - `subscribeOn(..., requestOn)`
  - `switchMapCompletable`
  - `switchMapCompletableDelayError`
  - `switchMapMaybe`
  - `switchMapMaybeDelayError`
  - `switchMapSingle`
  - `switchMapSingleDelayError`
  - `throttleLatest` + 3  
- **`Observable`**:
  - `as`
  - `concatMapCompletable` + 1
  - `concatMapCompletableDelayError` + 2
  - `concatMapMaybe` + 1
  - `concatMapMaybeDelayError` + 2
  - `concatMapSingle` + 1
  - `concatMapSingleDelayError` + 2
  - `concatWith` + 2
  - `mergeWith` + 2
  - `switchMapCompletable`
  - `switchMapCompletableDelayError`
  - `switchMapMaybe`
  - `switchMapMaybeDelayError`
  - `switchMapSingle`
  - `switchMapSingleDelayError`
  - `throttleLatest` + 3  
- **`Maybe`**:
  - `mergeDelayError(Publisher, int)`
  - `as`
  - `switchIfEmpty`
- **`Single`**:
  - `mergeDelayError` + 4
  - `as`
  - `delay(..., delayError)` + 1
  - `onTerminateDetach`
  - `retry(long, Predicate)`
  - `unsubscribeOn`
- **`Completable`**: 
  - `fromMaybe`
  - `as`
  - `onTerminateDetach`
  - `retry(long, Predicate)`
  - `takeUntil`
- **`ConnectableFlowable`**:
  - `refCount` + 4
- **`ConnectableObservable`**:
  - `refCount` + 4
- **`ParallelFlowable`**:
  - `as`
  - `map(errorHandling)` + 1
  - `filter(errorHandling)` + 1
  - `doOnNext(errorHandling)` + 1
  - `sequentialDelayError` + 1
- **`TestSubscriber`/`TestObserver`** (**`BaseTestConsumer`**):
  - `assertValueAt`
  - `assertValuesOnly`
  - `assertValueSetOnly`
  - `assertValueSequenceOnly`
- **`RxJavaPlugins`**:
  - `setOnParallelAssembly`
  - `getOnParallelAssembly`
  - `onAssembly(ParallelFlowable)`
- **`Subject`s/`FlowableProcessor`s**:
  - `BehaviorProcessor.offer`
  - `PublishProcessor.offer` 
  - `ReplayProcessor.cleanupBuffer`
  - `ReplaySubject.cleanupBuffer`
  - `UnicastProcessor.create([...], delayError)` + 1
  - `UnicastSubject.create([...], delayError)` + 1

### Interfaces

- `CompletableConverter`
- `CompletableEmitter`
- `FlowableConverter`
- `FlowableEmitter`
- `FlowableSubscriber`
- `MaybeConverter`
- `MaybeEmitter`
- `ObservableConverter`
- `ObservableEmitter`
- `SingleConverter`
- `SingleEmitter`
- `LambdaConsumerIntrospection`
- `ParallelFlowableConverter`
- `ParallelTransformer`
- `SchedulerRunnableIntrospection`

### Enums

- `ParallelFailureHandling`

### Classes

- `OnErrorNotImplementedException`
- `ProtocolViolationException`
- `UndeliverableException`
- `ParallelFlowable`
- `MulticastProcessor`

### Other components

- `SchedulerSupport.SINGLE`
",2018-07-23 13:14:20,2018-07-30 13:56:38,https://api.github.com/repos/ReactiveX/RxJava/issues/6105,"['2.x', 'API promotion']",428,535,ReactiveX_RxJava_pull_6105.diff
ReactiveX/RxJava,Fixing javadoc's code example of Observable#lift.,"Code example in javadoc for Observable#lift seems not compilable in 2.x.
Also, parameter name of ObservableOperator#apply should be downstream I think.
",2018-07-22 09:27:43,2018-07-22 11:26:53,https://api.github.com/repos/ReactiveX/RxJava/issues/6104,[],4,4,ReactiveX_RxJava_pull_6104.diff
ReactiveX/RxJava,2.x: Fix Completable mergeX JavaDoc missing dt before dd,Couple of the `<dt><b>Error handling:</b></dt>` subheaders were missing from various `Completable.mergeX` operators in the JavaDocs.,2018-07-20 12:06:01,2018-07-20 12:44:11,https://api.github.com/repos/ReactiveX/RxJava/issues/6103,"['2.x', 'Cleanup']",3,0,ReactiveX_RxJava_pull_6103.diff
ReactiveX/RxJava,2.x: Adjust JavaDoc stylesheet of dt/dd within the method details,"This PR adjusts the JavaDoc stylesheet so that the `dt`/`dd` listings in the detailed method descriptions no longer use monospaced font (which should be generally reserved for `{@code }`s and {@link }`s) for better readability.

Before:

![image](https://user-images.githubusercontent.com/1269832/43001178-8edcff7c-8c24-11e8-9622-e7ee3515f0ca.png)

After:

![image](https://user-images.githubusercontent.com/1269832/43001192-9c937754-8c24-11e8-84b0-f23518ae8a40.png)

",2018-07-20 11:56:53,2018-07-20 12:26:45,https://api.github.com/repos/ReactiveX/RxJava/issues/6102,"['2.x', 'Cleanup']",3,3,ReactiveX_RxJava_pull_6102.diff
ReactiveX/RxJava,2.x: Final set of missing Completable marbles (+26),"This PR contains the final set of missing `Completable` marbles (#5789):

#### repeat

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeat.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeat.n.png)

-------------------------

#### repeatUntil

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeatUntil.png)

-------------------------

#### repeatWhen

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeatWhen.png)

-------------------------

#### retry

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.n.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.f.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.ff.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.nf.png)

-------------------------

#### retryWhen

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retryWhen.png)

-------------------------

#### startWith

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.startWith.c.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.startWith.o.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.startWith.p.png)

-------------------------

#### timeout

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timeout.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timeout.s.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timeout.c.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timeout.sc.png)

-------------------------

#### create

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.create.png)

-------------------------

#### unsafeCreate

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.unsafeCreate.png)

-------------------------

#### lift

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.lift.png)

-------------------------

#### subscribe

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribe.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribe.f.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribe.ff.png)

-------------------------

#### subscribeWith

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribeWith.png)

-------------------------

#### test

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.test.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.test.b.png)",2018-07-20 10:58:15,2018-07-20 11:15:10,https://api.github.com/repos/ReactiveX/RxJava/issues/6101,"['2.x', 'Documentation']",52,0,ReactiveX_RxJava_pull_6101.diff
ReactiveX/RxJava,Makes blockingGet on Single have an optional non-blocking fast return path,"Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [ ] Please give a description about what and why you are contributing, even if it's trivial.

This allows blockingGet to quickly return known values instead of blocking and creating a Subscription. Implements first on SingleSubject and SingleJust. I imagine it will have a much greater effect on SingleSubject.

  - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

N/A

  - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.

The existing unit tests seemed sufficient to verify current behavior. I did add some variations in the JMH benchmark tests to demonstrate usefulness of the change. The `Single.defer` behavior is essentially without the fast path, as it is wrapping the inner `Single` with one that does not have the fast path.

Local benchmark results show an order of magnitude improvement on `blockingGet` where this change applies.
```
Benchmark                        Mode  Cnt          Score         Error  Units
BlockingGetPerf.single          thrpt    5  325290806.912 ± 6329789.491  ops/s
BlockingGetPerf.singleDeferred  thrpt    5   29213041.202 ± 1734102.589  ops/s
BlockingGetPerf.singleSubject   thrpt    5  296488077.286 ± 9972222.042  ops/s
```",2018-07-19 20:00:37,2018-07-22 11:27:57,https://api.github.com/repos/ReactiveX/RxJava/issues/6100,['2.x'],48,0,ReactiveX_RxJava_pull_6100.diff
ReactiveX/RxJava,Update TestHelper.java: trivial typo fix,"Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [x] Please give a description about what and why you are contributing, even if it's trivial.
Just a small typo fix. I grepped for the same misspelling and it only appeared in this file.

  - [x] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.
N/A

  - [x] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.
N/A",2018-07-19 19:31:00,2018-07-19 19:54:38,https://api.github.com/repos/ReactiveX/RxJava/issues/6099,[],2,2,ReactiveX_RxJava_pull_6099.diff
ReactiveX/RxJava,2.x: Several more Completable marbles (7/19b),"This PR adds a couple of more marble diagrams to `Completable` (#5789):

#### subscribeOn

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribeOn.png)

#### unsubscribeOn

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.unsubscribeOn.png)

#### toSingle, toSingleDefault

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toSingle.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toSingleDefault.png)

#### toFlowable

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toFlowable.png)

#### toMaybe

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toMaybe.png)",2018-07-19 13:55:18,2018-07-19 14:11:02,https://api.github.com/repos/ReactiveX/RxJava/issues/6098,"['2.x', 'Documentation']",12,0,ReactiveX_RxJava_pull_6098.diff
ReactiveX/RxJava,"2.x: Add missing Completable marbles (+19, 07/19a)","This PR add even more missing marbles to `Completable` (tracked by #5789):

#### delay

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delay.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delay.s.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delay.sb.png)

#### doOnX

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnComplete.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnDispose.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnEvent.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnSubscribe.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnTerminate.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnError.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doAfterTerminate.png)

#### doFinally

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doFinally.png)

#### onErrorComplete

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onErrorComplete.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onErrorComplete.f.png)

#### onErrorResumeNext

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onErrorResumeNext.png)

#### onTerminateDetach

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onTerminateDetach.png)

#### mergeWith

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeWith.png)

#### concatWith

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatWith.png)

#### observeOn

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.observeOn.png)

#### hide

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.hide.png)",2018-07-19 10:18:05,2018-07-19 11:27:57,https://api.github.com/repos/ReactiveX/RxJava/issues/6097,"['2.x', 'Documentation']",44,4,ReactiveX_RxJava_pull_6097.diff
ReactiveX/RxJava,2.x: Improve Completable.delay operator internals,"This PR improves the `Completable.delay()` operator internals, reducing allocation and indirection.",2018-07-19 08:24:57,2018-07-19 08:45:26,https://api.github.com/repos/ReactiveX/RxJava/issues/6096,"['2.x', 'Cleanup', 'Performance']",117,37,ReactiveX_RxJava_pull_6096.diff
ReactiveX/RxJava,"Add marbles for Single.timer, Single.defer and Single.toXXX operators","Here are marbles for `defer`, `timer(delay, unit)`, `timer(delay, unit, scheduler)`, `toFlowable`, `toMaybe`, `toFuture` operators in #5788 

Marble for `defer`:
![defer](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/Defer.png)

Marble for `timer(delay, unit)`:
![timer](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/Timer.png)

Marble for `timer(delay, unit, scheduler)`:
![timerScheduler](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/TimerScheduler.png)

Marble for `toFuture`, although for this one I believe we should add case when there is no event sent from Single as there will be timeout exception thrown:
![toFuture](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/toFuture.png)

Marble for `toMaybe`:
![toMaybe](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/toMaybe.png)

Marble for `toFlowable`, although here I didnt figured out what will happen if we request more than 1 event from flowable:
![toFlowable](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/toFlowable.png)",2018-07-18 21:32:00,2018-08-02 07:34:24,https://api.github.com/repos/ReactiveX/RxJava/issues/6095,"['2.x', 'Documentation']",9,3,ReactiveX_RxJava_pull_6095.diff
ReactiveX/RxJava,Add marbles for Single.amb operators,"Here are operators for `amb` and `ambArray` from #5788 

Marble for `amb`:
![amb](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/amb.png)

Marble for `ambArray`:
![ambArray](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/ambArray.png)",2018-07-18 10:27:35,2018-07-18 11:12:28,https://api.github.com/repos/ReactiveX/RxJava/issues/6091,"['2.x', 'Documentation']",4,0,ReactiveX_RxJava_pull_6091.diff
ReactiveX/RxJava,"2.x: Add missing Completable marbles (+17, 07/18a)","This PR adds marble diagrams to various `Completable` operators:

#### wrap

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.wrap.png)

#### using

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.using.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.using.b.png)

#### ambWith

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.ambWith.png)

#### andThen

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.c.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.s.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.m.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.o.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.p.png)

#### as, to

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.as.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.to.png)

#### compose

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.compose.png)

#### cache

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.cache.png)

#### blockingAwait

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingAwait.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingAwait.t.png)

#### blockingGet

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingGet.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingGet.t.png)",2018-07-18 09:33:02,2018-07-18 10:21:03,https://api.github.com/repos/ReactiveX/RxJava/issues/6090,"['2.x', 'Documentation']",34,0,ReactiveX_RxJava_pull_6090.diff
ReactiveX/RxJava,Add marbles for Single.from operators,"Here are marbles for `fromCallable`, `fromPublisher` and `fromObservable` operators from #5788 

Marble for `fromCallable`
![fromCallable](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/fromCallable.png)


Marble for `fromPublisher`
![fromPublisher](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/fromPublisher.png)


Marble for `fromObservable`
![fromObservable](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/fromObservable.png)",2018-07-17 22:55:20,2018-07-18 07:22:44,https://api.github.com/repos/ReactiveX/RxJava/issues/6087,"['2.x', 'Documentation']",6,0,ReactiveX_RxJava_pull_6087.diff
ReactiveX/RxJava,Single error operators marbles,"Here are marbles for #5788 

For `error(Callable)`
![errorCallable](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/ErrorCallable.png)

For `error(Throwable)`, only added error event to be red:
![errorThrowable](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/Error.png)

For `onErrorReturn`
![onErrorReturn](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/onErrorReturn.png)

For `onErrorReturnItem`
![onErrorReturnItem](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/onErrorReturnItem.png)

For `onErrorResumeNext(SingleSource)`
![onErrorResumeNext](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/onErrorResumeNext.png)

For `onErrorResumeNext(Function)`
![onErrorResumeNextFn](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/onErrorResumeNextWithFn.png)",2018-07-17 16:17:15,2018-07-18 07:36:26,https://api.github.com/repos/ReactiveX/RxJava/issues/6086,"['2.x', 'Documentation']",8,4,ReactiveX_RxJava_pull_6086.diff
ReactiveX/RxJava,"2.x: More Completable marbles (+18), add Completable.fromMaybe","This PR adds marble diagrams (#5789) to the following operators as well as adds the missing `Completable.fromMaybe` operator (`fromX` of other types were already there, uses existing `Maybe.ignoreElement`'s underlying implementation).

#### fromAction

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromAction.png)

#### fromCallable

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromCallable.png)

#### fromFuture

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromFuture.png)

#### fromMaybe

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromMaybe.png)

#### fromObservable

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromObservable.png)

#### fromPublisher

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromPublisher.png)

#### fromSingle

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromSingle.png)

#### mergeArray & mergeArrayDelayError

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeArray.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeArrayDelayError.png)

#### merge

(both `Iterable` and `Publisher` variants)

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.merge.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.merge.p.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.merge.pn.png)

#### mergeDelayError

(both `Iterable` and `Publisher` variants)

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeDelayError.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeDelayError.p.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeDelayError.pn.png)

#### never

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.never.png)

#### timer

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timer.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timer.s.png)


",2018-07-17 12:57:04,2018-07-17 13:15:26,https://api.github.com/repos/ReactiveX/RxJava/issues/6085,"['2.x', 'Documentation', 'Enhancement']",104,0,ReactiveX_RxJava_pull_6085.diff
ReactiveX/RxJava,Add marble diagram for Single.repeatUntil operator,"Here is marble for `repeatUntil` operator in #5788

![repeatUntil](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/RepeatUntil.png)
Please let me know if I need to change anything on the diagram itself. If not, please send me URL when you upload image within the project so I can change URL for the marble in the PR.",2018-07-17 12:56:37,2018-07-17 13:45:36,https://api.github.com/repos/ReactiveX/RxJava/issues/6084,"['2.x', 'Documentation']",2,0,ReactiveX_RxJava_pull_6084.diff
ReactiveX/RxJava,2.x: Add Completable marble diagrams (07/17a),"This PR adds the following marble diagrams to `Completable` operators (#5789):

#### amb, ambArray

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.ambArray.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.amb.png)

#### complete

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.complete.png)

#### concatArray, concat

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatArray.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concat.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concat.p.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concat.pn.png)

#### defer

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.defer.png)

#### error

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.error.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.error.f.png)

",2018-07-17 08:58:09,2018-07-17 09:19:14,https://api.github.com/repos/ReactiveX/RxJava/issues/6083,"['2.x', 'Documentation']",20,0,ReactiveX_RxJava_pull_6083.diff
ReactiveX/RxJava,Add marble diagrams for Single.repeat operators,"Here are marbles for `repeat`, `repeat(times)` and `repeatWhen` operator in #5788

Please let me know if I need to change anything on the diagram itself. If not, please send me URL when you upload image within the project so I can change URL for the marble in the PR.

I intentionally added two diagrams for `repeatWhen` as I would say its interesting case that people should be aware of.

**EDIT:**
Here are marbles

`repeat` operator:
![repeat](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/Repeat.png)

`repeat(count)` operator:
![repeat with count](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/RepeatCount.png)

`repeatWhen` operator:
![repeatWhen](https://raw.githubusercontent.com/UMFsimke/RxJava/Images/Images/RepeatWhen.png)",2018-07-15 23:32:24,2018-07-17 13:06:11,https://api.github.com/repos/ReactiveX/RxJava/issues/6081,"['2.x', 'Documentation']",6,0,ReactiveX_RxJava_pull_6081.diff
ReactiveX/RxJava,"2.x: Improve class Javadoc of Single, Maybe and Completable","This PR expands the Javadocs of `Single`, `Maybe` and `Completable` where the latter also receives an explanation marble:

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.png)

Please let me know if there is any property worthy of mentioning in the class' JavaDocs as well as please look out for copy-paste mistakes.",2018-07-13 12:21:48,2018-07-14 19:42:02,https://api.github.com/repos/ReactiveX/RxJava/issues/6080,"['2.x', 'Documentation']",192,14,ReactiveX_RxJava_pull_6080.diff
ReactiveX/RxJava,2.x: Add Completable.takeUntil(Completable) operator,"This PR adds the missing dedicated `takeUntil` operator to `Completable`.

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.takeuntil.c.png)

Previously, the same effect could be achieved via the `ambWith` but there are two benefits of a dedicated operator:
- easier to discover based on the `takeUntil` operator in other types
- more direct implementation unlike `ambWith` which is built upon an N-ary `amb` operator with additional overhead.

There was a feature request in #3708 some time ago but apparently the issue got closed off after `Single.takeUntil` was implemented.",2018-07-10 13:44:58,2018-07-11 07:19:03,https://api.github.com/repos/ReactiveX/RxJava/issues/6079,"['2.x', 'Enhancement']",406,0,ReactiveX_RxJava_pull_6079.diff
ReactiveX/RxJava,2.x: Add Maybe.hide() marble diagram,"Add marble to `Maybe.hide()`:

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.hide.png)",2018-07-09 08:03:10,2018-07-09 08:35:46,https://api.github.com/repos/ReactiveX/RxJava/issues/6078,"['2.x', 'Documentation']",2,0,ReactiveX_RxJava_pull_6078.diff
ReactiveX/RxJava,Add marble diagram for Single.hide operator,"This should complete `hide` operator in #5788

Please let me know if I need to change anything on the diagram itself. If not, please send me URL when you upload image within the project so I can change URL for the marble in the PR.

Although I wasn't sure if I should represent somehow that `Disposable` is hidden as well. If so, can you please tell me how to represent that on marble?",2018-07-08 23:33:52,2018-07-12 07:28:58,https://api.github.com/repos/ReactiveX/RxJava/issues/6077,"['2.x', 'Documentation']",2,0,ReactiveX_RxJava_pull_6077.diff
ReactiveX/RxJava,Add marble diagrams to the Single.delay method,"Here are marbles for `delay` operator in #5788

Please let me know if I need to change anything on the diagram itself. If not, please send me URL when you upload image within the project so I can change URL for the marble in the PR.",2018-07-08 21:08:15,2018-07-10 07:44:54,https://api.github.com/repos/ReactiveX/RxJava/issues/6076,"['2.x', 'Documentation']",8,0,ReactiveX_RxJava_pull_6076.diff
ReactiveX/RxJava,Add marble diagram to the Single.filter method,"Hopefully this should tick off the `filter` operator in #5788

Please let me know if I need to change anything on the diagram itself. If not, please send me URL when you upload image within the project so I can change URL for the marble in the PR.

Although, I had a doubt and wanted to double check. Operator `filter` returns `Maybe` which essentially will call `onSuccess` or `onComplete`. By running jUnit tests, I could observe that this is a behavior but if I use `TestObserver` then both `assertValue()` and `assertComplete()` are invoked when there are elements that satisfy `filter` condition.",2018-07-08 14:37:19,2018-07-08 18:27:19,https://api.github.com/repos/ReactiveX/RxJava/issues/6075,"['2.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_6075.diff
ReactiveX/RxJava,Add marble diagram to the Single.never method,"First of all, I'm extremely grateful to open my first PR for RxJava. I hope that I'll be able to tick more of the marbles from #5788 but for now this should tick off the `never` operator.

Please let me know if I need to change anything on the diagram itself. If not, please send me URL when you upload image within the project so I can change URL for the marble in the PR.",2018-07-07 23:42:47,2018-07-08 10:58:18,https://api.github.com/repos/ReactiveX/RxJava/issues/6074,"['2.x', 'Documentation']",3,1,ReactiveX_RxJava_pull_6074.diff
ReactiveX/RxJava,2.x: Adjust JavaDocs dl/dd entry stylesheet,"The default JavaDocs stylesheet uses monospaced for the **Scheduler**/**Backpressure**/etc definitions list entries which practically makes any `{@code }` marking practically invisible. This PR set up a stylesheet with that specific style definition reverted to default. There was an unused `stylesheet.css` in the project from long before.

Before:

![image](https://user-images.githubusercontent.com/1269832/42266803-b4701698-7f77-11e8-8255-b5221f1f3e23.png)

After:

![image](https://user-images.githubusercontent.com/1269832/42266818-c0735f5e-7f77-11e8-8786-14ad4fc9a5a9.png)
",2018-07-04 08:48:41,2018-07-04 09:13:18,https://api.github.com/repos/ReactiveX/RxJava/issues/6070,"['2.x', 'Cleanup', 'Documentation']",224,123,ReactiveX_RxJava_pull_6070.diff
ReactiveX/RxJava,Fix links for Single class,"* Change observable.html to single.html
* Delete completable.html link which doesn't exist
",2018-06-30 10:51:32,2018-06-30 11:20:06,https://api.github.com/repos/ReactiveX/RxJava/issues/6066,"['2.x', 'Documentation']",1,3,ReactiveX_RxJava_pull_6066.diff
ReactiveX/RxJava,Add createScan operator to Observable,"Imagine a situation when your app has some state and wants it to be synchronized with the state of a server. The app sends its state to the server and gets back the difference between that state and the actual state of the server. Then, it applies the difference to its current state, sends the new state to the server and so on. This algorithm may be implemented using Observable.scan() operator. However, this operator seems to be redundant for the task because it acts on an upstream. In this example we will need to use a dummy Observable.range(...) stream as the upstream for Observable.scan(). The proposed operator provides a more elegant solution for the described problem and perhaps for some other problems.

Observable.scan() based solution:
```Java
Observable<State> streamOfAppStates =
        Observable.range(0, Long.MAX_VALUE - 1)
                .scan(initialState, (dummyLong, state) -> state.applyDiff(makeRequest(state)));
```

Observable.createScan() based solution:
```Java
Observable<State> streamOfAppStates =
        Observable.createScan(initialState, state -> state.applyDiff(makeRequest(state)));
```

![createscan](https://user-images.githubusercontent.com/4264235/41943446-22a52d64-79ac-11e8-8553-a5173961cf75.png)
",2018-06-26 22:49:18,2018-06-27 14:09:02,https://api.github.com/repos/ReactiveX/RxJava/issues/6064,"['2.x', 'Feature-Request']",180,0,ReactiveX_RxJava_pull_6064.diff
ReactiveX/RxJava,2.x: Fix concatMap{Single|Maybe} null emission on dispose race,"This PR fixes a bug in all 4 specialized `concatMap` implementation that allows `null` to be emitted when the success signal of the inner source races with the dispose signal of the sequence.

Likely fixes: #6059",2018-06-22 13:42:33,2018-06-22 13:58:45,https://api.github.com/repos/ReactiveX/RxJava/issues/6060,"['2.x', 'Bug']",126,0,ReactiveX_RxJava_pull_6060.diff
ReactiveX/RxJava,2.x: Use different wording on blockingForEach() JavaDocs,"Change the wording on the `blockingForEach()` method to clarify it runs the `Consumer` on the current thread. Since there is no onError callback, the extra sentence about the error behavior was removed. There is an error handling section already that explains it properly.",2018-06-21 21:08:22,2018-06-21 21:24:00,https://api.github.com/repos/ReactiveX/RxJava/issues/6057,"['2.x', 'Documentation']",18,22,ReactiveX_RxJava_pull_6057.diff
ReactiveX/RxJava,2.x: Expand {X}Processor JavaDocs by syncing with {X}Subject docs,"This PR expands and adapts the JavaDocs of `AsyncProcessor`, `BehaviorProcessor`, `PublishProcessor`, `ReplayProcessor` and `UnicastProcessor` with the details of their already documented `Subject` variants.

In addition, some wording has been fixed with `UnicastSubject` as it was refering to plural `Observer`s in some sentences even though it only supports one.

Since the basis of this expansion is copy-paste, please read through the changes carefully to verify the terminology and described behavior matches what's usually expected from `Flowable`s/`FlowableProcessor`s (i.e., subjects don't have to deal with backpressure and thus nothing much to elaborate on that in a subject doc).",2018-06-21 12:10:12,2018-06-21 22:38:19,https://api.github.com/repos/ReactiveX/RxJava/issues/6054,"['2.x', 'Documentation']",388,98,ReactiveX_RxJava_pull_6054.diff
ReactiveX/RxJava,2.x: Add Maybe marble diagrams 06/21/a,"Resolved the following diagrams of #5806:

#### amb: missing diagram

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.amb.png)

#### ambArray: missing diagram

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.ambArray.png)

#### concat(Iterable): missing diagram

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.i.png)

#### concat(Publisher): missing diagram

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.p.png)

#### concat(Publisher, int): missing diagram

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.pn.png)

#### concatArray: missing diagram

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatArray.png)

#### concatArrayDelayError: indicate error delayed, 1 marble per source

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatArrayDelayError.png)

#### concatArrayEager: missing diagram

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatArrayEager.png)

#### concatDelayError(Iterable): missing diagram

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatDelayError.i.png)

#### concatDelayError(Publisher): missing diagram

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatDelayError.p.png)

#### concatEager(Iterable): missing diagram

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEager.i.png)

#### concatEager(Publisher): missing diagram

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEager.p.png)
",2018-06-21 09:03:46,2018-06-21 09:32:34,https://api.github.com/repos/ReactiveX/RxJava/issues/6053,"['2.x', 'Documentation']",23,3,ReactiveX_RxJava_pull_6053.diff
ReactiveX/RxJava,#5980 made subscribeActual protected,"### Proposal

Changed `subscribeActual` from `public` to `protected`, as described in #5980.

### How I tested

Ran tests locally, please let me know if I missed part of the contributing guidelines 👼 

Fixes: #5980.",2018-06-20 13:46:40,2018-06-21 07:22:21,https://api.github.com/repos/ReactiveX/RxJava/issues/6052,"['2.x', 'Cleanup']",2,2,ReactiveX_RxJava_pull_6052.diff
ReactiveX/RxJava,Make it explicit that throttleWithTimout is an alias of debounce,"The documentation implies that these two methods are somewhat different. Fixing that confusion, as discussed in #6043:
- Made the descriptions of these methods the same
- Mentioned that it is an alias in the first paragraphs of `throttleWithTimeout` javadoc comments
- Removed the links to third-party websites",2018-06-17 11:47:31,2018-06-18 11:14:55,https://api.github.com/repos/ReactiveX/RxJava/issues/6049,"['2.x', 'Documentation']",44,91,ReactiveX_RxJava_pull_6049.diff
ReactiveX/RxJava,2.x: Add the wiki pages as docs,"This PR adds the `RxJavaWiki.git` subgit markdown files under the `docs` directory, allowing external contribution through the same workflow as for the code.",2018-06-17 09:22:59,2018-06-17 13:31:04,https://api.github.com/repos/ReactiveX/RxJava/issues/6047,"['2.x', 'Documentation']",6023,0,ReactiveX_RxJava_pull_6047.diff
ReactiveX/RxJava,Fix check that would always be false,"Checking `BlockingSubscriber.TERMINATED` (`new Object()`) against `o` would always be false since `o` is a publisher. Since `v` comes from the queue this is presumably the variable that should be checked.

However the check might even be redundant with this change since that variable can only appear in the queue after the subscriber has been cancelled. I am not familiar enough with the memory model to say whether the object appearing in the queue implies the cancelled subscriber is visible.",2018-06-15 20:45:25,2018-06-16 13:18:50,https://api.github.com/repos/ReactiveX/RxJava/issues/6045,"['2.x', 'Bug']",1,1,ReactiveX_RxJava_pull_6045.diff
ReactiveX/RxJava,fix MulticastProcessor javadoc comment,"fix wrong javadoc comment of MulticastProcessor. 
I think `#create(boolean)` is an optional refcount behavior.
",2018-06-14 05:34:19,2018-06-14 07:45:50,https://api.github.com/repos/ReactiveX/RxJava/issues/6042,"['2.x', 'Documentation']",2,2,ReactiveX_RxJava_pull_6042.diff
ReactiveX/RxJava,2.X: Fix disposed LambdaObserver onError to route to global error handler,"Fix the behaviour of LambdaObserver when disposed to route to the global error handler

Fixes #6025 ",2018-06-09 11:03:37,2018-06-09 11:25:55,https://api.github.com/repos/ReactiveX/RxJava/issues/6036,"['2.x', 'Bug']",31,0,ReactiveX_RxJava_pull_6036.diff
ReactiveX/RxJava,Update DESIGN.md,"I've just read the DESIGN.md and noticed some things that I could do to improve the quality of the DESIGN.md. So as a result of my ""proofreading"" I mainly:
- Added periods at the ending of some sentences.
- Did case matching of certain types and terms. e.g. `OnSubscribe` -> `onSubscribe` OR flowable -> `Flowable`.

Hope it helps! :smile:",2018-06-01 15:28:49,2018-06-01 18:17:02,https://api.github.com/repos/ReactiveX/RxJava/issues/6033,[],69,69,ReactiveX_RxJava_pull_6033.diff
ReactiveX/RxJava,2.x: Inline CompositeDisposable JavaDoc,"Normally, overriding a method will reuse the JavaDoc unless specified directly on the new method. Unfortunately, when the base type is part of a javadoc exclude, such as everything below `**/internal`, the documentation is not copied and public facing methods have no HTML documentation:

![image](https://user-images.githubusercontent.com/1269832/40828381-b8cdd07e-6580-11e8-84cf-783f1cf892f9.png)

This PR copies the javadoc of the internal `DisposableContainer` onto `CompositeDisposable` so it shows up properly:

![image](https://user-images.githubusercontent.com/1269832/40828451-ea8c4122-6580-11e8-8ad9-e2cd606d6a39.png)


The IDEs still show the documentation correctly.",2018-06-01 07:48:45,2018-06-01 08:12:00,https://api.github.com/repos/ReactiveX/RxJava/issues/6031,"['2.x', 'Cleanup', 'Documentation']",18,0,ReactiveX_RxJava_pull_6031.diff
ReactiveX/RxJava,2.x: Fix MulticastProcessor JavaDoc warnings,Add two missing `&gt;` tags to avoid the javadoc tool warnings.,2018-05-30 08:31:57,2018-05-30 08:50:30,https://api.github.com/repos/ReactiveX/RxJava/issues/6030,"['2.x', 'Cleanup', 'Documentation']",2,2,ReactiveX_RxJava_pull_6030.diff
ReactiveX/RxJava,"2.x: Upgrade to Gradle 4.3.1, add TakeUntilPerf","The JMH plugin 0.4.4 has some shortcomings that prevent the execution of unit tests on Windows 10 (and on some very restricted Linuxes). Version 0.4.5 has been fixed in this regard but it also requires Gradle 4.3.x. Unfortunately, there are no newer versions to the JMH plugin so this is likely as far as we can go with versions.

I've also added a new benchmark to measure the overhead in `takeUntil`. Here are the results:

i7 4790, Windows 10 x64, Java 8u172, JMH 1.20:

```
Benchmark                        Mode  Cnt         Score       Error  Units
TakeUntilPerf.flowable          thrpt    5    341933,112   13328,573  ops/s
TakeUntilPerf.flowable:items    thrpt    5  21128765,548  677544,832  ops/s
TakeUntilPerf.observable        thrpt    5    366931,108    8202,644  ops/s
TakeUntilPerf.observable:items  thrpt    5  10733841,643  112853,358  ops/s
```

The `observable` here uses an older algorithms & structure and is generally relaying half the items under the same time amonut than the `flowable` version. PR #6028  can then be evaluated with this benchmark.",2018-05-30 08:26:00,2018-05-30 09:16:03,https://api.github.com/repos/ReactiveX/RxJava/issues/6029,"['2.x', 'Build', 'Performance']",98,2,ReactiveX_RxJava_pull_6029.diff
ReactiveX/RxJava,2.x: Improve Observable.takeUntil,"This PR upgrades the `Observable.takeUntil` to a newer algorithm (the `Flowable` version is up-to-date).

Some unit test remnants from the v1 era were upgraded too as the new algorithm no longer disposes the source or other if they terminate on their own (the Reactive Streams specification doesn't allow that anyway).",2018-05-29 22:01:46,2018-05-30 20:12:02,https://api.github.com/repos/ReactiveX/RxJava/issues/6028,"['2.x', 'Enhancement']",75,58,ReactiveX_RxJava_pull_6028.diff
ReactiveX/RxJava,Fix Flowable.blockingSubscribe is unbounded and can lead to OOME,"Create and bound new `blockingSubscribe` overloads to `bufferSize`.
* Create new overloads with `bufferSize`
* Create a `boundedConsumer`
* Create a `BoundedSubsciber`

Close: #5988 
",2018-05-29 11:57:26,2018-06-14 08:04:00,https://api.github.com/repos/ReactiveX/RxJava/issues/6026,"['2.x', 'Enhancement']",816,0,ReactiveX_RxJava_pull_6026.diff
ReactiveX/RxJava,2.x: Dedicated {Single|Maybe}.flatMap{Publisher|Observable} & andThen(Observable|Publisher) implementations,"This PR implements the following operators directly instead of conversions between base types:

- `Single.flatMapObservable`
- `Maybe.flatMapObservable`
- `Maybe.flatMapPublisher`
- `Completable.andThen(Observable)`
- `Completable.andThen(Publisher)`

The `Single.flatMapPublisher` was reimplemented in #6021 already.",2018-05-27 13:35:11,2018-05-27 21:06:40,https://api.github.com/repos/ReactiveX/RxJava/issues/6024,"['2.x', 'Enhancement', 'Performance']",1086,18,ReactiveX_RxJava_pull_6024.diff
ReactiveX/RxJava,2.x: More time to BehaviorProcessor & Interval TCK tests,This PR increases the timeout of the Reactive Streams TCK tests targeting `BehaviorProcessor` and `interval()` from 25ms to 50ms to have some slack on Travis-CI.,2018-05-27 10:44:26,2018-05-27 12:09:52,https://api.github.com/repos/ReactiveX/RxJava/issues/6023,"['2.x', 'Test-Failures']",8,0,ReactiveX_RxJava_pull_6023.diff
ReactiveX/RxJava,2.x: Add TCK for MulticastProcessor & {0..1}.flatMapPublisher,"This PR adds Reactive Streams TCK tests to:

- `MulticastProcessor` (both externally and internally refcounted`
- `Single.flatMapPublisher`
- `Maybe.flatMapPublisher`
- `Completable.andThen(Publisher)`",2018-05-26 14:40:20,2018-05-26 16:41:23,https://api.github.com/repos/ReactiveX/RxJava/issues/6022,"['2.x', 'Test']",297,0,ReactiveX_RxJava_pull_6022.diff
ReactiveX/RxJava,2.x: Single.flatMapPublisher full implementation,"See discussion in #6015.

Resolves: #6015",2018-05-26 06:12:13,2018-05-27 10:14:19,https://api.github.com/repos/ReactiveX/RxJava/issues/6021,"['2.x', 'Enhancement', 'Performance']",228,1,ReactiveX_RxJava_pull_6021.diff
ReactiveX/RxJava,"2.x: Fix Single.takeUntil, Maybe.takeUntil dispose behavior","Fix the dispose behavior of the `Single.takeUntil` and `Maybe.takeUntil` operators.

Tests were also added to the other 3 `takeUntil` variants (for `Completable`, it is delegated to `amb`).

Fixes: #6018",2018-05-25 08:32:07,2018-05-25 10:35:35,https://api.github.com/repos/ReactiveX/RxJava/issues/6019,"['2.x', 'Bug']",880,1,ReactiveX_RxJava_pull_6019.diff
ReactiveX/RxJava,"2.x: benchmark (0..1).flatMap, andThen & flattenAs performance","This PR adds JMH benchmarks to measure the overhead of `{Single|Maybe}.flatMap{Publisher|Observable}`, `{Single|Maybe}.flattenAs{Flowable|Observable}` and `Completable.andThen({Publisher|Observable})`.

### Results 

on i7 4770K, Windows 7 x64, Java 8u172, JMH 1.20 (larger is better):

#### comparing based on the final output type

![image](https://user-images.githubusercontent.com/1269832/40439189-7effb8b6-5eba-11e8-9581-8bec8d770f40.png)

Observable should be generally lower overhead yet some cases it has more overhead.

#### comparing what to flatten

(**flatMapHide** = without fusion, **flatMap** = reactive source, **flattenAs** = list source)

![image](https://user-images.githubusercontent.com/1269832/40439286-c07cf2ae-5eba-11e8-9692-4f6836f8b6cd.png)

The **hide** case is expected to have the most overhead, yet the two reactive classes have uneven boosts with a supposedly fuseable cases:

![image](https://user-images.githubusercontent.com/1269832/40439592-ab3a8388-5ebb-11e8-9e4b-a0b4109452ce.png)

#### comparing based on source type

![image](https://user-images.githubusercontent.com/1269832/40439448-3e4cfa08-5ebb-11e8-9655-14c4f097a3bc.png)

`Single` and `Maybe` should be practically the same here, yet in some cases `Maybe` is quite worse. Also `Completable` should effectively win over the others on each line.


-------

Plenty of optimization opportunities.",2018-05-23 17:04:31,2018-05-23 18:35:40,https://api.github.com/repos/ReactiveX/RxJava/issues/6017,"['2.x', 'Performance']",275,0,ReactiveX_RxJava_pull_6017.diff
ReactiveX/RxJava,2.x: Fix & prevent null checks on primitives,"This PR removes the accidental null checks on primitives in two `Observable` methods and adds a trap method to `ObjectHelper` to both highlight and fail the tests in case the null checks are still attempted. The method is marked as deprecated so it will also show up in (Eclipse's) problems window.

Replaces #6012 
Resolves #6013",2018-05-23 07:05:31,2018-05-23 07:23:11,https://api.github.com/repos/ReactiveX/RxJava/issues/6014,"['2.x', 'Cleanup']",20,4,ReactiveX_RxJava_pull_6014.diff
ReactiveX/RxJava,Stops Integer boxing via null checks in Observable.concatEager,"Replaces with verifyPositive as in other similar methods.

This seems to be a trivial change and makes this more consistent with other areas of the code. Let me know if it needs its own issue or any specific tests. Given the methods only accept primitive ints, and passing a null Integer would throw a runtime exception, I'm not sure there's anything needed outside of the already present testing.",2018-05-22 22:15:56,2018-05-23 07:08:11,https://api.github.com/repos/ReactiveX/RxJava/issues/6012,"['2.x', 'Cleanup']",4,4,ReactiveX_RxJava_pull_6012.diff
ReactiveX/RxJava,2.x: Add assertValueSetOnly and assertValueSequenceOnly to TestObserver + TestSubscriber,"This basically copies the behavior of `assertValuesOnly` to the `assertValueSet` and `assertValueSequence` equivalent methods.

Coped the tests exactly from `assertValuesOnly` and adjusted them with the new added methods.",2018-05-17 10:54:51,2018-05-18 08:58:51,https://api.github.com/repos/ReactiveX/RxJava/issues/6010,"['2.x', 'Enhancement']",300,22,ReactiveX_RxJava_pull_6010.diff
ReactiveX/RxJava,2.x: Javadoc space cleanup,"This PR adds a gradle task to replace the excessive whitespaces generated into the Javadocs between method arguments and after method argument annotations.

This task should run before the javadoc gets packaged up for maven and before it gets pushed back to the gh-pages.

(This was created as a repo branch so that the snapshot pushback is triggered, see the comparison links below.)

Resolves: #6004

#### Comparison

Multiple parameters before: [combineLatest](http://reactivex.io/RxJava/2.x/javadoc/2.1.13/io/reactivex/Flowable.html#combineLatest-io.reactivex.functions.Function-org.reactivestreams.Publisher...-)

![image](https://user-images.githubusercontent.com/1269832/39813943-b841e820-5392-11e8-9a01-8f79b521f76b.png)

Multiple parameters after: [combineLatest snapshot](http://reactivex.io/RxJava/2.x/javadoc/snapshot/io/reactivex/Flowable.html#combineLatest-io.reactivex.functions.Function-org.reactivestreams.Publisher...-)

![image](https://user-images.githubusercontent.com/1269832/39813959-cc80385a-5392-11e8-8084-7ca89c0686d7.png)

----------------

Newline after parameter annotation before: [as](http://reactivex.io/RxJava/2.x/javadoc/2.1.13/io/reactivex/Flowable.html#as-io.reactivex.FlowableConverter-)

![image](https://user-images.githubusercontent.com/1269832/39813894-86bc22c0-5392-11e8-8748-aba6a214d4fc.png)

Newline after parameter annotation after: [as snapshot](http://reactivex.io/RxJava/2.x/javadoc/snapshot/io/reactivex/Flowable.html#as-io.reactivex.FlowableConverter-)

![image](https://user-images.githubusercontent.com/1269832/39813906-97f7aca8-5392-11e8-981f-9ff93396c35f.png)
",2018-05-09 12:11:11,2018-05-09 17:13:18,https://api.github.com/repos/ReactiveX/RxJava/issues/6005,"['2.x', 'Cleanup', 'Documentation']",34,0,ReactiveX_RxJava_pull_6005.diff
ReactiveX/RxJava,Fix typo in documentation,"Rewrote `sameSource` to `someSource` because `someSource` is used in code snippets.
",2018-05-09 10:12:30,2018-05-09 10:32:42,https://api.github.com/repos/ReactiveX/RxJava/issues/6003,"['2.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_6003.diff
ReactiveX/RxJava,2.x: Add MulticastProcessor,"This PR adds the `MulticastProcessor` from the [extensions project](https://github.com/akarnokd/RxJava2Extensions#multicastprocessor) to be a standard processor option.

This type of processor fills the gap of having a backpressure-coordinating processor type as `PublishProcessor` doesn't coordinate backpressure on its own and `Flowable.publish()` often can't be used because the upstream may not yet exist when the dowstream consumers are setup.

![MulticastProcessor](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/MulticastProcessor.png)

Example:

```java
MulticastProcessor<Integer> mp = Flowable.range(1, 10)
    .subscribeWith(MulticastProcessor.create());

mp.test().assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// --------------------

MulticastProcessor<Integer> mp2 = MulticastProcessor.create(4);
mp2.start();

assertTrue(mp2.offer(1));
assertTrue(mp2.offer(2));
assertTrue(mp2.offer(3));
assertTrue(mp2.offer(4));

assertFalse(mp2.offer(5));

mp2.onComplete();

mp2.test().assertResult(1, 2, 3, 4);
```

Resolves: #5999",2018-05-09 08:44:53,2018-05-17 21:17:55,https://api.github.com/repos/ReactiveX/RxJava/issues/6002,"['2.x', 'Enhancement']",1429,0,ReactiveX_RxJava_pull_6002.diff
ReactiveX/RxJava,Export path from RxJava to InputStream,"The submitted pattern allows exporting RxJava computations to a non-reactive system, for example for use in publishing computations to REST using Scalatra or Jackson frameworks as endpoints that can accept InputStream instances whose data can be streamed to the client, as opposed to blocking for a final value from an Observable or Flowable.  Rx operations can enrich such REST frameworks, for example merging with interval() sequences to provide heartbeats, or subscribing to other merged sources to aggregate long-lived connections.  Outside of REST, other applications include serializing RX streams for archival, debugging, and monitoring.

The unit tests demonstrate example operation, coverage, and error behavior.  While the marshalling in unit tests uses toString().getBytes(), the marshalling is more general. I've demonstrated to myself at home using basic types like Integer and Long, but the examples seemed contrived.  I would expect most users to serialize to JSON or XML strings, but the framework leaves open a general hook for non-text solutions.

Back pressure is addressed for flowables by requesting values when pulled by the InputStream.read() operations.  Buffering can be added by wrapping the ReactiveInputStream in a BufferedReader/etc and keeping the the ReactiveInputStream code simple.

Internally buffering is limited using the rx2.buffer-size property used in other areas of the codebase to limit the size of queue of items to be passed along to a reader.

Apologetically, I first thought that the submission might receive warmer reception in RxJavaStrings. 
- Marshalling performed in ReactiveInputStream is not limited to Strings; 
- the additional code is in ReactiveInputStream is minimal;
- RxJavaStrings doesn't look to have momentum moving to Rx2. 
I've hacked around with ReactiveInputStream in conjunction ObjectInput/OutputStreams and Java serialization, though I would not promote serialization that way, but one could plug in a serialization library and go to the races.... 
",2018-05-07 15:55:37,2018-05-07 16:45:29,https://api.github.com/repos/ReactiveX/RxJava/issues/5998,[],571,0,ReactiveX_RxJava_pull_5998.diff
ReactiveX/RxJava,2.x: readme: mention 1.x eol; 2.x snapshot javadoc url,"Small update to the `README.md`:

- 1.x end-of-life notice
- link to the snapshot Javadocs",2018-05-07 10:36:20,2018-05-09 10:55:22,https://api.github.com/repos/ReactiveX/RxJava/issues/5997,"['2.x', 'Documentation']",6,9,ReactiveX_RxJava_pull_5997.diff
ReactiveX/RxJava,2.x: Automatically publish the generated JavaDocs from CI,"This PR adds a script that publishes the generated JavaDocs from CI back to the `gh-pages` branch upon successful snapshot and release builds (this latter needs testing though via -RC releases).

The snapshot JavaDocs will go into the same directory: http://reactivex.io/RxJava/2.x/javadoc/snapshot/

The release builds update
- http://reactivex.io/RxJava/javadoc/ while preserving the old `rx` links,
- http://reactivex.io/RxJava/2.x/javadoc/ for the latest 2.x and
- http://reactivex.io/RxJava/2.x/javadoc/2.1.13/ for the specific release version.

The `push.sh` script uses a Travis-CI secured token `GITHUB_TOKEN` to talk to the GitHub API. This token was created for my account via https://github.com/settings/tokens (requires repo direct push access), and provided to Travis via ""Environment variables"" on the page https://travis-ci.org/ReactiveX/RxJava/settings .

If, for some reason the publishing fails, the build still counts as successful. The reason for this is that restarting the otherwise successful build will try to reupload the same library version into maven which fails. In this case, the JavaDocs can be updated via the old manual method.",2018-05-05 23:26:54,2018-05-06 14:31:08,https://api.github.com/repos/ReactiveX/RxJava/issues/5996,"['2.x', 'Build', 'Documentation']",121,0,ReactiveX_RxJava_pull_5996.diff
ReactiveX/RxJava,Implement 'toString' method for some Emitters,"When use `.create` method it's unclear why `emitter` is null (if call `toString` or observe object via debugger). 
",2018-05-05 21:06:34,2018-05-06 19:33:10,https://api.github.com/repos/ReactiveX/RxJava/issues/5995,"['2.x', 'Cleanup']",100,0,ReactiveX_RxJava_pull_5995.diff
ReactiveX/RxJava,Proposing solution for: Automate Publishing of Javadocs #2631,"This is referencing issue https://github.com/ReactiveX/RxJava/issues/2631 to automate publishing of JavaDocs for 2.x

I've added in a Gradle task using https://github.com/ajoberstar/gradle-git-publish and provided a block to pick up a Github token for auth if present. You can publish a doc with this method by generating the JavaDocs with the already included Gradle task javadocJar and then running the gitPublishPush Gradle task. I have this working here: https://rpmcdougall.github.io/RxJava/

Thanks!",2018-05-05 15:39:32,2018-05-06 15:09:15,https://api.github.com/repos/ReactiveX/RxJava/issues/5993,"['2.x', 'Build', 'Documentation']",39,1,ReactiveX_RxJava_pull_5993.diff
ReactiveX/RxJava,Observable's javadoc cleanup,"The sample code in the Observable javadoc erroneously uses `onNext(Integer t)` for a `DisposableObserver<String>`

This has been corrected to be `onNext(String t)`
",2018-05-04 14:01:14,2018-05-04 14:25:31,https://api.github.com/repos/ReactiveX/RxJava/issues/5992,"['2.x', 'Cleanup', 'Documentation']",1,1,ReactiveX_RxJava_pull_5992.diff
ReactiveX/RxJava,2.x: Fix switchMap to indicate boundary fusion,"Fix `Flowable.switchMap` and `Observable.switchMap` to request for boundary fusion in order to prevent a thread-confined but otherwise fusion-capable sub-sequence from running on the unintended thread.

Fixes: #5990",2018-05-02 20:20:10,2018-05-04 15:47:22,https://api.github.com/repos/ReactiveX/RxJava/issues/5991,"['2.x', 'Bug']",281,13,ReactiveX_RxJava_pull_5991.diff
ReactiveX/RxJava,Add marble diagrams to a few Single.doOnX methods.,"This should tick a few tasks from this issue: https://github.com/ReactiveX/RxJava/issues/5788.

The urls are a bit ugly, as they're from the uploads in the issue. I'm happy to update the urls with different ones if there's a better place to upload the diagrams.",2018-04-30 20:28:10,2018-05-01 09:43:30,https://api.github.com/repos/ReactiveX/RxJava/issues/5987,"['2.x', 'Documentation']",15,0,ReactiveX_RxJava_pull_5987.diff
ReactiveX/RxJava,2.x: Add refCount with count & disconnect timeout,"This PR exposes the additional `refCount` operation modes from #5975:

- Connect only when the specified number of `Subscriber`s/`Observer`s have subscribed
- Disconnect when the given amount of time elapsed since the very last `Subscriber`/`Observer` cancelled/disposed.
- The combination of both.

In addition, the original `refCount` received extra JavaDocs details.",2018-04-30 17:22:41,2018-05-09 07:44:35,https://api.github.com/repos/ReactiveX/RxJava/issues/5986,"['2.x', 'Enhancement']",342,83,ReactiveX_RxJava_pull_5986.diff
ReactiveX/RxJava,2.x: Small cleanups in the Scheduler class,"- Remove `@NonNull` from a primitive type
- Make the package-private `PeriodicDirectTask` final
- Add `@NonNull` to other fields",2018-04-30 10:10:53,2018-04-30 10:28:42,https://api.github.com/repos/ReactiveX/RxJava/issues/5985,"['2.x', 'Cleanup']",11,3,ReactiveX_RxJava_pull_5985.diff
ReactiveX/RxJava,2.x: Add blockingSubscribe JavaDoc clarifications,This PR adds some clarifications to the `blockingSubscribe` methods on `Flowable` and `Observable`.,2018-04-29 20:59:33,2018-04-30 10:47:07,https://api.github.com/repos/ReactiveX/RxJava/issues/5984,"['2.x', 'Documentation']",66,6,ReactiveX_RxJava_pull_5984.diff
ReactiveX/RxJava,2.x: deprecate getValues() in Subjects/Processors,"This PR deprecates the `getValues()` and `getValues(T[])` methods in `AsyncSubject`, `BehaviorSubject`, `AsyncProcessor` and `BehaviorProcessor`.

These methods were remnants of an early 2.x API design where `Subject` itself had these methods for the sake of `ReplaySubject`  and `SerializedSubject` and thus every other subject type had to implement them. The listed subjects and processors above have at most one value accessible via `getValue()` which can then be assigned to an array index manually if needed.",2018-04-29 16:51:27,2018-04-30 09:16:18,https://api.github.com/repos/ReactiveX/RxJava/issues/5982,"['2.x', 'Deprecation']",47,0,ReactiveX_RxJava_pull_5982.diff
ReactiveX/RxJava,2.x: improve JavaDocs of the subscribeActual methods,The PR improves the wording of the abstract `subscribeActual` method across the base reactive types.,2018-04-29 16:14:14,2018-04-29 17:47:26,https://api.github.com/repos/ReactiveX/RxJava/issues/5981,"['2.x', 'Documentation']",20,9,ReactiveX_RxJava_pull_5981.diff
ReactiveX/RxJava,2.x: Add throttleLatest operator,"This PR adds the `throttleLatest` operator to `Observable` and `Flowable`, also known as `conflate` (#4856): it is a combination of `throttleFirst` and `sample` whereby frequent items are sampled but the first item outside the sampling window will be emitted immediately:

![throttleLatest](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLatest.png)

![throttleLatest](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLatest.se.png)

Resolves: #4856
Replaces: #5968",2018-04-29 13:19:40,2018-05-17 08:11:13,https://api.github.com/repos/ReactiveX/RxJava/issues/5979,"['2.x', 'Enhancement']",1259,0,ReactiveX_RxJava_pull_5979.diff
ReactiveX/RxJava,2.x: Fix Flowable.take to route post-cancel errors to RxJavaPlugins.onError,"This PR makes sure errors emitted by the upstream just after the `Flowable.take` has received the specified amount of items get routed to `RxJavaPlugins.onError`.

`Observable.take()` and `Flowable.limit()` were already doing this. Added unit tests to verify the behavior across the board.",2018-04-29 10:10:11,2018-04-29 13:56:29,https://api.github.com/repos/ReactiveX/RxJava/issues/5978,"['2.x', 'Cleanup']",56,2,ReactiveX_RxJava_pull_5978.diff
ReactiveX/RxJava,2.x: Maybe/Single Javadoc; annotation cleanup,"The PR cleans up some wording around ""Single source"" and ""Maybe source"", plus removes some unnecessary annotations.",2018-04-29 09:13:26,2018-04-29 10:00:09,https://api.github.com/repos/ReactiveX/RxJava/issues/5977,"['2.x', 'Cleanup', 'Documentation']",27,31,ReactiveX_RxJava_pull_5977.diff
ReactiveX/RxJava,Adding eager concats to Single,"  - Adding concatEager operator for Singles covering:
   concatEager(Publisher<? extends SingleSource<? extends T>> sources)
   concatEager(Iterable<? extends SingleSource<? extends T>> sources)
   concatArrayEager(SingleSource<? extends T>... sources)
  
- Issue: https://github.com/ReactiveX/RxJava/issues/5974

 - Added tests for both methods, I wasn't sure if I should add tests covering just a single element in the vararg list and respectively an iterable with a single element.. any thoughts on this?
",2018-04-28 20:38:46,2018-04-29 08:23:20,https://api.github.com/repos/ReactiveX/RxJava/issues/5976,"['2.x', 'Enhancement']",144,10,ReactiveX_RxJava_pull_5976.diff
ReactiveX/RxJava,2.x: Fix refCount() connect/subscribe/cancel deadlock,"This PR fixes a deadlock issue with the `refCount` operator when a subscription leads to a blocking execution while the lock is being held, preventing other subscription or cancellation from executing on other threads.

The bug was discovered as the cause of a reported hang on [the Google groups](https://groups.google.com/forum/#!topic/rxjava/G0axw5PbOF4).

The [code](https://github.com/akarnokd/RxJava2Extensions/blob/master/src/main/java/hu/akarnokd/rxjava2/operators/FlowableRefCountTimeout.java) has been developed in the extensions project where the operator has [more features](https://github.com/akarnokd/RxJava2Extensions#flowabletransformersrefcount). The overloads supporting these features can be added in a separate enhancement PR.",2018-04-28 12:32:02,2018-04-29 08:39:43,https://api.github.com/repos/ReactiveX/RxJava/issues/5975,"['2.x', 'Bug']",973,307,ReactiveX_RxJava_pull_5975.diff
ReactiveX/RxJava,2.x: Fix Observable.concatMapSingle dropping upstream items,"The internal queue of `Observable.concatMapSingle` was incorrectly the bounded one from its `Flowable` counterpart, causing it to drop upstream items if the current `Single` was delayed. The right queue for `Observable`s is the `SpscLinkedArrayQueue`.

Added unit tests to both `concatMapSingle` and `concatMapMaybe` to verify the correct behavior.

Fixes: #5971.",2018-04-24 07:48:01,2018-04-24 08:06:16,https://api.github.com/repos/ReactiveX/RxJava/issues/5972,"['2.x', 'Bug']",37,3,ReactiveX_RxJava_pull_5972.diff
ReactiveX/RxJava,Adding Flowable.throttleAndSample - Conflate operator,This pull request is to add Flowable.throttleAndSample operator as discussed in #4856  ,2018-04-22 21:17:43,2018-05-09 10:33:44,https://api.github.com/repos/ReactiveX/RxJava/issues/5968,"['2.x', 'Enhancement', 'Feature-Request']",644,0,ReactiveX_RxJava_pull_5968.diff
ReactiveX/RxJava,Fix few typos in README.,3 of them. All in README.,2018-04-21 15:51:40,2018-04-21 17:00:10,https://api.github.com/repos/ReactiveX/RxJava/issues/5967,['Documentation'],3,3,ReactiveX_RxJava_pull_5967.diff
ReactiveX/RxJava,2.x: Workaround for Objects.requireNonNull inserted by javac,"For some reason, when compiling RxJava with Java 9 or 10 and target 8, there is an implicit `Objects.requireNonNull` added by the compiler to `us.new X` which makes AnimalSniffer detect a non-Java 6 API usage. Interestingly, this does not happen with:

- Java 8 target 6, 
- Java 8 target 8, 
- Java 9 target 6, 
- Java 9 target 9, 
- Java 10 target 6, 
- Java 10 target 9,
- Java 10 target 10

or AnimalSniffer doesn't detect it for non-8 targets somehow. I know that the latest AnimalSniffer doesn't work with (some?) Java 9 class files, but it doesn't explain why the fully supported Java 8 target 8 does not trigger this error but Java 9 target 8 does.

I have reported this anomaly as a potential javac bug.

The build matrices and outcomes for RxJava 2 can be found here: https://travis-ci.org/akarnokd/RxJava2_9/builds",2018-04-20 12:40:46,2018-04-20 13:04:41,https://api.github.com/repos/ReactiveX/RxJava/issues/5966,"['2.x', 'Cleanup']",1,1,ReactiveX_RxJava_pull_5966.diff
ReactiveX/RxJava,Fix typo,"Update 'Dependend sub-flows' to 'Dependent sub-flows'

Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [ ] Please give a description about what and why you are contributing, even if it's trivial.

  - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.
",2018-04-13 10:07:25,2018-04-13 10:25:15,https://api.github.com/repos/ReactiveX/RxJava/issues/5960,"['2.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_5960.diff
ReactiveX/RxJava,2.x: Fix some grammar mistakes,"This PR fixes a bunch of typos (in many files) and grammar mistakes in `Flowable` (based on Grammarly checks).

The PR also fixes the `JavadocWording` checks to start from the beginning of the method's javadoc as well as checking for cross-line a/an typos.",2018-04-12 14:36:54,2018-04-14 14:44:26,https://api.github.com/repos/ReactiveX/RxJava/issues/5959,"['2.x', 'Cleanup', 'Documentation']",279,240,ReactiveX_RxJava_pull_5959.diff
ReactiveX/RxJava,"2.x: Add Single.ignoreElement, deprecate toCompletable","Rename-deprecate `Single.toCompletable` to `ignoreElement` to be in line with the same operator in the other classes and also indicate more clearly in the method name that it ignores the element.

In addition, the marbles have been updated on both `Single` and `Maybe` of this operator.

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.ignoreElement.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.ignoreElement.png)",2018-04-12 09:37:02,2018-04-13 07:53:38,https://api.github.com/repos/ReactiveX/RxJava/issues/5957,"['2.x', 'Cleanup', 'Documentation']",39,4,ReactiveX_RxJava_pull_5957.diff
ReactiveX/RxJava,Add missing parenthesis on README.md,,2018-04-11 17:50:10,2018-04-11 18:32:27,https://api.github.com/repos/ReactiveX/RxJava/issues/5955,[],1,1,ReactiveX_RxJava_pull_5955.diff
ReactiveX/RxJava,AppendOnlyLinkedArrayList#forEachWhile is not breaking iteration properly,"`AppendOnlyLinkedArrayList#forEachWhile(NonThrowingPredicate)` was `break`-ing from inner loop instead of `return`-ing when predicate returned `true`.

This caused iteration to continue with items from the next array bucket.",2018-04-07 00:51:35,2018-04-07 11:03:23,https://api.github.com/repos/ReactiveX/RxJava/issues/5952,"['2.x', 'Bug']",22,2,ReactiveX_RxJava_pull_5952.diff
ReactiveX/RxJava,2.x: blockingX JavaDoc to mention wrapping of checked Exceptions,This PR adds an **Error handling** section to various `blockingX` operators to specify checked exceptions from their source will be wrapped into `RuntimeException`s.,2018-04-05 13:44:57,2018-04-05 18:38:42,https://api.github.com/repos/ReactiveX/RxJava/issues/5951,"['2.x', 'Documentation']",68,0,ReactiveX_RxJava_pull_5951.diff
ReactiveX/RxJava,Fix Observable javadoc (#5944),"* Replace `doOnCancel` by `doOnDispose` in Observable javadoc

Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [x] Please give a description about what and why you are contributing, even if it's trivial.

Replace `doOnCancel` by `doOnDispose` in Observable javadoc

  - [x] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

#5944

  - [x] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.

Javadoc only",2018-04-03 07:43:06,2018-04-03 09:09:38,https://api.github.com/repos/ReactiveX/RxJava/issues/5948,"['2.x', 'Documentation']",9,9,ReactiveX_RxJava_pull_5948.diff
ReactiveX/RxJava,2.x: fix groupBy cancellation with evicting map factory,"Fixes #5933.

When the outer stream is cancelled there may be evicted groups present in the queue to be completed.

I've added code to complete the evicted groups in the `cancel` method as suggested by @akarnokd. To protect against a race condition where the EvictionAction is called just after the evicted groups are completed in `cancel` I've added a `cancelled` check to `EvictionAction`. 

However, I am concerned about a race that I'll place in the comments on the code below.",2018-04-03 02:37:19,2018-05-29 12:14:34,https://api.github.com/repos/ReactiveX/RxJava/issues/5947,[],146,11,ReactiveX_RxJava_pull_5947.diff
ReactiveX/RxJava,Removed TERMINATED check in onNext,"`TERMINATED` is an empty array, so iterating over it would be harmless. The cost of the check is probably minuscule, but it was imposed on the common case where the subject is not terminated. In essence, it was optimizing for misuse of the API.",2018-03-31 06:33:21,2018-04-01 21:42:28,https://api.github.com/repos/ReactiveX/RxJava/issues/5942,"['2.x', 'Cleanup']",0,7,ReactiveX_RxJava_pull_5942.diff
ReactiveX/RxJava,2.x: Allow @SchedulerSupport on constructors.,Motivation behind this is having a class which takes multiple constructor parameters where one can be a Scheduler with a default and a custom overload. In both cases I'd want to slam `@SchedulerSupport` on it so it can be handled properly by static analysis as well.,2018-03-31 00:05:53,2018-03-31 06:37:26,https://api.github.com/repos/ReactiveX/RxJava/issues/5940,[],1,1,ReactiveX_RxJava_pull_5940.diff
ReactiveX/RxJava,fix typo `ingored`,"just fix few typos.

Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [x] Please give a description about what and why you are contributing, even if it's trivial.
         Just fix typos.

  - [x] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.
          Just typo fix, I assume an issue is unnecessary.

  - [x] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.
          No.
",2018-03-30 03:51:22,2018-03-30 07:25:44,https://api.github.com/repos/ReactiveX/RxJava/issues/5938,[],3,3,ReactiveX_RxJava_pull_5938.diff
ReactiveX/RxJava,Update Gradle 4.2.1 → 4.6.,"Benchmark results:

- Gradle 4.2.1 median `assemble` (clean) time: `8547` ms
- Gradle 4.6 median `assemble` (clean) time: `8491.5` ms

<img width=""927"" alt=""Benchmark Gradle 4.2.1"" src=""https://user-images.githubusercontent.com/967132/38032721-3213edbc-3253-11e8-9da7-78e8eb43f23a.png"">

<img width=""926"" alt=""Benchmark Gradle 4.6"" src=""https://user-images.githubusercontent.com/967132/38032728-3604999e-3253-11e8-8a23-6f51d7c3a992.png"">


Benchmark environment:

- Tool: https://github.com/gradle/gradle-profiler
- Task: `assemble`, clean task: `clean`
- Warmups: 6
- Iterations: 10
- OS: Ubuntu Server 17.10.1 (0 unnecessary services running), Linux Kernel 4.13.0-37-generic
- JDK: OpenJDK build 1.8.0_151-8u151-b12-0ubuntu0.17.10.2-b12
- Hardware: 
    - CPU: AMD Ryzen 7 1800X
    - RAM: Corsair Vengeance, 2x 16 GB, 2134 MHz (0.5 ns)
    - Disk: Samsung 850 EVO 1TB

---

@akarnokd I also got one unit test failure on 10 core (20 threads) machine during `./gradlew build` check (was just checking for myself):

```java
io.reactivex.internal.operators.observable.ObservableMergeTest > testSynchronizationOfMultipleSequencesLoop FAILED
    java.lang.AssertionError: expected:<1> but was:<0>
        at org.junit.Assert.fail(Assert.java:88)
        at org.junit.Assert.failNotEquals(Assert.java:834)
        at org.junit.Assert.assertEquals(Assert.java:645)
        at org.junit.Assert.assertEquals(Assert.java:631)
        at io.reactivex.internal.operators.observable.ObservableMergeTest.testSynchronizationOfMultipleSequences(ObservableMergeTest.java:273)
        at io.reactivex.internal.operators.observable.ObservableMergeTest.testSynchronizationOfMultipleSequencesLoop(ObservableMergeTest.java:207)

```",2018-03-28 13:44:18,2018-03-28 13:53:21,https://api.github.com/repos/ReactiveX/RxJava/issues/5937,"['2.x', 'Build']",1,1,ReactiveX_RxJava_pull_5937.diff
ReactiveX/RxJava,2.x: Fix Completable.toMaybe() @return javadoc.,"Current javadoc:

```java
@return a {@link Maybe} that emits a single item T or an error.
```

But in reality, converting `Maybe` to `Completable` should never emit `item T`.",2018-03-27 14:45:58,2018-03-27 15:19:58,https://api.github.com/repos/ReactiveX/RxJava/issues/5936,[],2,1,ReactiveX_RxJava_pull_5936.diff
ReactiveX/RxJava,1.x: Fix take() to route late errors to RxJavaHooks,"If there is a late exception after take has unsubscribed from the upstream, this exception was ignored by the operator. This fix makes sure such late exceptions are routed to the `RxJavaHooks.onError` handler, just like 2.x does.

Fixes: #5934.",2018-03-26 12:59:38,2018-03-26 13:45:53,https://api.github.com/repos/ReactiveX/RxJava/issues/5935,"['1.x', 'Bug']",42,1,ReactiveX_RxJava_pull_5935.diff
ReactiveX/RxJava,Adding support for Intellij IDEA project generation,"(All in title.)
",2018-03-24 02:20:55,2018-03-26 22:19:23,https://api.github.com/repos/ReactiveX/RxJava/issues/5932,[],1,0,ReactiveX_RxJava_pull_5932.diff
ReactiveX/RxJava,Add @NonNull annotations to create methods of Subjects and Processors,I am annotating *Subject's and *Processor's create methods with @NonNull annotations to remove compiler's nullability warnings when calling the methods from Kotlin language.,2018-03-23 19:17:28,2018-03-23 20:55:59,https://api.github.com/repos/ReactiveX/RxJava/issues/5930,['2.x'],35,0,ReactiveX_RxJava_pull_5930.diff
ReactiveX/RxJava,2.x: Fix concatMapSingle & concatMapMaybe dispose-cleanup crash,"This PR fixes the accidental logical mistake in the `cancel`/`dispose` logic of the new `concatMapSingle` and `concatMapMaybe` operators of both `Flowable` and `Observable` where the internal queue cleanup should happen in a serialized fashion only, which is the state when the work-in-progress counter changes from 0 to 1 ensured by a `==` check.

Fixes #5927",2018-03-23 10:07:25,2018-03-23 10:31:48,https://api.github.com/repos/ReactiveX/RxJava/issues/5928,"['2.x', 'Bug']",108,4,ReactiveX_RxJava_pull_5928.diff
ReactiveX/RxJava,2.x: Expand the Getting Started,"This PR expands the Readme.md with further examples and details, plus adds headers so that (former and new) sections can be easily linked in answers on issue lists or StackOverflow.

(Note that it was written offline without proper markdown rendering so I may update the PR a couple of times to get the render mistakes fixed).",2018-03-22 14:06:37,2018-03-23 08:19:17,https://api.github.com/repos/ReactiveX/RxJava/issues/5926,"['2.x', 'Documentation']",330,9,ReactiveX_RxJava_pull_5926.diff
ReactiveX/RxJava,Add @Nullable annotations to Processors,"Add `@Nullable` annotations to Processors. 

Updated our project to use 2.11.1, and discovered there's this PR https://github.com/ReactiveX/RxJava/pull/5890 which added `@Nullable` annotations to Subjects. Thought might as well add `@Nullable` to Processors.",2018-03-22 06:02:00,2018-03-22 08:32:32,https://api.github.com/repos/ReactiveX/RxJava/issues/5925,['2.x'],12,0,ReactiveX_RxJava_pull_5925.diff
ReactiveX/RxJava,2.x: Update Single.flatMapPublisher marble,"Renamed the operator in the box. For #5788.

![flatMapPublisher](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMapPublisher.png)",2018-03-21 09:00:15,2018-03-21 09:39:42,https://api.github.com/repos/ReactiveX/RxJava/issues/5924,"['2.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_5924.diff
ReactiveX/RxJava,2.x: Fix JavaDoc warnings of buffer(Publisher|Callable),"Text is not allowed between `<dl>` and its child tags.

Fixes #5916.",2018-03-19 14:04:02,2018-03-19 14:26:10,https://api.github.com/repos/ReactiveX/RxJava/issues/5923,"['2.x', 'Cleanup', 'Documentation']",12,10,ReactiveX_RxJava_pull_5923.diff
ReactiveX/RxJava,change compile to implementation.,"Change `compile` to `implementation` in README.
",2018-03-18 18:17:20,2018-03-18 18:41:09,https://api.github.com/repos/ReactiveX/RxJava/issues/5922,"['2.x', 'Documentation']",3,3,ReactiveX_RxJava_pull_5922.diff
ReactiveX/RxJava,2.x: Add fusion support to ObservableSwitchMap inner source,"This PR improves the performance of the `Observable.switchMap` operator by adding fusion support as well as upgrading the `Completable` and `Single` conversion to `Observable` to be fuseable. The PR also fixes an error in the `DeferredScalarDisposable` implementation as the protocol requires calling with `null`.

The plain (`Observable.switchMap(Observable)`) conversion has promising performance improvements:

![image](https://user-images.githubusercontent.com/1269832/37464461-ba6d5c0c-2858-11e8-8aa0-96d53350cfed.png)

The conversion `Observable.switchMap(Maybe.toObservable)` has promising performance improvements:

![image](https://user-images.githubusercontent.com/1269832/37464488-cf9b1290-2858-11e8-8ac7-462a58f61a13.png)

The conversion `Observable.switchMap(Completable.toObservable)` is also promising, but there is a 11% loss in the scalar case for some reason:

![image](https://user-images.githubusercontent.com/1269832/37464621-2ad6b1c8-2859-11e8-9a0a-d34c8ff8048b.png)

Finally, the conversion  `Observable.switchMap(Single.toObservable)` got a bigger hit for the scalar case, 21% loss, but the rest are impressive:

![image](https://user-images.githubusercontent.com/1269832/37464636-41ea983e-2859-11e8-9258-6c1c85ee8347.png)



",2018-03-15 13:02:20,2018-03-15 13:22:29,https://api.github.com/repos/ReactiveX/RxJava/issues/5919,"['2.x', 'Performance']",342,76,ReactiveX_RxJava_pull_5919.diff
ReactiveX/RxJava,2.x: Improve the scalar source performance of Observable.(concat|switch)MapX,"This PR adds scalar source optimizations to `Observable` operators:

- `concatMapCompletable`
- `concatMapSingle`
- `concatMapMaybe`
- `switchMapCompletable`
- `switchMapSingle`
- `switchMapMaybe`

#### Benchmark

i7 4770K, Windows 7 x64, Java 8u162

The baseline is taken from #5914. The target is to be faster than using the plain `concatMap` or `switchMap` with a `toObservable` conversion. The apparent shortcomings of longer `concatMapMaybe` and `concatMapSingle` will be addressed in a subsequent PR.

![image](https://user-images.githubusercontent.com/1269832/37457267-c41bb4a4-2841-11e8-87a4-3951514a7f8f.png)
",2018-03-15 10:17:44,2018-03-15 10:35:57,https://api.github.com/repos/ReactiveX/RxJava/issues/5918,"['2.x', 'Performance']",420,43,ReactiveX_RxJava_pull_5918.diff
ReactiveX/RxJava,1.x: fix and deprecate evicting groupBy and add new overload,"See #5868

There is a problem with the existing 1.x `Observable.groupBy` overload with an evicting map factory where depending on the eviction behaviour of the supplied map factory, groups may not be completed and may leak memory. The problem extends to the method signature in that the eviction action should report the evicted `GroupedObservable` not the corresponding key.

This PR

* fixes the existing method at the expense of doubling up the internal map `groups` ( into `groupsCopy`) so that we can always successfully lookup the evicted group from the `groupsCopy` map. Evictions from `groups` are mirrored in `groupsCopy` after the lookup.
* deprecates the problematic overload indicating that it uses more memory than the preferred new overload
* adds a new method `groupBy` that has the corrected signature and offers `bufferSize` and `delayError` parameters for a bit more flexibility and to differentiate the erased signature from the deprecated method
* adds tests that were ported from the 2.x tests


",2018-03-15 01:07:20,2018-03-19 14:21:41,https://api.github.com/repos/ReactiveX/RxJava/issues/5917,[],928,6,ReactiveX_RxJava_pull_5917.diff
ReactiveX/RxJava,2.x: Optimize ObservableConcatMapCompletable,"This PR reduces the overhead in the `Observable.concatMapCompletable` operator by:

- adding front-queue fusion to eliminate queue allocations (although this didn't improve the performance beyond a +/- 3% noise),
- moving the `error` and `errorMode` fields into local variables, saving on the mandatory volatile re-read of other fields,
- adding a scalar shortcut in case the upstream is known to be 0-1.

#### Benchmark comparison:

i7 4770K, Windows 7 x64, Java 8u162

The PR improves the dedicated case considerably:

![image](https://user-images.githubusercontent.com/1269832/37437588-44960732-27ee-11e8-9f91-00c3313ac60b.png)

and it is now better across the board compared to a `toFlowable` conversion and the main `concatMap`:

![image](https://user-images.githubusercontent.com/1269832/37437618-7490a244-27ee-11e8-99de-cb20d5828555.png)
",2018-03-15 00:18:03,2018-03-15 08:49:48,https://api.github.com/repos/ReactiveX/RxJava/issues/5915,"['2.x', 'Performance']",244,24,ReactiveX_RxJava_pull_5915.diff
ReactiveX/RxJava,2.x: Benchmark X-Map-Z operators,"This PR adds JMH benchmarks to measure operators mapping onto other types, such as `flatMapCompletable`, `concatMapSingle`, etc. In addition, two new benchmarks were added to measure the `flatMapIterable` performance in additional situations.

#### Baseline results

i7 4770K, Windows 7 x64, Java 8u162

[JMH Compare GUI](https://github.com/akarnokd/jmh-compare-gui/releases/tag/v1.3.2) workspace file: [xmapz_ws.xml](https://gist.github.com/akarnokd/317e2d38128f45c8fbb1ec8ebd20d970)

The first diagram compares the dedicated, plain (same inner type as the outer type) and conversion-based flows:

![image](https://user-images.githubusercontent.com/1269832/37431058-6df2d0f2-27d4-11e8-9d6a-b9d8a0f34e0b.png)

The switchMap-based `Observable` operators look like they could use some optimizations. Overall, `count == 1` is not optimized with the dedicated versions.

From the `Observable`'s perspective:

![image](https://user-images.githubusercontent.com/1269832/37431169-c1f69d46-27d4-11e8-8159-c598e7f50e68.png)

Looks like the `concatMapX` operators could use some optimizations.

The `flatMapIterable` measures are as follows:

![image](https://user-images.githubusercontent.com/1269832/37431246-00fab8ba-27d5-11e8-94b5-67b94e1869a7.png)

The `Flowable` version seem to be considerably slower, probably not explainable due to backpressure overhead.",2018-03-14 21:18:35,2018-03-14 22:36:22,https://api.github.com/repos/ReactiveX/RxJava/issues/5914,"['2.x', 'Performance']",2687,1,ReactiveX_RxJava_pull_5914.diff
ReactiveX/RxJava,"2.x: Improve coverage, fix operator logic 03/12",Improve coverage of RxJava internal components. See the change explanation as comments below.,2018-03-12 15:22:48,2018-03-13 20:55:04,https://api.github.com/repos/ReactiveX/RxJava/issues/5910,"['2.x', 'Cleanup', 'Coverage']",895,86,ReactiveX_RxJava_pull_5910.diff
ReactiveX/RxJava,2.x: Cleanup test local variable names,"Add an unit test that scans the unit test files for common local variable misnaming due to copy-pasting between the types, such as:

- `TestObserver ts` <-> `TestSubscriber to`
- `PublishSubject pp` <-> `PublishProcessor ps`

See the new `CheckLocalVariablesInTests` for other patterns described with a regexp.",2018-03-09 13:25:25,2018-03-09 13:56:09,https://api.github.com/repos/ReactiveX/RxJava/issues/5907,"['2.x', 'Cleanup']",4706,4515,ReactiveX_RxJava_pull_5907.diff
ReactiveX/RxJava,2.x: Add public constructor for TestScheduler that takes the time.,"- adds a time constructor to TestScheduler
- should I make it experimental or will it just be stable?

Fixes #5901",2018-03-09 10:58:00,2018-03-09 13:22:54,https://api.github.com/repos/ReactiveX/RxJava/issues/5906,"['2.x', 'Enhancement']",25,1,ReactiveX_RxJava_pull_5906.diff
ReactiveX/RxJava,"2.x: Coverage improvements, logical fixes and cleanups 03/08",This PR fixes a couple of logical errors and cleans up some other components as well as improves the coverage of some classes. See the change comments below about the relevant details.,2018-03-09 00:18:03,2018-03-09 09:29:57,https://api.github.com/repos/ReactiveX/RxJava/issues/5905,"['2.x', 'Bug', 'Cleanup', 'Coverage']",411,42,ReactiveX_RxJava_pull_5905.diff
ReactiveX/RxJava,2.x: Fix Flowable.singleOrError().toFlowable() not signalling NoSuchElementException,"When a `singleOrError` is followed by `toFlowable()`, the assembly process switches the `Flowable->Single` operator into a `Flowable->Flowable` operator implementing the `singleOrError` behavior (saving the back-and-forth type conversion). The backing implementation was shared with `singleElement` and as such, did not properly handle the `orError` case for an empty source. The PR fixes the lack of `NoSuchElementException` in this case.

Fixes #5903.

The `Observable` variant doesn't have such optimization but the test has been converted to make sure `Observable` is verified for this aspect in case the optimization is implemented with it in the future.",2018-03-08 21:25:36,2018-03-09 08:43:45,https://api.github.com/repos/ReactiveX/RxJava/issues/5904,"['2.x', 'Bug']",36,6,ReactiveX_RxJava_pull_5904.diff
ReactiveX/RxJava,2.x: Perf measure of Flowable flatMap & flatMapCompletable,"This PR adds two benchmarks that measure the synchronous and asynchronous behavior of `Flowable.flatMap` and `Flowable.flatMapCompletable` when both are run with a `Completable` source.

Apart from the `item == 1` case, which is due to lack of scalar optimizations with `flatMapCompletable`, the `flatMapCompletable` is faster by a good margin:

![image](https://user-images.githubusercontent.com/1269832/37175444-de62c1fe-2319-11e8-90ce-1f0b0dbd661b.png)

I'd say the asynchronous use is slightly faster in general with `flatMapCompletable`:

![image](https://user-images.githubusercontent.com/1269832/37175490-fa38bd8e-2319-11e8-84ff-e01d1ec18129.png)

-----------

Originally, this PR started out as an attempt to optimize the inner consumer tracking in `flatMapCompletable` when the `maxConcurrency` is non-default by using a special containers for 1..8 instead of the `CompositeDisposable`. Unfortunately, this made it slightly slower in general (PR column):

![image](https://user-images.githubusercontent.com/1269832/37175604-4b4c8bb0-231a-11e8-8f28-a18b364c4d64.png)

The async benchmark is within +/- 3% most of the time, and generally inconclusive.

![image](https://user-images.githubusercontent.com/1269832/37175638-64e9e806-231a-11e8-8c42-682c53b986e7.png)

An additional test method was added to verify the new tracking classes, which is left as an additional mean to verify `flatMapCompletable`'s behavior in general.
",2018-03-08 20:50:46,2018-03-09 09:02:24,https://api.github.com/repos/ReactiveX/RxJava/issues/5902,"['2.x', 'Performance']",159,2,ReactiveX_RxJava_pull_5902.diff
ReactiveX/RxJava,2.x: Fix Observable.flatMap scalar maxConcurrency overflow,"Since `Observable` is not backpressured, the `flatMap` of it has to manage the buffering of inner sources so that only a limited number of them are active at the same time. However, when most outstanding inner sources were scalar (`just()` is such a source) but the drain loop was busy, the operator overflow its bounded scalar queue (as it is supposed to be holding at most maxConcurrency scalar items), causing an `IllegalStateException`.

The PR fixes this corner case by making sure the `tryScalarEmit` returns false if it had to queue up the scalar, which in turn prevents the next inner source to be subscribed to until the queued item is cleared. In addition, the terminal state check has to include the buffer holding the remaining inner sources: being done, having an empty scalar queue and having no active inner observers is just not enough.

`Flowable.flatMap` is not affected as it uses backpressure to ensure only a limited number of sources or scalars are mapped in.

Originally reported in the chat of this [StackOverflow question](https://stackoverflow.com/q/49151111/61158):

```

AndroidRuntime: FATAL EXCEPTION: RxCachedThreadScheduler-1 
Process: com.hackerli.girl, PID: 6030 
java.lang.IllegalStateException: Scalar queue full?! 
at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.tryEmitScalar(ObservableFlatMap.java:250) 
at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(ObservableFlatMap.java:146) 
at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:475) 
at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:323) 
at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onComplete(ObservableFlatMap.java:579) 
at io.reactivex.internal.observers.BasicFuseableObserver.onComplete(BasicFuseableObserver.java:119) 
at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onComplete(ObservableSubscribeOn.java:68) 
at retrofit2.adapter.rxjava2.BodyObservable$BodyObserver.onComplete(BodyObservable.java:66) 
at retrofit2.adapter.rxjava2.CallExecuteObservable.subscribeActual(CallExecuteObservable.java:47)
at io.reactivex.Observable.subscribe(Observable.java:11442) 
at retrofit2.adapter.rxjava2.BodyObservable.subscribeActual(BodyObservable.java:34) 
at io.reactivex.Observable.subscribe(Observable.java:11442) 
at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96) 
at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:571) 
at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66) 
at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57) 
at java.util.concurrent.FutureTask.run(FutureTask.java:237) 
at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:269) 
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113) 
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588) 
at java.lang.Thread.run(Thread.java:818)
```",2018-03-07 14:33:14,2018-03-07 17:15:26,https://api.github.com/repos/ReactiveX/RxJava/issues/5900,"['2.x', 'Bug']",157,12,ReactiveX_RxJava_pull_5900.diff
ReactiveX/RxJava,2.x: Fix excess item retention in the other replay components,"This is a follow-up PR to #5892 in order to avoid item retention in the head node. For the `ReplayProcessor`, the cleanup can be triggered with `cleanupBuffer`. For the `replay()` operators, such trigger is not possible. However, the terminal events will perform the cleanup internally at least.",2018-03-07 12:18:03,2018-03-07 17:49:10,https://api.github.com/repos/ReactiveX/RxJava/issues/5898,"['2.x', 'Shortcoming']",548,8,ReactiveX_RxJava_pull_5898.diff
ReactiveX/RxJava,2.x: clarify dematerialize() and terminal items/signals,"Specify in both `Flowable` and `Observable` that a terminal notification item or a regular terminal signal ends the flow.

Fixes: #5261",2018-03-07 10:21:14,2018-03-07 11:06:50,https://api.github.com/repos/ReactiveX/RxJava/issues/5897,"['2.x', 'Documentation']",38,0,ReactiveX_RxJava_pull_5897.diff
ReactiveX/RxJava,Fix buffer() documentation to correctly describe onError behaviour,Fixes #5894. I just copied the sentence from the fixed docs in 1.x and updated to use ObservableSource/Publisher naming.,2018-03-07 03:11:47,2018-03-07 10:46:53,https://api.github.com/repos/ReactiveX/RxJava/issues/5895,"['2.x', 'Documentation']",128,72,ReactiveX_RxJava_pull_5895.diff
ReactiveX/RxJava,2.x: Fix Flowable.publish(-|Function) subscriber swap possible data loss,"This PR fixes an avoidable dataloss in the following subscriber-swap scenario with the `publish()` and `publish(Function<Flowable, Publisher>)`.

When an `onNext` changes the current array of subscribers (an existing consumer cancelled or a new one arrived), the change detection is delayed and items may get dropped even though a fresh consumer could take those values.

The algorithms were updated to fix this case as well as the emission tracking in `FlowableMulticastProcessor`: a global `emitted` value is not good here after all (subscribers joining late would indicate an incorrect aggregate demand and get overflown).

One of the advanced uses of `publish(Function)` is to implement consumption mode changes by having a mode cancel the subscription to the shared `Flowable` and synchronously subscribe a new consumer with a different behavior. 

The discovery of this shortcoming was due to a special transformation pattern: apply a transformer if the source is not empty, and in this case, deliver all items of it.

```java
FlowableTransformer<T, U> transformer = ...
source.publish(shared ->
   // let's see if there is at least 1 source item
   shared.take(1)
   // if there is one item, stop this phase and keep the item
   .concatMap(first ->
       // given the very first item, apply the transformation
       // on the ""original"" sequence by reattaching the first
       // item to the rest of the source
       transformer.apply(shared.startWith(first))
   )
)
.subscribe(/* ... */);
```",2018-03-06 22:39:03,2018-03-07 17:32:48,https://api.github.com/repos/ReactiveX/RxJava/issues/5893,"['2.x', 'Shortcoming']",439,40,ReactiveX_RxJava_pull_5893.diff
ReactiveX/RxJava,2.x: Fix the extra retention problem in ReplaySubject,"In the bounded buffers of `ReplaySubject`, the head reference may retain one extra item when the trimming happens. Nulling out this reference is not possible at this point because old consumers may be still walking through the underlying linked list of nodes. However, replacing a head with the same next pointer (which is always not null if value is not null) but no value will eventually let the value get GCd. This cleanup doesn't happen on every `onNext` because it doubles the node allocation and thus the overhead.

This PR modifies the code so that terminal events do perform this head swapping and introduces the `ReplaySubject.cleanupBuffer()` method to allow the user to perform the head swapping while the `ReplaySubject` is not yet terminated and the cleanup is needed.

If this type of change is accepted, the `ReplayProcessor` can also be refitted. For the `replay()` operators, the terminal cleanup can be implemented but the on demand cleanup can't as there is no API surface for its internal buffer available.",2018-03-06 16:18:07,2018-03-07 11:21:54,https://api.github.com/repos/ReactiveX/RxJava/issues/5892,"['2.x', 'Shortcoming']",166,6,ReactiveX_RxJava_pull_5892.diff
ReactiveX/RxJava,2.x: Improve coverage & related cleanup 03/05,"Improve the coverage of various components, fix impossible paths and other fixes. See the comments attached to the code changes.",2018-03-05 15:16:21,2018-03-05 16:41:10,https://api.github.com/repos/ReactiveX/RxJava/issues/5891,"['2.x', 'Cleanup', 'Coverage']",2523,433,ReactiveX_RxJava_pull_5891.diff
ReactiveX/RxJava,Added nullable annotations to subjects,"Adding nullable annotations to subjects. The `throwable` and `getValue` methods are annotated with Nullable.

Quick question about styling - In some places, javadocs has trailing whitespaces but it is absent in other places. Is there a styling policy around that? Intellij is removing the trailed whitespace automatically.",2018-03-05 03:54:47,2018-03-05 10:00:51,https://api.github.com/repos/ReactiveX/RxJava/issues/5890,"['2.x', 'Cleanup']",54,33,ReactiveX_RxJava_pull_5890.diff
ReactiveX/RxJava,"2.x: Cleanup, coverage and related component fixes","This PR improves the coverage of various components and contains the following additional fixes:

- Remove a very unlikely cancellation check in `FlowableConcatMapEager`.
- Improve backpressure tracking in `FlowablePublishMulticast` to avoid atomic decrement per items emitted (part of `publish(Function)`).
- Improve check for empty or terminated state in `FlowablePublishMulticast` by using the array length.
- `UnicastProcessor` termination to use a one-step `getAndSet`
- `BehaviorSubject` termination to use a one-step `getAndSet`
- Remove impossible try-finally in `BehaviorSubject.setCurrent` as the body could never crash.
",2018-03-04 23:27:58,2018-03-05 00:08:39,https://api.github.com/repos/ReactiveX/RxJava/issues/5889,"['2.x', 'Cleanup', 'Coverage']",490,139,ReactiveX_RxJava_pull_5889.diff
ReactiveX/RxJava,2.x: Fix Flowable.window(Publisher|Callable) upstream handling,"This PR fixes the upstream handling in `Flowable.window(Publisher)` and `Flowable.window(Callable<Publisher>)` operators to make sure if both the main output and the inner windows have been cancelled, the upstream is also cancelled.

Related: #5887, #5881.

In addition, the Jacoco code coverage has been updated to 0.8.0 mainly due to the [automatic filtering of difficult-to-impossible code paths](https://github.com/jacoco/jacoco/releases/tag/v0.8.0).",2018-03-04 19:36:19,2018-03-04 23:54:21,https://api.github.com/repos/ReactiveX/RxJava/issues/5888,"['2.x', 'Bug']",990,336,ReactiveX_RxJava_pull_5888.diff
ReactiveX/RxJava,2.x: Fix window(Observable|Callable) upstream handling,"This PR fixes the upstream handling in `Observable.window(ObservableSource)` and `Observable.window(Callable<ObservableSource>)` operators to make sure if both the main output and the inner windows have been disposed, the upstream is also disposed.

Fixes #5881.

*Remark:*

There are a couple of `w != null` checks showing up as partially covered. In theory, with the right interleaving, `w` can become `null`, but unfortunately the usual `TestHelper.race()` testing is unlikely to trigger that case. There would be a higher chance with 3 threads (one disposing, one completing the main and one completing the inner window) but the current CI is effectively 1.5 - 2 cores/threads that tend to not produce a thorough interleaving.",2018-03-04 17:25:46,2018-03-04 18:19:12,https://api.github.com/repos/ReactiveX/RxJava/issues/5887,"['2.x', 'Bug']",943,276,ReactiveX_RxJava_pull_5887.diff
ReactiveX/RxJava,2.x: Upgrade the algorithm of Observable.timeout(time|selector) operators,"This PR improves the algorithms of the `Observable.timeout(time)` and `Observable.timeout(selector)` operators to match their `Flowable` counterparts implemented in #5661.

In addition, coverage of the `Flowable` counterparts have been improved by synchronizing the unit tests.

Note that they were the last users of `ObserverFullArbiter` and `FullArbiterObserver` which are now removed.

Closes #5882.",2018-03-04 13:09:34,2018-03-04 13:38:27,https://api.github.com/repos/ReactiveX/RxJava/issues/5886,"['2.x', 'Enhancement']",911,777,ReactiveX_RxJava_pull_5886.diff
ReactiveX/RxJava,Fix BlockingSingle.value() not unsubscribing after onSuccess and onError,"Fix for the issue mentioned here: https://github.com/ReactiveX/RxJava/issues/5884

```BlockingSingle.value()``` was missing the unsubscribe() call to the created subscription. 
",2018-03-03 23:18:59,2018-03-04 03:04:06,https://api.github.com/repos/ReactiveX/RxJava/issues/5885,[],35,4,ReactiveX_RxJava_pull_5885.diff
ReactiveX/RxJava,2.x: Improve coverage and fix small mistakes/untaken paths in operators,"This PR improves the coverage of RxJava while adjusting some code paths and fixing other types of smaller bugs.

- Fix `Maybe.merge(Publisher)` to define a 1 element buffer only.
- Fix `Maybe.mergeDelayError(Publisher)` to use the dedicated `FlowableFlatMapPublisher` similar to the plain `merge()`.
- In `Flowable.flatMap`, checking for empty or cancelled arrays in `removeInner()` can be replaced with a length check.
- Make sure in `Flowable.reduce(seed, f)` the terminal events can't be called a second time if the reducer crashes.
- Turn the `FlowableReplay.MultiCastPublisher` into a `Flowable` and rename it to `MulticastFlowable`.
- Fix `FlowableWindowBoundary` not cancelling the upstream on a missing backpressure case, causing `NullPointerException`.
- Remove unused override of `accept()` in `FlowableWindowBoundary`.
- Remove the ineffective done flag from `OperatorWindowBoundaryOpenSubscriber`.
- Replace the timer CASs with the `replace()` call in `FlowableWindowTimed`.
- Remove the unused `RepeatWhen`, `ErrorMapperFilter` and `RetryWhen` components from `ObservableInternalHelper`.
- Make sure the value is cleared at most once in `ObservableReduceSeedSingle`.
- Simplify `ObservableWindowBoundarySelector`'s inner consumer's `onNext` handling.
- Simplify `FlowableWindowBoundarySelector`'s inner consumer's `onNext` handling.
- Inline the finally actions in `InstantPeriodicTask.call()`.
- Fix `InstantPeriodicTask.setFirst` and `setRest` to return from the loop when the task has been cancelled to prevent excess looping and overwriting the `CANCELLED` indicator.
- Inline the finally actions in `ScheduledDirectPeriodicTask.call()`.
- Slight adjustment of crash propagation in the `SchedulerWhen` constructor.
- In `BehaviorProcessor`, checking for empty or cancelled arrays in `remove()` can be replaced with a length check.
- In `BehaviorSubject`, checking for empty or cancelled arrays in `remove()` can be replaced with a length check.",2018-03-03 22:26:04,2018-03-04 11:39:29,https://api.github.com/repos/ReactiveX/RxJava/issues/5883,"['2.x', 'Bug', 'Cleanup', 'Coverage']",2713,178,ReactiveX_RxJava_pull_5883.diff
ReactiveX/RxJava,2.x: Add Flowable.generateAsync to bridge 1-by-1 async APIs,"This PR proposes a new source operator to bridge async APIs that can be repeatedly called to produce the next item (or terminate in some way) asynchronously and only call the API again once the result has been received and delivered to the downstream, while honoring the backpressure of the downstream. This means if the downstream stops requesting, the API won't be called until the latest result has been requested and consumed by the downstream.

The operator was inspired by [this StackOverflow](https://stackoverflow.com/questions/49059458/is-there-an-equivalent-of-project-reactors-flux-create-that-caters-for-push-p) question.

Example APIs could be [AsyncEnumerable](https://github.com/akarnokd/async-enumerable#async-enumerable) style, coroutine style or [async-await](https://github.com/electronicarts/ea-async).

There are no convenience overloads unlike `generate`, because these APIs likely require their interaction points created for each individual subscriber and otherwise should not be run from multiple subscriptions of the same Flowable.

(I'm still thinking about how a batched variant of this could be reasonably implemented. Batched means the downstream request is presented to the async preparation call and multiple items could be generated with a single API invocation. There are, however, complications such as controlling the request channel over multiple intermediate operators in between or how to detect and act on the case when there are fewer items delivered than requested and the API didn't indicate completion.)

The JavaDoc features the following example:

#### Example
Let's assume there is an async API with the following interface definition:

```java
interface AsyncAPI<T> extends AutoCloseable {

    CompletableFuture<Void> nextValue(Consumer<? super T> onValue);

}
```

When the call succeeds, the `onValue` is invoked with it. If there are no more items, the
` CompletableFuture`  returned by the last ` nextValue`  is completed (with ` null` ).
If there is an error, the same ` CompletableFuture`  is completed exceptionally. Each
` nextValue`  invocation creates a fresh ` CompletableFuture`  which can be cancelled
if necesary. ` nextValue`  should not be invoked again until the ` onValue`  callback
has been notified.

An instance of this API can be obtained on demand, thus the state of this operator consists of the
` AsyncAPI`  instance supplied for each individual {@code Subscriber}. The API can be transformed into
a ` Flowable`  as follows:

```java
Flowable<Integer> source = Flowable.<Integer, AsyncAPI<Integer>>generateAsync(

    // create a fresh API instance for each individual Subscriber
    () -> new AsyncAPIImpl<Integer>(),

    // this BiFunction will be called once the operator is ready to receive the next item
    // and will invoke it again only when that item is delivered via emitter.onNext()
    (state, emitter) -> {
        // issue the async API call
        CompletableFuture<Void> f = state.nextValue(

            // handle the value received
            value -> {

                // we have the option to signal that item
                if (value % 2 == 0) {
                    emitter.onNext(value);
                } else if (value == 101) {
                    // or stop altogether, which will also trigger a cleanup
                    emitter.onComplete();
                } else {
                    // or drop it and have the operator start a new call
                    emitter.onNothing();
                }
            }
        );

        // This API call may not produce further items or fail
        f.whenComplete((done, error) -> {
            // As per the CompletableFuture API, error != null is the error outcome,
            // done is always null due to the Void type
            if (error != null) {
                emitter.onError(error);
            } else {
                emitter.onComplete();
            }
        });

        // In case the downstream cancels, the current API call
        // should be cancelled as well
        emitter.replaceCancellable(() -> f.cancel(true));

        // some sources may want to create a fresh state object
        // after each invocation of this generator
        return state;
    },

    // cleanup the state object
    state -> { state.close(); }
);
```",2018-03-02 22:42:21,2018-03-07 17:30:52,https://api.github.com/repos/ReactiveX/RxJava/issues/5879,"['2.x', 'Enhancement']",1485,0,ReactiveX_RxJava_pull_5879.diff
ReactiveX/RxJava,2.x: Add note about NoSuchElementException to Single.zip().,,2018-03-02 16:50:52,2018-03-03 10:38:45,https://api.github.com/repos/ReactiveX/RxJava/issues/5876,"['2.x', 'Documentation']",8,2,ReactiveX_RxJava_pull_5876.diff
ReactiveX/RxJava,2.x: Add Observable switchMapX and concatMapX operators,"This PR ports the various `switchMapX` and `concatMapX` operators from #5870, #5871, #5872 and #5873 to `Observable`:

- `concatMapCompletable` (replaced by the common implementation)
- `concatMapCompletableDelayError`
- `concatMapMaybe`
- `concatMapMaybeDelayError`
- `concatMapSingle`
- `concatMapSingleDelayError`
- `switchMapCompletable`
- `switchMapCompletableDelayError`
- `switchMapMaybe`
- `switchMapMaybeDelayError`
- `switchMapSingle` (dedicated implementation)
- `switchMapSingleDelayError` (dedicated implementation)

This PR concludes the requested set of operators in #4853.

Marbles will be updated/adjusted in a separate PR.",2018-03-02 11:29:32,2018-03-03 13:36:05,https://api.github.com/repos/ReactiveX/RxJava/issues/5875,"['2.x', 'Enhancement']",4949,288,ReactiveX_RxJava_pull_5875.diff
ReactiveX/RxJava,"2.x: Add Flowable.switchMap{Maybe,Single}{DelayError} operators","This PR adds `Flowable` operators that allow switching between a mapped sequence of `Maybe`s or `Single`s, with or without delaying their errors:

- `switchMapMaybe`
- `switchMapMaybeDelayError`
- `switchMapSingle`
- `switchMapSingleDelayError`

They are in the same PR as the `Single` variant's implementation is practically the `Maybe` implementation minus the `onComplete` case.

Their marbles will be updated in a separate PR.

Originally requested in #4853.",2018-03-01 20:35:47,2018-03-02 08:56:41,https://api.github.com/repos/ReactiveX/RxJava/issues/5873,"['2.x', 'Enhancement']",1990,0,ReactiveX_RxJava_pull_5873.diff
ReactiveX/RxJava,"2.x: Add Flowable.concatMap{Maybe,Single}{DelayError} operators","This PR adds operators that allow concatenating a mapped sequence of `Maybe`s or `Single`s, with or without delaying their errors:

- `concatMapMaybe` (+1 overload with prefetch)
- `concatMapMaybeDelayError` (+2 overloads with error mode and prefetch)
- `concatMapSingle` (+1 overload with prefetch)
- `concatMapSingleDelayError` (+2 overloads with error mode and prefetch)

They are in the same PR as the `Single` variant's implementation is practically the `Maybe` implementation minus the `onComplete` case.

Their marbles will be updated in a separate PR.

Originally requested in #4853.",2018-03-01 14:27:47,2018-03-01 18:46:57,https://api.github.com/repos/ReactiveX/RxJava/issues/5872,"['2.x', 'Enhancement']",1692,5,ReactiveX_RxJava_pull_5872.diff
ReactiveX/RxJava,2.x: Add Flowable.concatMapCompletable{DelayError} operator,"This PR adds the `Flowable.concatMapCompletable` and `Flowable.concatMapCompletableDelayError` operators as requested by #4853.

The marbles will be updated in a separate PR.",2018-02-28 21:28:26,2018-03-01 12:05:53,https://api.github.com/repos/ReactiveX/RxJava/issues/5871,"['2.x', 'Enhancement']",845,0,ReactiveX_RxJava_pull_5871.diff
ReactiveX/RxJava,2.x: Add Flowable.switchMapCompletable{DelayError} operator,"This PR adds the `Flowable.switchMapCompletable` and `Flowable.switchMapCompletableDelayError` operators as requested by #4853.

The associated new marbles are:

![switchMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapCompletable.f.png)

![switchMapCompletableDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapCompletableDelayError.f.png)",2018-02-28 11:09:10,2018-03-01 16:46:05,https://api.github.com/repos/ReactiveX/RxJava/issues/5870,"['2.x', 'Enhancement']",720,0,ReactiveX_RxJava_pull_5870.diff
ReactiveX/RxJava,2.x: enhance test for groupBy with evicting map factory,Enhance `FlowableGroupByTest.SingleThreadEvictingHashMap` so that it actually evicts and be a bit defensive by supporting `putAll` and `clear` properly. No change to `src/main/java`.,2018-02-26 23:07:20,2018-02-26 23:22:45,https://api.github.com/repos/ReactiveX/RxJava/issues/5867,"['2.x', 'Test']",6,2,ReactiveX_RxJava_pull_5867.diff
ReactiveX/RxJava,2.x: Improve the JavaDoc of the other lift() operators,"Improve the JavaDoc of the `{Observable | Maybe | Single | Completable}.lift()` operator, adapting the text from #5863.",2018-02-26 12:51:12,2018-02-28 08:41:25,https://api.github.com/repos/ReactiveX/RxJava/issues/5865,"['2.x', 'Documentation']",529,54,ReactiveX_RxJava_pull_5865.diff
ReactiveX/RxJava,2.x: Expand the documentation of the Flowable.lift() operator,"This PR expands the documentation of the `Flowable.lift()` operator used for inserting custom operators into flows in a functional and fluent fashion.

The other reactive base classes feature similar `lift()` operators for which the text can be adapted and contributed in a separate PR once the content of this PR is stabilized by review feedback.

Related: #5862 ",2018-02-23 23:28:00,2018-02-26 11:45:36,https://api.github.com/repos/ReactiveX/RxJava/issues/5863,"['2.x', 'Documentation']",133,17,ReactiveX_RxJava_pull_5863.diff
ReactiveX/RxJava,"2.x: Fix Javadoc warnings, links to the JDK types","The definition of multiple external links was wrong in `build.gradle` where the `options.links()` is actually defined as `String...` and multiple calls are not additional. This made the generated JavaDoc not have links to the JDK types. The fix now properly uses the varargs of the method. In addition, somehow the plain `http://` still wouldn't generate the proper links probably because they are redirected to `https://` for which the javadoc tool is not prepared.

In addition, 4 dangling `<p>` tags were showing up as warnings and have been removed.",2018-02-22 14:27:44,2018-02-23 10:07:53,https://api.github.com/repos/ReactiveX/RxJava/issues/5861,"['2.x', 'Cleanup', 'Documentation']",4,6,ReactiveX_RxJava_pull_5861.diff
ReactiveX/RxJava,2.x: Flowable.groupBy add overload with evicting map factory,"As per discussion in #5763, this PR adds an overload for `Flowable.groupBy` that specifies an `evictingMapFactory`. 

An example of usage taken from the new javadoc:

```java
Function<Consumer<Object>, Map<Integer, Object>> evictingMapFactory = 
   notify ->
       CacheBuilder
         .newBuilder() 
         .maximumSize(3)
         .removalListener(entry -> { 
              try {
                  // emit the value not the key!
                  notify.accept(entry.getValue());
              } catch (Exception e) {
                  throw new RuntimeException(e);
              }
            })
         .<Integer, Object> build()
         .asMap();
         
 // Emit 1000 items but ensure that the
 // internal map never has more than 3 items in it           
 Flowable
   .range(1, 1000)
   // note that number of keys is 10
   .groupBy(x -> x % 10, x-> x, true, 16, evictingMapFactory)
   .flatMap(g -> g)
   .forEach(System.out::println);
```

Note that I based this operator on the 1.x version which I think may have a bug that goes as far as the signature of that method. The eviction consumer should not be given a key but rather the value from the map. I'll pursue the 1.x issue after dealing with this.
",2018-02-21 03:59:36,2018-02-22 12:24:21,https://api.github.com/repos/ReactiveX/RxJava/issues/5860,"['2.x', 'Enhancement']",416,7,ReactiveX_RxJava_pull_5860.diff
ReactiveX/RxJava,2.x: Remove unnecessary comment from Observable.timeInterval(TimeUnit),"
",2018-02-18 16:57:57,2018-02-18 17:30:45,https://api.github.com/repos/ReactiveX/RxJava/issues/5858,[],1,1,ReactiveX_RxJava_pull_5858.diff
ReactiveX/RxJava,2.x: Unify race test loop counts and invocations,"This PR replaces the individual race-test loop counts with global constants and removes the unnecessary custom `Scheduler` value from the invocations of `TestHelper.race()`.

The default loop count is now 2500 and should elimitate the +/- 0.1% coverage fluctuations.",2018-02-17 22:41:13,2018-02-17 23:18:16,https://api.github.com/repos/ReactiveX/RxJava/issues/5857,"['2.x', 'Cleanup', 'Test']",580,623,ReactiveX_RxJava_pull_5857.diff
ReactiveX/RxJava,2.x: Add finite requirement to various collector operators JavaDoc,"Add notes to the following operators to state their sources has to be finite. It has been already done to `toList` in #5465.

- `collect`
- `collectInto`
- `reduce`
- `reduceWith`
- `toMap`
- `toMultimap`
- `toSortedList`",2018-02-17 21:04:23,2018-02-19 20:41:01,https://api.github.com/repos/ReactiveX/RxJava/issues/5856,"['2.x', 'Documentation']",158,33,ReactiveX_RxJava_pull_5856.diff
ReactiveX/RxJava,Fix a race condition in OperatorMerge.InnerSubscriber#onError,"Inner subscriber must queue the error first before setting done, so that after `emitLoop` removes the subscriber,`emitLoop` is guaranteed to notice the error. Otherwise it would be possible that inner subscribers count was 0, and at the same time the error queue was empty.

We observed that sometimes a result of flattening two observables doesn't properly mark the resulting observable as failed, despite the inner observable properly reporting onError. Instead, the error condition was ignored and the result observable was completing normally.


",2018-02-14 20:47:24,2018-02-15 10:15:44,https://api.github.com/repos/ReactiveX/RxJava/issues/5851,"['1.x', 'Bug']",32,1,ReactiveX_RxJava_pull_5851.diff
ReactiveX/RxJava,Fix a race condition that may make OperatorMaterialize emit too many terminal notifications,"We're using RxJava 1.3.5 and one of our tests occasionally fails (very hard to reproduce). The test asserts that `anObservable.toBlocking.toList` (RxScala) expression throws a particular exception, because we expect the observable to be in error state by emitting a single `onError`. However, in rare cases, we observe that there is no exception thrown, and an empty list is returned instead. We verified that the problem is not the observable we use. The observable properly fires the `doOnError` handler prior to  the test assertion failure. Therefore we suspected something wrong happening in the `toBlocking.toList` conversion. I debugged that in fact this conversion uses `OperatorMaterialize` as a part of `BlockingOperatorToIterator`. 

I took a look at the `OperatorMaterialize` and found an obvious bug. The `busy` variable is never set to true anywhere, despite the comments showing the author of the code intended it to be true when the `drain` loop was running.

The PR fixes this problem by setting `busy` to true at the entry of the `drain` method. 

However I still have some doubts about the original code: 
- Why does `drain` have to be called from `requestMore`? Why isn't it enough to call it from `onCompleted` and `onError`? It looks like the `drain` logic does anything only if the `terminalNotification` is set, and it can be set only by `onCompleted` and `onError`.
- What is this `drain` logic supposed to do? Looks rather complex and the intent of it is not obvious. If we don't call it from `requestMore` then maybe we don't need the `drain` logic at all? Why not emit the terminal notifications directly from `onError` and `onCompleted` ?

Thanks,
Piotr Kołaczkowski",2018-02-14 11:25:36,2018-02-15 18:49:26,https://api.github.com/repos/ReactiveX/RxJava/issues/5850,"['1.x', 'Bug']",32,1,ReactiveX_RxJava_pull_5850.diff
ReactiveX/RxJava,2.x: Improve the wording of the Maybe.fromCallable JavaDoc,This PR improves the wording and details of the `Maybe.fromCallable` operator's JavaDoc.,2018-02-09 22:13:08,2018-02-13 09:19:46,https://api.github.com/repos/ReactiveX/RxJava/issues/5848,"['2.x', 'Documentation']",24,8,ReactiveX_RxJava_pull_5848.diff
ReactiveX/RxJava,2.x: Add efficient mergeWith(Single|Maybe|Completable) overloads.,"This PR adds specialized overloads to the `mergeWith` operator in `Flowable` and `Observable`.

If accepted, the marbles will be updated in a separate PR.

Related: #5350.",2018-02-09 11:34:17,2018-02-19 20:18:42,https://api.github.com/repos/ReactiveX/RxJava/issues/5847,"['2.x', 'Enhancement']",3441,4,ReactiveX_RxJava_pull_5847.diff
ReactiveX/RxJava,2.x: Add efficient concatWith(Single|Maybe|Completable) overloads,"This PR adds specialized overloads to the `concatWith` operator in `Flowable` and `Observable`.

If accepted, the marbles will be updated in a separate PR.

Related: #5350.",2018-02-08 20:19:08,2018-02-16 11:37:38,https://api.github.com/repos/ReactiveX/RxJava/issues/5845,"['2.x', 'Enhancement']",1717,3,ReactiveX_RxJava_pull_5845.diff
ReactiveX/RxJava,2.x: Explain the properties of the XEmitter interfaces in detail,"This PR explains the properties of the 5 specifc `Emitter` types in more details:

- error handling
- resource handling
- concurrent use aspects
- the difference between `Disposable` and `Cancellable` resource handling
- terminal state effects",2018-02-08 12:53:37,2018-02-13 08:56:24,https://api.github.com/repos/ReactiveX/RxJava/issues/5844,"['2.x', 'Documentation']",135,22,ReactiveX_RxJava_pull_5844.diff
ReactiveX/RxJava,2.x: Expand the JavaDocs of the Scheduler API,"This PR adds more details to the `Scheduler` and `Worker` API, rewords some older sentences and fixes a few mistakes in others.

In addition, the wording of the `SchedulerRunnableIntrospection` felt a bit clumsy and has been updated as well.",2018-02-07 21:37:14,2018-02-13 07:28:00,https://api.github.com/repos/ReactiveX/RxJava/issues/5843,"['2.x', 'Documentation']",142,29,ReactiveX_RxJava_pull_5843.diff
ReactiveX/RxJava,prevent encapsulation issues,"Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [x] Please give a description about what and why you are contributing, even if it's trivial.

  - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.
---

Member values are subject to change from anywhere in the code and may not meet the programmer's assumptions.
",2018-02-05 23:34:04,2018-02-05 23:42:14,https://api.github.com/repos/ReactiveX/RxJava/issues/5842,['Invalid'],13,5,ReactiveX_RxJava_pull_5842.diff
ReactiveX/RxJava,2.x: Improve JavaDoc of XObserver types.,"This PR improves the JavaDoc of the 4 RxJava main consumer types:

- `Observer`
- `SingleObserver`
- `MaybeObserver`
- `CompletableObserver`",2018-02-05 12:34:26,2018-02-08 22:02:49,https://api.github.com/repos/ReactiveX/RxJava/issues/5841,"['2.x', 'Documentation']",138,21,ReactiveX_RxJava_pull_5841.diff
ReactiveX/RxJava,Added nullability annotation for RxJavaPlugins.onCompletableAssembly,Just annotation that didn't exist ,2018-02-03 13:53:48,2018-02-03 14:17:32,https://api.github.com/repos/ReactiveX/RxJava/issues/5838,"['2.x', 'Cleanup']",1,0,ReactiveX_RxJava_pull_5838.diff
ReactiveX/RxJava,2.x: Detail distinct() & distinctUntilChanged() in JavaDoc,The PR clarifies the comparison and retention behavior of the `distinct` and `distinctUntilChanged` operators (in both `Flowable` and `Observable`).,2018-02-02 15:49:39,2018-02-03 16:28:57,https://api.github.com/repos/ReactiveX/RxJava/issues/5837,"['2.x', 'Documentation']",135,10,ReactiveX_RxJava_pull_5837.diff
ReactiveX/RxJava,Add JavaDoc links to the base reactive classes to Readme: Getting started,"Turn the listing of the base reactive classes in the ""Getting started"" ReadMe section.",2018-02-02 14:37:06,2018-02-02 15:09:49,https://api.github.com/repos/ReactiveX/RxJava/issues/5836,"['2.x', 'Documentation']",5,5,ReactiveX_RxJava_pull_5836.diff
ReactiveX/RxJava,2.x: Fix copy-paste errors in SingleSubject JavaDoc,The `SingleSubject` JavaDoc was derived from the `MaybeSubject` JavaDoc and thus some mentions of `onComplete` remained in there. This PR fixes copy-paste errors.,2018-02-02 09:15:33,2018-02-02 15:09:30,https://api.github.com/repos/ReactiveX/RxJava/issues/5834,"['2.x', 'Documentation']",4,4,ReactiveX_RxJava_pull_5834.diff
ReactiveX/RxJava,2.x: Fix Observable.switchMap main onError not disposing the current inner source,"The `Observable.switchMap` had bad logic in its main `onError` handler which didn't dispose the current inner `Observable`.

The `Flowable` version didn't have this logic error. Both variants received an unit test to verify the correct behavior.

Fixes #5832.",2018-02-01 17:51:34,2018-02-02 09:56:25,https://api.github.com/repos/ReactiveX/RxJava/issues/5833,"['2.x', 'Bug']",119,7,ReactiveX_RxJava_pull_5833.diff
ReactiveX/RxJava,2.x: Reword the just() operator and reference other typical alternatives,"This PR updates the `Flowable.just` and `Observable.just` JavaDocs to clarify its behavior, namely it re-emits a constant reference and does not compute it. In addition, links to the other typical source operators are added. The redundant sentence about `just` were removed as well.",2018-01-31 11:14:38,2018-02-01 06:36:52,https://api.github.com/repos/ReactiveX/RxJava/issues/5830,"['2.x', 'Documentation']",22,14,ReactiveX_RxJava_pull_5830.diff
ReactiveX/RxJava,2.x: Document replay(N) emission retention caveat,"Adds javadocs indicating a caveat regarding size-bounded replay operators, subjects, and processors. See #5827 for details.",2018-01-31 00:49:29,2018-01-31 09:34:51,https://api.github.com/repos/ReactiveX/RxJava/issues/5828,"['2.x', 'Documentation']",55,0,ReactiveX_RxJava_pull_5828.diff
ReactiveX/RxJava,2.x: Fix O.blockingIterable(int) & add O.blockingLatest marbles,"This PR fixes the `Observable.blockingIterable(int)` marble by using the `blockingIterable` redone earlier.

In addition, the PR adds a marble diagram to `Observable.blockingLatest`:

![blockingLatest](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLatest.o.png)",2018-01-30 11:31:48,2018-01-30 23:18:25,https://api.github.com/repos/ReactiveX/RxJava/issues/5826,"['2.x', 'Documentation']",3,1,ReactiveX_RxJava_pull_5826.diff
ReactiveX/RxJava,2.x: Improve the wording of the share() JavaDocs,"This PR improves the wording of the `Flowable.share()` and `Observable.share()` operators and fixes a JavaDoc link display mistake:

![image](https://user-images.githubusercontent.com/1269832/35439076-7a9816c4-0299-11e8-97ca-462238c6489f.png)
",2018-01-26 12:05:13,2018-01-28 13:31:38,https://api.github.com/repos/ReactiveX/RxJava/issues/5824,"['2.x', 'Documentation']",4,4,ReactiveX_RxJava_pull_5824.diff
ReactiveX/RxJava,1.x: Plugin lookup workaround for System.properties access restrictions,"The PR adds a `try-catch` around the System property lookup inside the `RxJavaPlugins` in case a security manager prevents reading arbitrary property entries.

This mainly affects the `rxjava.plugin.[index].class` lookup which were introduced due to the 31 character key limit on Android.

However, when running in a container such as Tomcat, a security manager may prevent reading these type of prefixed entries (where `[index]` can't be known upfront), crashing the initialization.

**Update**:

The `System.getProperties()` can also fail, therefore, retrieving the properties has been factored out into a separate method that returns an empty properties.

Fixes #5819.",2018-01-25 09:16:24,2018-01-25 12:40:00,https://api.github.com/repos/ReactiveX/RxJava/issues/5820,"['1.x', 'Shortcoming']",109,17,ReactiveX_RxJava_pull_5820.diff
ReactiveX/RxJava,2.x: Add Subject and Processor marbles,"This PR adds the missing marble diagrams to the various `Subject` and `Processor` implementations:

### AsyncSubject

![AsyncSubject](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/AsyncSubject.png)

### PublishSubject

![PublishSubject](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/PublishSubject.png)

### ReplaySubject

![ReplaySubject1](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplaySubject.u.png)
![ReplaySubject2](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplaySubject.ue.png)
![ReplaySubject3](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplaySubject.n.png)
![ReplaySubject4](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplaySubject.t.png)
![ReplaySubject5](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplaySubject.nt.png)

### CompletableSubject

![CompletableSubject](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/CompletableSubject.png)

### SingleSubject

![SingleSubject](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/SingleSubject.png)

### MaybeSubject

![MaybeSubject](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/MaybeSubject.png)

### AsyncProcessor

![AsyncProcessor](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/AsyncProcessor.png)

### PublishProcessor

![PublishProcessor](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/PublishProcessor.png)

### ReplayProcessor

![ReplayProcessor1](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplayProcessor.u.png)
![ReplayProcessor2](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplayProcessor.ue.png)
![ReplayProcessor3](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplayProcessor.n.png)
![ReplayProcessor4](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplayProcessor.t.png)
![ReplayProcessor5](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplayProcessor.nt.png)
",2018-01-19 13:21:40,2018-01-22 09:06:23,https://api.github.com/repos/ReactiveX/RxJava/issues/5816,"['2.x', 'Documentation']",59,13,ReactiveX_RxJava_pull_5816.diff
ReactiveX/RxJava,"2.x: Fix buffer(open, close) not disposing indicators properly","The PR fixes the resource management in the `buffer` operator that uses other reactive sources to indicate when a buffer starts and ends. Both `Flowable` and `Observable` implementations had to be fixed.

Fixes: #5809",2018-01-16 14:46:56,2018-01-19 09:36:39,https://api.github.com/repos/ReactiveX/RxJava/issues/5811,"['2.x', 'Bug']",1173,311,ReactiveX_RxJava_pull_5811.diff
ReactiveX/RxJava,fix #5809 Prevent new windows to open once source has completed,"The idea of this PR is to keep a reference to the ""open"" `Publisher` and dispose it in main `onComplete`, so that it won't keep opening new windows once the source has completed.

It would open new windows due to an unbalanced opening/closing cycle when the open and close signal overlap (eg. interval-based signals where the close delay is shorter than the open delay). As a result, the `windows` counter would never reach `0` and actually complete the main sequence.",2018-01-16 11:25:26,2018-01-16 12:00:19,https://api.github.com/repos/ReactiveX/RxJava/issues/5810,['2.x'],52,0,ReactiveX_RxJava_pull_5810.diff
ReactiveX/RxJava,2.x: Final planned Observable marble additions/fixes,"This is the final part of the `Observable` marble fixes and additions as planned in #5319.

- [toList(Callable)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toList.o.c.png)
- [toFlowable(BUFFER)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.buffer.png)
- [toFlowable(DROP)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.drop.png)
- [toFlowable(LATEST)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.latest.png)
- [toFlowable(ERROR)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.error.png)
- [toFlowable(MISSING)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.missing.png)
- [unsubscribeOn](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/unsubscribeOn.o.png)
- Fixed position and spacing of the marbles in the `zipWith` overloads (no image change).

Images in https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-356630375 .",2018-01-10 15:09:46,2018-01-10 17:15:58,https://api.github.com/repos/ReactiveX/RxJava/issues/5805,"['2.x', 'Documentation']",33,7,ReactiveX_RxJava_pull_5805.diff
ReactiveX/RxJava,"2.x: More Observable marbles, 01/10-a","More marbles for `Observable`:

- [retry(int)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.n.png)
- [retry(BiFunction)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.ne.png)
- [retry(Predicate)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.e.png)
- [retry(int, Predicate)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.nfe.png)
- [retryUntil(BooleanSupplier)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retryUntil.o.png)
- [share](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishRefCount.o.png)
- [switchMapSingle](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapSingle.o.png)
- [switchMapSingleDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapSingleDelayError.o.png)

Images in https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-356560596 .",2018-01-10 10:25:13,2018-01-10 14:00:06,https://api.github.com/repos/ReactiveX/RxJava/issues/5804,"['2.x', 'Documentation']",9,8,ReactiveX_RxJava_pull_5804.diff
ReactiveX/RxJava,2.x: Improved XSubject JavaDocs,"This PR adds more detailed JavaDoc descriptions to the various `XSubject` types.

Some of them are missing a marble diagram which will be created (or found) in a separate PR after this PR.

The `package-info.java` has been extended as well.",2018-01-09 22:03:42,2018-01-10 08:27:15,https://api.github.com/repos/ReactiveX/RxJava/issues/5802,"['2.x', 'Documentation']",548,45,ReactiveX_RxJava_pull_5802.diff
ReactiveX/RxJava,2.x: Add missing {Maybe|Single}.mergeDelayError variants,"This PR adds `mergeDelayError` overloads to `Maybe` and `Single`; the infrastructure was there from the beginning but the `delayErrors == true` settings were not exposed publicly.

- `Maybe.mergeDelayError(Publisher, int)`
- `Single.mergeDelayError(Iterable)`
- `Single.mergeDelayError(Publisher)`
- `Single.mergeDelayError(SingleSource, SingleSource)`
- `Single.mergeDelayError(SingleSource, SingleSource, SingleSource)`
- `Single.mergeDelayError(SingleSource, SingleSource, SingleSource, SingleSource)`",2018-01-09 15:38:52,2018-01-09 19:18:27,https://api.github.com/repos/ReactiveX/RxJava/issues/5799,"['2.x', 'Enhancement']",399,16,ReactiveX_RxJava_pull_5799.diff
ReactiveX/RxJava,"2.x: Observable.replay(Function, ...) marble fixes","This PR updates the marble diagrams of the 8 `Observable.replay()` overload that take a `Function` and various other parameters:

- [no arguments](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.f.png)
- [scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fs.png)
- [bufferSize](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fn.png)
- [bufferSize, scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fns.png)
- [time](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ft.png)
- [time, scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fts.png)
- [bufferSize, time](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fnt.png)
- [bufferSize, time, scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fnts.png)

Images in https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-356286139 .
  ",2018-01-09 13:39:14,2018-01-09 14:46:11,https://api.github.com/repos/ReactiveX/RxJava/issues/5798,"['2.x', 'Documentation']",8,8,ReactiveX_RxJava_pull_5798.diff
ReactiveX/RxJava,2.x: Observable marble fixes 01/08-b,"This PR adds and updates marbles of the following `Observable` operators:

- [lastOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrError.png)
- [onErrorReturn](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.o.png)
- [onErrorReturnItem](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturnItem.o.png)
- [onTerminateDetach](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onTerminateDetach.o.png)
- [publish(Function)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishFunction.o.png)
- [reduce(seed, f)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceSeed.o.png)
- [reduceWith](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceWith.o.png)
- [repeat()](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatInf.o.png)
- [repeat(long)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatCount.o.png)
- [repeatUntil](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatUntil.o.png)
- [replay()](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.png)
- [replay(int)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.n.png)  
- [replay(int, long, TimeUnit)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.nt.png)
- [replay(int, long, TimeUnit, Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.nts.png)
- [replay(int, Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ns.png)
- [replay(long, TimeUnit)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.t.png)
- [replay(long, TimeUnit, Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ts.png)
- [replay(Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.s.png)

Images in https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-355986927 .",2018-01-08 14:44:02,2018-01-08 16:32:58,https://api.github.com/repos/ReactiveX/RxJava/issues/5797,"['2.x', 'Documentation']",22,19,ReactiveX_RxJava_pull_5797.diff
ReactiveX/RxJava,2.x: More marbles 01/08-a,"This PR adds 5 marble diagrams to `Observable`:

- `flatMapCompletable` (2 overloads)
- `forEach`
- `forEachWhile`
- `hide`

Images in https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-355932289
",2018-01-08 10:46:03,2018-01-08 12:08:34,https://api.github.com/repos/ReactiveX/RxJava/issues/5795,"['2.x', 'Documentation']",20,10,ReactiveX_RxJava_pull_5795.diff
ReactiveX/RxJava,Remove apostrophe to correct grammar.,"  - [x] Please give a description about what and why you are contributing, even if it's trivial.

This pull request corrects a minor grammar issue in the README. In this case we want the 3rd person present form of ""let"", not the contraction ""let us"".

  - [x] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

n/a

  - [x] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.

n/a",2018-01-05 19:52:34,2018-01-05 20:10:28,https://api.github.com/repos/ReactiveX/RxJava/issues/5793,['Documentation'],1,1,ReactiveX_RxJava_pull_5793.diff
ReactiveX/RxJava,2.x: Fix flatMap inner fused poll crash not cancelling the upstream,"This PR fixes the lack of upstream `cancel()` call when an inner, fused source's `queue.poll()` crashes in a non-delayed error mode.

Unit tests were added to verify `Observable.flatMap`, `Flowable.flatMapIterable` and `Observable.flatMapIterable` as well.
  
Fixes #5791",2018-01-05 16:00:31,2018-01-05 23:26:30,https://api.github.com/repos/ReactiveX/RxJava/issues/5792,"['2.x', 'Bug']",192,11,ReactiveX_RxJava_pull_5792.diff
ReactiveX/RxJava,2.x: improve request accounting overhead in retry/repeat,"This PR improves the request accounting overhead in the `retry` and `repeat` operators.

Previously, every individual `onNext` invocation signaled a an item production, which had a lot of overhead since the `SubscriptionArbiter` has to serialize invocations of `setSubscription`, `request` and `produced`. The improved algorithm counts the `onNext` calls in a field and calls `produced` once with the total count before subscribing to the upstream again.

Other small changes:
- rename inner class to `RetrySubscriber` (sloppy copy-paste),
- add `isCancelled()` check to `repeatUntil` subscription loop, which was somehow missing.",2018-01-05 14:28:56,2018-01-05 22:34:32,https://api.github.com/repos/ReactiveX/RxJava/issues/5790,"['2.x', 'Cleanup', 'Performance']",61,11,ReactiveX_RxJava_pull_5790.diff
ReactiveX/RxJava,2.x: add error handling section to merge() operator docs,"This PR adds the **Error handling** JavaDoc section to the other `merge` operators throughout the base reactive classes.

Note though that the following `mergeDelayError` methods don't exist yet:

- `Maybe.mergeDelayError(Publisher, int)`
- `Single.mergeDelayError(*)` (`*` all variants of their respective `merge` methods are missing)

These can be added in a separate PR and don't require implementing new operators but to configure existing ones with `delayError == true`.",2018-01-03 12:51:33,2018-01-06 14:19:15,https://api.github.com/repos/ReactiveX/RxJava/issues/5786,"['2.x', 'Documentation']",503,5,ReactiveX_RxJava_pull_5786.diff
ReactiveX/RxJava,"2.x: Update Maybe doOn{Success,Error,Complete} JavaDoc","This PR updates the JavaDoc of the `Maybe.doOnSuccess`, `Maybe.doOnError` and `Maybe.doOnComplete` marble diagrams and adds an explicit sentence about mutually exclusive events.

![DoOnSuccess](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnSuccess.m.png)
-----
![DoOnError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.m.png)
-----
![DoOnComplete](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnComplete.m.png)",2018-01-02 12:18:41,2018-01-03 12:01:17,https://api.github.com/repos/ReactiveX/RxJava/issues/5785,"['2.x', 'Documentation']",9,3,ReactiveX_RxJava_pull_5785.diff
ReactiveX/RxJava,2.x: Fix JavaDoc wording of onTerminateDetach,"A missing `nulls` word from `Flowable.onTerminateDetach` and `Observable.onTerminateDetach` JavaDoc. The other types have this word already.

Related: #5782.",2017-12-28 18:49:01,2017-12-29 16:22:00,https://api.github.com/repos/ReactiveX/RxJava/issues/5783,"['2.x', 'Documentation']",2,2,ReactiveX_RxJava_pull_5783.diff
ReactiveX/RxJava,2.x: Describe merge() error handling.,"This PR adds some clarifications about how `merge` handles (multiple) errors in a new *Error handling* section in its `<dl>` JavaDoc entry.

There exist several dozen variants of `merge` in the various base classes that could also include such JavaDoc addition. Once the wording has been reviewed, the other places will receive a separate PR.

Related: #5779, #5780",2017-12-27 16:50:36,2018-01-03 11:35:54,https://api.github.com/repos/ReactiveX/RxJava/issues/5781,"['2.x', 'Documentation']",14,0,ReactiveX_RxJava_pull_5781.diff
ReactiveX/RxJava,2.x: Improve BehaviorSubject JavaDoc + related clarifications,"This PR adds detailed behavior and feature description to the `BehaviorSubject` JavaDoc.

In addition, small mistakes in the `BehaviorProcessor` JavaDoc have also been fixed and both received an extra section: `Error handling` that points at the global error handler for undeliverable errors. Due to this link, the `RxJavaPlugins.onError` JavaDoc has been also expanded.",2017-12-27 16:23:31,2018-01-03 11:16:45,https://api.github.com/repos/ReactiveX/RxJava/issues/5780,"['2.x', 'Documentation']",112,4,ReactiveX_RxJava_pull_5780.diff
ReactiveX/RxJava,2.x: Improve BehaviorProcessor JavaDoc,"A [StackOverflow](https://stackoverflow.com/q/47982511/61158) question prompted me to look at `BehaviorProcessor` to find it quite lacking of a detailed JavaDoc. This PR adds sentences and examples (I could think of) to it that explain the available features and behavior of this `Processor` implementation.

If the sentences are reviewed, the `BehaviorSubject` will be updated with the applicable information (i.e., everything minus backpressure related sentences).",2017-12-26 22:52:19,2017-12-27 11:00:49,https://api.github.com/repos/ReactiveX/RxJava/issues/5778,"['2.x', 'Documentation']",90,9,ReactiveX_RxJava_pull_5778.diff
ReactiveX/RxJava,2.x: Fix race conditions in observeOn operators.,"We should check isDisposed() just before emitting results.

This PR fixes https://github.com/ReactiveX/RxJava/issues/5776",2017-12-23 01:24:20,2017-12-23 09:52:35,https://api.github.com/repos/ReactiveX/RxJava/issues/5777,[],46,0,ReactiveX_RxJava_pull_5777.diff
ReactiveX/RxJava,2.x: Improve JavaDoc of retryWhen() operators,"This PR improves the Javadoc of the `retryWhen` operators in the 5 base classes, adds example to handling an asynchronous source with delay where an early `onComplete` may cause unexpected terminations otherwise.

Related: #5772.",2017-12-21 12:16:21,2017-12-22 12:36:57,https://api.github.com/repos/ReactiveX/RxJava/issues/5773,"['2.x', 'Documentation']",137,11,ReactiveX_RxJava_pull_5773.diff
ReactiveX/RxJava,2.x: Upgrade to Reactive Streams 1.0.2 final,Reactive Streams 1.0.2 just went final.,2017-12-18 22:22:58,2017-12-19 15:38:06,https://api.github.com/repos/ReactiveX/RxJava/issues/5771,['2.x'],1,1,ReactiveX_RxJava_pull_5771.diff
ReactiveX/RxJava,Rename interface parameters,"#5762 

Signed-off-by: shaishavgandhi05 <shaishgandhi@gmail.com>
",2017-12-17 01:38:52,2017-12-19 17:36:32,https://api.github.com/repos/ReactiveX/RxJava/issues/5766,"['2.x', 'Cleanup']",10,10,ReactiveX_RxJava_pull_5766.diff
ReactiveX/RxJava,2.x: fix timed exact buffer calling cancel unnecessarily,"This PR removes the unnnecessary `cancel`/`dispose` call from the exact-boundary timed `buffer()` operators in `Observable` and `Flowable` when the upstream completes normally.

Originally appeared in a [StackOverflow question](https://stackoverflow.com/questions/47772415/rxjava2-completing-a-cold-source-flowable-explicitly).",2017-12-12 12:56:03,2017-12-15 08:26:30,https://api.github.com/repos/ReactiveX/RxJava/issues/5761,"['2.x', 'Bug']",132,5,ReactiveX_RxJava_pull_5761.diff
ReactiveX/RxJava,"2.x: Subject NPE fixes, add UnicastProcessor TCK","This PR adds the `Subject.refCount()` and `FlowableProcessor.refCount()` that capture the upstream's `Disposable`/`Subscription` and disposes/cancels them if the number of `Observer`s/`Subscriber`s decreases to zero. The Reactive-Streams TCK and thus other implementations may expect such behavior from a `Processor` implementation and this wrapper is required to pass the TCK tests.

While implementing the TCK tests, it turned out the `null`-handling of the `Subject`s and `FlowableProcessor`s were not following the Reactive-Streams specification. They have to throw a `NullPointerException` immediately and not turn them into NPEs for the downstream. These classes and the tests have been fixed as well. Their error messages have been uniformed too.",2017-12-11 23:22:44,2017-12-15 10:13:50,https://api.github.com/repos/ReactiveX/RxJava/issues/5760,"['2.x', 'Bug', 'Enhancement']",464,473,ReactiveX_RxJava_pull_5760.diff
ReactiveX/RxJava,2.x: marble additions and updates (12/11),"This PR adds or updates mable diagrams of `Observable`:

- [doOnTerminate](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnTerminate.o.png)
- [elementAt](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAt.o.png)
- [elementAt](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtDefault.o.png) with default
- [elementAtOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtOrError.o.png)
- [firstOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstOrError.o.png)
- [flatMap](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapDelayError.o.png) with error delayed
- [flatMap](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapMaxConcurrency.o.png) with maximum concurrency

Related: https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-350682783

",2017-12-11 10:28:16,2017-12-12 23:04:05,https://api.github.com/repos/ReactiveX/RxJava/issues/5759,"['2.x', 'Documentation']",13,13,ReactiveX_RxJava_pull_5759.diff
ReactiveX/RxJava,2.x: add a couple of @see to Completable,This PR adds a couple of `@see` cross references to `Completable` JavaDoc.,2017-12-08 12:24:03,2017-12-10 18:51:19,https://api.github.com/repos/ReactiveX/RxJava/issues/5758,"['2.x', 'Documentation']",34,10,ReactiveX_RxJava_pull_5758.diff
ReactiveX/RxJava,2.x: improve autoConnect() Javadoc + add its marble,"This PR improves the JavaDoc of `ConnectableObservable.autoConnect()` and `ConnectableFlowable.autoConnect()` operators and adds the respective marble diagrams:

![autoConnect](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/autoConnect.o.png)

![autoConnect](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/autoConnect.f.png)",2017-12-06 12:32:21,2017-12-07 09:08:00,https://api.github.com/repos/ReactiveX/RxJava/issues/5756,"['2.x', 'Documentation']",72,6,ReactiveX_RxJava_pull_5756.diff
ReactiveX/RxJava,2.x: Add marbles for Observable (12/06),"This PR adds some missing marbles to `Observable`:

- [concatMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapCompletable.o.png)
- [concatMapDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapDelayError.o.png)
- [concatMapEager](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEager.o.png)
- [concatMapEagerDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEagerDelayError.o.png)
- [concatMapIterable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapIterable.o.png)
- [doAfterNext](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doAfterNext.o.png)
- [doFinally](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)

Tracked in #5319, images in [comment](https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-349595094).",2017-12-06 10:27:22,2017-12-07 08:37:03,https://api.github.com/repos/ReactiveX/RxJava/issues/5755,"['2.x', 'Documentation']",24,2,ReactiveX_RxJava_pull_5755.diff
ReactiveX/RxJava,"2.x: Add retry(times, predicate) to Single & Completable and verify behavior across them and Maybe.","- Add retry(times, predicate) to Single & Completable (Maybe had it already) which just forwards to Flowable for now
- verify behavior across the three reactive types

Happy to get better testing names
",2017-12-05 15:03:01,2017-12-07 23:02:48,https://api.github.com/repos/ReactiveX/RxJava/issues/5753,"['2.x', 'Enhancement']",401,0,ReactiveX_RxJava_pull_5753.diff
ReactiveX/RxJava,2.x: Reactive-Streams 1.0.2-RCx - not for merge,This PR verifies the upcoming Reactive-Streams 1.0.2 with TCK changes are still okay with RxJava.,2017-12-05 11:36:54,2017-12-18 22:19:16,https://api.github.com/repos/ReactiveX/RxJava/issues/5752,"['2.x', 'Test']",1,1,ReactiveX_RxJava_pull_5752.diff
ReactiveX/RxJava,Test.txt,"just for  test

Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [ ] Please give a description about what and why you are contributing, even if it's trivial.

  - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.
",2017-11-30 13:23:07,2017-11-30 13:24:31,https://api.github.com/repos/ReactiveX/RxJava/issues/5749,['Invalid'],1,0,ReactiveX_RxJava_pull_5749.diff
ReactiveX/RxJava,2.x: Check runnable == null in *Scheduler.schedule*().,"To enforce `@NotNull` guarantee for the PR #5734, see  https://github.com/ReactiveX/RxJava/pull/5734/files#r153951238",2017-11-30 01:30:42,2017-12-07 08:52:36,https://api.github.com/repos/ReactiveX/RxJava/issues/5748,"['2.x', 'Cleanup']",33,6,ReactiveX_RxJava_pull_5748.diff
ReactiveX/RxJava,"2.x: Fix TrampolineScheduler not calling RxJavaPlugins.onSchedule(), add tests for all schedulers.",Noticed during figuring out how #5734 works.,2017-11-30 00:23:32,2017-11-30 08:35:07,https://api.github.com/repos/ReactiveX/RxJava/issues/5747,"['2.x', 'Bug']",74,2,ReactiveX_RxJava_pull_5747.diff
ReactiveX/RxJava,2.x: improve wording and links in package-infos + remove unused imports,This PR is to improve the wording of a few `package-info.java` JavaDocs and removes two unused imports.,2017-11-29 21:01:20,2017-11-29 23:14:01,https://api.github.com/repos/ReactiveX/RxJava/issues/5746,"['2.x', 'Documentation']",13,11,ReactiveX_RxJava_pull_5746.diff
ReactiveX/RxJava,2.x: add/update Observable marbles 11/28,"This PR adds or updates mable diagrams of `Observable`:

- [`blockingFirst`](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingFirst.o.png)
- [`blockingFirst` with default](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingFirst.o.default.png)
- [`toFuture`](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFuture.o.png)
- [`blockingSubscribe` no arguments](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.0.png)
- [`blockingSubscribe` with 1 argument](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.1.png)
- [`blockingSubscribe` with 2 arguments](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.2.png)
- [`blockingSubscribe` with 3 arguments](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.png)
- [`collectInto`](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collectInto.o.png)
- [`doOnComplete`](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnComplete.o.png)
- [`doOnError`](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.o.png)
- [`doOnLifecycle`](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnLifecycle.o.png)
- [`doOnNext`](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnNext.o.png)
- [`doOnDispose`](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnDispose.png)


Related #5319: [comment](https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-347482919).",2017-11-28 10:46:31,2017-11-30 08:49:09,https://api.github.com/repos/ReactiveX/RxJava/issues/5745,"['2.x', 'Documentation']",19,7,ReactiveX_RxJava_pull_5745.diff
ReactiveX/RxJava,2.x: Check isdisposed before emitting in SingleFromCallable,"Previously SingleFromCallable did not check if the subscriber was
unsubscribed before emitting onSuccess or onError. This fixes that
behavior and adds tests to SingleFromCallable, CompletableFromCallable,
and MaybeFromCallable.

Fixes #5742
",2017-11-25 14:56:01,2017-11-25 17:38:03,https://api.github.com/repos/ReactiveX/RxJava/issues/5743,"['2.x', 'Bug']",373,11,ReactiveX_RxJava_pull_5743.diff
ReactiveX/RxJava,2.x: internal API to get distinct Workers from some Schedulers,"This PR adds an internal interface `SchedulerMultiWorkerSupport` that allows retrieving multiple workers from a `Scheduler` that implements this interface.

The standard `Scheduler.getWorker()` can be invoked as many times as necessary, but specific implementations such as the `computation()` `Scheduler` and the [`ParallelScheduler`](https://github.com/akarnokd/RxJava2Extensions#parallelscheduler) is not guaranteed to return workers that are backed by distinct single-threaded thread pools. 

This does not effect other scheduler types because: 
- they are single threaded (`single()`) or don't use threads at all (`trampoline()`) and 
- already hand out distinct workers (`io()`, `newThread()`).

Such worker reuse can happen when in a highly concurrent application, typical tasks are mixed with parallel tasks and both pull out workers from these `Scheduler`s. If this is happens, it is possible there will be duplicate threads used by the parallel operations and thus not utilize the originally intended parallelism level.

By implementing this suggested interface, a batch-retrieval can be supported by the `Scheduler`s and they can make sure the caller gets as many distinct thread-pool as possible. If more workers are requested than the `Scheduler`'s parallelism, the workers are handed out in round-robin fashion similar to the standard `createWorker()`.

Why a callback instead of returning an array? 
- even if both require an allocation to set up, there is no need to have all workers visible at once,
- simply less memory usage, and
- avoids looping twice: once for filling in the array and once for using the elements of the array.

",2017-11-24 14:54:28,2017-11-27 22:12:44,https://api.github.com/repos/ReactiveX/RxJava/issues/5741,"['2.x', 'Enhancement']",272,19,ReactiveX_RxJava_pull_5741.diff
ReactiveX/RxJava,"2.x: marbles for Observable all, fromPublisher, zipArray","This PR adds a marble diagram to `fromPublisher` and updates the marbles of `all` and `zipArray` inside `Observable`.

The images can be seen in [this comment](https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-346585222) of #5319.",2017-11-23 10:57:10,2017-11-24 07:37:47,https://api.github.com/repos/ReactiveX/RxJava/issues/5740,"['2.x', 'Documentation']",4,2,ReactiveX_RxJava_pull_5740.diff
ReactiveX/RxJava,2.x: fix javadoc for ConnectableFlowable and others,"Some javadoc fixes for ConnectableFlowable, GroupedFlowable and FlowableAutoConnect",2017-11-22 10:13:50,2017-11-22 12:13:41,https://api.github.com/repos/ReactiveX/RxJava/issues/5738,"['2.x', 'Documentation']",21,21,ReactiveX_RxJava_pull_5738.diff
ReactiveX/RxJava,Improved code formatting for README.md,"Modifications:

- Inserted indents for code readability in code blocks

",2017-11-22 01:43:51,2017-11-22 08:36:45,https://api.github.com/repos/ReactiveX/RxJava/issues/5737,"['2.x', 'Documentation']",9,9,ReactiveX_RxJava_pull_5737.diff
ReactiveX/RxJava,Restore license to correct text.,"This section is a template on how to apply the header and not something that actually should have been changed.

Refs #4980.",2017-11-21 21:02:18,2017-11-21 21:19:03,https://api.github.com/repos/ReactiveX/RxJava/issues/5735,['2.x'],1,1,ReactiveX_RxJava_pull_5735.diff
ReactiveX/RxJava,2.x: RxJavaPlugins unwrapRunnable,"Hi,
RxJava2 version: [2.1.6]
It is reference to https://github.com/ReactiveX/RxJava/issues/5733",2017-11-21 11:12:31,2017-12-04 12:12:13,https://api.github.com/repos/ReactiveX/RxJava/issues/5734,"['2.x', 'Enhancement']",203,14,ReactiveX_RxJava_pull_5734.diff
ReactiveX/RxJava,2.x: Implement as(),"This implement `as()` support as discussed in #5654

I took the opportunity to try to standardize the docs and tests for it (which vary a little bit across implementations of `to()`)

Related: #5654",2017-11-16 10:41:24,2017-11-19 10:39:00,https://api.github.com/repos/ReactiveX/RxJava/issues/5729,"['2.x', 'Enhancement']",826,11,ReactiveX_RxJava_pull_5729.diff
ReactiveX/RxJava,1.x: fix broken backpressure through unsubscribeOn(),"The `unsubscribeOn` did not properly forward the upstream's `Producer` to the downstream, thus the default `Subscriber` request behavior of `Long.MAX_VALUE` was incorrectly in effect.

Fixes: #5725",2017-11-15 12:32:51,2017-11-16 08:36:47,https://api.github.com/repos/ReactiveX/RxJava/issues/5726,"['1.x', 'Bug']",31,0,ReactiveX_RxJava_pull_5726.diff
ReactiveX/RxJava,2.x: Add toMap overload with a merge function for updating existing mappings,"Equivalent to the `java.util.stream.Collectors#toMap` merge map functionality. Could compliment the other map collectors nicely. There is an argument that this isn't suitable because we can't delegate to `Map#merge` with a language level lower than 8, but wanted to get your thoughts. Thanks!",2017-11-15 12:06:34,2017-11-19 10:31:22,https://api.github.com/repos/ReactiveX/RxJava/issues/5724,"['2.x', 'Feature-Request']",222,1,ReactiveX_RxJava_pull_5724.diff
ReactiveX/RxJava,Remove duplicate nullity check line from Observable.toMap(),Small cleanup to remove duplicate nullity check line from `Observable#toMap`,2017-11-14 11:22:36,2017-11-14 11:55:48,https://api.github.com/repos/ReactiveX/RxJava/issues/5723,[],0,1,ReactiveX_RxJava_pull_5723.diff
ReactiveX/RxJava,"2.x : Rename variable name ""subject"" to ""processor"" for exact expression","Rename variable name ""subject"" to ""processor"" in processor pacakage",2017-11-14 04:58:06,2017-11-14 12:26:15,https://api.github.com/repos/ReactiveX/RxJava/issues/5721,"['2.x', 'Cleanup', 'Test']",211,211,ReactiveX_RxJava_pull_5721.diff
ReactiveX/RxJava,1.x: Add a sentence to documentation of take() operator,#5716 ,2017-11-11 05:11:34,2017-11-11 13:30:47,https://api.github.com/repos/ReactiveX/RxJava/issues/5719,"['1.x', 'Documentation']",6,0,ReactiveX_RxJava_pull_5719.diff
ReactiveX/RxJava,2.x: Add a sentence to documentation of take() operator.,#5716 ,2017-11-11 05:01:18,2017-11-11 12:25:46,https://api.github.com/repos/ReactiveX/RxJava/issues/5718,"['2.x', 'Documentation']",12,0,ReactiveX_RxJava_pull_5718.diff
ReactiveX/RxJava,2.x: Javadocs: add period to custom scheduler use sentences,There were missing `.` from sentences in the operator Javadocs detailing certain overloads use custom `Scheduler`s.,2017-11-10 18:43:16,2017-11-10 19:48:05,https://api.github.com/repos/ReactiveX/RxJava/issues/5717,"['2.x', 'Documentation']",99,99,ReactiveX_RxJava_pull_5717.diff
ReactiveX/RxJava,2.x: distinguish between sync and async dispose in ScheduledRunnable,"This PR adds logic to distinguish between synchronous and asynchronous dispose calls when `setFuture` is executing. It should prevent interrupting the currently running task body if it requested cancellation indirectly before the `setFuture` was executed by the Thread which scheduled the task.

Fixes #5711",2017-11-09 19:24:43,2017-11-15 10:24:46,https://api.github.com/repos/ReactiveX/RxJava/issues/5715,"['2.x', 'Shortcoming']",133,12,ReactiveX_RxJava_pull_5715.diff
ReactiveX/RxJava,2.x: BaseTestConsumer values() and errors() thread-safety clarifications,"This PR adds clarifications to the `BaseTestConsumer.values()` and `BaseTestConsumer.errors()` method in regard to accessing elements while the upstream is still actively emitting events.

Related discussion: #5712",2017-11-09 12:56:58,2017-11-09 21:50:30,https://api.github.com/repos/ReactiveX/RxJava/issues/5713,"['2.x', 'Documentation']",28,0,ReactiveX_RxJava_pull_5713.diff
ReactiveX/RxJava,1.x: Single.subscribe should not crash onSuccess into onError,"Fix `Single.subscribe(Action1, Action1)` to not call `onError` if the `onSuccess` action crashes, ensuring that the `Single` protocol `onSuccess|onError` is maintained. Crashes will go into the `RxJavaHooks.onError` handler.

Fixes: #5237.",2017-11-08 11:35:56,2017-11-09 09:24:44,https://api.github.com/repos/ReactiveX/RxJava/issues/5710,"['1.x', 'Bug']",181,4,ReactiveX_RxJava_pull_5710.diff
ReactiveX/RxJava,2.x: Improve Javadocs of flatMapSingle and flatMapMaybe,"Clarify that `flatMapSingle` and `flatMapMaybe` merge in no particular order and fix the copy-paste error from `flatMapCompletable` as they have values to merge, not just waiting.

Related: [StackOverflow question](https://stackoverflow.com/questions/47176437/rxjava-2-observable-flatmapsingle-clarification)",2017-11-08 10:15:58,2017-11-09 00:07:55,https://api.github.com/repos/ReactiveX/RxJava/issues/5709,"['2.x', 'Documentation']",20,16,ReactiveX_RxJava_pull_5709.diff
ReactiveX/RxJava,Remove mentions of Main thread from Schedulers.single() javadoc.,"To avoid confusion. 

One could think that `single()` can be used to execute code on ""Main"" thread.",2017-11-06 07:56:14,2017-11-06 08:31:10,https://api.github.com/repos/ReactiveX/RxJava/issues/5706,[],2,2,ReactiveX_RxJava_pull_5706.diff
ReactiveX/RxJava,2.x: Moved tests to FromCallableTest from FromCompletableTest,"Fixes #5698. There was a test class named `ObservableFromCompletableTest` which actually was targeting `ObservableFromCallableTest`. This was most likely just a naming issue. Copied all tests from `ObservableFromCompletableTest` to `ObservableFromCallableTest` and deleted the former class.
",2017-11-04 16:36:13,2017-11-04 17:05:34,https://api.github.com/repos/ReactiveX/RxJava/issues/5705,"['2.x', 'Cleanup', 'Test']",74,97,ReactiveX_RxJava_pull_5705.diff
ReactiveX/RxJava,just test,"Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [ ] Please give a description about what and why you are contributing, even if it's trivial.

  - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.
",2017-11-03 14:16:05,2017-11-03 14:25:15,https://api.github.com/repos/ReactiveX/RxJava/issues/5702,['Invalid'],0,0,ReactiveX_RxJava_pull_5702.diff
ReactiveX/RxJava,1.x: fix Completable.concat to use replace (don't dispose old),"Fixes the same bug as with the 2.x `Completable.andThen` and `Completable.concat`.

See #5694 & #5695.",2017-10-31 11:41:11,2017-10-31 18:37:55,https://api.github.com/repos/ReactiveX/RxJava/issues/5696,"['1.x', 'Bug']",87,9,ReactiveX_RxJava_pull_5696.diff
ReactiveX/RxJava,2.x: fix Completable.concat to use replace (don't dispose old),"`Completable.andThen`, `concat(Iterable)` and `concatArray()` disposed the previous `Disposable` when receiving the new `Disposable` from the next source which could lead to interruption. `concat(Publisher)` already uses `replace` instead of `update`.

There is a peculiar interplay between `subscribeOn`, `observeOn` and the trampoline in `concat` which can trigger such an interruption: the task of the `observeOn` is cancelled with `mayInterruptIfRunning == true` because the `dispose` call chain shuts down the worker of the `observeOn` from the `subscribeOn`'s thread.

Reported in #5694",2017-10-31 10:44:29,2017-10-31 18:58:55,https://api.github.com/repos/ReactiveX/RxJava/issues/5695,"['2.x', 'Bug']",82,3,ReactiveX_RxJava_pull_5695.diff
ReactiveX/RxJava,add onError in try-catch,"I don't know why It isn't pass exception to ""onError"" in onSuccess try-catch",2017-10-26 06:32:27,2017-10-26 07:35:32,https://api.github.com/repos/ReactiveX/RxJava/issues/5689,"['2.x', 'Invalid']",1,0,ReactiveX_RxJava_pull_5689.diff
ReactiveX/RxJava,2.x: Add TCK test for limit(),This PR adds a Reactive-Streams TCK test for `limit()` .,2017-10-19 18:44:54,2017-10-19 19:00:43,https://api.github.com/repos/ReactiveX/RxJava/issues/5683,"['2.x', 'Test']",30,0,ReactiveX_RxJava_pull_5683.diff
ReactiveX/RxJava,"Update 'java' → 'java-library' Gradle plugin, update deps configurations.","Documentation: https://docs.gradle.org/4.2.1/userguide/java_library_plugin.html

Reasoning:

- `api` instead of `compile` shows intention better, ie RS should be available for RxJava users
- `testImplementation` instead of `testCompile` [should hide dependencies from RxJava pom.xml](https://search.maven.org/remotecontent?filepath=io/reactivex/rxjava2/rxjava/2.1.5/rxjava-2.1.5.pom)
- If [RxJava 3.x will actually be split into multiple modules](https://github.com/ReactiveX/RxJava/issues/5621), `api/implementation` configurations might be handy

Issues:

- JMH Gradle Plugin doesn't seem to properly support `api`, so I had to manually declare RS for `jmh` configuration

@akarnokd can you please check if Eclipse works ok with this?

If not, we probably need to add:

```groovy
plugins.withType(EclipsePlugin) {
    project.eclipse.classpath.plusConfigurations += [ configurations.api ]
}
```",2017-10-19 13:18:43,2017-10-27 07:52:36,https://api.github.com/repos/ReactiveX/RxJava/issues/5682,"['2.x', 'Build']",7,6,ReactiveX_RxJava_pull_5682.diff
ReactiveX/RxJava,2.x: More Observable marble fixes (10/18),"Update several `Observable` marble diagrams. Images can be viewed [here](https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-337563753).

- `zipIterable`
- `ambWith`
- `blockingForEach`
- `blockingIterable`
- `blockingLast`
- `blockingLast(T)`
- `blockingMostRecent`
- `blockingNext`
- `blockingSingle`
- `blockingSingle(T)`
- `cacheWithInitialCapacity`
",2017-10-18 11:49:13,2017-10-18 13:53:48,https://api.github.com/repos/ReactiveX/RxJava/issues/5680,"['2.x', 'Documentation']",11,11,ReactiveX_RxJava_pull_5680.diff
ReactiveX/RxJava,2.x: make parallel() a fusion-async-boundary,"The `parallel()` supports front-fusion but since the operator is almost always followed by the separate `runOn` operator, the parallel version of the `observeOn` operator, such front-fusion should be considered a `BOUNDARY`-type fusion just like with `observeOn`. 

A `requestFusion` with `BOUNDARY` tells the upstream operator(s) that when fused, their actions would be executed behind an async boundary and possibly on an unwanted thread. Operators, such as `map` and `doOnNext`, who are generally expected to be thread-confined, can then refuse to fuse, restoring the traditional queue hopping behavior (`source -> queue -> op -> queue -> op -> queue -> consumer`).

Reported in #5676.

/cc @smaldini & @simonbasle ",2017-10-17 12:10:15,2017-10-17 19:57:50,https://api.github.com/repos/ReactiveX/RxJava/issues/5677,"['2.x', 'Bug']",101,4,ReactiveX_RxJava_pull_5677.diff
ReactiveX/RxJava,2.x: Add PublishProcessor JMH perf comparison,"This PR adds a Perf class to measure the overhead of request management inside `PublishProcessor` and a comparison with `PublishSubject`.

Note that running JMH with RxJava under Windows is currently not possible because Gradle adds so many of its own jar dependencies that the resulting command line classpath exceeds the 32k limit.

Results with 2.1.5 release (separate gradle project, Windows 7, i7 4790, Java 8u144)

![image](https://user-images.githubusercontent.com/1269832/31654835-74257c76-b327-11e7-801f-49c46e0321b2.png)

The bounded benchmark indicates a 4x the throughput for some reason I don't understand yet.",2017-10-17 08:45:06,2017-10-17 09:23:45,https://api.github.com/repos/ReactiveX/RxJava/issues/5675,"['2.x', 'Performance']",168,2,ReactiveX_RxJava_pull_5675.diff
ReactiveX/RxJava,"2.x: coverage, add SingleToFlowableTest","Add ""SingleToFlowableTest"" to cover toFlowable with test.",2017-10-16 15:40:12,2017-10-16 16:03:50,https://api.github.com/repos/ReactiveX/RxJava/issues/5673,"['2.x', 'Cleanup', 'Test']",93,0,ReactiveX_RxJava_pull_5673.diff
ReactiveX/RxJava,"2.x: coverage, add SingleToFlowableTest","Add ""SingleToFlowableTest"" to cover toFlowable with test.",2017-10-16 15:29:33,2017-10-16 15:34:19,https://api.github.com/repos/ReactiveX/RxJava/issues/5672,[],94,0,ReactiveX_RxJava_pull_5672.diff
ReactiveX/RxJava,Refactor : Organized Imports,"Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [ ] Please give a description about what and why you are contributing, even if it's trivial.

  - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.
",2017-10-15 17:56:53,2017-10-15 17:57:40,https://api.github.com/repos/ReactiveX/RxJava/issues/5670,[],3512,1391,ReactiveX_RxJava_pull_5670.diff
ReactiveX/RxJava,2.x: fix PublishProcessor cancel/emission overflow bug,"This PR should fix the bug that caused the test failure in #5545.

The bug manifested itself when a cancellation was happening the same time a request 1 was being fulfilled. Since the same request accounting was used for cancellation indicator, if the cancel happened between the `onNext()`'s `get()` check and `decrementAndGet`, this `decrementAndGet` decremented Long.MIN_VALUE unconditionally, which lead to a state that would appear the Subscriber still can receive events. A concurrent `offer`, which saves the current array of registered `Subscriber`s, then would emit an item and overflow the `Subscriber`.

The fix is to use the cancellation-aware `BackpressureHelper.producedCancel()` utility.

Unit test were added to verify the correct behavior on both `PublishProcessor` and `BehaviorProcessor` (the latter uses different cancellation mechanism via a dedicated field).",2017-10-15 13:27:32,2017-10-15 21:25:28,https://api.github.com/repos/ReactiveX/RxJava/issues/5669,"['2.x', 'Bug']",67,3,ReactiveX_RxJava_pull_5669.diff
ReactiveX/RxJava,Fix a misleading documentation of Observable.singleElement(),"This PR improves the documentation of `Observable.singleElement()`, as mentioned in  https://github.com/ReactiveX/RxJava/issues/5317.

An appropriate unit test to verify the `empty` behaviour already exist (`ObservableSingleTest. testSingleWithEmpty()`), I just added one more check there to make it very explicit that an error is not thrown.

As a side note, I'm attaching an updated Marble diagram for the method that includes all 3 states of the resulting Maybe (empty, success, error). I believe this is listed in https://github.com/ReactiveX/RxJava/issues/5319.


![singleelement](https://user-images.githubusercontent.com/4089934/31583261-a6da996a-b18f-11e7-8682-dffa647c7e4a.png)
",2017-10-15 09:00:28,2017-10-15 10:06:24,https://api.github.com/repos/ReactiveX/RxJava/issues/5668,"['2.x', 'Documentation']",4,4,ReactiveX_RxJava_pull_5668.diff
ReactiveX/RxJava,remove duplcated codes,"`CompositeDisposable` has duplicate check logic.
Checking before `Synchronized` does not seem to be a big performance difference.
So I removed the duplicated code from the code.",2017-10-12 03:21:05,2017-10-12 06:38:38,https://api.github.com/repos/ReactiveX/RxJava/issues/5664,['2.x'],19,35,ReactiveX_RxJava_pull_5664.diff
ReactiveX/RxJava,Fix broken license link,I found a broken link in the CONTRIBUTING docs. The link was referencing the LICENSE document on master (which doesn't exist currently). I fixed it to point to the correct document on the 2.x branch.,2017-10-11 13:34:07,2017-10-11 13:48:27,https://api.github.com/repos/ReactiveX/RxJava/issues/5662,[],1,1,ReactiveX_RxJava_pull_5662.diff
ReactiveX/RxJava,2.x: improve Flowable.timeout(),"This PR improves the internal overhead of the `Flowable.timeout` operator (its 2 timed and 2 selector-based versions) to use the adapted [indexed atomic state transition approach](http://akarnokd.blogspot.hu/2017/09/java-9-flow-api-timing-out-events.html).

In addition, there was a race condition and potential event loss in `TestScheduler`: 
- `peek()` could return `null` if the task was removed from the queue (via disposing it) between the `isEmpty()` check and `peek()` itself. 
- In addition, if the task was disposed between the `peek` and `remove`, the `remove` could remove the new head of the queue which is no longer what `peek` saw and results in tasks being dropped.",2017-10-11 12:19:31,2017-10-13 20:53:02,https://api.github.com/repos/ReactiveX/RxJava/issues/5661,"['2.x', 'Bug', 'Cleanup']",692,748,ReactiveX_RxJava_pull_5661.diff
ReactiveX/RxJava,"1.x: fix timeout (timed, selector) unsubscribe bug",This PR fixes an unsubscribe bug somewhere in the timed `timeout` operator reported in #5657 by implementing it in a algorithmically fresh manner.,2017-10-11 09:20:56,2017-10-13 19:11:13,https://api.github.com/repos/ReactiveX/RxJava/issues/5660,"['1.x', 'Bug']",726,385,ReactiveX_RxJava_pull_5660.diff
ReactiveX/RxJava,2.x: add limit() to limit both item count and request amount,"This PR adds the operator `limit` to limit the number of items as well as the total request amount.

Some asynchronous boundary-like sources, such as network libraries that translate from/to `Flowable`/`Publisher`, may not modulate or limit downstream requests and thus the other side may produce items unnecessarily. 

Alternatives, such as `take(N)` is designed to go unbounded if its downstream requests more than N to improve performance of local flows and `rebatchRequests(M)` will keep requesting once 75% of M has been received.

Note that requests are negotiated on an operator boundary and `limit`'s amount may not be preserved further upstream. For example, `source.observeOn(Schedulers.computation()).limit(5)` will still request the default (128) elements from the given `source`.

Related discussion: #5077.
Blog: [Java 9 Flow API: taking and skipping - Limiting the request amount](http://akarnokd.blogspot.hu/2017/09/java-9-flow-api-taking-and-skipping.html)",2017-10-09 21:45:33,2017-10-18 13:39:34,https://api.github.com/repos/ReactiveX/RxJava/issues/5655,"['2.x', 'Enhancement']",396,1,ReactiveX_RxJava_pull_5655.diff
ReactiveX/RxJava,2.x Upgrade testng to fix issue #5641,"Fix for #5641 

Method names now show up in gradle console when tests are skipped and in testng html output (previously no test names were showing up in html output for skipped or completed tests).",2017-10-09 19:45:06,2017-10-09 20:00:10,https://api.github.com/repos/ReactiveX/RxJava/issues/5653,"['2.x', 'Build', 'Test']",1,1,ReactiveX_RxJava_pull_5653.diff
ReactiveX/RxJava,2.x: inline disposability in Obs.concatMap(Completable),"The inner `Observer` type and the `SequentialDisposable` of the `concatMap` and `concatMapCompletable` can be combined into a single instance, saving on indirection and allocation.

(I've noticed this when reviewing #5649.)",2017-10-09 18:30:43,2017-10-09 19:31:41,https://api.github.com/repos/ReactiveX/RxJava/issues/5652,"['2.x', 'Cleanup']",33,32,ReactiveX_RxJava_pull_5652.diff
ReactiveX/RxJava,2.x: update Obs.just(2..10) & switchOnNextDelayError marbles,"This PR updates the marble diagrams of the 2..10 argument `Observable.just()` and two overloads of `Observable.switchOnNextDelayError`.

Images in [Issue 5319](https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-335124895).",2017-10-09 11:05:19,2017-10-09 12:19:02,https://api.github.com/repos/ReactiveX/RxJava/issues/5651,"['2.x', 'Documentation']",11,11,ReactiveX_RxJava_pull_5651.diff
ReactiveX/RxJava,2.x Add concatMapCompletable() to Observable,"Add `concatMapCompletable()` to `Observable` as discussed in #4853
I didn't think it made sense in other reactive types.

Code is mostly a copy of `ObservableConcatMap`.  Let me know if there is a better style of code to base this off instead.  It also does not have the option to delay errors as concatMap() does, not sure if that is needed.",2017-10-06 18:55:50,2017-10-09 08:44:36,https://api.github.com/repos/ReactiveX/RxJava/issues/5649,"['2.x', 'Enhancement']",548,0,ReactiveX_RxJava_pull_5649.diff
ReactiveX/RxJava,2.x: improve package JavaDoc,Add `Maybe` to the `io.reactivex` package Javadoc. Reword `io.reactivex.observers` and `io.reactivex.subscribers` as there are no utility classes in 2.x in them to create consumers from callbacks (those are internal and offered by the `subscribe()` overloads only).,2017-10-06 12:50:14,2017-10-06 13:18:00,https://api.github.com/repos/ReactiveX/RxJava/issues/5648,"['2.x', 'Documentation']",13,8,ReactiveX_RxJava_pull_5648.diff
ReactiveX/RxJava,2.x: Fix subscribeWith documentation examples,"This PR improves a documentation of `subscribeWith` functions in `Single`, `Maybe`, `Completable` by making sure examples are compilable (by using classes which implement `Disposable`).

This should fix issue #5642 .

In that issue @akarnokd approved my idea to use `DisposableMaybeObserver` in the example, but as I looked in other classes, I noticed that `Observable.subscribeWith()` documentation uses a `ResourceObserver` (which implements `Disposable`), so I thought that this is the way to go in all other top-classes?

If you think that this is not the case, and instead all of them should be switched to use `Disposable*Observer` in their examples, let me know, I will do it in this way then.

I think that all those example should use similar classes.",2017-10-05 22:04:14,2017-10-09 08:19:57,https://api.github.com/repos/ReactiveX/RxJava/issues/5647,"['2.x', 'Documentation']",10,10,ReactiveX_RxJava_pull_5647.diff
ReactiveX/RxJava,2.x: Readme.md update snapshot links,Update the snapshot link to the upcoming 2.1.5+ and 2.2.x versions. Also I've added a convenience link to the actual directory listing of the various snapshots hosted by JFrog.,2017-10-04 14:00:49,2017-10-05 07:58:15,https://api.github.com/repos/ReactiveX/RxJava/issues/5645,"['2.x', 'Documentation']",2,2,ReactiveX_RxJava_pull_5645.diff
ReactiveX/RxJava,2.x: Added Automatic-Module-Name instruction in build.gradle,"Credits to @zyxist for pointing this out in the issue #5618 

This will assign a module name to RxJava 2 according to the the recommended module naming conventions in the generated manifest.",2017-10-04 13:37:03,2017-10-04 13:51:12,https://api.github.com/repos/ReactiveX/RxJava/issues/5644,"['2.x', 'Build']",1,0,ReactiveX_RxJava_pull_5644.diff
ReactiveX/RxJava,2.x: additional warnings for fromPublisher(),"This PR adds JavaDoc warnings for `fromPublisher` as people still try to implement a source through it and fail to follow the specification like this:

```java
// DON'T DO THIS!
Flowable.fromPublisher((Subscriber<Integer> s) -> s.onNext(1));
```

Even though `Publisher` is a single abstract method (SAM) type, it is almost never reasonable to write a source with it that doesn't require a per-subscriber state. The example above fails to setup backpressure properly and it didn't call `s.onSubscribe()` for that, causing `NullPointerException` whenever the `Subscription` would be needed (i.e., for cancellation and requesting) by the downstream operator.

`Maybe` doesn't have `fromPublisher`.",2017-10-04 08:28:58,2017-10-04 16:32:58,https://api.github.com/repos/ReactiveX/RxJava/issues/5640,"['2.x', 'Documentation']",48,0,ReactiveX_RxJava_pull_5640.diff
ReactiveX/RxJava,2.x: Fixing JavaDoc warnings,"Minor fixes for warnings reported by `javadoc` tool, mentioned in #5634 ",2017-10-03 13:15:32,2017-10-03 13:35:50,https://api.github.com/repos/ReactiveX/RxJava/issues/5637,"['2.x', 'Cleanup', 'Documentation']",45,86,ReactiveX_RxJava_pull_5637.diff
ReactiveX/RxJava,"Upgrade to Gradle 4.2.1, remove nebula plugin dependency","This PR upgrades the Gradle runtime to 4.2 (which supports Java 9) and gets rid of the `rxjava-nebula` plugin. Its two features, publishing a snapshot and publishing a release has been manually implemented in `build.gradle` based on some [online examples] and [RxAndroid's](https://github.com/ReactiveX/RxAndroid/blob/2.x/rxandroid/build.gradle) variant.

The snapshot publication [works](https://oss.jfrog.org/artifactory/libs-snapshot/io/reactivex/rxjava2/rxjava/2.2.0-SNAPSHOT/) and to test the release, we may have to burn a couple of version tags from 2.1.x.

The PR also renamed the `perf` directory into `jmh` because the replacement JMH plugin expects those files there.",2017-10-02 14:53:49,2017-10-03 07:59:14,https://api.github.com/repos/ReactiveX/RxJava/issues/5633,"['2.x', 'Build']",248,129,ReactiveX_RxJava_pull_5633.diff
ReactiveX/RxJava,"Add 'onCompleteThrows', 'onErrorThrows' test for CallbackCompletable",This is test code for CallbackCompletable. ,2017-09-29 07:55:12,2017-10-01 19:55:42,https://api.github.com/repos/ReactiveX/RxJava/issues/5627,"['2.x', 'Test']",82,4,ReactiveX_RxJava_pull_5627.diff
ReactiveX/RxJava,2.x: add RxJavaPlugins.onCallbackCrash hook?,"This PR suggests a new `RxJavaPlugins` hook: `onCallbackCrash` which should be called by operator implementations when the user-provided callback (`Function`, `Action`, `Consumer`, etc.) crashes for some reason but the exception itself may contain not enough information about what that callback was.

As the test demonstrates, one can call `getClass()` and `getClass().getEnclosingMethod()` to help narrow down the search for the callback's source; Java doesn't provide the source code location this way unfortunately. In addition `getEnclosingMethod()` may return null for Java 8 lambda callbacks and `getClass()` may return a cryptic and unhelpful synthetic method identifier.


Perhaps the only reasonable use case could be the help with finding `null`-returning `Function`s (and the other 0, 2..9 argument variants). This alternative could focus on `ObjectHelper` and replace `requireNonNull` with:

```java
public static <T, R> R nonNullInvoke(Function<T, R> f, T t, 
        String name, String returnDesc) throws Exception {
    R r = f.apply(t);
    if (r != null) {
       return r;
    }
    NullPointerException npe = new NullPointerException(
        ""The "" + name + "" returned a null "" + returnDesc);
    RxJavaPlugins.onCallbackCrash(npe, f);
    throw npe;
}
```

The drawback in this case is the heavily increased bytecode count involved which may lead to missed JIT optimizations due to JVM default limits.",2017-09-28 21:30:53,2017-10-01 19:57:07,https://api.github.com/repos/ReactiveX/RxJava/issues/5626,"['2.x', 'Discussion', 'Enhancement']",203,3,ReactiveX_RxJava_pull_5626.diff
ReactiveX/RxJava,2.x: add onTerminateDetach to Single and Completable,"This PR adds the `onTerminateDetach` operator to `Single` and `Completable`. It was available on `Flowable`, `Observable` and `Maybe` already.

Plus:

- Fixes the javadoc for `Maybe.onTerminateDetach`
- Adds unit tests for verifying terminal events do release references with `Maybe` as well.

Their non-existence came up on [StackOverflow](https://stackoverflow.com/questions/46397082/disposablecompletableobserver-leaking-activity-even-though-im-clearing-composit?noredirect=1#comment79870549_46397082).

**Update**

Turns out the downstream's `actual` references were not cleared in `Maybe` after all. Updated the PR to ensure that in all 3 of them and improved coverage.",2017-09-27 22:25:50,2017-09-28 16:23:33,https://api.github.com/repos/ReactiveX/RxJava/issues/5624,"['2.x', 'Enhancement']",617,1,ReactiveX_RxJava_pull_5624.diff
ReactiveX/RxJava,2.x: fix incorrect error message at SubscriptionHelper.setOnce,"I found an incorrect error message at `SubscriptionHelper.setOnce`.
The error message should mention that the second argument `Subscription s` is null, but the error message says `""d is null""`.",2017-09-27 00:27:07,2017-09-27 07:42:16,https://api.github.com/repos/ReactiveX/RxJava/issues/5623,[],1,1,ReactiveX_RxJava_pull_5623.diff
ReactiveX/RxJava,2.x: Fix Observable.delay & Flowable.delay javadoc,Error notifications can be delayed when using the overloads with a `delayError` parameter.,2017-09-23 22:23:51,2017-09-24 06:22:00,https://api.github.com/repos/ReactiveX/RxJava/issues/5617,"['2.x', 'Documentation']",4,4,ReactiveX_RxJava_pull_5617.diff
ReactiveX/RxJava,2.x: Add Single.delay overload that delays errors,"Much like #5382, I discovered when trying to fake a slow/flaky backend that `Single.delay` doesn't delay errors.

This PR adds an overload that does, bringing `Single.delay` in line with `Observable.delay`. It also corrects the javadoc for existing overloads (#5409 only updated 1/2).",2017-09-23 21:44:21,2017-09-24 10:48:49,https://api.github.com/repos/ReactiveX/RxJava/issues/5616,"['2.x', 'Enhancement']",101,27,ReactiveX_RxJava_pull_5616.diff
ReactiveX/RxJava,2.x: Add missing license headers,`FixLicenseHeaders` is currently failing when run locally (it's skipped on CI).,2017-09-23 21:00:37,2017-09-23 22:30:28,https://api.github.com/repos/ReactiveX/RxJava/issues/5615,"['2.x', 'Cleanup']",52,0,ReactiveX_RxJava_pull_5615.diff
ReactiveX/RxJava,Add onSubscribe in Completable to provide Disposable,#5612 issue,2017-09-21 07:22:28,2017-09-26 09:04:35,https://api.github.com/repos/ReactiveX/RxJava/issues/5613,"['2.x', 'Enhancement']",123,22,ReactiveX_RxJava_pull_5613.diff
ReactiveX/RxJava,2.x: Fix Observable.concatMapEager queueing of source items,"This PR fixes the wrong queue type in `Observable.concatMapEager` to be the `SpscLinkedArrayQueue` instead of the `SpscArrayQueue` (the latter basically ignored items from the main source when it got full - a remnant from its bounded `Flowable` cousin). Unit tests added that ensure both `Flowable` and `Observable` variants work properly.

Reported in: #5608 ",2017-09-18 16:43:21,2017-09-18 17:43:37,https://api.github.com/repos/ReactiveX/RxJava/issues/5609,"['2.x', 'Bug']",72,1,ReactiveX_RxJava_pull_5609.diff
ReactiveX/RxJava,1.x: Workaround for CHM.keySet bad type with Java 8 compiler,"This PR fixes the problem that `ConcurrentHashMap::keySet`, when compiled on JDK 8, adds the `KeySetView` type in the bytecode which is not available in JDK 7 and before. The change forces the offending place to use the the standard `Map::keySet` which returns a standard `Set`.
",2017-09-14 20:20:50,2017-09-15 07:27:07,https://api.github.com/repos/ReactiveX/RxJava/issues/5602,"['1.x', 'Bug']",5,3,ReactiveX_RxJava_pull_5602.diff
ReactiveX/RxJava,Updating JavaDoc with correct return types,"A small PR with updated JavaDoc, mentioned in the issue #5595 (thanks to @RobLewis for reporting it).

Updated documentation about return types, where `Observable` was incorrectly mentioned instead of `Single`.
",2017-09-14 13:59:37,2017-09-14 14:18:32,https://api.github.com/repos/ReactiveX/RxJava/issues/5600,"['2.x', 'Documentation']",4,4,ReactiveX_RxJava_pull_5600.diff
ReactiveX/RxJava,2.x: fix assertValueSequence reversed error message,"The error message/variable names in `TestBaseConsumer.assertValueSequence` was reversed: if more items were expected, it said ""Fewer"" and vice versa.",2017-09-10 16:35:57,2017-09-12 11:28:11,https://api.github.com/repos/ReactiveX/RxJava/issues/5594,"['2.x', 'Cleanup']",12,12,ReactiveX_RxJava_pull_5594.diff
ReactiveX/RxJava,2.x: Fix wrapping error signaled after unsubscription into UndeliverableException.,"For now it's just a failing test since I'm not sure if and how we'll fix that.

Explanation:

`RxJavaPlugins.isBug()` treats 3 common JDK exceptions as user bugs and doesn't wrap them into `UndeliverableException` even if they were actually signalled after observer unsubscription:

- `IllegalStateException`
- `NullPointerException`
- `IllegalArgumentException`

Real-life example:

1. User is doing long (IO, etc.) operation in some part of Rx chain ie `fromCallable()`, `map()`, `create()`, `doOnNext()`, etc. 
1. Then at some point user unsubscribes from the chain.
1. Long operation throws one of 3 common JDK exceptions mentioned above.
1. Exception gets delivered to `RxJavaPlugins.onError()` since there is no observer to deliver it to.
1. Even if user has custom `RxJavaPlugins` error handler, he/she won't be able to understand that this exception is actually an `UndeliverableException` and can be ~safely ignored/logged/etc in most situations (RxJava 1.x [just didn't do anything](https://github.com/ReactiveX/RxJava/blob/8e925345814c291e2ab2f10f4986f1ac9b8ee68a/src/main/java/rx/observers/SafeSubscriber.java#L113) with them).

---

Possible solution:

1. Do not rely on JDK exceptions that could be used by other projects, ie create `RxJavaIllegalStateException` and so on.
1. Explicitly wrap exceptions caught after `isDisposed()` in the operators into `UndeliverableException` before signalling them to `RxJavaPlugins.onError()` (I like this better atm).",2017-09-07 08:14:30,2017-10-18 13:39:10,https://api.github.com/repos/ReactiveX/RxJava/issues/5592,"['2.x', 'Feature-Request']",53,0,ReactiveX_RxJava_pull_5592.diff
ReactiveX/RxJava,Implement LambdaConsumerIntrospection,"Followup from #5569, and allows you to introspect if the resulting observer has missing error consumption and subsequently supplies a default (throwing) one.",2017-09-06 22:41:08,2017-09-12 11:45:58,https://api.github.com/repos/ReactiveX/RxJava/issues/5590,"['2.x', 'Enhancement']",208,20,ReactiveX_RxJava_pull_5590.diff
ReactiveX/RxJava,2.x: fix Single.timeout unnecessary dispose calls,This PR fixes the unnecessary `dispose` call towards the main source when the source terminates and reworks the internals to use less allocation and indirection.,2017-09-06 11:32:47,2017-09-10 11:35:24,https://api.github.com/repos/ReactiveX/RxJava/issues/5586,"['2.x', 'Cleanup']",223,60,ReactiveX_RxJava_pull_5586.diff
ReactiveX/RxJava,implement Maybe.switchIfEmpty(Single),"Adds `Maybe.switchIfEmpty(Single)`, fixes #4544.",2017-09-02 18:16:33,2017-09-04 12:28:24,https://api.github.com/repos/ReactiveX/RxJava/issues/5582,"['2.x', 'Feature-Request']",257,0,ReactiveX_RxJava_pull_5582.diff
ReactiveX/RxJava,2.x: Added a .filter(value) operator shorthand,"NOTE: This is my first ever contribution to anything, so i'm sure there will be revising involved here.

There are times when you simply want to filter events by a single value, and implementing a predicate seems ugly.

I think you should be able to do thinks like ```.filter(false)``` or ```.filter(enum.SOME_EVENT)```.

Let me know what you all think!
",2017-09-01 11:38:48,2017-09-01 12:11:48,https://api.github.com/repos/ReactiveX/RxJava/issues/5581,"['2.x', 'Feature-Request']",272,11,ReactiveX_RxJava_pull_5581.diff
ReactiveX/RxJava,2.x: add Maybe null test cases,"Add Maybe null test cases.

I will add more test cases for Maybe by studying Maybe. 

This code is similar with Observable, Single,, test case.",2017-08-30 16:45:11,2017-08-30 17:32:58,https://api.github.com/repos/ReactiveX/RxJava/issues/5579,"['2.x', 'Cleanup']",675,0,ReactiveX_RxJava_pull_5579.diff
ReactiveX/RxJava,Add NullPointerException comment,Add comments in Single.java,2017-08-30 16:29:58,2017-08-30 16:44:35,https://api.github.com/repos/ReactiveX/RxJava/issues/5578,"['2.x', 'Cleanup']",11,0,ReactiveX_RxJava_pull_5578.diff
ReactiveX/RxJava,Remove unnecessary code,,2017-08-30 16:02:25,2017-08-30 16:13:34,https://api.github.com/repos/ReactiveX/RxJava/issues/5577,"['2.x', 'Cleanup']",3,2,ReactiveX_RxJava_pull_5577.diff
ReactiveX/RxJava,Remove unnecessary git command from build instructions,"Removing line to match wiki instructions and since 2.x is the default branch
",2017-08-27 23:47:54,2017-08-28 07:55:54,https://api.github.com/repos/ReactiveX/RxJava/issues/5572,[],0,1,ReactiveX_RxJava_pull_5572.diff
ReactiveX/RxJava,Added formatting to license section,"The license section did not previously contain markdown syntax formatting. Added 4 spaces to add it.
",2017-08-27 20:56:47,2017-08-27 21:16:52,https://api.github.com/repos/ReactiveX/RxJava/issues/5571,['2.x'],10,10,ReactiveX_RxJava_pull_5571.diff
ReactiveX/RxJava,2.x: Strawman proposal for uncaught exception configuration,"This is a strawman example/proposal for configurable uncaught exception handling in RxJavaPlugins. This is in ref to #5234.

The two options are to defer to current thread's handler (the current implementation and remains the default) and an optional `throw` option that wraps the throwable into an `UncaughtRxJavaException` for developers to watch for separately (and rethrowing, which requires some sort of `RuntimeException` wrapping).

If the proposal is agreeable/after API design is in place, I can add tests.",2017-08-26 03:00:26,2017-09-05 11:22:14,https://api.github.com/repos/ReactiveX/RxJava/issues/5569,"['2.x', 'Feature-Request']",47,3,ReactiveX_RxJava_pull_5569.diff
ReactiveX/RxJava,2.x: Add assertValuesOnly to BaseTestConsumer.,"Adds `assertValuesOnly` that asserts that the TestObserver/TestSubscriber received only the specified values in the specified order without terminating.

Fixes #5555 ",2017-08-24 21:53:51,2017-08-25 09:54:52,https://api.github.com/repos/ReactiveX/RxJava/issues/5568,"['2.x', 'Enhancement']",139,0,ReactiveX_RxJava_pull_5568.diff
ReactiveX/RxJava,2.x: fix Obs.combineLatestDelayError sync initial error not emitting,"This PR fixes the case reported in #5558 where a synchronous first, non-empty source triggered an error completion immediately instead of giving a chance to the other sources to form combinations.

The fix also includes:

- initialization of the `CombineObserver`s now happen in the constructor,
- the `AtomicReference<Disposable>` of the inner observers are now inlined into `CombineObserver`,
- cleaned up drain logic
- unit tests verifying `FlowableCombineLatest` (no changes required there).
",2017-08-22 16:18:42,2017-08-22 16:59:54,https://api.github.com/repos/ReactiveX/RxJava/issues/5560,"['2.x', 'Bug']",142,114,ReactiveX_RxJava_pull_5560.diff
ReactiveX/RxJava,[Typo] Update Schedulers.java,Just a typo I came across while reading the javadocs.,2017-08-13 06:30:04,2017-08-13 07:55:44,https://api.github.com/repos/ReactiveX/RxJava/issues/5552,"['2.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_5552.diff
ReactiveX/RxJava,2.x: upgrade Reactive-Streams dependency to 1.0.1,"This PR upgrades the dependency to Reactive-Streams 1.0.1 final, and

- organizes the other dependency versions into nice variables,
- allows the javadoc generator to link to the RS javadoc.

A couple of remarks on the other dependency versions:

- *JMH 1.16*: last version that supports Java 6
- *TestNG 6.9.10*: last version that doesn't break the RS TCK and works with the TestNG Eclipse plugin
- *Mockito 2.1.0*: I guess upgrading within the minor version has little advertising value.
- *JUnit 4.12*: Latest version everything supports as of now.",2017-08-09 14:46:54,2017-08-10 07:25:50,https://api.github.com/repos/ReactiveX/RxJava/issues/5546,"['2.x', 'Build']",21,7,ReactiveX_RxJava_pull_5546.diff
ReactiveX/RxJava,Fix grammar error in README.md,"grammar fix :D
",2017-08-09 05:20:43,2017-08-10 07:30:20,https://api.github.com/repos/ReactiveX/RxJava/issues/5544,"['2.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_5544.diff
ReactiveX/RxJava,2.x: Fix flaky MaybeFromCallableTest.noErrorLoss,"The `MaybeFromCallableTest.noErrorLoss` failed occasionally because the `await` didn't throw `InterruptedException` as expected. 

The reason for this is that if the main `to.cancel();` and the subsequent `cdl2.countDown();` happened just before `await()` was called, the `await` didn't even look at the thread's interrupt status but returned immediately as there was nothing to wait for.

The fix just removes that `cdl2.countDown` and adds a regular timeout to the inner `await`.

*(Detected while verifying RxJava 2 against JDK 9b181.)*",2017-08-08 11:03:31,2017-08-08 14:34:46,https://api.github.com/repos/ReactiveX/RxJava/issues/5541,"['2.x', 'Test-Failures']",3,9,ReactiveX_RxJava_pull_5541.diff
ReactiveX/RxJava,Switch to JSR305 nullability annotations.,"This PR implements proposal #5341.

Since `@ParametersAreNonnullByDefault` only covers function parameters, I've left `@Nonnull` for return results in existing usage places. 

@hzsweers suggested creating `@EverythingIsNonNullByDefault` but I'm not sure how tooling will recognise it.

@akarnokd we can also change RxJava's `@CheckReturnValue` with `javax.annotation.@CheckReturnValue` in a separate PR if this one gets merged. 

P.S. I've tried to minimize imports regrouping, but some files were written in different code styles regarding imports, so you might find few minor regroupings, sorry.",2017-08-07 04:01:49,2017-10-18 13:37:52,https://api.github.com/repos/ReactiveX/RxJava/issues/5538,['2.x'],806,754,ReactiveX_RxJava_pull_5538.diff
ReactiveX/RxJava,2.x: Try fixing Travis CI lack of java,"Travis CI has replaced the previous Precise image with the Trusty image as part of an ongoing rollout. Unfortunately, the Trusty image fails for `oraclejdk7` because probably it is no longer supported (although I couldn't find anything about it).

This PR tries to identify what's available by trying a matrix of build setups.",2017-08-01 20:10:42,2017-08-01 21:29:12,https://api.github.com/repos/ReactiveX/RxJava/issues/5531,"['2.x', 'Build']",1,1,ReactiveX_RxJava_pull_5531.diff
ReactiveX/RxJava,(refactor) some opportunities to use lambda functions,"Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [ ] Please give a description about what and why you are contributing, even if it's trivial.

  - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.",2017-08-01 01:37:46,2017-08-01 06:39:22,https://api.github.com/repos/ReactiveX/RxJava/issues/5530,"['2.x', 'Invalid']",34,34,ReactiveX_RxJava_pull_5530.diff
ReactiveX/RxJava,"Add assertValueAt(int, value) to TestObserver","I found myself frequently writing tests that want to check that an observable emitted a certain value second or third, but I don't care what the first or other values one, so `assertValues(Object...))` is more brittle.

This PR implements an `assertValueAt(index, value)` method, similar to `assertValue(value)`. Tests are also added.  ",2017-07-31 21:54:25,2017-08-02 16:02:03,https://api.github.com/repos/ReactiveX/RxJava/issues/5529,['2.x'],72,2,ReactiveX_RxJava_pull_5529.diff
ReactiveX/RxJava,2.x: add onErrorResumeNextFilter() and OnErrorReturnFilter() operators,"@akarnokd 

I try to add these two operators, but i not so good at english.

Please check it, test, add doc.

Thanks
",2017-07-31 17:04:27,2017-08-01 07:41:00,https://api.github.com/repos/ReactiveX/RxJava/issues/5527,"['2.x', 'Invalid']",124,1,ReactiveX_RxJava_pull_5527.diff
ReactiveX/RxJava,2.x: add/update Observable marbles (07/30),"This PR updates the marbles of the following `Observable` operators:

- `just` ([image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.item.png)) by @leonardortlima 
- `rangeLong` ([image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/rangeLong.png)) by @leonardortlima 
- `startWith` ([image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.item.png)) by @leonardortlima 
- `startWithArray` ([image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWithArray.png)) by @leonardortlima 
- `sorted` ([image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sorted.png)) by @leonardortlima 

See #5319.",2017-07-30 08:13:40,2017-07-31 20:32:52,https://api.github.com/repos/ReactiveX/RxJava/issues/5524,"['2.x', 'Documentation']",10,8,ReactiveX_RxJava_pull_5524.diff
ReactiveX/RxJava,test,"Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [ ] Please give a description about what and why you are contributing, even if it's trivial.

  - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.
",2017-07-29 04:41:16,2017-07-29 06:57:36,https://api.github.com/repos/ReactiveX/RxJava/issues/5522,[],1,0,ReactiveX_RxJava_pull_5522.diff
ReactiveX/RxJava,findbugs fixes on unused fields and suspicious integer instance compa…,"…rison

Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [ ] Please give a description about what and why you are contributing, even if it's trivial.

  - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.
",2017-07-26 23:59:41,2017-07-27 00:13:05,https://api.github.com/repos/ReactiveX/RxJava/issues/5519,[],25,82,ReactiveX_RxJava_pull_5519.diff
ReactiveX/RxJava,findbugs fixes on unused fields and suspicious integer instance compa…,"…rison

Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [ ] Please give a description about what and why you are contributing, even if it's trivial.

  - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.
",2017-07-26 23:44:04,2017-07-26 23:49:13,https://api.github.com/repos/ReactiveX/RxJava/issues/5518,[],25,82,ReactiveX_RxJava_pull_5518.diff
ReactiveX/RxJava,2.x: add missing null check to fused Observable.fromCallable,"There was a missing null check on the fusion path in `ObservableFromCallable` which meant the consumer considered the source to be empty. (The `FlowableFromCallable` was okay.)

Discovered on StackOverflow: https://stackoverflow.com/questions/45304226/null-handling-in-rx-java2-flatmap

Unit test mirrored and updated to verify both `Flowable` and `Observable` versions.",2017-07-25 13:59:28,2017-07-25 17:33:22,https://api.github.com/repos/ReactiveX/RxJava/issues/5517,"['2.x', 'Bug']",325,1,ReactiveX_RxJava_pull_5517.diff
ReactiveX/RxJava,Remove unnecessary generic type parameters for delaySubscription methods in Single,"I was running into an issue with using the `delaySubscription(long time, TimeUnit unit)` while testing a `Single` and I saw that the `U` generic type parameter was there unnecessarily. I believe this is only a Kotlin specific issue as I tried playing around in Java and there was no inference error upon compilation. To get it to compile for Kotlin, I would need to specify the generic type parameter and it didn't matter what I set it to as `Any` was a valid option: `.delaySubscription<Any>(5, TimeUnit.SECONDS)`. I also went through `Flowable`, `Observable`, and `Maybe` and saw that the generics were missing for the time-specific `delaySubscription` methods so I believe they should be removed from `Single` as well to help keep things consistent and remove this compilation error for future Kotlin users.

![kotlin_error](https://user-images.githubusercontent.com/1130517/28450952-83ad8468-6db8-11e7-841e-85be4ddf0c26.png)
",2017-07-21 06:09:21,2017-07-21 15:26:55,https://api.github.com/repos/ReactiveX/RxJava/issues/5511,['2.x'],2,4,ReactiveX_RxJava_pull_5511.diff
ReactiveX/RxJava,"2.x: fix SpscLAQ nepotism, FlowableRefCountTest.testRefCountAsync flaky","This PR fixes the so-called GC Nepotism (see #3794) in `SpscLinkedArrayQueue` by not nulling out the previous buffer's next pointer upon switching buffers in the `peek()`/`poll()` methods.

In addition, the FlowableRefCountTest.testRefCountAsync has been reworked to be more forgiving towards unexpected delays due to system load (reported in #5506).",2017-07-19 21:01:07,2017-07-20 13:52:14,https://api.github.com/repos/ReactiveX/RxJava/issues/5507,"['2.x', 'Bug', 'Test-Failures']",45,8,ReactiveX_RxJava_pull_5507.diff
ReactiveX/RxJava,"2.x: make withLatestFrom conditional subscriber, test cold consumption","This PR adjusts #5494 by converting the `withLatestFrom` operators into conditional subscribers and adds unit tests that verify a cold source is consumed fully if there is no event(s) from the other source(s).

(Also there was a missing space before the bracked and the new unit test name had the `test` prefix.)",2017-07-18 07:46:32,2017-07-18 17:04:31,https://api.github.com/repos/ReactiveX/RxJava/issues/5495,"['2.x', 'Cleanup']",145,21,ReactiveX_RxJava_pull_5495.diff
ReactiveX/RxJava,FlowableWithLatestFrom forgets request,"The following scenario did not work with FlowableWithLatestFrom:
Flowable<?> result = source.combineWithLatest(other, someCombiner)
- client subscribe to the result stream
- source stream emits
- other stream emits
- source stream emits

expected result: result stream emits the combined event
actual result: result stream does not emit anything",2017-07-17 19:56:14,2017-07-18 07:32:45,https://api.github.com/repos/ReactiveX/RxJava/issues/5494,"['2.x', 'Bug']",37,2,ReactiveX_RxJava_pull_5494.diff
ReactiveX/RxJava,2.x: fix ReplayProcessor backpressure and NotificationLite emission bug,"This PR upgrades the replaying algorithms of the `ReplayProcessor` to the standard queue-drain and as an added effect, fixes a request-emission race where the internal `NotificationLite.complete` could be emitted to the consumers.",2017-07-17 16:41:30,2017-07-18 08:42:48,https://api.github.com/repos/ReactiveX/RxJava/issues/5493,"['2.x', 'Bug']",501,308,ReactiveX_RxJava_pull_5493.diff
ReactiveX/RxJava,Indent comments,Indent comments to be consistent to other comment's indentation,2017-07-17 02:14:17,2017-07-17 05:23:45,https://api.github.com/repos/ReactiveX/RxJava/issues/5492,"['2.x', 'Cleanup']",1,4,ReactiveX_RxJava_pull_5492.diff
ReactiveX/RxJava,Improved Java doc for Maybe#defaultIfEmpty to suggest Maybe#toSingle,Improved Java doc for Maybe#defaultIfEmpty to suggest Maybe#toSingle for Issue 5480,2017-07-15 10:48:41,2017-07-17 16:33:43,https://api.github.com/repos/ReactiveX/RxJava/issues/5491,"['2.x', 'Documentation']",2,1,ReactiveX_RxJava_pull_5491.diff
ReactiveX/RxJava,2.x: small note on Maybe.defaultIfEmpty regarding toSingle,"Ths PR replaces #5485 regarding the issue of #5480 because our javadoc validation did not allow that type of wording (i.e., mentioning `Single` when the method signature is not related to it).",2017-07-12 22:07:40,2017-07-15 10:52:39,https://api.github.com/repos/ReactiveX/RxJava/issues/5486,"['2.x', 'Documentation']",8,2,ReactiveX_RxJava_pull_5486.diff
ReactiveX/RxJava,Update Maybe#defaultIfEmpty javadoc (#5480),"Adds a link to Javadoc for `Maybe#defaultIfEmpty` method which has a surprising return type (#5480, #5417).",2017-07-12 21:11:50,2017-07-12 22:21:03,https://api.github.com/repos/ReactiveX/RxJava/issues/5485,"['2.x', 'Documentation']",2,0,ReactiveX_RxJava_pull_5485.diff
ReactiveX/RxJava,Fix a typo in the changelog,Fixed a typo in the work `changelog`,2017-07-11 14:04:22,2017-07-11 15:14:01,https://api.github.com/repos/ReactiveX/RxJava/issues/5481,"['2.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_5481.diff
ReactiveX/RxJava,"Fixed  doc for F.reduce(seed, reducer), F.reduceWith(seedSupplier, reducer) and O.reduce(seed, reducer)","Corrected the doc for Issue No: #5476
",2017-07-10 16:57:31,2017-07-10 17:16:43,https://api.github.com/repos/ReactiveX/RxJava/issues/5478,"['2.x', 'Documentation']",4,4,ReactiveX_RxJava_pull_5478.diff
ReactiveX/RxJava,Fixed Javadoc for Flowable and Observable reduce.,"Fixed Javadoc for `Flowable.reduce(T, BiFunction)` and `Observable.reduce(T, BiFunction)` mentioning the wrong return type.

#5456 ",2017-07-09 21:29:09,2017-07-09 22:32:15,https://api.github.com/repos/ReactiveX/RxJava/issues/5476,"['2.x', 'Documentation']",2,2,ReactiveX_RxJava_pull_5476.diff
ReactiveX/RxJava,1.x: increase timeout of some tests,Increase timeouts of tests that started failing due to slower CI.,2017-07-06 10:40:39,2017-07-06 20:23:11,https://api.github.com/repos/ReactiveX/RxJava/issues/5471,"['1.x', 'Test-Failures']",69,58,ReactiveX_RxJava_pull_5471.diff
ReactiveX/RxJava,fix #5468: eager hooks onError call,"Move the call to RxJavaHooks into the catch block, so we only report and it if the underlying subscriber throws in its onError method.

This brings its behaviour in line with that of SafeSubscriber


",2017-07-06 08:11:58,2017-07-06 09:54:01,https://api.github.com/repos/ReactiveX/RxJava/issues/5470,"['1.x', 'Bug']",1,1,ReactiveX_RxJava_pull_5470.diff
ReactiveX/RxJava,2.x: Removing commented code from tests,"Hi,

In this PR I'm removing commented code from tests as it's generally considered as bad practice.
Part of this code is even not available in the current RxJava API. It does not resolve all of the issues like that, but only part of them. I didn't want to create PR with more changes because it will be harder to review. Rest of the similar issues could be resolved in the future PRs.

Regards,
Piotr
",2017-07-05 15:02:29,2017-07-05 22:04:43,https://api.github.com/repos/ReactiveX/RxJava/issues/5467,"['2.x', 'Cleanup']",0,122,ReactiveX_RxJava_pull_5467.diff
ReactiveX/RxJava,2.x: FlowableTimeoutTimed - replace AtomicReference with mutable field,"As per discussion in #5461. The timer fields in the Subscriber classes in [FlowableTimeoutTimed](https://github.com/ReactiveX/RxJava/blob/4c22f969927a98bc35458645d373bcb94b7df622/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java) are `AtomicReference`s but this is not required as the fields are accessed synchronously.

The `timer` field in `TimeoutTimedOtherSubscriber` did require an `AtomicReference` because of the dispose call [here](https://github.com/ReactiveX/RxJava/blob/4c22f969927a98bc35458645d373bcb94b7df622/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java#L173) but this call is not required if we just call `worker.dispose()`.

No unit test additions.

P.S. 9321 unit tests in RxJava 2.x! An outrageous amount of work, thanks @akarnokd (and other contributors)!",2017-07-05 12:03:22,2017-07-05 12:48:11,https://api.github.com/repos/ReactiveX/RxJava/issues/5466,"['2.x', 'Cleanup']",9,20,ReactiveX_RxJava_pull_5466.diff
ReactiveX/RxJava,"2.x: fix wording of toList, fix a/an in subscribeOn","This PR

- fixes the wording of `toList()` putting emphasis of the need for finite sources and removes a misleading/incorrect sentence about unstoppability;
- corrects a/an spelling errors in `subscribeOn`.
- removes the mention of `toBlocking` from the `toFuture` javadoc",2017-07-05 09:09:43,2017-07-05 13:46:57,https://api.github.com/repos/ReactiveX/RxJava/issues/5465,"['2.x', 'Documentation']",34,28,ReactiveX_RxJava_pull_5465.diff
ReactiveX/RxJava,Refactoring SingleSchedulerTest,"Hi,

I refactored `SingleSchedulerTest`. Now it extends `AbstractSchedulerTests`, so redundant tests (with duplicated code) could be removed in favor of abstract tests. Now, thanks to the abstract test class, `SingleScheduler` has 21 unit tests instead of just 7. This approach is consistent with the test classes for other Schedulers.

Regards,
Piotr",2017-07-04 22:15:58,2017-07-05 08:46:17,https://api.github.com/repos/ReactiveX/RxJava/issues/5462,"['2.x', 'Cleanup', 'Test']",4,59,ReactiveX_RxJava_pull_5462.diff
ReactiveX/RxJava,2.x: fix Javadoc mistakes and some style,"This PR fixes most JavaDoc errors discovered from RxJava 3 preview's javadoc generator (doclint enabled). 

(I was unable to make gradle in RxJava 2 to report the same errors regardless of source level and underlying Java 8 runtime locally.)

Changes include:

- Fix closing tag of `<dt>` in `<dl>`s
- Fix `<td>` to `<dt>` in `<dl>`s
- Replace `>` in `<code>` blocks with `&gt;`  (as it is forbidden in doclint of Java 8)
- Replace `<` in `<code>` blocks with `&lt;`
- Add source code checker for the previous mistakes
- Remove `initialSeed` mentions from `scan` operators that take a `seedSupplier` and remove the deferred example as well
- Switch the order of `<code><pre>` to `<pre><code>`.
- A couple of end-sentence punctuation.


",2017-07-03 11:28:30,2017-07-03 18:20:34,https://api.github.com/repos/ReactiveX/RxJava/issues/5460,"['2.x', 'Documentation']",306,201,ReactiveX_RxJava_pull_5460.diff
ReactiveX/RxJava,2.x: See if sudo required results in consistent & faster build times,I asked the Travis support about the slow build times of lately and they suggested I try `sudo:required` to have an isolated build VM instead of the shared container-based one. I'll rerun this PR a couple of times to see the effects.,2017-06-30 16:55:43,2017-07-09 22:18:17,https://api.github.com/repos/ReactiveX/RxJava/issues/5457,"['2.x', 'Build']",1,1,ReactiveX_RxJava_pull_5457.diff
ReactiveX/RxJava,2.x: Replace duplicate calling method setAccessible on the same object in FunctionsTest class.,"I would like to add unit tests to my project and decided to watch tests in this repository. During reviewing testing class <code>FunctionsTest</code> I watch duplicated calling method <code>setAccessible(true)</code> at the same object.
",2017-06-30 09:18:32,2017-07-03 17:34:28,https://api.github.com/repos/ReactiveX/RxJava/issues/5454,"['2.x', 'Cleanup']",2,2,ReactiveX_RxJava_pull_5454.diff
ReactiveX/RxJava,2.x: upgrade to Reactive-Streams 1.0.1-x,"The Reactive-Streams initiative has updated their specification, API and TCK to 1.0.1 and short testing phase started with RC1. The binary RS API has not changed but the Test Compatibility Kit has received several bugfixes and some extensions. Depending on the time it will take the RC to become stable, RxJava 2.1.2 may not release with an RC dependency (i.e., doing some gradle version overriding to have the most recent TCK but still have 1.0.0 as the API dependency).",2017-06-29 14:13:29,2017-08-09 08:20:44,https://api.github.com/repos/ReactiveX/RxJava/issues/5453,"['2.x', 'Test']",4,2,ReactiveX_RxJava_pull_5453.diff
ReactiveX/RxJava,Remove the @NonNull annotation from Function,As per per the discussion in #5447,2017-06-27 19:31:03,2017-06-28 08:43:25,https://api.github.com/repos/ReactiveX/RxJava/issues/5449,['2.x'],0,1,ReactiveX_RxJava_pull_5449.diff
ReactiveX/RxJava,Remove @NonNull annotation in Consumer method parameter,This fixes #5442 ,2017-06-27 08:16:33,2017-06-27 13:11:09,https://api.github.com/repos/ReactiveX/RxJava/issues/5447,"['2.x', 'Shortcoming']",1,3,ReactiveX_RxJava_pull_5447.diff
ReactiveX/RxJava,2x: Fix wording in Async and Publish processors javadoc.,Seams that these are some leftovers from the 1.x -> 2.x refactoring.,2017-06-26 21:31:49,2017-06-26 22:14:26,https://api.github.com/repos/ReactiveX/RxJava/issues/5444,"['2.x', 'Documentation']",7,6,ReactiveX_RxJava_pull_5444.diff
ReactiveX/RxJava,2.x: fix periodic scheduler purging config not honored,"The `SchedulerPoolFactory` did not act properly on the system properties setup.

Reported on StackOverflow: https://stackoverflow.com/q/44717193/61158",2017-06-26 08:06:18,2017-06-27 13:11:51,https://api.github.com/repos/ReactiveX/RxJava/issues/5441,"['2.x', 'Bug']",11,5,ReactiveX_RxJava_pull_5441.diff
ReactiveX/RxJava,2.x: concat to report isDisposed consistently with termination,"This PR makes sure the `Disposable` of a `concat` operator reports `true` when the sequence terminates.

Reported in #5439",2017-06-26 07:54:32,2017-06-27 13:11:34,https://api.github.com/repos/ReactiveX/RxJava/issues/5440,"['2.x', 'Shortcoming']",186,3,ReactiveX_RxJava_pull_5440.diff
ReactiveX/RxJava,1.x: TestSubscriber::assertValuesAndClear should reset valueCount,"During the time between calling `assertValuesAndClear` and providing the next `onNext` event, the `valueCount` is inconsistent with the size of the internal `values` list.",2017-06-23 17:26:22,2017-06-24 11:34:48,https://api.github.com/repos/ReactiveX/RxJava/issues/5437,"['1.x', 'Bug']",13,1,ReactiveX_RxJava_pull_5437.diff
ReactiveX/RxJava,"2.x: Gradle to use less memory, missed an export command","Looks like there was a missing ""export"" keyword in the build options and thus gradle ate all 3 GB memory dancing on the edge of the OOMKiller.",2017-06-23 12:30:27,2017-06-23 12:45:53,https://api.github.com/repos/ReactiveX/RxJava/issues/5436,"['2.x', 'Build']",1,1,ReactiveX_RxJava_pull_5436.diff
ReactiveX/RxJava,2.x: fix time bounded replaySubject getValue() inconsistency with getValues() on old items,See https://github.com/ReactiveX/RxJava/issues/5433.,2017-06-21 13:58:07,2017-06-21 16:12:46,https://api.github.com/repos/ReactiveX/RxJava/issues/5434,"['2.x', 'Bug']",50,0,ReactiveX_RxJava_pull_5434.diff
ReactiveX/RxJava,2.x: fix/clarify the Observable class' javadoc,This PR rewords the javadoc of the `Observable` class a bit and adds a couple of extra clarifying sentences.,2017-06-21 11:48:24,2017-06-23 09:16:48,https://api.github.com/repos/ReactiveX/RxJava/issues/5432,"['2.x', 'Documentation']",47,8,ReactiveX_RxJava_pull_5432.diff
ReactiveX/RxJava,1.x: fix premature cleanup in AsyncOnSubscribe when the last Observable is still running,"The issue is caused by premature cleanup when onCompleted is emitted from the callback function which may happen while a requested async sequence is still not completed.
The unit test is provided which will fail without the fix.
More cases are provided in the issue https://github.com/ReactiveX/RxJava/issues/5429.",2017-06-21 06:38:20,2017-06-23 09:16:14,https://api.github.com/repos/ReactiveX/RxJava/issues/5430,"['1.x', 'Bug']",39,2,ReactiveX_RxJava_pull_5430.diff
ReactiveX/RxJava,"2.x: fix buffer(time, maxSize) duplicating buffers on time-size race","The PR fixes both the time+maxSize bound `buffer` operators of `Flowable` and `Observable`. The logic didn't properly mutually exclude the timer action and the `onNext` action, resulting in probabilistic emission of the same buffer twice.

Reported in #5426.",2017-06-19 18:56:05,2017-06-20 08:02:06,https://api.github.com/repos/ReactiveX/RxJava/issues/5427,"['2.x', 'Bug']",94,23,ReactiveX_RxJava_pull_5427.diff
ReactiveX/RxJava,2.x: more eager cancellation in flatMapX,The FlatMapX tests kept failing because there was a race between the cancellation and the disposing of their inner set: the cancel may have interrupted the test wait and ended up in the inner subscribe before `set.isDisposed()` would become true in the `dispose()` call of the operator that run on the main thread. The change adds/uses a boolean field that gets set first and is checked before the inner are subscribed.,2017-06-16 17:03:10,2017-06-17 06:23:45,https://api.github.com/repos/ReactiveX/RxJava/issues/5422,"['2.x', 'Test-Failures']",20,8,ReactiveX_RxJava_pull_5422.diff
ReactiveX/RxJava,2.x: attempt to fix a few time-sensitive tests.,"As of lately, the Travis CI runs much slower than usual and causes some time-sensitive tests to fail for some reason. This PR tries to figure out why this happens.",2017-06-16 11:28:11,2017-06-16 16:22:14,https://api.github.com/repos/ReactiveX/RxJava/issues/5421,"['2.x', 'Test-Failures']",34,23,ReactiveX_RxJava_pull_5421.diff
ReactiveX/RxJava,2.x: fix periodic scheduling with negative period causing IAE,"This PR adds unit tests to verify the `Scheduler.schedulePeriodicallyDirect` and `Scheduler.Worker.schedulePeriodically` works with non-positive period as required by the Javadoc. 

The `computation` and `single` schedulers were not working properly and the underlying `ScheduledExecutorService` crashed with `IllegalArgumentException` thus these are now fixed with custom handler for the `period <= 0L` cases.

Related: #5416.",2017-06-16 10:39:31,2017-06-17 06:23:24,https://api.github.com/repos/ReactiveX/RxJava/issues/5419,"['2.x', 'Bug']",279,3,ReactiveX_RxJava_pull_5419.diff
ReactiveX/RxJava,2.x: fix doOnNext failure not triggering doOnError when fused,"This PR fixes an issue when in a fused chain of `doOnNext` and `doOnError` the `doOnNext` function fails, the `doOnError` consumer is not called.

Originally reported in Reactor-Core: https://github.com/reactor/reactor-core/issues/664",2017-06-14 17:40:49,2017-06-16 08:08:20,https://api.github.com/repos/ReactiveX/RxJava/issues/5415,"['2.x', 'Bug']",263,4,ReactiveX_RxJava_pull_5415.diff
ReactiveX/RxJava,2.x: Add empty source clauses to javadocs of combineLatest operators …,…accepting unspecified number of sources. This commit resolves #5412,2017-06-14 13:01:01,2017-06-28 08:58:59,https://api.github.com/repos/ReactiveX/RxJava/issues/5413,"['2.x', 'Documentation']",71,0,ReactiveX_RxJava_pull_5413.diff
ReactiveX/RxJava,#5382 Corrected Single.delay documentation,"Corrected Single.delay documentation that says that success or error signals will be delayed by the specified amount, but in fact errors are not delayed, only successes.",2017-06-12 10:08:45,2017-06-12 10:39:41,https://api.github.com/repos/ReactiveX/RxJava/issues/5409,"['2.x', 'Documentation']",2,3,ReactiveX_RxJava_pull_5409.diff
ReactiveX/RxJava,DefaultSubscriber javadoc sample fix,"The example in the javadoc of `DefaultSubscriber` is not compiling, `DefaultSubscriber` is not a `Disposable`. 
This PR updates the javadoc to provide a compiling example.

Fix is similar to #5405 for `DefaultObserver`.",2017-06-11 15:44:53,2017-06-11 16:39:15,https://api.github.com/repos/ReactiveX/RxJava/issues/5407,"['2.x', 'Documentation']",2,5,ReactiveX_RxJava_pull_5407.diff
ReactiveX/RxJava,Fix javadoc for Observable.reduce() and Observable.reduceWith(),"The sample code given in the javadoc for `Observable.reduce()` isn't compiling, since the function returns a `Single`. 
This PR changes it to a compiling example. 
It also updates the javadoc for `reduceWith()` to better match its actual behaviour.

*Remark*
I'm not sure whether the sample code for `reduce()` is needed at all. The problem that it addresses might be solved better by using `reduceWith()`, imho.

*Update*
- similar changes applied to `Flowable.reduce()` and `Flowable.reduceWith()`",2017-06-11 00:11:17,2017-06-11 17:23:36,https://api.github.com/repos/ReactiveX/RxJava/issues/5406,"['2.x', 'Documentation']",26,42,ReactiveX_RxJava_pull_5406.diff
ReactiveX/RxJava,DefaultObserver javadoc example fix,"The example in the javadoc of `DefaultObserver` is not compiling, `DefaultObserver` is not a `Disposable`. 
This PR updates the javadoc to provide a compiling example.",2017-06-09 21:55:48,2017-06-09 22:13:18,https://api.github.com/repos/ReactiveX/RxJava/issues/5405,"['2.x', 'Documentation']",2,5,ReactiveX_RxJava_pull_5405.diff
ReactiveX/RxJava,2.x: Fix documentation of Single.doAfterTerminate.,"Fix the copy-paste error in the javadoc of `Single.doAfterTeminate` mentioning `doAfterSuccess`.
",2017-06-09 11:55:10,2017-06-09 14:01:44,https://api.github.com/repos/ReactiveX/RxJava/issues/5403,"['2.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_5403.diff
ReactiveX/RxJava,Update README.md,"Added Gitter.im chat for support.

As discussed in #5394",2017-06-05 15:07:30,2017-06-05 15:58:23,https://api.github.com/repos/ReactiveX/RxJava/issues/5395,"['2.x', 'Information']",1,0,ReactiveX_RxJava_pull_5395.diff
ReactiveX/RxJava,Changed minimum value of rx2.buffer-size to 1,"Before the minimum value you could set with the system variable `rx2.buffer-size` was 16. With this commit, that is changed to 1.
",2017-06-03 09:39:44,2017-06-03 10:42:42,https://api.github.com/repos/ReactiveX/RxJava/issues/5391,"['2.x', 'Shortcoming']",1,1,ReactiveX_RxJava_pull_5391.diff
ReactiveX/RxJava,some trash (accidentally created),"Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [ ] Please give a description about what and why you are contributing, even if it's trivial.

  - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.
",2017-06-01 19:33:05,2017-06-01 19:33:42,https://api.github.com/repos/ReactiveX/RxJava/issues/5389,[],12,0,ReactiveX_RxJava_pull_5389.diff
ReactiveX/RxJava,2.x: add subscribeOn overload to avoid same-pool deadlock with create,"This PR adds an overload to `subscribeOn` that exposes the existing feature to optionally request on the same scheduler where the subscription happened. This is necessary to avoid same-pool deadlock when the upstream contains `create` logic that blocks the emission thread, preventing any scheduled request to get through and leading to excess buffering or dropping data excessively. By not scheduling the request, it can directly update the emitter's request tracking and let the emitter continue.

Formerly, the existing `subscribeOn` automatically disabled scheduling the requests if the immediate upstream was a `FlowableCreate`. However, if there were operators between `create` and `subscribeOn` (as often happening on Android with composing the schedulers at the end of the chain), the `subscribeOn` operator run in scheduled request mode by default. 

This change allows specifying this behavior through the new overload and thus distance between the `create` and `subscribeOn` operators no longer matters.

(Note that 1.x already has this overload.)",2017-06-01 08:18:38,2017-06-04 13:36:57,https://api.github.com/repos/ReactiveX/RxJava/issues/5386,"['2.x', 'Enhancement']",94,4,ReactiveX_RxJava_pull_5386.diff
ReactiveX/RxJava,Fixed Javadoc for SingleFlatMapIterableObservable.,Fixed Javadoc for `SingleFlatMapIterableObservable`.,2017-05-31 22:56:35,2017-06-01 07:35:01,https://api.github.com/repos/ReactiveX/RxJava/issues/5383,"['2.x', 'Cleanup']",1,1,ReactiveX_RxJava_pull_5383.diff
ReactiveX/RxJava,2.x: add missing null checks on values returned by user functions,"This PR adds null checks to places where it was missing.

In addition, the `XMapNotification` operators now report a composite exception of the original `Throwable` and the error thrown by the function that should return the continuation source.

Also fixed `TestSubscriber`/`TestObserver` not cancelling the sequence if the fused poll crashed.",2017-05-30 10:47:12,2017-06-01 07:35:43,https://api.github.com/repos/ReactiveX/RxJava/issues/5379,"['2.x', 'Bug']",315,31,ReactiveX_RxJava_pull_5379.diff
ReactiveX/RxJava,2.x: make SingleMap not allow map function return null,"Found code like below can works
```
Single.just(""1234"").map(s -> null)
              .subscribe(s -> {
                  System.out.println(s);
              });
```
Because Single#just not allow null, so prevent mapper return null.",2017-05-30 07:14:36,2017-05-30 08:29:48,https://api.github.com/repos/ReactiveX/RxJava/issues/5378,"['2.x', 'Bug']",88,1,ReactiveX_RxJava_pull_5378.diff
ReactiveX/RxJava,2.x: Flowable.combineLatest combiner should not return null,"As per #5376 the combiner should not return null when applied.

* added unit test that failed on original code 
* mentioned constraint in javadoc

I'll look for some others as well.",2017-05-30 07:02:06,2017-05-30 07:29:08,https://api.github.com/repos/ReactiveX/RxJava/issues/5377,[],43,20,ReactiveX_RxJava_pull_5377.diff
ReactiveX/RxJava,2.x: make sure interval+trampoline can be stopped,"This PR fixes the case where a `trampoline` scheduler is used with the `interval` or `intervalRange` operator, the periodic emissions can't be cancelled properly. The synchronous and blocking nature of the periodic schedule is that the `Disposable` is never connected with the downstream and the `interval` stays in a drain-sleep loop per emission indefinitely.

This PR changes the operators to use the `Worker` of a trampoline scheduler that is available before the drain-sleep loop thus a downstream cancellation can stop the loop. Any other ""async"" scheduler will still use the direct periodic scheduling facility.

In addition, the trampoline loop has been fixed to check for the worker `disposed` state in the inner loop.
",2017-05-25 08:38:02,2017-05-28 10:14:37,https://api.github.com/repos/ReactiveX/RxJava/issues/5367,"['2.x', 'Shortcoming']",105,9,ReactiveX_RxJava_pull_5367.diff
ReactiveX/RxJava,1.x,"Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [x] Please give a description about what and why you are contributing, even if it's trivial.

  - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.
",2017-05-19 07:31:36,2017-05-19 07:43:12,https://api.github.com/repos/ReactiveX/RxJava/issues/5357,[],74309,18427,ReactiveX_RxJava_pull_5357.diff
ReactiveX/RxJava,2.x: Fix typo in error message.,"When `BaseTestConsumer` receives fewer items than expected, the error shown has a typo. Replaced *Fever* with *Fewer*.",2017-05-18 14:40:34,2017-05-18 15:01:50,https://api.github.com/repos/ReactiveX/RxJava/issues/5354,"['2.x', 'Cleanup']",1,1,ReactiveX_RxJava_pull_5354.diff
ReactiveX/RxJava,1.x: remove semicolon that Eclipse thinks is compile error,"as per title, gradle build works fine but Eclipse doesn't like it.",2017-05-18 07:33:02,2017-05-18 07:53:35,https://api.github.com/repos/ReactiveX/RxJava/issues/5353,"['1.x', 'Cleanup']",1,1,ReactiveX_RxJava_pull_5353.diff
ReactiveX/RxJava,2.x: update some marbles of Observable,"Update/fix to a couple of marble diagrams in `Observable`:

- `singleOrError`: [reuse existing](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/singleOrError.png)
- `combineLatestDelayError`: [reuse existing](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatestDelayError.png)
- `concatArrayEager`: [new diagram](https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-302041653)
- `erro`r: [new diagrams](https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-302043293)
- `fromFuture`: [new diagrams](https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-302054241)
- `fromIterable`: [new diagram](https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-302054967)",2017-05-17 10:57:01,2017-05-18 07:57:12,https://api.github.com/repos/ReactiveX/RxJava/issues/5351,"['2.x', 'Documentation']",13,9,ReactiveX_RxJava_pull_5351.diff
ReactiveX/RxJava,2.x: Fix Javadoc of FunctionX,fix the mistake for  `FunctionX` javadoc,2017-05-17 06:30:32,2017-05-17 07:20:55,https://api.github.com/repos/ReactiveX/RxJava/issues/5347,"['2.x', 'Documentation']",28,28,ReactiveX_RxJava_pull_5347.diff
ReactiveX/RxJava,2.x: add tryOnError to create/XEmitter API,"This PR adds the `tryOnError` method to the various `Emitter` types used in the `create` operators that allows the developer to avoid the `UndeliverableException` in case a cancellation is racing with the emission of an error. The return value indicates a success of the delivery; in case of `false`, the developer can decide to log/drop the specific error if that makes sense for him/her.",2017-05-16 09:26:32,2017-05-16 18:24:19,https://api.github.com/repos/ReactiveX/RxJava/issues/5344,"['2.x', 'Enhancement']",349,40,ReactiveX_RxJava_pull_5344.diff
ReactiveX/RxJava,Fix Javadoc for Maybe.toSingle,"The Javadoc for the `Maybe.toSingle()` overload that accepts a `defaultValue` incorrectly states that it will convert an empty `Maybe` into a `Single` that signals `NoSuchElementException` (likely copied from the version of `Maybe.toSingle()` that does not accept a default value).

This change updates the Javadoc to indicate that the returned `Single` will emit `defaultValue` if called on an empty `Maybe`.

Relevant existing test: https://github.com/ReactiveX/RxJava/blob/8819cc933e26449751535bc48ba2f10852c9b96d/src/test/java/io/reactivex/maybe/MaybeTest.java#L2730",2017-05-15 20:00:45,2017-05-15 21:38:57,https://api.github.com/repos/ReactiveX/RxJava/issues/5343,[],2,1,ReactiveX_RxJava_pull_5343.diff
ReactiveX/RxJava,Add the cast operator to Single.,"Adding the cast operator to Single.  This exists in the 2.x branch but not in the 1.x branch, so callers have had to do unnatural operations like `.map(SomeClass.class:cast)` to get around this.  Added tests similar to those for Observable.cast. 

Signed-off-by: Mike Burns <burnsm523@gmail.com>",2017-05-04 14:01:01,2017-05-08 21:10:28,https://api.github.com/repos/ReactiveX/RxJava/issues/5332,"['1.x', 'Enhancement']",105,0,ReactiveX_RxJava_pull_5332.diff
ReactiveX/RxJava,Add missing bracket to example code,Difficult to count those with all the java 7 boilerplate!,2017-05-02 03:39:27,2017-05-02 07:30:09,https://api.github.com/repos/ReactiveX/RxJava/issues/5326,[],1,1,ReactiveX_RxJava_pull_5326.diff
ReactiveX/RxJava,Mark VolatileSizeArrayList as RandomAccess list,"This is needed for generic functions to select appropriate algorithm when searching etc.
Details are in RandomAccess interface javadoc.",2017-05-01 11:37:06,2017-05-01 11:54:17,https://api.github.com/repos/ReactiveX/RxJava/issues/5324,"['2.x', 'Enhancement']",1,1,ReactiveX_RxJava_pull_5324.diff
ReactiveX/RxJava,1.x: apply API promotions for 1.3,"This PR applies the API promotions of #5201.

Note that `Single.unsubscribeOn` remainded experimental and `Observable.fromEmitter` was removed.

Where the experimental version was available, it was moved up as `<p>History: 1.x.y - experimental` similar to how 2.x versioning/promotions happen.

Suggested review strategy:

- verify `@Experimental` and `@Beta` annotations are removed from the method and from Javadoc
- verify `@since 1.3` is present",2017-04-27 11:30:53,2017-04-27 15:57:52,https://api.github.com/repos/ReactiveX/RxJava/issues/5318,"['1.x', 'API promotion']",176,376,ReactiveX_RxJava_pull_5318.diff
ReactiveX/RxJava,2.x: improve coverage of some classes (no functional changes),"Improve the coverage of some classes, plus re-add the unit test that validates the `StrictSubscriber`.

Only test changes, no functional changes.",2017-04-21 22:09:44,2017-04-22 08:43:48,https://api.github.com/repos/ReactiveX/RxJava/issues/5310,"['2.x', 'Coverage']",479,1,ReactiveX_RxJava_pull_5310.diff
ReactiveX/RxJava,2.x: Fix Javadoc of Flowable.toObservable,The `Flowable.toObservable()` javadoc was referring to `Publisher` instead of `Observable`.,2017-04-21 20:02:18,2017-04-21 20:19:18,https://api.github.com/repos/ReactiveX/RxJava/issues/5309,"['2.x', 'Documentation']",3,3,ReactiveX_RxJava_pull_5309.diff
ReactiveX/RxJava,2.x: Apply promotions for v2.1,"This PR applies the promotions listed in #5243.

Suggested review strategy:

- Check if the `@Experimental` annotation has been removed or turned into `@Beta`.
- Check if the `<p>History: 2.0.x` matches the original value of the updated `@since 2.0.x`.",2017-04-21 14:44:20,2017-04-21 18:02:26,https://api.github.com/repos/ReactiveX/RxJava/issues/5307,"['2.x', 'API promotion']",141,484,ReactiveX_RxJava_pull_5307.diff
ReactiveX/RxJava,2.x: Change ObservableSource.defer to Observable.defer in Observable.scan() documentation.,- changes `ObservableSource.defer` to `Observable.defer()`,2017-04-21 13:17:03,2017-04-21 13:32:28,https://api.github.com/repos/ReactiveX/RxJava/issues/5306,"['2.x', 'Documentation']",8,8,ReactiveX_RxJava_pull_5306.diff
ReactiveX/RxJava,Correct documented return type of Single#flatMapObservable Function argument,The argument of `Single#flatMapObservable` clearly states that it is expecting a `Function` which returns an `ObservableSource` but the documentation contradicts that.,2017-04-20 20:57:15,2017-04-20 21:11:50,https://api.github.com/repos/ReactiveX/RxJava/issues/5304,"['2.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_5304.diff
ReactiveX/RxJava,2.x: add Single.unsubscribeOn(),"This PR adds the `Single.unsubscribeOn()` operator.

Related: #5300.",2017-04-20 16:29:43,2017-04-20 17:20:53,https://api.github.com/repos/ReactiveX/RxJava/issues/5302,"['2.x', 'Enhancement']",247,1,ReactiveX_RxJava_pull_5302.diff
ReactiveX/RxJava,2.x: more detailed no-multi-subscribe with std consumers error message,"This PR changes the ""Disposable already set!"" and ""Subscription already set!"" messages on the standard consumer classes (`DisposableSubscriber`, `DisposableObserver`, etc.) to something more meaningful:

""It is not allowed to subscribe with a(n) `<class name>` multiple times. Please create a fresh instance of `<class name>` and subscribe that to the target source instead.""

Where `<class name>` is a placeholder for the `getClass().getName()` of the subclass of those consumer types. It should clearly state to avoid subscribing with them multiple times as well as printing the full class name to indicate the problem is with the use of the implementor class, and not with the abstract RxJava class.

Inspired by [this StackOverflow](http://stackoverflow.com/questions/43482263/rxjava2-protocolviolationexception-disposable-already-set) question, one of many such questions.

For the internal operators, the original error message stays because when they appear, that is still likely due to an implementation bug (or a misbehaving user-created custom implementation).",2017-04-20 16:15:21,2017-04-20 21:23:14,https://api.github.com/repos/ReactiveX/RxJava/issues/5301,"['2.x', 'Cleanup']",830,34,ReactiveX_RxJava_pull_5301.diff
ReactiveX/RxJava,Fix JavaDoc image for Single#flatMapObservable,[`Single.flatMapObservable.png`](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMapObservable.png) should be used for `Single#flatMapObservable` instead of [`Single.flatMap.png`](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMap.png).,2017-04-20 01:18:00,2017-04-20 09:09:46,https://api.github.com/repos/ReactiveX/RxJava/issues/5297,"['2.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_5297.diff
ReactiveX/RxJava,Improve doOnDispose JavaDoc,"Sorry for the earlier PR #5295... :/ 

This addresses the JavaDoc issues discussed in #5283.

- Removes the Note in `Observable.doOnDispose` which claims its action would be called on terminal events.
- Slightly adjusts the JavaDocs of the `Maybe`/`Single`/`Completable` variants.
- Adds `@throws` note to some `Observable`/`Single`/`Maybe` `.doOnDispose` as it was present in the `Completable` variant.",2017-04-19 18:34:04,2017-04-19 18:46:24,https://api.github.com/repos/ReactiveX/RxJava/issues/5296,"['2.x', 'Documentation']",10,9,ReactiveX_RxJava_pull_5296.diff
ReactiveX/RxJava,xMr/do on dispose javadoc,"Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [ ] Please give a description about what and why you are contributing, even if it's trivial.

  - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.
",2017-04-19 18:30:06,2017-04-19 18:30:19,https://api.github.com/repos/ReactiveX/RxJava/issues/5295,[],10,9,ReactiveX_RxJava_pull_5295.diff
ReactiveX/RxJava,Friendly dependency for beginner developers.,"Just a small change for 101 developers be able to copy and past, and compile easily without need too much about Gradle.",2017-04-19 09:06:06,2017-04-19 10:33:16,https://api.github.com/repos/ReactiveX/RxJava/issues/5294,[],1,1,ReactiveX_RxJava_pull_5294.diff
ReactiveX/RxJava,2.x: add/remove empty lines in ConnectableObservable and Observable,"**Edit:**

This PR adds a newline to `ConnectableObservable` and removes one excess empty line from `Observable`.",2017-04-17 09:10:11,2017-04-17 10:44:40,https://api.github.com/repos/ReactiveX/RxJava/issues/5288,"['2.x', 'Cleanup']",1,1,ReactiveX_RxJava_pull_5288.diff
ReactiveX/RxJava,2.x: fix Flowable.flatMapMaybe/Single maxConcurrency not requesting more,This PR fixes `Flowable.flatMapMaybe` and `Flowable.flatMapSingle` not replenishing from the upstream when they complete/error per inner source.,2017-04-16 23:34:29,2017-04-17 10:40:42,https://api.github.com/repos/ReactiveX/RxJava/issues/5287,"['2.x', 'Bug']",60,0,ReactiveX_RxJava_pull_5287.diff
ReactiveX/RxJava,2.x: cleanup for text and javadoc 04/15,"This PR 

- fixes a couple of documentation and message copy-paste errors
- fixed FlowableFlattenIterable not checking for null returned by `Iterator::next()`
- replace `publisher` with the appropriate name",2017-04-15 20:12:37,2017-04-15 20:29:03,https://api.github.com/repos/ReactiveX/RxJava/issues/5286,"['2.x', 'Cleanup']",28,28,ReactiveX_RxJava_pull_5286.diff
ReactiveX/RxJava,BoundedReplayBuffer no longer leaks memory,"The Issue: When `BoundedReplayBuffer` evicts an item to make room for a new item it still contains a strong reference to the evicted item.

New Test: This diff adds a new unit test to verify this behavior. Given this unit test needs to look under the hood of `BoundedReplayBuffer` in order to ensure no memory leaks exist, writing this test requires a new package private method.

Change: This diff fixes misbehavior.",2017-04-13 00:06:36,2017-04-13 20:27:34,https://api.github.com/repos/ReactiveX/RxJava/issues/5282,['2.x'],55,32,ReactiveX_RxJava_pull_5282.diff
ReactiveX/RxJava,2.x: BehaviorProcessor & Subject terminate-subscribe race,"This PR fixes the race condition in `BehaviorProcessor` and `BehaviorSubject` when `onComplete()` or `onError()` is called concurrently with `subscribe` and the consumer throws a `NullPointerException` instead of relaying the terminal event.

The fix involves having a separate `terminalEvent` atomic field, CAS-ing in the actual or marker `Throwable` and reading that field in `subscribe`.",2017-04-12 11:31:08,2017-04-12 13:24:43,https://api.github.com/repos/ReactiveX/RxJava/issues/5281,"['2.x', 'Bug']",131,20,ReactiveX_RxJava_pull_5281.diff
ReactiveX/RxJava,2.x: Single.subscribe(BiConsumer) consistent isDisposed,"Fixes the `Single.subscribe(BiConsumer)` to report `isDisposed` when terminating.

Reported in #5276.",2017-04-10 12:24:18,2017-04-10 12:44:37,https://api.github.com/repos/ReactiveX/RxJava/issues/5277,"['2.x', 'Bug']",39,0,ReactiveX_RxJava_pull_5277.diff
ReactiveX/RxJava,"2.x: enable link to external JDK, fix Schedulers style","This PR enables the generated Javadoc to `{@link }` to JDK classes properly (current 2.0.8 doc [shows them](http://reactivex.io/RxJava/2.x/javadoc/2.0.8/io/reactivex/schedulers/Schedulers.html#io()) as plain text). I'm linking to the v7 docs because v6 is ugly.

In addition, I've fixed the style of the `Schedulers` documentation by separating the **Supported system properties** properly into a new paragraph.",2017-04-07 19:03:28,2017-04-07 19:25:58,https://api.github.com/repos/ReactiveX/RxJava/issues/5271,"['2.x', 'Documentation']",5,4,ReactiveX_RxJava_pull_5271.diff
ReactiveX/RxJava,2.x: Remove commented out code in IoScheduler,"Removes some code that was commented out in `IoScheduler`. Those lines were last edited in 2 years ago, so I assume they should be safe to delete.",2017-04-06 17:46:25,2017-04-06 18:21:21,https://api.github.com/repos/ReactiveX/RxJava/issues/5268,"['2.x', 'Cleanup']",0,6,ReactiveX_RxJava_pull_5268.diff
ReactiveX/RxJava,2.x: Fixed broken links in Readme file,"Fixed broken links for @Beta and @Experimental annotations

Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [x] Please give a description about what and why you are contributing, even if it's trivial.

  - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.
",2017-04-03 06:55:39,2017-04-03 07:25:19,https://api.github.com/repos/ReactiveX/RxJava/issues/5262,"['2.x', 'Documentation']",2,2,ReactiveX_RxJava_pull_5262.diff
ReactiveX/RxJava,1.x Use IntelliJ IDE friendly assertion failure message,"The `assertItem` failure message pattern in `TestSubscriber` does not match any of the regex patterns defined by IntelliJ to show `<Click to see difference>` link. 
![before](https://cloud.githubusercontent.com/assets/2339109/24586365/9239290c-179f-11e7-8178-38425448d3a1.jpg)

By changing the ""_expected to be_"" to ""_expected:_"", the pattern is recognised by IntelliJ and the helpful link is presented.
![after](https://cloud.githubusercontent.com/assets/2339109/24586364/9238f414-179f-11e7-9b12-e6b648318550.jpg)

The original idea from #5249 was to use the ""_expected:<> but was:<>_"" pattern used in JUnit, but it is not picked up on its own by IntelliJ. The AssertionError must extend from JUnit's ComparisonFailure, to get it recognised. This however requires dependency on JUnit.
![junit](https://cloud.githubusercontent.com/assets/2339109/24586389/fefd6c38-179f-11e7-8841-884bc07db404.jpg)

So in the end, the fix is just a very simple change in the message.
",2017-04-02 10:33:32,2017-04-02 10:42:11,https://api.github.com/repos/ReactiveX/RxJava/issues/5258,"['1.x', 'Enhancement']",3,3,ReactiveX_RxJava_pull_5258.diff
ReactiveX/RxJava,Remove @NonNull annotations in BiConsumer method parameter,"This PR is part of https://github.com/ReactiveX/RxJava/issues/5216

This PR remove @NonNull annotations from ```BiConsumer``` method parameters, there's no sense use these annotations in ```Single``` context because in this case ```BiConsumer``` always brings you a null parameter.
",2017-04-01 19:46:47,2017-04-02 08:46:56,https://api.github.com/repos/ReactiveX/RxJava/issues/5257,[],1,3,ReactiveX_RxJava_pull_5257.diff
ReactiveX/RxJava,2.x: fix flatMapIterable appearing to be empty when fused,"The wrong logical expression in the `isEmpty()` method made `flatMapIterable` complete earlier, even if data was available in the current iterable.

Somewhat related: https://github.com/reactor/reactor-core/issues/508 (different logical bug in the same method).",2017-04-01 17:38:56,2017-04-01 18:00:20,https://api.github.com/repos/ReactiveX/RxJava/issues/5256,"['2.x', 'Bug']",64,12,ReactiveX_RxJava_pull_5256.diff
ReactiveX/RxJava,Add nullPointerException comments and ObjectHelper test code.,:),2017-04-01 14:57:20,2017-04-01 15:49:27,https://api.github.com/repos/ReactiveX/RxJava/issues/5255,"['2.x', 'Cleanup']",23,1,ReactiveX_RxJava_pull_5255.diff
ReactiveX/RxJava,Add some comments & verifyCountPositive method,,2017-04-01 03:17:36,2017-04-01 07:13:12,https://api.github.com/repos/ReactiveX/RxJava/issues/5253,[],61,19,ReactiveX_RxJava_pull_5253.diff
ReactiveX/RxJava,Add NullPointerException comment for doc,nothing special.,2017-04-01 01:54:17,2017-04-01 03:01:14,https://api.github.com/repos/ReactiveX/RxJava/issues/5252,[],64,19,ReactiveX_RxJava_pull_5252.diff
ReactiveX/RxJava,More nullability annotations,"Added nullability annotations to:
- Disposables
- Observers
and some others",2017-03-31 16:33:37,2017-04-01 19:11:23,https://api.github.com/repos/ReactiveX/RxJava/issues/5251,"['2.x', 'Cleanup']",187,87,ReactiveX_RxJava_pull_5251.diff
ReactiveX/RxJava,Defer creation of the TimeoutException when using the Single.timeout() operator,"Use a defer instead of simply `other = Single.error(new TimeoutException())` since instantiating an exception will cause the current stack trace to be inspected and that overhead should only be incurred when a timeout actually happens.

I caught this problem as I was investigating unusually high CPU usage in one of the systems I operate. When measuring the impact of this change in a real world situation that makes only moderate use of this operator, I observed a *11%* reduction in CPU usage.",2017-03-31 14:43:14,2017-04-02 08:48:07,https://api.github.com/repos/ReactiveX/RxJava/issues/5250,"['1.x', 'Enhancement']",9,1,ReactiveX_RxJava_pull_5250.diff
ReactiveX/RxJava,2.x: fix Flowable.toList() onNext/cancel race,"This PR fixes the `NullPointerException` that can happen because `cancel` nulls out the value and `onNext` simply dereferences that value in `FlowableToList`.

Reported in #5246 .",2017-03-31 11:01:49,2017-03-31 11:16:01,https://api.github.com/repos/ReactiveX/RxJava/issues/5247,"['2.x', 'Bug']",84,2,ReactiveX_RxJava_pull_5247.diff
ReactiveX/RxJava,Remove CheckReturnValue on methods returning Disposable,Per #4878.,2017-03-30 15:03:29,2017-03-31 10:31:32,https://api.github.com/repos/ReactiveX/RxJava/issues/5244,"['2.x', 'Cleanup']",3,27,ReactiveX_RxJava_pull_5244.diff
ReactiveX/RxJava,1.x fix async single error report (bug #5237),"Targets issue #5237 where an `Exception` in `onSuccess` of an async `Single` wasn't forwarded to `onError`. For a sync `Single` it already gets forwarded correctly.

Example:
```java
Single.just(""test"")
        .delay(1, TimeUnit.MILLISECONDS)
        .subscribe(
        result -> {
            System.out.println(""got text: "" + result);
            throw new IllegalStateException(""single async something is wrong"");
            // onError will not be called, hard crash
        },
        e -> {
            // not called
            System.out.println(""caught error "" + e.getMessage());
            e.printStackTrace();
        });
```

I introduced `SafeSingleSubscriber` analog to `SafeSubscriber` of `Observable`. It makes sure `onError` gets called when `onSuccess` throws.

I had to introduce `private Subscription unsafeSubscribe(SingleSubscriber)` for internal usage of `Single#subscribeOn()` and `Single#unsubscribeOn()` which should *not* be wrapped by `SafeSingleSubscriber`.

Furthermore I added the `subscriber.isUnsubscribed()` case in all three `subscribe` methods analog to `Observable#subscribe`
```java
    // ...
    if (subscriber.isUnsubscribed()) {
        RxJavaHooks.onError(RxJavaHooks.onSingleError(e));
    } else {
        // try forwarding error to subscriber
    }
    // ....
```
as well as `Single#subscribe` now throws `OnErrorFailedException` instead of `RuntimeException` when calling `subscriber.onError(e)` fails.

`Single.using` is now working correctly, I uncommented the missing assertions",2017-03-27 21:38:01,2017-04-06 13:21:15,https://api.github.com/repos/ReactiveX/RxJava/issues/5241,['1.x'],631,91,ReactiveX_RxJava_pull_5241.diff
ReactiveX/RxJava,"2.x: fix CallbackCompletableObserver calling onError, ResourceX wording",This PR contains the fix for incorrect call of the `onError` handler within `CallbackCompletableObserver.onComplete()` reported in [5099](https://github.com/ReactiveX/RxJava/issues/5099#issuecomment-289544756) as well as wording fixes to the `ResourceX` javadoc.,2017-03-27 19:09:43,2017-03-27 19:37:01,https://api.github.com/repos/ReactiveX/RxJava/issues/5240,"['2.x', 'Bug', 'Cleanup', 'Documentation']",23,18,ReactiveX_RxJava_pull_5240.diff
ReactiveX/RxJava,Merge pull request #1 from ReactiveX/1.x,"同步

Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [x] Please give a description about what and why you are contributing, even if it's trivial.

  - [x] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [x] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.
",2017-03-27 08:14:50,2017-03-27 08:38:05,https://api.github.com/repos/ReactiveX/RxJava/issues/5236,[],0,0,ReactiveX_RxJava_pull_5236.diff
ReactiveX/RxJava,Add TimeUnit null check test case in Timed,"1. It's about Timed.java test case that is null check TimeUnit parameter.
2. formatting in BasicIntQueueDisposable
3. add testcase blockingIterableNegativeBufferSizeFail for blockingIterable
4. modify BlockingMultiObserver field’s modfier

",2017-03-26 14:25:40,2017-03-26 16:49:40,https://api.github.com/repos/ReactiveX/RxJava/issues/5231,"['2.x', 'Cleanup']",5,0,ReactiveX_RxJava_pull_5231.diff
ReactiveX/RxJava,2.x: Fix wrong comments in Functions.java “Function3” -> “BiFunction”,I'm using this library in my company(KakaoBank in Korea) and interested in this library.. so I read whole code these days. I feel really thanks for all people who make awesome library and I just wanted to contribute this library.  ,2017-03-26 10:38:44,2017-03-26 12:33:23,https://api.github.com/repos/ReactiveX/RxJava/issues/5230,"['2.x', 'Documentation']",57,1,ReactiveX_RxJava_pull_5230.diff
ReactiveX/RxJava,2.x UnicastProcessor fail-fast support,"This PR adds support for fail-fast behavior to `UnicastProcessor` with methods `UnicastProcessor<T> create(boolean delayError)`, `UnicastProcessor<T> create(int capacityHint, Runnable onTerminated, boolean delayError)`. Relates to #5165, #5217 ",2017-03-24 17:13:21,2017-03-24 18:34:24,https://api.github.com/repos/ReactiveX/RxJava/issues/5226,"['2.x', 'Enhancement']",130,20,ReactiveX_RxJava_pull_5226.diff
ReactiveX/RxJava,1.x: fix Completable.onErrorResumeNext unsubscribe not propagated,"The `Completable.onErrorResumeNext` did not properly propagate the downstream `unsubscribe()` call to upstream.

Reported in #5224.",2017-03-24 17:08:03,2017-03-24 19:39:32,https://api.github.com/repos/ReactiveX/RxJava/issues/5225,"['1.x', 'Bug']",64,0,ReactiveX_RxJava_pull_5225.diff
ReactiveX/RxJava,2.x: improve the documentation of Schedulers utility class.,"This PR improves the javadoc of the `io.reactivex.schedulers.Schedulers` utility class plus adds a missing `SchedulerSupport` constant for the `single()` scheduler.

Let me know if something needs further explanation (or some new case needs explanation).

Related: #5145.",2017-03-24 15:44:10,2017-03-24 17:49:55,https://api.github.com/repos/ReactiveX/RxJava/issues/5223,"['2.x', 'Documentation']",196,18,ReactiveX_RxJava_pull_5223.diff
ReactiveX/RxJava,2.x: cleanup based on IntelliJ 2017.1 inspections,"This PR is the result of running IntelliJ inspections on the code:

  - replace `unsubscribe` with `cancel` and `dispose` in the main classes to better match the 2.x terminology
  - write out a couple of local variables
  - remove unnecessary `return` and `continue` statements
  - remove unnecessary variable writes
  - remove unnecessary and unused fields
  - add `final` to some fields
  - fix typos ",2017-03-24 14:22:26,2017-03-24 18:06:57,https://api.github.com/repos/ReactiveX/RxJava/issues/5222,"['2.x', 'Cleanup']",223,279,ReactiveX_RxJava_pull_5222.diff
ReactiveX/RxJava,2.x: safeguard against building with v1 tags,"This PR adds the same version guard that 1.x has: stop the build when the version tag doesn't start with ""v2."" to prevent releasing a 2.x version under the 1.x numbering.

This almost happened with today's botched 1.2.8 release where I forgot to set the target tag to 1.x, but noticed the mistake and stopped the build.

Since tags can't be deleted or retargeted, the fix can't prevent the wrong target tag mistake on itself. A small workaround is to mark bad tagged releases as pre-release.

Either way, the 2.x snapshots have a fixed `2.0.0-DP0-SNAPSHOT` and don't draw a custom version number from the latest release tag on their branch, unlike 1.x.",2017-03-24 09:33:51,2017-03-24 10:07:16,https://api.github.com/repos/ReactiveX/RxJava/issues/5219,"['2.x', 'Build']",7,0,ReactiveX_RxJava_pull_5219.diff
ReactiveX/RxJava,[2.x] UnicastSubject fail fast support,"This PR adds support for fail-fast behavior to `UnicastSubject` with methods `UnicastSubject<T> create(boolean delayError)`, `UnicastSubject<T> create(int capacityHint, Runnable onTerminated, boolean delayError)`.  Relates to #5165
",2017-03-23 14:54:43,2017-03-23 16:51:29,https://api.github.com/repos/ReactiveX/RxJava/issues/5217,"['2.x', 'Enhancement']",200,30,ReactiveX_RxJava_pull_5217.diff
ReactiveX/RxJava,2.x: fix window() with time+size emission problems,"The `window()` operator overload with time and size bound didn't work correctly when some windows were terminated by the timeout and others by the size. This PR fixes:

  - the case when the operator restarts the time windows when the size bound is reached,
  - leaking of the worker,
  - the item counter not reset to zero when the time bound is reached,
  - periodic window bound stopped working after the first window.

Related #5104 (again).",2017-03-22 12:09:38,2017-03-22 19:54:35,https://api.github.com/repos/ReactiveX/RxJava/issues/5213,"['2.x', 'Bug']",233,15,ReactiveX_RxJava_pull_5213.diff
ReactiveX/RxJava,1.x: add link rel=canonical to 1.x javadoc files (semi auto),"This PR adds `<link rel=""canonical"" href=""...""/>` nodes to the 1.x javadoc via the following program:

https://github.com/akarnokd/akarnokd-misc/blob/master/src/main/java/hu/akarnokd/rxjava/javadoc/AddCanonical.java

How to use it:
- Within a Java 8 project, replace the file directories that point to your checked-out `gh-pages` branch.
- Unpack the rxjava-1.2.x-javadoc.jar into the two places
- Run `AddCanonical`
- Push a PR with the changes.",2017-03-22 10:24:44,2017-03-22 11:36:57,https://api.github.com/repos/ReactiveX/RxJava/issues/5212,"['1.x', 'Documentation']",142,142,ReactiveX_RxJava_pull_5212.diff
ReactiveX/RxJava,2.x: better documentation on the abstract consumer classes,"This PR improves the documentation of the abstract consumer classes such as `DisposableSubscriber`, `ResourceSubscriber` and their counterparts for the other base reactive types.

It contains a lot of copy-paste so please read through all of the text in case the text was not properly adapted to the abstract class at hand.

Related: #5148.",2017-03-21 13:41:25,2017-03-21 21:43:12,https://api.github.com/repos/ReactiveX/RxJava/issues/5210,"['2.x', 'Documentation']",529,15,ReactiveX_RxJava_pull_5210.diff
ReactiveX/RxJava,"1.x: add marble diagram to UnicastSubject, fix javadoc","This PR fixes a missing javadoc entry for `<T>` in `UnicastSubject` and adds a marble diagram to the class itself:

![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/UnicastSubject.v1.png)",2017-03-21 10:25:56,2017-03-21 22:14:02,https://api.github.com/repos/ReactiveX/RxJava/issues/5209,"['1.x', 'Documentation']",3,1,ReactiveX_RxJava_pull_5209.diff
ReactiveX/RxJava,"2.x: fix images of firstElement, flattenAsX, flatMapIterable",This PR links in the new images from #5130 for previously misleading marble diagrams of the operators.,2017-03-21 09:50:51,2017-03-21 13:59:00,https://api.github.com/repos/ReactiveX/RxJava/issues/5208,"['2.x', 'Documentation']",18,14,ReactiveX_RxJava_pull_5208.diff
ReactiveX/RxJava,2.x: prevent tasks to self interrupt on the standard schedulers,"Task wrappers of the various schedulers and modes (direct & worker) were able to get cancelled via interruption from the same thread they were running.

Related #5203.",2017-03-20 19:32:55,2017-03-22 12:51:57,https://api.github.com/repos/ReactiveX/RxJava/issues/5207,"['2.x', 'Bug']",924,41,ReactiveX_RxJava_pull_5207.diff
ReactiveX/RxJava,2.x: fix timer() to prevent a self-interrupt when signals its only value,"When the `timer()` is firing its `onNext(0L)`, there is no point in allowing a canellation to bubble up to the current `Future` as it just interrupts the current thread. The fix thus makes sure the cancellation chain is cut off before `onNext` and the current parent `Future` should complete normally.

Related: #5203.",2017-03-20 17:05:12,2017-03-20 17:35:02,https://api.github.com/repos/ReactiveX/RxJava/issues/5205,"['2.x', 'Bug']",38,2,ReactiveX_RxJava_pull_5205.diff
ReactiveX/RxJava,"2.x: add resilient versions of parallel map(), filter() & doOnNext()","This PR adds 2 new overloads to `ParallelFlowable` operators `map`, `filter` and `doOnNext` to enable per item error handling in case the main function fails with some exception.

```java
Flowable.range(0, 2)
.parallel(1)
.map(v -> 1 / v, ParallelFailureHandling.SKIP)
.sequential()
.test()
.assertResult(1);
```

The new `ParallelFailureHandling` has some default enumeration values to handle the common cases. In addition, the `BiFunction` overload allows bounded retries and/or conditional handling of failures.


Related: #5128.",2017-03-20 14:25:04,2017-03-23 17:27:59,https://api.github.com/repos/ReactiveX/RxJava/issues/5202,"['2.x', 'Enhancement']",2173,1,ReactiveX_RxJava_pull_5202.diff
ReactiveX/RxJava,2.x: increase timeout on parallel & completable tests,"This PR increases the timeout on `CompletableTest` test methods and on `ParallelFlowableTest.parallelismAndPrefetchAsync`.

Related: #5154, #5179.",2017-03-20 09:10:46,2017-03-20 10:28:13,https://api.github.com/repos/ReactiveX/RxJava/issues/5199,"['2.x', 'Test-Failures']",191,190,ReactiveX_RxJava_pull_5199.diff
ReactiveX/RxJava,"2.x: add ParallelTransformer interface, params-validation","This PR adds the `ParallelTransformer` interface to match the other `XTransformer` interfaces, adds `@NonNull` annotations to the `ParallelFlowable` operators and adds the `ParallelFlowable` class to the parameter validator test set.",2017-03-19 23:34:22,2017-03-20 08:56:04,https://api.github.com/repos/ReactiveX/RxJava/issues/5197,"['2.x', 'Cleanup']",102,51,ReactiveX_RxJava_pull_5197.diff
ReactiveX/RxJava,2.x: Add a few more @Nullable & @NonNull annotations to public interfaces,"- adds the @Nullable & @NonNull annotations to
  - Emitters
  - Observer
  - OnSubscribe
  - Operator
  - Source
  - Transformer

for Observable, Maybe, Single, Completable & Flowable.",2017-03-19 12:22:30,2017-03-19 15:17:52,https://api.github.com/repos/ReactiveX/RxJava/issues/5196,[],101,46,ReactiveX_RxJava_pull_5196.diff
ReactiveX/RxJava,1.X: UnicastSubject fail-fast and delay-error behavior,"This PR adds support for delay-error behavior to `UnicastSubject` with methods `UnicastSubject<T> create(boolean delayError)`, `UnicastSubject<T> create(int capacityHint, Action0 onTerminated, boolean delayError)`. Behavior of existing factory methods was not changed, and is fail-fast.

Relates to #5165 
",2017-03-18 16:01:17,2017-03-18 16:47:15,https://api.github.com/repos/ReactiveX/RxJava/issues/5195,"['1.x', 'Enhancement']",153,10,ReactiveX_RxJava_pull_5195.diff
ReactiveX/RxJava,Correct java doc for refCount() return type. v2.0.7,"Java doc for `ConnectableObservable.refCount()` says  it returns a `Flowable`, but it should be `Observable`",2017-03-16 16:13:03,2017-03-16 17:19:01,https://api.github.com/repos/ReactiveX/RxJava/issues/5191,"['2.x', 'Cleanup', 'Documentation']",1,1,ReactiveX_RxJava_pull_5191.diff
ReactiveX/RxJava,2.x: fix concatMapEager should accept 0 for prefetch,"Fixes a bug that  Flowable.concatMapEager(mapper , maxConcurrency , prefetch) and Observable.concatMapEager(mapper , maxConcurrency , prefetch) operators will not accept 0 and negative numbers.

Reported in #5185.",2017-03-15 16:01:25,2017-03-15 19:16:13,https://api.github.com/repos/ReactiveX/RxJava/issues/5189,[],6,6,ReactiveX_RxJava_pull_5189.diff
ReactiveX/RxJava,2.x: fix flatMap emitting the terminal exception indicator on cancel,"This PR fixes the case when `Flowable.flatMap` and `Observable.flatMap` would emit the `ExceptionHelper.TERMINTED` indicator exception to downstream due to emission-cancellation race.

Reported on [StackOverflow](http://stackoverflow.com/questions/42580195/what-is-the-meaning-of-no-further-exceptions).",2017-03-15 15:20:02,2017-03-16 08:26:14,https://api.github.com/repos/ReactiveX/RxJava/issues/5188,"['2.x', 'Bug']",166,11,ReactiveX_RxJava_pull_5188.diff
ReactiveX/RxJava,2.x: reflection-based parameter validator & fixes,This PR adds a reflection-based parameter validator to check the base reactive classes for proper parameter validation: null checks and argument ranges. The problems detected are fixed as well.,2017-03-15 14:28:18,2017-03-15 16:37:37,https://api.github.com/repos/ReactiveX/RxJava/issues/5187,"['2.x', 'Bug', 'Cleanup']",1374,14,ReactiveX_RxJava_pull_5187.diff
ReactiveX/RxJava,2.x: add offer() method to Publish & Behavior Processors,"This PR adds the `boolean offer(T item)` method to `PublishProcessor` and `BehaviorProcessor` to prevent `MissingBackpressureException` when one of the `Subscriber`s is not ready to receive element by indicating a false return value. The sender can then retry the offer with any wait strategy it choses.

In addition, this PR adds Reactive-Streams Publisher TCK checks to verify `AsyncProcessor`, `BehaviorProcessor`, `PublishProcessor`, `ReplayProcessor` and `UnicastProcessor` as being `Publisher`s. Unfortunately, the TCK can't verify them as `Processor's because the TCK has certain expectations about how a `Processor` should behave (namely: expects fail-fast, refCount-like nature).",2017-03-14 13:37:01,2017-03-16 08:39:41,https://api.github.com/repos/ReactiveX/RxJava/issues/5184,"['2.x', 'Enhancement']",602,2,ReactiveX_RxJava_pull_5184.diff
ReactiveX/RxJava,2.x: test to disallow anonymous inner classes,"This PR adds an unit test that scans the compiled .class files for anonymous inner classes naming (i.e., dollar sign followed by a number). Since all the main, test and perf classes end up in the same place, the test has exceptions for file names containing `Perf` or `Test`.

The PR also fixes a few Checkstyle warnings from #5177 and fixes a couple classes from tests that don't have the word `Test` in their name and thus were detected.",2017-03-14 09:53:03,2017-03-14 11:58:20,https://api.github.com/repos/ReactiveX/RxJava/issues/5183,"['2.x', 'Cleanup']",402,229,ReactiveX_RxJava_pull_5183.diff
ReactiveX/RxJava,2.x: fix replay().refCount() leaking items between connections,"This PR updates `Observable.replay()` and `Flowable.replay()` **for 2.x** to not leak items between reconnections when run with `.refCount()`. The `replay()` operator is designed to hold onto the buffer even after its completion so late subscribers can still receive the cached data. Only a new `connect()` clears this data which may or may not happen. Since `refCount` ensures that there won't be any latecommers to an already completed connection (because it also drops its current subscribers on termination or when reaching zero), the `replay()` can be reset to an empty state.

Related: #5172, #5181.",2017-03-13 23:02:59,2017-03-14 08:57:08,https://api.github.com/repos/ReactiveX/RxJava/issues/5182,"['2.x', 'Bug']",343,3,ReactiveX_RxJava_pull_5182.diff
ReactiveX/RxJava,1.x: replay().refCount() avoid leaking items between connections,"This PR updates `replay()` to not leak items between reconnections when run with `.refCount()`. The `replay()` operator is designed to hold onto the buffer even after its completion so late subscribers can still receive the cached data. Only a new `connect()` clears this data which may or may not happen. Since `refCount` ensures that there won't be any latecommers to an already completed connection (because it also drops its current subscribers on termination or when reaching zero), the `replay()` can be reset to an empty state.

Reported in #5172 
",2017-03-13 21:54:55,2017-03-15 16:31:09,https://api.github.com/repos/ReactiveX/RxJava/issues/5181,"['1.x', 'Bug']",177,1,ReactiveX_RxJava_pull_5181.diff
ReactiveX/RxJava,Removes all anonymous inner classes,"This is a what left to complete [this one](https://github.com/ReactiveX/RxJava/pull/5174) :

  - Removes all AICs

  - Issue [#5150](https://github.com/ReactiveX/RxJava/issues/5150)
",2017-03-12 01:56:45,2017-03-12 11:32:29,https://api.github.com/repos/ReactiveX/RxJava/issues/5177,"['2.x', 'Cleanup']",500,328,ReactiveX_RxJava_pull_5177.diff
ReactiveX/RxJava,"2.x: fix private field access, few generics problems","This PR fixes some private field accessor problems introduced by #5174 as well as a couple of generics warnings.

Note that in IntelliJ, there is a J2ME inspection for private access checks between parent and inner classes.",2017-03-11 22:16:41,2017-03-11 22:40:03,https://api.github.com/repos/ReactiveX/RxJava/issues/5176,"['2.x', 'Cleanup']",19,19,ReactiveX_RxJava_pull_5176.diff
ReactiveX/RxJava,2.x: WIP removes anonymous inner classes.,"This is a WIP. Since the changes are big, an incremental review and PR was recommended by @akarnokd 

 - Removes them  from flowable/observable/operators.
- Issue [#5150](https://github.com/ReactiveX/RxJava/issues/5150)",2017-03-11 16:09:20,2017-03-11 21:48:01,https://api.github.com/repos/ReactiveX/RxJava/issues/5174,"['2.x', 'Cleanup']",2033,1366,ReactiveX_RxJava_pull_5174.diff
ReactiveX/RxJava,2.x: fix LambdaObserver not cancelling the upstream,"The `LambdaObserver` didn't cancel the upstream when its `onSubscribe` and `onNext` callbacks crashed. Also reported on the mailing list:

> Dave Smith: When I am using an operator in Observable that calls subscribe (forEach as a example) and the onNext function throws an Exception the underlying class (LambdaObserver) marks the subscription disposed but does not notify upstream that is is disposed. What is the reason for this?

The `LambdaSubscriber` was working correctly. Both received unit tests to ensure the correct behavior.",2017-03-10 08:41:49,2017-03-10 17:22:23,https://api.github.com/repos/ReactiveX/RxJava/issues/5170,"['2.x', 'Bug']",139,13,ReactiveX_RxJava_pull_5170.diff
ReactiveX/RxJava,2.x: Single.subscribe() to report isDisposed() true on success/error,"The `ConsumerSingleObserver` didn't report `isDisposed` consistently with its state.

Reported in #5160.",2017-03-08 10:27:07,2017-03-08 17:05:18,https://api.github.com/repos/ReactiveX/RxJava/issues/5163,"['2.x', 'Bug']",12,0,ReactiveX_RxJava_pull_5163.diff
ReactiveX/RxJava,2.x: add Observable.switchMapSingle and switchMapSingleDelayError,"This is a new operator discussed in #4853. The issue refers to a goodly number of new operators which I'll do bit by bit as my time allows and to ensure review is not too daunting.
",2017-03-08 09:48:32,2017-03-09 08:48:38,https://api.github.com/repos/ReactiveX/RxJava/issues/5161,"['2.x', 'Enhancement']",172,1,ReactiveX_RxJava_pull_5161.diff
ReactiveX/RxJava,2.x: Remove anonymous inner classes,"This PR removes anonymous inner classes.

Related #5150.",2017-03-08 08:24:20,2017-03-09 08:48:11,https://api.github.com/repos/ReactiveX/RxJava/issues/5159,"['2.x', 'Cleanup']",2482,1698,ReactiveX_RxJava_pull_5159.diff
ReactiveX/RxJava,Add @NonNull to the methods of Emitter,"This PR is a part of #4876 

This PR adds `@NonNull` annotation to some methods of `Emitter` so that the users of RxJava migrating from 1.x to 2.x can easily know passing null to the methods will cause NPE.",2017-03-05 15:47:16,2017-03-05 16:59:21,https://api.github.com/repos/ReactiveX/RxJava/issues/5156,"['2.x', 'Enhancement']",4,2,ReactiveX_RxJava_pull_5156.diff
ReactiveX/RxJava,2.x: improve BaseTestConsumer with awaitCount & timeout,"This PR enhances the timeout detection and reporting of the `TestSubscriber`/`TestObserver` base class `BaseTestConsumer`:

   - `awaitCount(int atLeast [, Runnable waitStrategy [, timeout]])`: wait until at least the given amount of onNext events have been observed or the upstream terminated.
  - Enhance `awaitX` methods to set a `timeout` flag.
  - Show the `timeout!` string in the assertion failures set by the `awaitX` methods.
  - Show the `disposed!` string in the assertion failures if the consumer has been cancelled/disposed.
  - `assertTimeout` and `assertNoTimeout` to assert explicitly after an `awaitX` method.
  - `isTimeout` and `clearTimeout` to check and clear the flag status.

In addition, the internal array that collects the items has been replaced with a new custom `List` implementation: `VolatileSizeArrayList` that makes sure `size()` is a volatile read and happens before the committing the size in another thread due to `add()`. (In theory, one shouldn't cast `values()` unconditionally to `ArrayList` anyway.)",2017-03-04 16:44:30,2017-03-07 08:33:43,https://api.github.com/repos/ReactiveX/RxJava/issues/5155,"['2.x', 'Enhancement', 'Test']",714,7,ReactiveX_RxJava_pull_5155.diff
ReactiveX/RxJava,2.x: Java 9 compatibility fixes (March 3),"Java 9 has changed its overload resolution algorithm and things that resolved unambiguously in Java 8 no longer resolve:

```java
Flowable<? extends T> source = ...

source.subscribe(new FlowableSubscriber<T>() { ... });
```

With the code above, javac 8, Eclipse and IntelliJ 2017 EAP picks `Flowable.subscribe(FlowableSubscriber<? super T> s)` as expected. However, javac 9 finds it ambiguous with `Flowable.subscribe(Subscriber<? super T> s)` despite IntelliJ 2017 EAP not indicating any error and still jumping to the right method via CTRL+Click.

The problem may come from the `? extends T` part of the declaration. Having just `Flowable<T>` compiles properly with javac9.

Luckily, we don't need `? extends T` and this PR changes the internal signatures of the affected components.",2017-03-03 22:19:35,2017-03-03 22:57:37,https://api.github.com/repos/ReactiveX/RxJava/issues/5153,"['2.x', 'Cleanup']",8,8,ReactiveX_RxJava_pull_5153.diff
ReactiveX/RxJava,Add missing @CheckReturnValue,"Hi,

The method was not annotated with @CheckReturnValue.

Lucas",2017-02-28 05:03:19,2017-02-28 08:11:25,https://api.github.com/repos/ReactiveX/RxJava/issues/5147,[],1,0,ReactiveX_RxJava_pull_5147.diff
ReactiveX/RxJava,1.x: add unsubscribeOn to Single type (#5138),"resolve #5138 

add unsubscribeOn to Single type.",2017-02-28 03:05:09,2017-03-12 11:53:47,https://api.github.com/repos/ReactiveX/RxJava/issues/5146,"['1.x', 'Enhancement']",106,0,ReactiveX_RxJava_pull_5146.diff
ReactiveX/RxJava,1.x: fix timed replay() not terminating when all items timeout,"The timed `replay()` operator didn't terminate a late subscriber if all the items timed out in the meantime.

Related: #5139.",2017-02-27 18:16:10,2017-02-27 18:25:54,https://api.github.com/repos/ReactiveX/RxJava/issues/5141,"['1.x', 'Bug']",46,3,ReactiveX_RxJava_pull_5141.diff
ReactiveX/RxJava,2.x: fix timed replay-like components replaying outdated items,"The timed versions of `Flowable.replay()`, `ReplayProcessor`, `Observable.replay()` and `ReplaySubject` all replay outdated items to new subscribers and through the `getValues()` and `size()` state-peeking methods, similar to issue #3917 resolved via #4023.

The fix includes a node-walk for new subscribers that skips old entries. Some unit tests weren't logically considering the emission pattern (i.e., items timed out shouldn't appear) and have been fixed as well.

Reported in #5139.",2017-02-27 14:38:06,2017-02-27 17:10:17,https://api.github.com/repos/ReactiveX/RxJava/issues/5140,"['2.x', 'Bug']",188,50,ReactiveX_RxJava_pull_5140.diff
ReactiveX/RxJava,2.x: add TestSubscriber.withTag,"This PR adds the method `withTag` to the `TestBaseConsumer` that allows setting a textual tag which is then appended to the assertion failure's message:

```
Failure message (latch = 1, values = 0, errors = 0, completions = 0, tag = x: 5, y: 7)
```

Use case, for example, is to add the parameters of the current flow to help identify what settings caused the failure. This comes up with unit tests that have some form of (nested) loop(s) to verify multiple parameter ranges. (It is often much easier than trying to work out JUnit rules and such.) ",2017-02-25 21:13:03,2017-02-27 16:45:21,https://api.github.com/repos/ReactiveX/RxJava/issues/5137,"['2.x', 'Enhancement', 'Test']",57,0,ReactiveX_RxJava_pull_5137.diff
ReactiveX/RxJava,2.x: fix repeatWhen and retryWhen signatures,"Adjust the `repeatWhen` and `retryWhen` signatures to accept `Publisher<?>` on `Single` and `Completable`, matching `Flowable`'s signature.

Reported in #5135.",2017-02-25 10:27:53,2017-02-25 20:48:22,https://api.github.com/repos/ReactiveX/RxJava/issues/5136,"['2.x', 'Bug']",28,28,ReactiveX_RxJava_pull_5136.diff
ReactiveX/RxJava,2.x: fix flatMap not cancelling the upstream eagerly,"This PR fixes the lack of eager cancellation when flatmapping sources and not stopping the upstream if the inner source fails.

Unit tests were added to verify `Single` (in case it receives a dedicated implementation one day as currently it delegates to `Flowable`), `Flowable` and `Observable`.

Reported in #5132.",2017-02-24 09:39:26,2017-02-24 14:40:06,https://api.github.com/repos/ReactiveX/RxJava/issues/5133,"['2.x', 'Bug']",87,11,ReactiveX_RxJava_pull_5133.diff
ReactiveX/RxJava,2.x: update javadoc of flatMap() overloads,"This PR rewords the Javadoc of `Flowable.flatMap()` overloads to correctly express their behavior regarding backpressure towards their upstream. In 2.x, only `merge()` operators are unbounded-in by default, `flatMap`s are by default bounded by `bufferSize()` or the `maxConcurrency` parameter.

In addition, one of the `flatMap` overload still had `resultSelector` instead of the common `combiner` parameter name. As far as I know, there are no language-specific libraries targeting 2.x yet where in the language the actual parameter names are also part of the signature and changing them counts as an incompatible change.

Related #5126. ",2017-02-22 09:11:35,2017-02-22 17:11:55,https://api.github.com/repos/ReactiveX/RxJava/issues/5127,"['2.x', 'Documentation']",61,42,ReactiveX_RxJava_pull_5127.diff
ReactiveX/RxJava,1.x: reduce stack depth with switchIfEmpty,"Stack depths may get deep if `switchIfEmpty` has to switch to the alternative source at the end of an already long chain leading to the `onCompleted`. Using multiple `switchIfEmpty` amplifies the impact on the stack depth. 

This PR introduces trampolined subscribing to both sources (similar to how `concat` works), thus given synchronous sources, the stack depth rewinds to the level it was when the `switchIfEmpty` was subscribed to. In addition, to reduce the depth even further, the operator has been turned into an `OnSubscribe`-based implementation to avoid the extra depth due to `lift`.

Related: [rxjava StackOverflowError exception in long chain
](http://stackoverflow.com/questions/42363452/rxjava-stackoverflowerror-exception-in-long-chain)",2017-02-21 14:04:27,2017-02-21 16:45:19,https://api.github.com/repos/ReactiveX/RxJava/issues/5125,"['1.x', 'Shortcoming']",69,14,ReactiveX_RxJava_pull_5125.diff
ReactiveX/RxJava,1.x: throttleFirst detecting clock-drift backwards to open the gate,"If the current time moves backwards before the time the gate was closed, the opening of the gate would happen way later. Since we don't know how much relative time has passed, this fix opens the gate when the drift is detected during `onNext`.

Reported in #5120.

/cc @davidmoten as you've been experimenting with time-only (that is non-scheduled) gating.",2017-02-20 09:44:06,2017-02-22 09:59:44,https://api.github.com/repos/ReactiveX/RxJava/issues/5123,"['1.x', 'Bug']",29,13,ReactiveX_RxJava_pull_5123.diff
ReactiveX/RxJava,2.x: fix Observable.zip to dispose eagerly,"This PR fixes `Observable.zip` to dispose the sources outside the serialization loop, just like `Flowable.zip` does. This allows cancellation even if the serialization loop is busy/blocking inside an `onNext` emission.

In addition, a unit test was added to `Observable.zip` as well.

Reported in #5111.",2017-02-20 01:37:54,2017-02-20 08:30:43,https://api.github.com/repos/ReactiveX/RxJava/issues/5121,"['2.x', 'Bug']",54,8,ReactiveX_RxJava_pull_5121.diff
ReactiveX/RxJava,"2.x: improve coverage, remove unused code","This PR adds coverage to some low-coverage classes and removes unused code. 

In addition, the `XFlatMapTest` now retries each test up to 3 times with exponential backoff since they are the most sensitive to Travis CI fluctuations.",2017-02-19 18:45:21,2017-02-20 08:44:21,https://api.github.com/repos/ReactiveX/RxJava/issues/5119,"['2.x', 'Cleanup']",1122,841,ReactiveX_RxJava_pull_5119.diff
ReactiveX/RxJava,2.x: add ParallelFlowable.sequentialDelayError,"This PR adds the `sequentialDelayError` operator to `ParallelFlowable` that allows awaiting all 'rails' in a parallel flow to terminate normally or with the (composite) exception of the failed rail(s).

To enable this, the `Flowable.parallel()` operator's behavior regarding rail cancellation had to be changed. In v2.0.5 if any of the rails cancelled (maybe due to a failure, maybe due to an end consumer cancelling the entire parallel flow) the input `Flowable` was cancelled. 

This PR alters this by requiring all rails to cancel before cancelling the input `Flowable`. The change permits one or multiple rails to fail and let others progress in case the new `sequentialDelayError` is applied as a terminal operator. The original `sequential()` operator still cancels all rails if one of them fails (triggering the cancellation of the input `Flowable`).

Note that this change may still drop and never process elements in the internal queues of the operators in the parallel flow (because the parallel processing is not implemented with work-stealing that could pick up elements from a dead queue). In order to get as many elements processed as possible, it is recommended to reduce the default prefetch on the `runOn` operator to a reasonable tradeoff value (between throughput and fault tolerance).

**Edit**

Updated the PR to make sure `parallel()` ignores cancelled rails when it dispatches items.

Related: #5108.",2017-02-18 22:56:57,2017-02-21 16:27:48,https://api.github.com/repos/ReactiveX/RxJava/issues/5117,"['2.x', 'Enhancement']",567,58,ReactiveX_RxJava_pull_5117.diff
ReactiveX/RxJava,2.x: benchmark the new strict/interop mode,"Benchmark the overhead of the strict/interop mode.

i5 6440HQ, Windows 10 x64, Java 8u121

![image](https://cloud.githubusercontent.com/assets/1269832/23092637/ce9f343c-f5cf-11e6-868b-e24ff6fc2b43.png)

The numbers are consistent with my expectations; this mobile processor is roughly equivalent to i7 4770 desktop where the cost model is: 1 atomic increment per item equals to roughly 130 Mops/s upper limit, 2 atomic increment per item is roughly 60 Mops/s upper limit. Since the interop mode requires at minimum two atomic increments, 54 Mops/s is a reasonable value to get.",2017-02-18 10:52:03,2017-02-18 19:59:22,https://api.github.com/repos/ReactiveX/RxJava/issues/5115,"['2.x', 'Performance']",181,0,ReactiveX_RxJava_pull_5115.diff
ReactiveX/RxJava,2.x: fix Observable.combineLatest to dispose eagerly,"This PR fixes `Observable.combineLatest` to dispose the sources outside the serialization loop, just like `Flowable.combineLatest` does. This allows cancellation even if the serialization loop is busy/blocking inside an `onNext` emission.

In addition, a unit test was added to `Flowable.combineLatest` as well.

Reported in #5111.",2017-02-18 10:16:55,2017-02-18 20:22:07,https://api.github.com/repos/ReactiveX/RxJava/issues/5114,"['2.x', 'Bug']",73,2,ReactiveX_RxJava_pull_5114.diff
ReactiveX/RxJava,2.x: Flowable as a Publisher to be fully RS compliant,"This PR performs the changes suggested in #5110.

 - Introduce `FlowableSubscriber` with extra textual specification on its relaxed nature
 - `Flowable.subscribe(Subscriber)` checks for `FlowableSubscriber` and if not found, it wraps the incoming RS `Subscriber` into a `StrictSubscriber` that follows the RS spec to the letter at any cost.
 - Introduce `Flowable.subscribe(FlowableSubscribe)` that most internal operators will use
 - Change `AbstractFlowableWithUpstream` to accept `Flowable` as a source, update operators
 - Some operators were useful with raw `Publisher` input, these were duplicated on their outer containing type but use the same internal `FlowableSubscriber`
 - Removed ""cheat"" from the TCK tests, adjusted timeout on `delay`
 - Replaced most `implements Subscriber` with `implements FlowableSubscriber`
 - Replaced most `new Subscriber` with `new FlowableSubscriber` in tests, the rest is required for testing the strictness itself.
 - `strict()` is now an identity operator with suggested scheduled removal.

Performance impact estimation

- Most primary use of a `Flowable` should go through `subscribe(FlowableSubscribe)` and thus no overhead change.
- Where the API mandated `Publisher` as input, providing a `Flowable` will have an `instanceof` check at subscription time and routed to `subscribe(FlowableSubscriber) if the consumer is part of RxJava 2 itself.",2017-02-18 01:22:13,2017-02-18 09:02:48,https://api.github.com/repos/ReactiveX/RxJava/issues/5112,"['2.x', 'Discussion']",1702,734,ReactiveX_RxJava_pull_5112.diff
ReactiveX/RxJava,"2.x: fix window(time, size) not completing windows on timeout","This PR fixes the operators `Flowable.window(time, size)` and `Observable.window(time, size)` to complete the current window if the time elapses before the size limit is reached.

Reported in #5104.",2017-02-17 10:46:18,2017-02-17 17:56:17,https://api.github.com/repos/ReactiveX/RxJava/issues/5106,"['2.x', 'Bug']",40,0,ReactiveX_RxJava_pull_5106.diff
ReactiveX/RxJava,2.x: fix doOnSubscribe signalling Undeliv.Exception instead of just onError,"This PR fixes the issue reported on [StackOverflow](http://stackoverflow.com/questions/42279543/exception-is-not-propagated-to-onerror-when-thrown-from-doonsubscribe) where crashing the lambda in `Flowable.doOnSubscribe` calls the `RxJavaPlugins.onError`, which crashes the app and prevents calling the `EmptySubscription.error` on Android. (Desktop prints to the console and delivers the error normally.)

The bug was present in the `Flowable`, `Observable` and `Completable`. All 5 base types received the respective unit test to ensure correct behavior.",2017-02-16 21:54:43,2017-02-16 22:31:04,https://api.github.com/repos/ReactiveX/RxJava/issues/5103,"['2.x', 'Bug']",272,70,ReactiveX_RxJava_pull_5103.diff
ReactiveX/RxJava,2.x: Added missing @NonNull attribute to Function7.,"This Pull Request adds the missing @NonNull attribute to Function7. On Pull Request #5023, Function7 was missing from the updates.",2017-02-16 21:26:11,2017-02-16 21:56:13,https://api.github.com/repos/ReactiveX/RxJava/issues/5102,"['2.x', 'Cleanup']",4,1,ReactiveX_RxJava_pull_5102.diff
ReactiveX/RxJava,"2.x: fix Maybe.concat() subscribe-after-cancel, verify others","This PR fixes `Maybe.concatX` subscribing to the next source when the downstream cancelled the `Flowable` sequence from its `onNext`. This resulted in executing the subscription side-effects of the source to be immediately cancelled when it called `onSubscribe` on concat's `MaybeObserver`.

In addition, tests were added to verify the other types don't have this kind of a problem.

Related #5100.",2017-02-16 15:54:36,2017-02-16 17:20:41,https://api.github.com/repos/ReactiveX/RxJava/issues/5101,"['2.x', 'Bug']",302,6,ReactiveX_RxJava_pull_5101.diff
ReactiveX/RxJava,2.x: Observable.first* with predicate,"Recently I discovered that there is no first-with-predicate operator in `2.x.` So I've implemented `Observable.firstElement(predicate)`, `Observable.first(defaultItem, predicate)` and `Observable.firstOrError(predicate)` overloads using simple constructs like `filter(predicate).firstElement()`.

Also, I've rewritten all first* tests because seems it was just copied from 1.x with do-it-later intention.",2017-02-16 01:25:21,2017-02-16 14:04:45,https://api.github.com/repos/ReactiveX/RxJava/issues/5098,[],173,33,ReactiveX_RxJava_pull_5098.diff
ReactiveX/RxJava,2.x: Add doAfterTerminate callback to the Single type.,"As mentioned in [THIS StackOverflow question](http://stackoverflow.com/questions/42168043/why-is-doafterterminate-missing-from-single-in-rxjava-2), doAfterTerminate() is currently missing in RxJava2. There's no strong reason for that, so this PR adds support for it.",2017-02-12 14:40:21,2017-02-13 10:30:13,https://api.github.com/repos/ReactiveX/RxJava/issues/5093,"['2.x', 'Enhancement']",257,0,ReactiveX_RxJava_pull_5093.diff
ReactiveX/RxJava,"1.x: add Single.merge(Obs), Obs.flatMapSingle & flatMapCompletable","This PR adds specialized operators for merging `Single` and `Completable` sources:

  - `Single.merge(Observable<Single<T>>)` + `maxConcurrency` overload
  - `Single.mergeDelayError(Observable<Single<T>>)` + `maxConcurrency` overload
  - `Observable.flatMapSingle(Func1<T, Single<R>>)` + `delayErrors` + `delayErrors, maxConcurrency` overloads
  - `Observable.flatMapCompletable(Func1<T, Completable>)` + `delayErrors` + `delayErrors, maxConcurrency` overloads

All of these return `Observable`.

This replaces #4988.

*Sidenote: for some time now, contributor(s) from certain party tend to contribute low quality or inadequate code and ""disappear"" pretty quickly. I can't be sure this is just lazyness or a deliberate and elaborate scheme to extract free work out of me for their own party's benefit but it is annoying as hell.*",2017-02-11 14:22:31,2017-02-11 18:06:25,https://api.github.com/repos/ReactiveX/RxJava/issues/5092,"['1.x', 'Enhancement']",2115,2,ReactiveX_RxJava_pull_5092.diff
ReactiveX/RxJava,1.x: create+subscribeOn avoid same-pool deadlock,"This PR allows to fix the same-pool deadlock that may happen with `create()` (formerly `fromEmitter`) and `subscribeOn` as `subscribeOn` by default schedules the requests behind a running emitter and thus the internal request amount may not get updated, leading to unnecessary dataloss.

See #4735.

In the update, if `subscribeOn` detects its upstream is `OnSubscribeCreate`, it no longer reschedules requests for it. For other, non-immediate cases, a new overload allows specifying the `requestOn` parameter that should be `false` if there is a `create(Action1, BackpressureStrategy)` in the sequence upstream.",2017-02-10 10:41:35,2017-02-11 09:36:19,https://api.github.com/repos/ReactiveX/RxJava/issues/5091,"['1.x', 'Bug']",199,58,ReactiveX_RxJava_pull_5091.diff
ReactiveX/RxJava,"2.x: fix scan(seed, f) to emit accumulated values asap","For performance reasons, the `scan` delayed the emission of accumulated items by one which worked well with sources that pushed new items frequently. 

Unfortunately, if the source stopped emitting (without completion), the very last accumulated item was stuck and no way to get it out of `scan`. I considered this type of use being rare but apparently I was wrong.

The PR changes `scan` to emit accumulated items, including the initial seed, as soon as there is request for it. The operator now uses a stable-prefetch queue-drain found throughout other operators such as `observeOn`. 

Remark: sadly, request trickery such as capturing the first `request` call, emitting the seed and then requesting n - 1 doesn't work because if the `request()` call itself happens from another thread and the source is empty, the `onNext` and `onComplete` could run concurrently.

Reported in #5089 ",2017-02-10 09:50:12,2017-02-11 09:37:16,https://api.github.com/repos/ReactiveX/RxJava/issues/5090,"['2.x', 'Bug']",412,234,ReactiveX_RxJava_pull_5090.diff
ReactiveX/RxJava,"2.x: fix CI load sensitive BlockingNextTests, XFlatMapTest","This PR updates `testNoBufferingOrBlockingOfSequence` with

  - retry up to 3 times with an exponential backoff as the test is time sensitive and Travis CI load sensitive,
  - uses `Schedulers.single()` as the helper thread and manages resource cleanup properly,
  - both `Flowable` and `Observable` variants.

Update: Looks like `XFlatMapTest` is still flaky, added changes here to try fixing it as well.",2017-02-09 15:18:36,2017-02-10 08:27:08,https://api.github.com/repos/ReactiveX/RxJava/issues/5088,"['2.x', 'Test-Failures']",123,94,ReactiveX_RxJava_pull_5088.diff
ReactiveX/RxJava,2.x: Correct marble diagram dimensions,"This fixes part of #4535, as requested in #5067.

These changes were generated using the following script:

```sh
#!/usr/bin/env bash

find . -name '*.java' -print0 \
  | xargs -0 grep '^\s*\*' \
  | grep -oP 'https.*?\.png' \
  | sort -u \
  | while read -r I; do
      echo ""Updating ${I}...""
      # Gather image details.
      DATA=""$(identify <(curl -f -L -s ""${I}""))""

      # Extract the image's true width and height.
      WIDTH=""$(echo ""${DATA}"" | grep -oP '(?<=PNG )\d+')""
      HEIGHT=""$(echo ""${DATA}"" | grep -oP 'PNG \d+x\d+' | grep -oP '(?<=x)\d+')""

      # Determine the image's scaled height, assuming a width of 640 pixels.
      NEW_HEIGHT=""$(echo 'scale=100; s='""${WIDTH}""' / 640; scale=0; '""${HEIGHT}""' / s' | bc)""

      # Update all `<img/>` tags referencing the image.
      find . -name '*.java' -print0 \
        | xargs -0 perl -i -p -e 's,<img( (width|height)=""[^""]*"")* src=""\Q'""${I}""'\E"",<img width=""640"" height=""'""${NEW_HEIGHT}""'"" src=""'""${I}""'"",g'
    done
```
",2017-02-09 14:36:42,2017-02-09 17:00:38,https://api.github.com/repos/ReactiveX/RxJava/issues/5087,"['2.x', 'Documentation']",64,64,ReactiveX_RxJava_pull_5087.diff
ReactiveX/RxJava,"1.x: deprecate create(), add alternatives","Looks like `create()` won't go away unless we get the IDE mark it someway, such as being deprecated.

This PR deprecates `create()` and adds `unsafeCreate` for internal use and deprecate-renames `fromEmitter` to `create(Action1, BackpressureMode)`.

There was an earlier attempt at deprecating `create`, #4253, but it was not followed up. This PR executes what I suggested in one of the [comments](https://github.com/ReactiveX/RxJava/pull/4253#issuecomment-235913860).",2017-02-09 13:25:08,2017-02-10 08:38:14,https://api.github.com/repos/ReactiveX/RxJava/issues/5086,"['1.x', 'Cleanup']",595,529,ReactiveX_RxJava_pull_5086.diff
ReactiveX/RxJava,2.x: wrap undeliverable errors,"This PR adds the `UndeliverableException` and `ProtocolViolationException`. The former wraps exceptions that happen beyond the lifecycle of a flow and the latter is added to distinguish validation bugs.

The `RxJavaPlugins.onError` wraps errors into `UndeliverableException` unless `RxJavaPlugins.isBug()` returns true when the `Throwable` is relayed to the (default) handler.

Having the `UndeliverableException` should help with understanding the source of a crash and by having its own stack trace, help locating the offending positions (for example, a missed `isDisposed()` check in a 3rd party library).",2017-02-07 17:40:49,2017-02-08 10:06:34,https://api.github.com/repos/ReactiveX/RxJava/issues/5080,"['2.x', 'Enhancement']",447,255,ReactiveX_RxJava_pull_5080.diff
ReactiveX/RxJava,2x: Removed documentation leftover,"...that wrongly states that the error will be swallowed.

As discussed in #5036",2017-02-06 19:35:48,2017-02-06 19:48:57,https://api.github.com/repos/ReactiveX/RxJava/issues/5076,"['2.x', 'Documentation']",0,2,ReactiveX_RxJava_pull_5076.diff
ReactiveX/RxJava,"2.x: cancel upstream first, dispose worker last","This PR makes sure the `Scheduler.Worker` is disposed only after

  - disposing/cancelling the upstream,
  - emitting terminal events.

This may help with situations when the worker-dispose interrupts a thread that is blocked and the InterruptedException handler checks for the stream to be disposed so the exception can be safely ignored (and thus not end up in the RxJavaPlugins.onError handler to crash the app).

Related: #4863",2017-02-06 18:41:56,2017-02-06 19:25:53,https://api.github.com/repos/ReactiveX/RxJava/issues/5075,"['2.x', 'Cleanup']",67,81,ReactiveX_RxJava_pull_5075.diff
ReactiveX/RxJava,2.x: compatibility fixes (JDK 9 & IntelliJ 2017.1 EAP),"1. When the project is checked out into a directory that is not exactly `*/RxJava/` (i.e., `/RxJavaSomething/`) the source-code locator in the unit tests failed with a `NullPointerException`. The locator is now relaxed to expect `/RxJava` prefix.
2. Running the unit tests from IntelliJ 2017.1 EAP, the `ExceptionTests.testStackOverflowWouldOccur` failed with `AssertionError` because the final stack depth was exactly the constant value (800). The check now uses the correct `>=` as the dual of the recursion condition of `<`.",2017-02-04 14:05:54,2017-02-04 16:36:11,https://api.github.com/repos/ReactiveX/RxJava/issues/5069,"['2.x', 'Test-Failures']",6,3,ReactiveX_RxJava_pull_5069.diff
ReactiveX/RxJava,Update README.md,"I tried to use RxJava2 from the example and I get some error message.

Error:(13, 38) java: variable v is already defined in method main(java.lang.String[])",2017-02-04 04:32:34,2017-02-04 07:34:10,https://api.github.com/repos/ReactiveX/RxJava/issues/5068,[],1,1,ReactiveX_RxJava_pull_5068.diff
ReactiveX/RxJava,Update codecov.yml,"Fix codecov.yml

- `target` is used a ""coverage must be greater or equal to the target""
- `threshold` is the acceptable amount of loss to still consider the status as successful.
",2017-02-03 21:56:21,2017-02-03 22:12:50,https://api.github.com/repos/ReactiveX/RxJava/issues/5066,"['2.x', 'Build']",10,10,ReactiveX_RxJava_pull_5066.diff
ReactiveX/RxJava,2.x: fix replay() cancel/dispose NPE,"This PR fixes both `Flowable.replay()` and `Observable.replay()` throwing a `NullPointerException` if the connection is disconnect before the upstream calls `onSubscribe` on the connection being established. 

In practice, this requires an async cancellation to happen through `refCount().unsubscribeOn()` for example. The validation tests simulate this by not calling `onSubscribe` until the synchronous connect/disconnect happens.

Reported in #5060.",2017-02-03 18:25:47,2017-02-03 18:40:43,https://api.github.com/repos/ReactiveX/RxJava/issues/5064,"['2.x', 'Bug']",97,15,ReactiveX_RxJava_pull_5064.diff
ReactiveX/RxJava,2.x: update readme parallel example,Add `parallel()` example to the getting started in README.md,2017-02-03 17:03:30,2017-02-03 18:02:27,https://api.github.com/repos/ReactiveX/RxJava/issues/5062,"['2.x', 'Documentation']",11,0,ReactiveX_RxJava_pull_5062.diff
ReactiveX/RxJava,"When declaring Functions/BiFunctions as parameter, ? super / ? extends is used","I think a function should never be declared without ""super/extends"" as method parameter.
I have found a few instances where this has been the case.

In the most common cases this shouldn't make a difference, but sometimes it helps a lot...",2017-02-03 15:02:15,2017-02-05 19:02:13,https://api.github.com/repos/ReactiveX/RxJava/issues/5059,"['2.x', 'Cleanup', 'Enhancement']",296,136,ReactiveX_RxJava_pull_5059.diff
ReactiveX/RxJava,Feature/#5045 more generics in RxJavaPlugins,"I widened the bounds for the functions. Looks good for me.
Related to #5045 ",2017-02-03 14:47:37,2017-02-06 19:26:52,https://api.github.com/repos/ReactiveX/RxJava/issues/5058,"['2.x', 'Cleanup']",228,99,ReactiveX_RxJava_pull_5058.diff
ReactiveX/RxJava,2.x: disable codecov-checks on PRs,"Codecov.io seems to be messing around quite a bit lately. A day after the integration, new checks appeared at every PR that fail because of small irrelevant fluctuations in the coverage itself and they fail the whole PR even though the tests pass.

This PR seeks to disable these checks.",2017-02-03 12:20:43,2017-02-03 12:40:18,https://api.github.com/repos/ReactiveX/RxJava/issues/5057,"['2.x', 'Build']",3,0,ReactiveX_RxJava_pull_5057.diff
ReactiveX/RxJava,2.x: document (internal) SimpleQueue,The interface was missing javadoc on its methods.,2017-02-03 11:45:15,2017-02-03 16:39:42,https://api.github.com/repos/ReactiveX/RxJava/issues/5056,"['2.x', 'Documentation']",38,5,ReactiveX_RxJava_pull_5056.diff
ReactiveX/RxJava,2.x: Feature/#4876 more null checks,"I have added some more null checks to help the static code analysis.
I think I have also fixed one possible NPE in NewThreadWorker",2017-02-03 11:22:42,2017-02-03 16:41:34,https://api.github.com/repos/ReactiveX/RxJava/issues/5055,"['2.x', 'Cleanup', 'Enhancement']",46,13,ReactiveX_RxJava_pull_5055.diff
ReactiveX/RxJava,2.x: add nullable annotation to simple queue (fixes #5053),"As explained in https://github.com/ReactiveX/RxJava/issues/5053 SimpleQueue might return null.
To document this behavior a nullable annotation has been added.",2017-02-03 11:03:08,2017-02-03 11:18:18,https://api.github.com/repos/ReactiveX/RxJava/issues/5054,"['2.x', 'Cleanup', 'Enhancement']",131,0,ReactiveX_RxJava_pull_5054.diff
ReactiveX/RxJava,Update javadoc to 1.2.6,Update Javadoc to 1.2.6,2017-02-03 08:47:50,2017-02-03 08:47:58,https://api.github.com/repos/ReactiveX/RxJava/issues/5052,"['1.x', 'Documentation']",70771,1157,ReactiveX_RxJava_pull_5052.diff
ReactiveX/RxJava,Feature/#4876 nonnull annotations,"Issue: #4876

Starting to add @NonNull and @Nullable annotations.

I decided to add a compileOnly dependency to findbugs:jsr305 artifact.

We could also use ""io.reactivex.annotations.NonNull"" which already exists. But there is no ""io.reactivex.annotations.Nullable"" annotation which is at least as important in my experience.

Since these are only annotations, it is no problem when the class files are missing at compile time (JLS 9.6.1.2 Retention).


I have started to add annotations in the Scheduler and RxJavaPlugins.
The test RxJavaPlugins contains some invalid checks using null (lines 1353 and following).


This pull request is work in progress and should be discussed.


Questions so far:
- use jsr305 (compileOnly) or existing annotation in io.reactivex?
- (if not using jsr305): Use own @Nullable annotation or try to get one added to ""io.reactivex""? Or skip these completely (which misses the point of the static code analysis)
- Why has there been tests calling the RxJavaPlugins.on*Scheduler with null arguments? Can these be removed securely?
",2017-02-02 20:14:04,2017-02-03 10:29:35,https://api.github.com/repos/ReactiveX/RxJava/issues/5051,"['2.x', 'Cleanup', 'Enhancement']",349,132,ReactiveX_RxJava_pull_5051.diff
ReactiveX/RxJava,use bounded wildcards for errorHandler (fixes #5045),"Adding bound wildcards for error handler - fixes #5045
",2017-02-02 19:20:44,2017-02-03 16:42:22,https://api.github.com/repos/ReactiveX/RxJava/issues/5049,"['2.x', 'Enhancement']",26,5,ReactiveX_RxJava_pull_5049.diff
ReactiveX/RxJava,1.x: Improve the BehaviorSubject Java doc,"- The second example didn't explain what happened with ""default"".
- The first line is copied from the 2.x documentation. It's more clear.",2017-02-02 18:36:20,2017-02-02 18:45:08,https://api.github.com/repos/ReactiveX/RxJava/issues/5048,"['1.x', 'Documentation']",2,2,ReactiveX_RxJava_pull_5048.diff
ReactiveX/RxJava,2.x: Document and test amb subscription ordering.,Refs #5044.,2017-02-02 17:36:05,2017-02-02 18:43:05,https://api.github.com/repos/ReactiveX/RxJava/issues/5047,"['2.x', 'Documentation']",128,15,ReactiveX_RxJava_pull_5047.diff
ReactiveX/RxJava,Add StackOverflow links,Add StackOverflow links to Readme. Also trigger CI for codecov.io integration check.,2017-02-02 11:12:28,2017-02-02 15:03:14,https://api.github.com/repos/ReactiveX/RxJava/issues/5046,"['2.x', 'Documentation']",1,0,ReactiveX_RxJava_pull_5046.diff
ReactiveX/RxJava,"2.x: add parallel hooks to RxJavaPlugins, add missing params validation",This PR adds an `onAssembly` hook for `ParallelFlowable` operators and adds the missing parameter validation to some parallel operators.,2017-02-01 22:59:22,2017-02-02 08:16:09,https://api.github.com/repos/ReactiveX/RxJava/issues/5043,"['2.x', 'Enhancement']",154,32,ReactiveX_RxJava_pull_5043.diff
ReactiveX/RxJava,2.x: reintroduce OnErrorNotImplementedException for 0-1 argument subscribe(),"This PR reintroduces the `OnErrorNotImplementedException` wrapper from 1.x and applies it to the `subscribe()` methods that don't define an `onError` handler.

The errors are still routed to the `RxJavaPlugins.onError` handler but now wrapped with `OnErrorNotImplementedException`.

This should help with cases where the developer forgot to add the handler and distinguish such unhandled errors from other undeliverable errors due to lifecycle limitations.",2017-01-31 14:57:59,2017-02-01 09:38:58,https://api.github.com/repos/ReactiveX/RxJava/issues/5036,"['2.x', 'Enhancement']",267,26,ReactiveX_RxJava_pull_5036.diff
ReactiveX/RxJava,2.x stop distinctUntilChanged from updating its value unless changed,"This pull request will make the `FlowableDistinctUntilChanged` and `ObservableDistinctUntilChanged` operators keep the first of equal values.

The reasoning for this is the following code:
```
observable = someSource
    .distinctUntilChanged()
    .replay(1)
    .autoConnect();
```

Currently this code will will cache two values if the last two values are equal. Replay will cache the first of them and `distinctUntilChanged` will cache the second since it will update the internal reference even if the items are equal.",2017-01-30 08:54:54,2017-01-30 17:23:39,https://api.github.com/repos/ReactiveX/RxJava/issues/5033,['2.x'],86,4,ReactiveX_RxJava_pull_5033.diff
ReactiveX/RxJava,1.x: fix groupBy consuming the upstream in an unbounded manner,"Due to an unnecessary `request(1)`, `groupBy` consumed the upstream in an unbounded manner no matter the downstream request patterns against the main or the inner groups themselves.

This PR fixes this by removing it and rearranging the group/group item handling similar to how 2.x is implemented.

Related #5029.",2017-01-28 10:55:40,2017-01-28 18:17:31,https://api.github.com/repos/ReactiveX/RxJava/issues/5030,"['1.x', 'Bug']",35,6,ReactiveX_RxJava_pull_5030.diff
ReactiveX/RxJava,"2.x: dedicated Single.zip implementation, no dispose on all-success","This adds a dedicated implementation for zipping `Single`s (adapted from `MaybeZipX`).

Routing the original `zip` through `Flowable` added the usually unwanted behavior of cancelling the sources if one of them reports a completion after a row has been consumed from all (when converted to `Flowable`, `SingleObserver.onSuccess` becomes `Subscriber.onNext` + `onComplete`). Since there is only `onSuccess` and `onError` in `Single`, there is no need to dispose the sources once all signalled their only `onSuccess`.

Related: #5024.",2017-01-27 13:48:05,2017-01-27 16:35:08,https://api.github.com/repos/ReactiveX/RxJava/issues/5027,"['2.x', 'Enhancement']",852,34,ReactiveX_RxJava_pull_5027.diff
ReactiveX/RxJava,Update javadoc to 2.0.5,"Update the main javadoc to show the documentation of 2.0.5 since the project has been switched over to the 2.x.

The 1.x documentation can be accessed under http://reactivex.io/RxJava/1.x/javadoc/
The 2.x documentation can be also accessed under http://reactivex.io/RxJava/2.x/javadoc/",2017-01-27 12:01:00,2017-01-27 12:01:42,https://api.github.com/repos/ReactiveX/RxJava/issues/5025,"['2.x', 'Documentation']",195597,60446,ReactiveX_RxJava_pull_5025.diff
ReactiveX/RxJava,Add nullability annotations to io.reactivex.annotations interfaces.,"(Addresses https://github.com/ReactiveX/RxJava/issues/4876)

This pull request annotates everything in the `io.reactivex.annotations` package with a new `@NonNull` annotation defined in RxJava. This doesn’t annotate everything, but I think it’s a good start.

In particular, when migrating a large codebase of RxJava 1.x code to 2.x, catching null returns in these interfaces was very difficult. At best, it’s noticed while migrating, otherwise it’s up to unit tests or a production crash to catch these.

With these new annotations, you get much better IDE support (once you tell IntelliJ about the new annotation):
<img width=""563"" alt=""screen shot 2017-01-27 at 2 30 18 pm"" src=""https://cloud.githubusercontent.com/assets/23467/22362686/7f172032-e49f-11e6-9fc6-94049c263ceb.png"">
^ in this example, `getPhoneNumber()` is marked as `@Nullable`

In addition, support for this annotation can easily be added to static analysis tools like Infer, checker, or any other popular tool.

Open Questions
* Does this even make sense to add? There seem to be some concerns in the issue.
* The `@NonNull` annotation needs JavaDoc - I’m planning on following up with whatever is in existing NonNull annotations floating around unless anyone thinks otherwise.
* There are no tests since this is essentially just metadata. Should there be something that enforces this? I'm not sure if there is any kind of lint tool that runs on this project, but one approach would be to write a check that enforces everything in specific packages in annotated. This would also help keep future changes annotated.
* Is it worth adding this elsewhere? I find these function interfaces to be the easiest place to run into nullability problems, but I'm curious what others think. A simple, but kind of crazy brute force approach would be to require annotations on every public API.",2017-01-27 06:51:00,2017-01-27 17:21:03,https://api.github.com/repos/ReactiveX/RxJava/issues/5023,"['2.x', 'Enhancement']",77,12,ReactiveX_RxJava_pull_5023.diff
ReactiveX/RxJava,2.x: option to fail for using blockingX on the computation scheduler,"This PR adds an `RxJavaPlugins` option `failOnNonBlockingScheduler` that triggers an `IllegalStateException` when the user tries to run a blocking method while the execution is on the `computation()` or `single()` `Scheduler`: 

```java
Flowable.just(1)
.subscribeOn(Schedulers.computation())
.map(v -> Flowable.just(""query"").subscribeOn(Schedulers.io()).blockingFirst())
.doOnNext(v -> someAPI(v).subscribeOn(Schedulers.newThread()).blockingSubscribe());
.blockingFirst();
```

It is an optional setting, default off.

The check is done before going into an await method (and a few other types of blocking). Most blocking operators usually poll the status and try to avoid the actual blocking thus this shouldn't affect synchronous sequences that one extracts a value from.

Detection of a blocking-sensitive scheduler's thread is done by checking the current thread's class for implementing the `NonBlockingThread` marker interface (currently `internal`).

The `RxThreadFactory` has been updated to allow picking a default `Thread` implementation or a custom one for the `newThread()`. Note that since #5002 you can create custom schedulers by providing a `ThreadFactory`.

This works for RxJava's default schedulers but not for `AndroidSchedulers.mainThread()` where similar blocking should be avoided as well. For them, a plugin-callback action would be more suitable. ~~Question is how that callback should behave (throw, return false, should it be always executed or only when the flag is true).~~

My proposed solution is to have a plugin callback `RxJavaPlugins.setOnBeforeBlocking(BooleanSupplier)` that Android users can define the callback for:

```java
RxJavaPlugins.setOnBeforeBlocking(() -> Looper.myLooper() == Looper.getMainLooper())
RxJavaPlugins.setFailOnNonBlockingScheduler(true);
```

This callback is only executed if the `failOnNonBlockingScheduler` is set to true.",2017-01-25 14:51:49,2017-01-27 08:08:18,https://api.github.com/repos/ReactiveX/RxJava/issues/5020,"['2.x', 'Enhancement']",913,43,ReactiveX_RxJava_pull_5020.diff
ReactiveX/RxJava,Fix copyright instructions in CONTRIBUTING,After [changing the copyright of the project](https://github.com/ReactiveX/RxJava/issues/4978) the documentation in CONTRIBUTING.md should be adjusted with the updated copyright header,2017-01-24 17:41:26,2017-01-24 21:00:57,https://api.github.com/repos/ReactiveX/RxJava/issues/5017,"['2.x', 'Information']",1,1,ReactiveX_RxJava_pull_5017.diff
ReactiveX/RxJava,"Override RS dependency to compile, replace owner info","This PR overrides the dependency of Reactive-Streams in the generated POM.xml from `runtime` to `compile` to avoid trouble with plain maven users.

In addition, I took the liberty of overriding the responsible owner references which seem to be hard-coded in the `rxjava-nebula` plugin.

Related: #4813, #5014",2017-01-24 10:18:25,2017-01-24 10:31:34,https://api.github.com/repos/ReactiveX/RxJava/issues/5015,"['2.x', 'Build']",23,0,ReactiveX_RxJava_pull_5015.diff
ReactiveX/RxJava,1.x: update sample(time) diagram to indicate emission of last,"This PR updates the 1.x `sample(time)` diagram to indicate the last value is emitted when the sequence completes. It is the same (style) as for 2.x:


Default scheduler:
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.emitlast.1x.png)

Custom scheduler:
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.s.emitlast.1x.png)

Related: #4952",2017-01-19 14:28:05,2017-01-24 11:32:02,https://api.github.com/repos/ReactiveX/RxJava/issues/5007,"['1.x', 'Documentation']",2,2,ReactiveX_RxJava_pull_5007.diff
ReactiveX/RxJava,"2.x: improve the parallel() mode test coverage, improve its code","This PR adds additional unit tests for the `parallel()` operators, plus:

  - adds conditional fusion to `runOn`, `filter` and `map` operators
  - exposes the `FlowableFlatMap`'s internal `Subscriber` to be reused with `ParallelFlowable.flatMap`
  - uses the `FlowableConcatMap`'s internal `Subscriber` to be reused with `ParallelFlowable.concatMap`
  - fix generics with `collect` and `reduce`
  - change queue overflow errors to `MissingBackpressureException`
  - make sure join-like operators don't emit the same upstream `Throwable` to the `RxJavaPlugins.onError` handler if all rails have the same error reference
",2017-01-19 12:48:04,2017-01-20 19:24:00,https://api.github.com/repos/ReactiveX/RxJava/issues/5006,"['2.x', 'Coverage', 'Enhancement', 'Test']",2306,259,ReactiveX_RxJava_pull_5006.diff
ReactiveX/RxJava,2.x: ExecutorScheduler.scheduleDirect to report isDisposed on complete,"This PR makes the `Disposable` returned by the `ExecutorScheduler.scheduleDirect()` report `isDisposed` `true` if the task has actually finished, which should now be consistent with the `Worker` behavior of other schedulers.

Reported in #5004.",2017-01-18 17:20:02,2017-01-18 19:15:06,https://api.github.com/repos/ReactiveX/RxJava/issues/5005,"['2.x', 'Bug']",181,15,ReactiveX_RxJava_pull_5005.diff
ReactiveX/RxJava,2.x: Improve Flowable tests,"Some tests were missing the following assertions:
* Assert onComplete is called exactly once.
* Assert onError is not called at all for any throwable.
* Assert the order in which the observable's methods are called.

If you don't think this pull request is adding any value feel free to reject it.",2017-01-18 11:53:37,2017-01-18 12:11:12,https://api.github.com/repos/ReactiveX/RxJava/issues/5003,"['2.x', 'Test']",31,35,ReactiveX_RxJava_pull_5003.diff
ReactiveX/RxJava,2.x: Add scheduler creation factories,"Resolves #4993

This is a pretty vanilla copy from RxJava 1's implementation. Note that I had to tune NewThread scheduler to not be a singleton to support this.

We had talked about borrowing from project reactor's APIs for different overloads, let me know if you think we should add more fine-grained controls through these.
",2017-01-18 11:31:39,2017-01-25 08:22:00,https://api.github.com/repos/ReactiveX/RxJava/issues/5002,"['2.x', 'Enhancement']",277,53,ReactiveX_RxJava_pull_5002.diff
ReactiveX/RxJava,Add which are the other stardard methods of create,"I was using `Observable.create(OnSubscribe)`. I knew about the warning:

> This method requires advanced knowledge about building operators and data sources; please consider other standard methods first

But I didn't know which were the *other stadard methods*. There were no clue in the JavaDoc. With this change the problem is gone.",2017-01-17 10:24:31,2017-01-17 12:35:55,https://api.github.com/repos/ReactiveX/RxJava/issues/5000,"['1.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_5000.diff
ReactiveX/RxJava,2.x: assertNever(T value) / assertNever(Predicate<T> valuePredicate),"This pull request adds to any class extending ```BaseConsumerTest``` the ability to assert that a given value was not emitted by the observable it was subscribed to, either with ```assertNever(T value)```or ```assertNever(Predicate<T> valuePredicate)```",2017-01-14 12:10:49,2017-01-17 13:47:37,https://api.github.com/repos/ReactiveX/RxJava/issues/4994,"['2.x', 'Enhancement']",166,0,ReactiveX_RxJava_pull_4994.diff
ReactiveX/RxJava,2.x: A.flatMapB to eagerly check for cancellations before subscribing,"The `flatMap` implementations always subscribed to the generated inner source even if there was an asynchronous cancel while the function was running. With typical functions, there is only a really tiny window inside function but some users tend to block/sleep in the function and when that returns, the `flatMap` operator is already cancelled. 

If the generated inner source emitted an error disregarding its own cancellation signal (the `error()` operators do this), those errors end up in the `RxJavaPlugins.onError` and crash the app (on Android).

This PR adjusts the `flatMap` implementations to check for the disposed/cancelled state before subscribing to the inner source. For `Observable` and `Flowable`, this has practically no extra overhead as the add/remove already checks for the terminal state and can return a boolean for it. The rest require an explicit `isDisposed()` check.",2017-01-13 11:18:32,2017-01-16 10:13:07,https://api.github.com/repos/ReactiveX/RxJava/issues/4992,"['2.x', 'Bug']",659,40,ReactiveX_RxJava_pull_4992.diff
ReactiveX/RxJava,2.x: Update marble diagrams for sample overloads,"This PR updates the referenced marble diagrams to reflect the actual behavior and options with `sample`.

New images:

  - `sample(time, emitLast)`

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.emitlast.png)

  - `sample(time, scheduler, emitLast)`

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.s.emitlast.png)

  - `sample(other)` - the [original image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.o.png) indicated the emission of the last item which was not the case

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.o.nolast.png)

  - `sample(other, emitLast)`

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.o.emitlast.png)",2017-01-13 09:30:48,2017-01-16 10:12:54,https://api.github.com/repos/ReactiveX/RxJava/issues/4990,"['2.x', 'Documentation']",14,10,ReactiveX_RxJava_pull_4990.diff
ReactiveX/RxJava,2.x: Fix Observable.singleElement doc,"Fixes a subtle documentation bug. `Observable.singleElement` returns `Maybe<T>`, not `Observable<T>`.
",2017-01-13 05:52:13,2017-01-13 08:00:31,https://api.github.com/repos/ReactiveX/RxJava/issues/4989,"['2.x', 'Documentation']",2,2,ReactiveX_RxJava_pull_4989.diff
ReactiveX/RxJava,1.x: Merging an observable of singles.,"The addition of a `Observable<Single<T>> -> Observable<T>` to round out the basic API of `rx.Single`. I need this for doing a flat scan of sorts.

```
Single.merge(events.scan(Single.just(seed), (stateSingle, event) -> {
    return stateSingle.flatMap((state) -> {
        return state.write(event);
    }).cache();
}));
```
",2017-01-12 23:13:26,2017-02-11 18:06:47,https://api.github.com/repos/ReactiveX/RxJava/issues/4988,"['1.x', 'Enhancement']",1248,0,ReactiveX_RxJava_pull_4988.diff
ReactiveX/RxJava,2.x: make Obs.combineLatest consistent with Flowable + doc cornercase,"This PR fixes `Observable.combineLatest` to be consistent with `Flowable.combineLatest` by not subscribing to additional input sources if the operator reached a terminal state due to a valueless source (that completes or errors). In addition, such early termination didn't properly cancel the other sources when `delayErrors == true`.

I've also extended the documentation on the overloads to warn about empty sources that will terminate the operator, even with `combineLatestDelayError`, and thus subscription side-effects may not happen.

There is a related issue #4414 where the operator should fully consume each input source no matter what and terminate when all terminate. I'm still considering what would be the best way to introduce this.

Reported in #4986",2017-01-12 17:18:39,2017-01-12 18:25:12,https://api.github.com/repos/ReactiveX/RxJava/issues/4987,"['2.x', 'Bug', 'Documentation']",449,4,ReactiveX_RxJava_pull_4987.diff
ReactiveX/RxJava,"2.x: fix cross-boundary invalid fusion with observeOn, flatMap & zip","When `flatMap` and `zip` fuses its sources, it was possible one of the async source polls on another source which executed boundary-sensitive operators (`map`, `filter`) on the wrong thread.

For clarity, here is a diagram showing the execution flow of a classical and fused setup:

![image](https://cloud.githubusercontent.com/assets/1269832/21883621/536a123c-d8b0-11e6-9a7a-b6deb2ffb26b.png)

In the classical flow, everything is push and when flatMap collects the available elements, all side-effects happened inside `map`.

In the fused flow, there are no queues and the onNext call is an indication to `poll()` on the sources inside `flatMap` (or zip). If the first source triggers onNext, that source is correctly polled and `map` executes on the right thread. However, when the flatMap continues to collect other available elements, it polls on the other source and executes that `map` still on the first scheduler, despite that source having its own scheduler specified.

The solution is to mark `flatMap` and `zip`'s inner consumer as boundary sensitive which prevents the fusion above since `map` is also marked as boundary sensitive.

Related: https://github.com/reactor/reactor-core/issues/342",2017-01-12 09:20:39,2017-01-12 18:24:55,https://api.github.com/repos/ReactiveX/RxJava/issues/4984,"['2.x', 'Bug']",135,10,ReactiveX_RxJava_pull_4984.diff
ReactiveX/RxJava,2.x: fix Observable.concatMapEager bad logic for immediate scalars,"The operator `Observable.concatMapEager` had a bad optimization targeting scalar and callable sources and emitted their values immediately even if it wasn't that particular source's turn for it.

The `Flowable` is not affected, added unit tests for both.

Reported in #4981.",2017-01-11 16:36:20,2017-01-11 19:34:33,https://api.github.com/repos/ReactiveX/RxJava/issues/4982,"['2.x', 'Bug']",36,19,ReactiveX_RxJava_pull_4982.diff
ReactiveX/RxJava,Update Copyright to 'RxJava Contributors',"Updating all files containing a Copyright header to change from 'Netflix, Inc' to 'RxJava Contributors' as per https://github.com/ReactiveX/RxJava/issues/4978.",2017-01-09 21:27:46,2017-01-09 23:21:38,https://api.github.com/repos/ReactiveX/RxJava/issues/4980,['2.x'],1381,1381,ReactiveX_RxJava_pull_4980.diff
ReactiveX/RxJava,Add newline to end of files missing a newline,"This is to get rid of the ""No newline at end of file"" warning that exist on many but not all files in the project, so adds a newline to any file missing a newline. This came about while modifying a large number of files for https://github.com/ReactiveX/RxJava/issues/4978.

This is intended to clean this up once so it doesn't cause warnings and noise in each PR this can affect. Probably would be good if the project had a formatter than ensured this as part of CI.",2017-01-09 21:25:57,2017-01-09 23:20:49,https://api.github.com/repos/ReactiveX/RxJava/issues/4979,"['2.x', 'Cleanup']",287,287,ReactiveX_RxJava_pull_4979.diff
ReactiveX/RxJava,Fixed a typo and other cosmetics issues.,Fixed a small typo in README.md.,2017-01-09 14:27:42,2017-01-09 15:22:58,https://api.github.com/repos/ReactiveX/RxJava/issues/4976,"['2.x', 'Documentation']",18,18,ReactiveX_RxJava_pull_4976.diff
ReactiveX/RxJava,2.x: add Flowable.parallel() and parallel operators,"This PR adds the `parallel()` method to `Flowable` which opens up a sub-DSL with parallel operations. (Note that only a few operators make sense in a parallel settings.)

This parallel sub-DSL is not limited to computation tasks as it allows specifying the parallelism and the `Scheduler` to run the parallel 'rails'. For example, you can have parallel downloads that block:

```java
Flowable.range(1, 100)
.parallel(10)
.runOn(Schedulers.io())
.map(v -> httpClient.blockingGet(""http://server/item/"" + v))
.sequential()
.observeOn(AndroidSchedulers.mainThread())
.subscribe(...);
```

",2017-01-08 18:19:32,2017-01-18 22:24:16,https://api.github.com/repos/ReactiveX/RxJava/issues/4974,"['2.x', 'Enhancement']",5078,2,ReactiveX_RxJava_pull_4974.diff
ReactiveX/RxJava,2.x: Add Completable.hide(),- adds Completable.hide() operator so that CompletableSubject as well as other custom Completable implementations can be hidden,2017-01-08 11:59:22,2017-01-08 12:17:52,https://api.github.com/repos/ReactiveX/RxJava/issues/4973,"['2.x', 'Enhancement']",204,0,ReactiveX_RxJava_pull_4973.diff
ReactiveX/RxJava,Improve compose() generics,"Resolves #4950

I tested and built with the added tests on Java 6, 7, and 8. Not sure if you want to keep them in before merging since they're not really functional in nature, just there to make sure they compile.

",2017-01-08 11:02:13,2017-01-08 11:33:50,https://api.github.com/repos/ReactiveX/RxJava/issues/4972,"['2.x', 'Cleanup']",84,12,ReactiveX_RxJava_pull_4972.diff
ReactiveX/RxJava,2.x: Add @CheckReturnValue to create methods of Subjects + Processors,- adds the @CheckReturnValue annotation to subjects + processors since Single/Completable and MaybeSubject got them recently too,2017-01-08 10:55:03,2017-01-08 11:26:32,https://api.github.com/repos/ReactiveX/RxJava/issues/4971,"['2.x', 'Cleanup']",34,0,ReactiveX_RxJava_pull_4971.diff
ReactiveX/RxJava,"2.x: fix withLatestFrom null checks, lifecycle",This PR fixes the lack of null check on the result of the `combiner` function as well as fixes the lifecycle of the `FlowableWithLatestFrom` to avoid races with the `onSubscribe`.,2017-01-08 10:15:44,2017-01-08 14:44:43,https://api.github.com/repos/ReactiveX/RxJava/issues/4970,"['2.x', 'Bug']",71,22,ReactiveX_RxJava_pull_4970.diff
ReactiveX/RxJava,"2.x: add subjects for Single, Maybe and Completable","This PR adds 3 new subject types: `SingleSubject`, `MaybeSubject` and `CompletableSubject`. Their purpose is to provide an imperative way to multicast 0-1-error events as well as cache these events for later observers. They are thread-safe by design and there is no need for a serialized wrapper unlike the other `Subject`s.",2017-01-06 22:56:15,2017-01-08 09:38:24,https://api.github.com/repos/ReactiveX/RxJava/issues/4967,"['2.x', 'Enhancement']",1526,0,ReactiveX_RxJava_pull_4967.diff
ReactiveX/RxJava,2.x: add strict() operator for strong RS conformance,"This PR adds a new instance operator `strict()`:

Ensures that the event flow between the upstream and downstream follow the Reactive-Streams 1.0 specification by honoring the 3 additional rules (which are omitted in standard operators due to performance reasons).

 * §1.3: onNext should not be called concurrently until onSubscribe returns
 * §2.3: onError or onComplete must not call cancel
 * §3.9: negative requests should emit an onError(IllegalArgumentException)

In addition, if rule §2.12 (onSubscribe must be called at most once) is violated, the sequence is cancelled an onError(IllegalStateException) is emitted. Note that the Reactive-Streams specification doesn't have any sanction for violating §2.12.

The `strict()` operator also replaces the test-only operators that were supporting the Reactive-Streams TCKs already.
",2017-01-06 21:36:15,2017-01-07 08:45:06,https://api.github.com/repos/ReactiveX/RxJava/issues/4966,"['2.x', 'Enhancement']",394,218,ReactiveX_RxJava_pull_4966.diff
ReactiveX/RxJava,1.x: update javadoc to 1.2.5,Update Javadoc on gh-pages to 1.2.5.,2017-01-06 12:13:51,2017-01-06 12:14:18,https://api.github.com/repos/ReactiveX/RxJava/issues/4964,['Documentation'],75035,3427,ReactiveX_RxJava_pull_4964.diff
ReactiveX/RxJava,"1.x: add missing marbles, fix image sizes","  - add `create(SyncOnSubscribe)` marble and update image dimensions
  - add `create(AsyncOnSubscribe)` marble and update image dimensions
  - add `switchIfEmpty()` marble
  - add `toCompletable()` marble and update image dimensions",2017-01-06 11:44:57,2017-01-06 11:52:32,https://api.github.com/repos/ReactiveX/RxJava/issues/4963,"['1.x', 'Documentation']",5,3,ReactiveX_RxJava_pull_4963.diff
ReactiveX/RxJava,2.x: fix Single.takeUntil() other triggering twice,"This PR fixes the double termination of `Single.takeUntil(Publisher)` when the `other` fires an item and then completes while ignoring the cancellation in between, trying to signal a `CancellationException` again which is routed to the `RxJavaPlugins.onError` and crashing on Android.

In addition, the `Maybe.takeUntil()` received a unit test verifying this doesn't also happen to it.

Related: #4961.",2017-01-06 08:42:49,2017-01-06 18:39:59,https://api.github.com/repos/ReactiveX/RxJava/issues/4962,"['2.x', 'Bug']",34,2,ReactiveX_RxJava_pull_4962.diff
ReactiveX/RxJava,2.x: fix LambdaObserver calling dispose when terminating,"This PR changes the `LambdaObserver` to not dispose the upstream when it receives a terminal event. The `LambdaSubscriber` has been previoulsy updated but apparently not synced.

Reported in #4956.

This PR fixes 2 unit test methods of `Flowable.ignoreElements()` as they were not actually testing the operator (discovered when the `Observable.ignoreElements()` initially failed after the patch to `LambdaObserver`).",2017-01-04 14:24:05,2017-01-04 15:01:33,https://api.github.com/repos/ReactiveX/RxJava/issues/4957,"['2.x', 'Bug']",190,11,ReactiveX_RxJava_pull_4957.diff
ReactiveX/RxJava,2.x: add sample() overload that can emit the very last buffered item,"The `sample()` operator in 1.x has been changed to always emit the very last buffered item before completion for [1.1.3](https://github.com/ReactiveX/RxJava/releases/tag/v1.1.3): [Discussion](https://github.com/ReactiveX/RxJava/issues/3657), [PR](https://github.com/ReactiveX/RxJava/pull/3757).

This change has been forgotten in 2.x (because 2.x `sample()` was implemented several months earlier) but unlike 1.x, I don't want to break existing use cases, hence the introduction of 6 overloads (3 for each base type) that let's one define the ""tail"" behavior.

Note that the associated marble diagrams are inconsistent with the operators implemented, we need a new diagram where the timed-sample also emits the last value:

![image](https://cloud.githubusercontent.com/assets/1269832/21642878/891ca42a-d285-11e6-876a-e613de2443db.png)

and one new diagram where the sampler-sample doesn't emit the last value:

![image](https://cloud.githubusercontent.com/assets/1269832/21642917/b4dc257c-d285-11e6-8f25-707043957f26.png)

The default sampler-sample should use this and the `emitLast == true` version can use the current diagram.

(I don't have a Mac thus can't run OmniGraffle).

Related: #4952",2017-01-04 13:01:02,2017-01-04 15:21:41,https://api.github.com/repos/ReactiveX/RxJava/issues/4955,"['2.x', 'Enhancement']",801,38,ReactiveX_RxJava_pull_4955.diff
ReactiveX/RxJava,2.0.4 javadoc,Updated javadoc files to 2.0.4,2017-01-04 09:30:28,2017-01-04 09:30:46,https://api.github.com/repos/ReactiveX/RxJava/issues/4953,"['2.x', 'Documentation']",100976,3280,ReactiveX_RxJava_pull_4953.diff
ReactiveX/RxJava,fix javadoc for BehaviorSubject,-fix examples for creating BehaviorSubject with or without initial value.,2017-01-03 06:06:51,2017-01-03 15:11:38,https://api.github.com/repos/ReactiveX/RxJava/issues/4951,"['2.x', 'Documentation']",5,5,ReactiveX_RxJava_pull_4951.diff
ReactiveX/RxJava,1.x: header and whitespace cleanup,"  - Add missing header to 3 files
  - Remove trailing whitespaces from recent additions",2016-12-30 12:41:57,2016-12-30 15:20:26,https://api.github.com/repos/ReactiveX/RxJava/issues/4949,"['1.x', 'Cleanup']",54,6,ReactiveX_RxJava_pull_4949.diff
ReactiveX/RxJava,2.x: A simple Javadoc typo fix.,"Fixed Javadoc for SingleToObservable, MaybeToObservable, CompletableToObservable",2016-12-30 08:45:38,2016-12-30 08:59:37,https://api.github.com/repos/ReactiveX/RxJava/issues/4946,"['2.x', 'Documentation']",7,2,ReactiveX_RxJava_pull_4946.diff
ReactiveX/RxJava,2.x: fix timeout with fallback not cancelling the main source,"This PR fixes the lack of dispose/cancel call towards the upstream in the timed+fallback `timeout` operator version.

In addition, the selector version received similar unit tests to ensure they work properly (they did).

Related: #4944.",2016-12-29 18:33:46,2016-12-29 19:29:50,https://api.github.com/repos/ReactiveX/RxJava/issues/4945,"['2.x', 'Bug']",152,9,ReactiveX_RxJava_pull_4945.diff
ReactiveX/RxJava,2.x: fix publish(Function) not replenishing its queue,"I was working on converting the [Monte Carlo PI benchmark](http://swave.io/usage/show-off/monte-carlo-pi.html) to RxJava 2 and it turned out I forgot to replenish the internal queue of `publish(Function)` in case the upstream was not sync-fuseable.

This PR fixes the replenishment problem for non-fused and async-fused sources by requesting after 75% consumption.

In addition, if an inner subscriber cancelled while it was at request 0, the other inner subscribers might not have resumed draining.

I've also fixed two unit tests with wrong timeout unit of measure that randomly failed the tests on a slow machine or travis (#4902).",2016-12-29 16:09:51,2016-12-29 16:41:04,https://api.github.com/repos/ReactiveX/RxJava/issues/4943,"['2.x', 'Bug']",105,6,ReactiveX_RxJava_pull_4943.diff
ReactiveX/RxJava,1.x: Completable.mergeDelayError check unsafe availability,"This PR fixes the unconditional use of `MpscLinkedQueue` when Unsafe is not available or has been disabled inside `CompletableOnSubscribeMergeDelayErrorIterable`.

Related: #4940",2016-12-28 19:37:39,2016-12-28 21:03:45,https://api.github.com/repos/ReactiveX/RxJava/issues/4941,"['1.x', 'Bug']",9,2,ReactiveX_RxJava_pull_4941.diff
ReactiveX/RxJava,2.x: Fixed Javadoc for SingleToObservable,A simple Javadoc typo fix.,2016-12-28 08:10:59,2016-12-30 08:30:43,https://api.github.com/repos/ReactiveX/RxJava/issues/4939,"['2.x', 'Cleanup']",1,1,ReactiveX_RxJava_pull_4939.diff
ReactiveX/RxJava,Cleaner integration with CompositeDisposable,"Added a convenience method to allow for cleaner, more readable Disposable management;

Adding a disposeWith(Disposable d) method would allow for cleaner, more readable code. Implementation would be simple with something along the lines of:
```
void disposeWith(Disposable d){
    d.add(this);
}
```

Then subscription can be simplified from
```
Disposable d = observable
    .subscribe(() -> foo());
compositeDisposable.add(d);
```
to
```
observable
    .subscribe(()->foo())
    .disposeWith(compositeDisposable);
```
",2016-12-22 06:59:32,2016-12-22 07:23:52,https://api.github.com/repos/ReactiveX/RxJava/issues/4936,[],5,0,ReactiveX_RxJava_pull_4936.diff
ReactiveX/RxJava,2.x: Unify CompositeDisposable error messages,Unifies the CompositeDisposable error messages and make them a bit more helpful. Just seeing `d is null` reads oddly,2016-12-21 09:38:48,2016-12-23 13:01:24,https://api.github.com/repos/ReactiveX/RxJava/issues/4934,[],6,6,ReactiveX_RxJava_pull_4934.diff
ReactiveX/RxJava,2.x: add safeguards to generate(),"`Flowable.generate()` and `Observable.generate()` lacked the safeguards that were present in 1.x. This adds those and adds extra state cleanup.

Related: #4931",2016-12-20 18:12:31,2016-12-21 08:28:14,https://api.github.com/repos/ReactiveX/RxJava/issues/4932,"['2.x', 'Bug']",157,23,ReactiveX_RxJava_pull_4932.diff
ReactiveX/RxJava,2.x: add Completable.cache(),"This PR adds the operator `cache()` to `Completable` to cache the terminal event of a `Completable` sequence.

I came across the need for this when [answering a question](http://stackoverflow.com/a/41241793/61158) where the intent of using `Completable` was to indicate an operation has completed but not actually trigger the operation whenever one subscribed.

A small drawback, just like with other `cache()` operators is that once connected, there is no way for cancel it from within the operator itself. Returning `Completable & Disposable` doesn't work because of the the type restriction of `RxJavaPlugins.onAssembly`. There could be a `cache(Consumer<? super Disposable> onDispose)` overload or an example showing `source.ambWith(disposer).cache()`.",2016-12-20 15:18:10,2016-12-20 16:51:20,https://api.github.com/repos/ReactiveX/RxJava/issues/4930,"['2.x', 'Enhancement']",460,1,ReactiveX_RxJava_pull_4930.diff
ReactiveX/RxJava,2.x: don't call the Thread's uncaught handler from RxJavaPlugins.onError,This PR removes the call to the current thread's uncaught exception handler if there is no `RxJavaPlugins.onError` handler setup. The default behavior of the `UncaughtExceptionHandler` on Android crashes the whole app. Unit tests that expected this call are modified/disabled.,2016-12-19 14:14:07,2017-01-04 14:05:12,https://api.github.com/repos/ReactiveX/RxJava/issues/4928,"['2.x', 'Cleanup']",16,15,ReactiveX_RxJava_pull_4928.diff
ReactiveX/RxJava,2.x: fix timer() ISE due to bad resource mgmt,"Both `Observable.timer()` and `Flowable.timer()` could report `IllegalStateException` because if the delayed task completed before the task's `Disposable` was set, the `setOnce` found a non-null, non-terminal reference already set.

Related: #4926.",2016-12-19 08:19:51,2016-12-20 08:31:27,https://api.github.com/repos/ReactiveX/RxJava/issues/4927,"['2.x', 'Bug']",73,10,ReactiveX_RxJava_pull_4927.diff
ReactiveX/RxJava,2.x: Change Completable to CompletableSource,"Changing `Completable` to `CompletableSource`. Also found one other wrong spot that I fixed within this PR.

Fixes #4923 ",2016-12-16 13:24:49,2016-12-16 17:25:07,https://api.github.com/repos/ReactiveX/RxJava/issues/4924,"['2.x', 'Bug']",2,2,ReactiveX_RxJava_pull_4924.diff
ReactiveX/RxJava,2.x: fix TestSubscriber/Observer message texts,"Fix the wrong messages in `TestSubscriber` and `TestObserver`.

Related: #4920.",2016-12-15 12:45:13,2016-12-15 14:53:27,https://api.github.com/repos/ReactiveX/RxJava/issues/4921,"['2.x', 'Cleanup']",3,3,ReactiveX_RxJava_pull_4921.diff
ReactiveX/RxJava,Update Observable.java,"Thank you for contributing to RxJava. Before pressing the ""Create Pull Request"" button, please consider the following points:

  - [x] Please give a description about what and why you are contributing, even if it's trivial.

  - [x] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.

  - [x] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator, (if applicable) please make sure you have tests for working with an `empty`, `just`, `range` of values as well as an `error` source, with and/or without backpressure and see if unsubscription/cancellation propagates correctly.

change the order of generalized types of Operator to be consistent with Func1",2016-12-14 08:55:50,2016-12-15 08:20:48,https://api.github.com/repos/ReactiveX/RxJava/issues/4919,['1.x'],1,1,ReactiveX_RxJava_pull_4919.diff
ReactiveX/RxJava,#4914 Add support for Notification for rx.Single,"This pull request is created to add support for Notification in rx.Single.

This SingleNotification class provides two kinds of notifications.

- OnSuccess
- OnError

emitted out of rx.Single.

",2016-12-11 04:38:58,2016-12-11 16:36:59,https://api.github.com/repos/ReactiveX/RxJava/issues/4915,[],423,0,ReactiveX_RxJava_pull_4915.diff
ReactiveX/RxJava,Fix resolveAndroidApiVersion when running under Robolectric,"This is addressing issue #4697.

`PlatformDependent.resolveAndroidApiVersion()` tries to determine the Android SDK version by reading the `android.os.Build$VERSION#SDK_INT` field. When running under Robolectric, the class will be found (since Robolectric bundles an original android.jar). However, the method is using the system class loader for loading it (instead of the Robolectric instrumenting class loader), which will not instrument the class to run in the JVM. As a result, static initialization of the class fails with
an UnsatisfiedLinkError when calling `SystemProperties.get()`, which calls native method native_get.

I fixed by using the default class loader instead. This would only make a difference in the extremely rare case that the Android application installs a class loader that's not capable of finding Android classes. I tested that this behaves as expected on a device, fixes the issue with Robolectric, and detects it's not Android otherwise (as proven by the unit test).",2016-12-09 11:05:18,2016-12-09 17:03:19,https://api.github.com/repos/ReactiveX/RxJava/issues/4912,"['1.x', 'Android', 'Enhancement']",10,20,ReactiveX_RxJava_pull_4912.diff
ReactiveX/RxJava,2.x: fix & update Observable.repeatWhen and retryWhen (again),"This PR fixes the `Observable.repeatWhen` not completing properly if the handler completes. In addition, the `ObservableRedo` has been split to `ObservableRetryWhen` and `ObservableRepeatWhen` just like their `Flowable` counterpart and are now they use a less convoluted algorithm.

Related: #4909",2016-12-09 09:18:52,2016-12-09 17:24:31,https://api.github.com/repos/ReactiveX/RxJava/issues/4911,"['2.x', 'Bug', 'Enhancement']",406,390,ReactiveX_RxJava_pull_4911.diff
ReactiveX/RxJava,2.x: fix & update Observable.repeatWhen and redoWhen,"This PR fixes the `Observable.repeatWhen` not completing properly if the handler completes. In addition, the `ObservableRedo` has been split to `ObservableRetryWhen` and `ObservableRepeatWhen` just like their `Flowable` counterpart and are now they use a less convoluted algorithm.

Related: #4909",2016-12-09 09:13:29,2016-12-09 09:17:53,https://api.github.com/repos/ReactiveX/RxJava/issues/4910,"['2.x', 'Bug', 'Enhancement']",406,390,ReactiveX_RxJava_pull_4910.diff
ReactiveX/RxJava,Use t instead of value to allow for IDE naming 1.x,"Same as https://github.com/ReactiveX/RxJava/pull/4907 but for 1.x. Most places already named the variable `t`, there were just a few missing.
",2016-12-07 00:17:58,2016-12-07 07:53:50,https://api.github.com/repos/ReactiveX/RxJava/issues/4908,"['1.x', 'Cleanup']",5,5,ReactiveX_RxJava_pull_4908.diff
ReactiveX/RxJava,Use t instead of value to allow for IDE naming,"Naming the value `t` instead of `value` allows the IntelliJ to intelligently name the variable based on the type when autocompleting. 


Before:
```
Single.just(new Dog()).subscribe(new SingleObserver<String>() {
            @Override
            public void onSubscribe(Disposable d) {
                
            }

            @Override
            public void onSuccess(Dog value) {

            }

            @Override
            public void onError(Throwable e) {

            }
        });
```
After:
```
Single.just(new Dog()).subscribe(new SingleObserver<String>() {
            @Override
            public void onSubscribe(Disposable d) {

            }

            @Override
            public void onSuccess(Dog dog) {

            }

            @Override
            public void onError(Throwable e) {

            }
        });
```",2016-12-07 00:02:33,2016-12-07 07:53:21,https://api.github.com/repos/ReactiveX/RxJava/issues/4907,"['2.x', 'Cleanup']",6,6,ReactiveX_RxJava_pull_4907.diff
ReactiveX/RxJava,"2.x: Observable.scan, no seed - fix post-terminal behaviour","This PR
* ensures that scan function throwing cannot result in two terminal events (error or complete) and that additional error event is reported to `RxJavaPlugins` error handler.
* ensures that scan function if throws is not called again",2016-12-04 06:48:01,2016-12-04 09:07:53,https://api.github.com/repos/ReactiveX/RxJava/issues/4904,"['2.x', 'Bug']",101,1,ReactiveX_RxJava_pull_4904.diff
ReactiveX/RxJava,2.x: doAfterNext - prevent post-error calls to consumer,"This PR
* prevents further calls to the consumer if an error has been thrown",2016-12-03 21:43:33,2016-12-03 22:03:35,https://api.github.com/repos/ReactiveX/RxJava/issues/4903,"['2.x', 'Bug']",47,0,ReactiveX_RxJava_pull_4903.diff
ReactiveX/RxJava,2.x: FlowableScan - prevent multiple terminal emissions,"For scan without seed this PR
* prevents multiple terminal events being emitted when the scan function throws
* prevents processing of a later `onNext` if the previous `onNext` processing resulted in an error emission
* ensures post terminal errors are reported to `RxJavaPlugins` error handler

For scan with seed (forgot this one in the last PR)
* ensures post terminal errors are reported to `RxJavaPlugins` error handler",2016-12-03 21:17:21,2016-12-03 21:41:40,https://api.github.com/repos/ReactiveX/RxJava/issues/4901,"['2.x', 'Bug']",134,37,ReactiveX_RxJava_pull_4901.diff
ReactiveX/RxJava,2.x: Fix typo in DisposableHelper,Fixed a typo in DisposableHelper. `curren` -> `current`,2016-12-03 20:59:16,2016-12-03 21:23:50,https://api.github.com/repos/ReactiveX/RxJava/issues/4900,"['2.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_4900.diff
ReactiveX/RxJava,2.x: FlowableScanSeed - prevent multiple terminal events,"This PR
* prevents multiple terminal events being emitted when the scan function throws
* prevents processing of a later `onNext` if the previous `onNext` processing resulted in an error emission
* increases coverage to 100% of `FlowableScanSeed`

",2016-12-03 11:24:48,2016-12-03 16:28:31,https://api.github.com/repos/ReactiveX/RxJava/issues/4899,"['2.x', 'Bug']",99,0,ReactiveX_RxJava_pull_4899.diff
ReactiveX/RxJava,2.x: sys-property to disable calling uncaught exception handler,"This PR adds a new system property `rx2.onerror-nouncaught` to suppress calling the current thread's uncaught exception handler with the default `RxJavaPlugins.onError` as it crashes Android apps (on desktop, it either does nothing or prints the stacktrace).

Related: #4894, #4871, #4863, #4807",2016-11-29 17:49:35,2016-12-12 10:33:29,https://api.github.com/repos/ReactiveX/RxJava/issues/4895,['Enhancement'],20,3,ReactiveX_RxJava_pull_4895.diff
ReactiveX/RxJava,2.x: fix compilation errors when using Java 8,"This PR fixes a few compilation errors that happen when the project is compiled with Java 8 target (Eclipse is even slower then).

Some covariant casts don't work in 8 and some type arguments inferred as Object get inferred as a more concrete type in 8. The slight drawback is that with the changes, Java 6 compilation needs extra suppressions.",2016-11-28 16:32:23,2016-11-28 21:07:44,https://api.github.com/repos/ReactiveX/RxJava/issues/4893,"['2.x', 'Cleanup']",18,15,ReactiveX_RxJava_pull_4893.diff
ReactiveX/RxJava,Update CHANGES.md,fix URL typo,2016-11-28 11:34:20,2016-11-28 12:14:19,https://api.github.com/repos/ReactiveX/RxJava/issues/4892,"['1.x', 'Documentation']",1,1,ReactiveX_RxJava_pull_4892.diff
ReactiveX/RxJava,"2.x: Issue and PR ""welcome"" templates","This PR adds a basic GitHub template that is presented for new Issues and PRs once 2.x becomes the default branch, similar to #4890.",2016-11-28 11:00:58,2016-11-28 14:52:58,https://api.github.com/repos/ReactiveX/RxJava/issues/4891,"['2.x', 'Documentation']",20,0,ReactiveX_RxJava_pull_4891.diff
ReactiveX/RxJava,"1.x: add Issue and PR ""welcome"" templates",This PR adds a basic GitHub template that is presented for new Issues and PRs. This helps me maintain focus on important issues rather than questions that can be googled or asked on StackOverflow.,2016-11-28 10:59:46,2016-11-28 14:41:00,https://api.github.com/repos/ReactiveX/RxJava/issues/4890,"['1.x', 'Documentation']",20,0,ReactiveX_RxJava_pull_4890.diff
ReactiveX/RxJava,2.x: dedicated reduce() op implementations,"This PR adds dedicated operator implementations to

  - `Flowable.reduce(seed, reducer)` (returns `Single`),
  - `Flowable.reduceWith(seedSupplier, reducer)`  (returns `Single`),
  - `Observable.reduce(reducer)` (returns `Maybe`),
  - `Observable.reduce(seed, reducer)`  (returns `Single`) and
  - `Observable.reduceWith(seedSupplier, reducer)`  (returns `Single`)

instead of using `scan().takeLast(1)` (`Flowable.reduce(reducer)` already had a dedicated operator).

Comparison (Celeron 1005M, 4GB RAM, Windows 7 x64, Java 8u112, JMH 1.16):

![image](https://cloud.githubusercontent.com/assets/1269832/20644317/a411f9ba-b430-11e6-8fa7-0db5195f4ddd.png)

The new `ReducePerf` benchmark does a simple sum over a list of integer values. Unfortunately, this creates a lot of garbage for longer sequences (plus the CPU/RAM is not really suited for such benchmarks; the `flowMaybe` lines should be roughly the same since the code didn't change but there is a significant run-to-run variance).",2016-11-26 22:38:11,2016-11-28 08:08:13,https://api.github.com/repos/ReactiveX/RxJava/issues/4885,"['2.x', 'Performance']",616,7,ReactiveX_RxJava_pull_4885.diff
ReactiveX/RxJava,1.x: enable TestScheduler with nanosecond periodic scheduling,"The default periodic scheduling code accessed the current worker time as milliseconds which prevents running microsecond and nanosecond scale unit tests with TestScheduler as its internal nanosecond resolution time is always converted, losing precision.

This PR introduces the internal `SchedulePeriodicHelper` class, moves the default scheduling code into a static method and defines a `NowNanoSupplier` interface that is now implemented by TestSchedulerWorker to return the current nano time. The default `Worker.schedulePeriodically` delegates to this static method and given a `null` `noNanoSupplier` the `Worker.now()` is converted to nanoseconds as usual.

Related: #4883",2016-11-25 15:52:08,2016-11-28 08:07:53,https://api.github.com/repos/ReactiveX/RxJava/issues/4884,"['1.x', 'Bug']",147,70,ReactiveX_RxJava_pull_4884.diff
ReactiveX/RxJava,2.x: Common test classes for Processors.,Caused by https://github.com/JakeWharton/RxRelay/pull/20#discussion_r89308736,2016-11-24 10:59:36,2016-11-24 13:15:56,https://api.github.com/repos/ReactiveX/RxJava/issues/4882,"['2.x', 'Test']",183,283,ReactiveX_RxJava_pull_4882.diff
ReactiveX/RxJava,Add CheckReturnValue annotation,"First draft on this.

So far I have only annotated `subscribeWith()` and `test()` methods.

I checked this against Error Prone and their [check](http://errorprone.info/bugpattern/CheckReturnValue) is able of picking up the RxJava annotation.

How do you feel if I extend `BaseTypeAnnotations` to test for `@CheckReturnValue` too?

Related #4878 ",2016-11-24 09:17:47,2016-11-26 12:41:37,https://api.github.com/repos/ReactiveX/RxJava/issues/4881,"['2.x', 'Enhancement']",1331,8,ReactiveX_RxJava_pull_4881.diff
ReactiveX/RxJava,2.x: Apply missing RxJavaPlugins.onAssembly on ops,This PR adds the missing calls to `RxJavaPlugins.onAssembly` on a few operators.,2016-11-23 12:53:04,2016-11-23 15:00:05,https://api.github.com/repos/ReactiveX/RxJava/issues/4877,"['2.x', 'Bug']",6,6,ReactiveX_RxJava_pull_4877.diff
ReactiveX/RxJava,Remove empty list item from `io.reactivex.package-info.java`,,2016-11-23 02:42:31,2016-11-23 08:23:46,https://api.github.com/repos/ReactiveX/RxJava/issues/4874,"['2.x', 'Documentation']",0,1,ReactiveX_RxJava_pull_4874.diff
ReactiveX/RxJava,2.x: TestObserver shouldn't clear the upstream disposable on terminated,"`TestObserver` replaced the upstream's `Disposable` with the disposed-sentinel when it got a terminal event (unlike `TestSubscriber`) and there seems to be a need for triggering `dispose` in some upstream even after that. This PR changes this behavior and also updates unit tests that expect `isDisposed()` true without actually calling `dispose()`.

Related #4872 ",2016-11-22 17:07:35,2016-11-22 17:30:15,https://api.github.com/repos/ReactiveX/RxJava/issues/4873,"['2.x', 'Bug']",43,15,ReactiveX_RxJava_pull_4873.diff
ReactiveX/RxJava,Added assertForEachValue for TestSubscriber usage,"Example implementation for a proposed `testForEachValue` method, rf #4867, which can be applied to fluently test whether all emitted values adhere to some predicate.

If there is interest and the project maintainers/contributors see use in its addition, I will also write tests for the method.",2016-11-18 15:35:30,2016-12-12 10:33:51,https://api.github.com/repos/ReactiveX/RxJava/issues/4868,"['2.x', 'Feature-Request']",20,0,ReactiveX_RxJava_pull_4868.diff
ReactiveX/RxJava,Cycle midstream,In the middle of trying to break memory cycles and get unit tests to work.,2016-11-16 15:12:05,2016-11-16 15:13:06,https://api.github.com/repos/ReactiveX/RxJava/issues/4860,[],490512,1120,ReactiveX_RxJava_pull_4860.diff
ReactiveX/RxJava,2.x: add Maybe.flatMapSingleElement returning Maybe,"This PR adds the `Maybe.flatMapSingleElement()` operator that returns a `Maybe` and completes if the source completes unlike `flatMapSingle` where the returned `Single` signals `NoSuchElementException`.

Related #4857",2016-11-16 08:40:33,2016-11-18 07:57:52,https://api.github.com/repos/ReactiveX/RxJava/issues/4858,"['2.x', 'Enhancement']",307,0,ReactiveX_RxJava_pull_4858.diff
ReactiveX/RxJava,1.x: Single::takeUntil CancellationException message enh.,"This PR modifies the `CancellationException` message to include the operator name and source type.

Relate: #4756",2016-11-15 09:46:06,2016-11-15 21:26:49,https://api.github.com/repos/ReactiveX/RxJava/issues/4852,['Enhancement'],64,3,ReactiveX_RxJava_pull_4852.diff
ReactiveX/RxJava,1.x: add Single.fromEmitter,"This PR adds the `Single.fromEmitter` operator, driving a `SingleEmitter` instance similar to `Observable.fromEmitter` and `Completable.fromEmitter`.",2016-11-15 09:23:53,2016-11-15 21:19:51,https://api.github.com/repos/ReactiveX/RxJava/issues/4851,"['1.x', 'Enhancement']",497,42,ReactiveX_RxJava_pull_4851.diff
ReactiveX/RxJava,1.x: fix Completable.concat & merge hanging in async situations,"This PR fixes the hang in `Completable.concat(Observable)` and `Completable.merge(Observable)` mainly due to using `subscribe` instead of `unsafeSubscribe`. The underlying problem was that `SafeSubscriber` unsubscribed the dowstream consumer which cancelled the outstanding elements of `range`.

In addition, I've upgraded the `concat(Observable)` to use an up-to-date concatenation algorithm and more compact memory footprint.",2016-11-14 19:17:59,2016-11-14 19:42:38,https://api.github.com/repos/ReactiveX/RxJava/issues/4849,"['1.x', 'Bug']",132,34,ReactiveX_RxJava_pull_4849.diff
ReactiveX/RxJava,"1.x: remove ObjectPool, code style cleanups","This PR removes the `ObjectPool` and `SynchronizedQueue`  as their utility now seems surpassed.

In addition, this PR contains a bunch of code style cleanups. Use the `?w=1` [parameter to hide whitespace changes](https://github.com/ReactiveX/RxJava/pull/4846/files?w=1).

Other changes:

  - fix finality of `BackpressureOverflow`
  - introduce the system parameter for io scheduler time-to-live counter: `rx.io-scheduler.keepalive`
  - mention scheduler system parameters in the `Schedulers` javadoc",2016-11-13 22:28:49,2016-11-14 18:12:50,https://api.github.com/repos/ReactiveX/RxJava/issues/4846,"['1.x', 'Enhancement']",607,1065,ReactiveX_RxJava_pull_4846.diff
ReactiveX/RxJava,2.0.1 javadoc,Update the gh-pages javadoc to 2.0.1,2016-11-12 17:08:48,2016-11-12 17:11:24,https://api.github.com/repos/ReactiveX/RxJava/issues/4842,['Documentation'],96116,903,ReactiveX_RxJava_pull_4842.diff
ReactiveX/RxJava,1.x: replace non-serializable value of OnNextValue with its toString,"When certain operators crash, they attach the current value to the exception via `OnErrorThrowable.addValueAsLastCause`, however, the value may not be serializable and the Throwable itself is, that causes a serialization exception.

This PR replaces such values with their `String.valueOf` representation or the crash message if `toString` failed on that object.

This was reported in #4562 with the suggestion of making the internal field `transient`. The problem with that is that upon deserialization, the field is null and there is no way of knowing if the original value was really null or just not serializable. Using `String.valueOf` at least gives a chance to know it was non-null and gets across some information about the original value.",2016-11-12 12:24:44,2016-11-12 18:31:35,https://api.github.com/repos/ReactiveX/RxJava/issues/4841,['Bug'],59,16,ReactiveX_RxJava_pull_4841.diff
ReactiveX/RxJava,"2.x: javadoc: fix wording of some operators, remove @throws implications","This PR fixes some javadoc mistakes with operators such as `single`, `first`, `last` and co and removes `@throws` tags from operators since those don't throw it when the method is invoked.",2016-11-11 22:36:19,2016-11-11 23:10:16,https://api.github.com/repos/ReactiveX/RxJava/issues/4839,['Documentation'],76,98,ReactiveX_RxJava_pull_4839.diff
ReactiveX/RxJava,2.x: add fluent requestMore to TestSubscriber,This PR just adds the `TestSubscriber.requestMore` that calls `request` and returns `this` for method chaining purposes.,2016-11-11 18:47:06,2016-11-11 19:01:39,https://api.github.com/repos/ReactiveX/RxJava/issues/4838,['Enhancement'],26,1,ReactiveX_RxJava_pull_4838.diff
ReactiveX/RxJava,2.x: add doAfterNext & doAfterSuccess to the other types,"This PR adds `Observable.doAfterNext`, `Maybe.doAfterSuccess` and `Single.doAfterSuccess`.",2016-11-11 09:04:00,2016-11-11 17:11:44,https://api.github.com/repos/ReactiveX/RxJava/issues/4835,['Enhancement'],887,0,ReactiveX_RxJava_pull_4835.diff
ReactiveX/RxJava,2.x: add `Flowable.doAfterNext` operator + 3 doX TCKs,"This PR adds the `Flowable.doAfterNext` operator which calls a `Consumer` after the call to `downstream.onNext()` with the same value.

In addition, `doOnNext`, `doAfterNext` and `doFinally` received their Reactive-Streams TCK tests.",2016-11-10 18:57:23,2016-11-11 08:04:47,https://api.github.com/repos/ReactiveX/RxJava/issues/4833,['Enhancement'],523,0,ReactiveX_RxJava_pull_4833.diff
ReactiveX/RxJava,2.x: add doFinally to the rest of the reactive base classes,This PR adds the `doFinally` operator to the rest of the base reactive classes.,2016-11-10 15:23:03,2016-11-10 17:16:55,https://api.github.com/repos/ReactiveX/RxJava/issues/4832,['Enhancement'],1388,6,ReactiveX_RxJava_pull_4832.diff
ReactiveX/RxJava,2.x: add doFinally for handling post-terminal or cancel cleanup,"This PR adds the `Flowable.doFinally` method that executes an action when the upstream terminates or the downstream cancels (but only once per subscriber). Formerly, one could use `doAfterTerminate` + `doOnCancel` together but no support for making sure only one executed the cleanup action.

Based on the feedback, the rest of the base reactive types can get the same operator a bit later.",2016-11-10 12:53:56,2016-11-10 14:23:11,https://api.github.com/repos/ReactiveX/RxJava/issues/4831,['Enhancement'],732,0,ReactiveX_RxJava_pull_4831.diff
ReactiveX/RxJava,1.x: Completable.doAfterTerminate to run after onError as well,"DoAfterTerminate was intended to call the callback after either onCompleted or onError but somehow missed that behavior in 1.x.

Related: #4822",2016-11-10 08:22:19,2016-11-10 14:22:25,https://api.github.com/repos/ReactiveX/RxJava/issues/4830,['Bug'],14,8,ReactiveX_RxJava_pull_4830.diff
ReactiveX/RxJava,changing inner classes to package-private.,to fix issue in #4826,2016-11-10 00:32:57,2016-11-10 08:01:36,https://api.github.com/repos/ReactiveX/RxJava/issues/4828,['Cleanup'],4,4,ReactiveX_RxJava_pull_4828.diff
ReactiveX/RxJava,Porting the Scheduler.when operator from 1.x to 2.x,In fixing the Scheduler.when in 1.x I noticed that it hadn't been ported to 2.x. This PR tries to fix that translating Observable to Flowable and Subscription to Disposable. This also includes the fix from 1.x,2016-11-09 22:43:40,2016-11-10 14:26:30,https://api.github.com/repos/ReactiveX/RxJava/issues/4827,['Enhancement'],610,0,ReactiveX_RxJava_pull_4827.diff
ReactiveX/RxJava,Schedule when bug fix,"In using this in production we found a bug where some actions were dropped.  I've tracked it down to the premature onCompleted and unsubscription of the completable that represents the scheduled action causes the future to get canceled before it is started.

The fix was to delay the onCompleted until the action was truly done.

I did the PR as two commits because the first one is changing all the tabs to spaces! Look at the second commit for the actual functional difference.",2016-11-09 22:37:59,2016-11-09 22:55:03,https://api.github.com/repos/ReactiveX/RxJava/issues/4826,['Bug'],224,191,ReactiveX_RxJava_pull_4826.diff
ReactiveX/RxJava,1.x: update AssertableSubscriber API and add Javadoc,"This PR adds 3 convenience methods - `assertResult`, `assertFailure` and `assertFailureAndMessage` from 2.x, makes the `assertValueCount` fluent to allow chaining a subsequent `requestMore` call and adds the missing JavaDoc to the `AssertableSubscriber` interface.",2016-11-09 10:46:18,2016-11-10 08:13:06,https://api.github.com/repos/ReactiveX/RxJava/issues/4824,"['Cleanup', 'Documentation', 'Enhancement']",438,38,ReactiveX_RxJava_pull_4824.diff
ReactiveX/RxJava,2.x: Observable.repeatWhen fix for onError,`Observable.repeatWhen` was not properly signalling an upstream `onError` case. The `Flowable.repeatWhen` works as expected.,2016-11-07 18:26:21,2016-11-07 18:58:50,https://api.github.com/repos/ReactiveX/RxJava/issues/4819,['Bug'],50,7,ReactiveX_RxJava_pull_4819.diff
ReactiveX/RxJava,fix typo in javadoc of Maybe::toSingle,,2016-11-06 16:57:35,2016-11-06 17:14:50,https://api.github.com/repos/ReactiveX/RxJava/issues/4815,['Documentation'],2,2,ReactiveX_RxJava_pull_4815.diff
ReactiveX/RxJava,Subtle change in Completable's documentation for retryWhen.,Small change as discussed in #4809 ,2016-11-04 21:16:43,2016-11-04 21:46:28,https://api.github.com/repos/ReactiveX/RxJava/issues/4810,['Documentation'],1,1,ReactiveX_RxJava_pull_4810.diff
ReactiveX/RxJava,Fix typo,,2016-11-04 01:48:56,2016-11-04 08:11:19,https://api.github.com/repos/ReactiveX/RxJava/issues/4803,[],2,2,ReactiveX_RxJava_pull_4803.diff
ReactiveX/RxJava,documentation updates,,2016-11-03 08:55:12,2016-11-03 15:25:29,https://api.github.com/repos/ReactiveX/RxJava/issues/4798,['Documentation'],2,2,ReactiveX_RxJava_pull_4798.diff
ReactiveX/RxJava,2.x: Fix exceptions in javaDoc,"I've corrected some javadocs for methods that check arguments using `ObjectHelper.requireNonNull(arg, ""message"")`. It throws `NullPointerException` instead of `IllegalArgumentException`, but as we know copy-pasting is an insidious thing. ;)",2016-11-02 12:03:12,2016-11-02 12:38:06,https://api.github.com/repos/ReactiveX/RxJava/issues/4793,[],12,12,ReactiveX_RxJava_pull_4793.diff
ReactiveX/RxJava,Fixed detection of TestObserver.assertNotSubscribed(),"It wasn't working post-subscription, but now it checks for DISPOSED

Fixes #4790",2016-10-31 21:35:07,2016-11-01 13:21:01,https://api.github.com/repos/ReactiveX/RxJava/issues/4792,[],11,1,ReactiveX_RxJava_pull_4792.diff
ReactiveX/RxJava,1.x: Add null check to Observable.switchIfEmpty,#4762,2016-10-31 21:29:26,2016-11-01 14:32:04,https://api.github.com/repos/ReactiveX/RxJava/issues/4791,['Bug'],10,0,ReactiveX_RxJava_pull_4791.diff
ReactiveX/RxJava,2.x: fix Observable.repeatWhen & retryWhen not disposing the inner,"The `Observer` that is subscribing to the `Observable` returned by the handler function was not properly linked to the disposing of the end Observer. This PR fixes it by making that `Observer` do async `Disposable` management and make sure the end `Observer` receives a disposable list with both the main and the handler `Disposable`s.

The `Flowable` versions worked properly but added unit tests to them regardless.

Reported in #4782.
",2016-10-30 18:06:47,2016-10-31 14:05:56,https://api.github.com/repos/ReactiveX/RxJava/issues/4783,['Bug'],123,17,ReactiveX_RxJava_pull_4783.diff
ReactiveX/RxJava,Add Javadoc 2.0.0 final,"Update to 2.0.0 final javadocs.
",2016-10-29 11:54:19,2016-10-29 11:55:42,https://api.github.com/repos/ReactiveX/RxJava/issues/4780,['Documentation'],98460,3420,ReactiveX_RxJava_pull_4780.diff
ReactiveX/RxJava,1.x: support Observable.test(),"The new method chaining `TestSubscriber` in 2.x is too good not to have in 1.x as well (while I wait for 2.x to mature and to make my existing unit tests less verbose).

``` java
Observable
  .just(1)
  .test()
  .assertValue(1)
  .assertCompleted();
```

`Observable.test()` returns a `TestSubscriber2` that wraps a `TestSubscriber` and enables method chaining where it can.

I've added tests to get to 100% test coverage though I've been pretty slap-dash about testing some of the details (for example I haven't tested that `awaitXXX` really does wait for stuff).

I've noted it as `@since 1.2.3` but can update to 1.2.2 if you are happy to squeak it into the release.
",2016-10-28 04:04:12,2016-11-09 09:33:54,https://api.github.com/repos/ReactiveX/RxJava/issues/4777,"['Enhancement', 'Feature-Request']",648,0,ReactiveX_RxJava_pull_4777.diff
ReactiveX/RxJava,2.x: allow subscribeOn to work with blocking create,"When running a blocking emission in `Flowable.create` with `subscribeOn`, the default behavior of `subscribeOn` is to schedule downstream requests onto the same thread. Unfortunately, the blocking emission prevents the backing threadpool the `create` from accumulating that request amount leading to either buffer bloat or dropped emissions till the very end of the sequence.

This PR introduces a `nonScheduledRequests` parameter to `subscribeOn` that simply calls the upstream's `request()` from the caller's thread without scheduling it. The parameter is not exposed to the surface API but the `subscribeOn` operator does an `instanceof` check to see if the upstream type is `FlowableCreate`.

Note that this requires a direct upstream `create` and any intermediate operator re-enables the default behavior. It is possible to traverse the upstream graph to locate a `FlowableCreate` but it has relatively high cost and thus penalizing all `subscribeOn` usages.

Related: #4735
",2016-10-26 07:27:16,2016-10-26 17:16:04,https://api.github.com/repos/ReactiveX/RxJava/issues/4770,['Bug'],68,6,ReactiveX_RxJava_pull_4770.diff
ReactiveX/RxJava,1.x: Add note to SingleSubscriber doc about unsubscribe invocation,"Add note to SingleSubscriber doc about unsubscribe invocation in onSuccess and onError.

I wanted to clarify this in the doc after reading #4716.
",2016-10-25 22:31:59,2016-10-26 15:43:55,https://api.github.com/repos/ReactiveX/RxJava/issues/4769,['Documentation'],3,0,ReactiveX_RxJava_pull_4769.diff
ReactiveX/RxJava,2.x: Rename BackpressureStrategy.NONE to MISSING,"As discussed in #4643.
",2016-10-25 16:04:22,2016-10-25 16:21:58,https://api.github.com/repos/ReactiveX/RxJava/issues/4767,[],25,25,ReactiveX_RxJava_pull_4767.diff
ReactiveX/RxJava,"2.x: cleanup, fixes and coverage 10/25","This is the last part of my dedicated coverage improvement run.
- Update code paths and remove unnecessary and unused parts.
- Fix `skipUntil` lifecycle and concurrency properties.
- Fix `concatMapEager` error management.
- `Flowable.scan(T, BiFunction)` now emits the initial value only when the upstream signals an event. This has the effect that even if there is a downstream request, the initial value won't get emitted. This change reduces the overhead of the operator greatly.
",2016-10-25 12:37:41,2016-10-25 14:44:40,https://api.github.com/repos/ReactiveX/RxJava/issues/4766,"['Bug', 'Cleanup', 'Coverage']",1339,434,ReactiveX_RxJava_pull_4766.diff
ReactiveX/RxJava,1.x: zip - check local boolean before volatile in logical and,"Minor perf improvement.  Local boolean variable check should be placed before volatile check in `&&` operation.
",2016-10-25 02:54:11,2016-10-25 07:51:47,https://api.github.com/repos/ReactiveX/RxJava/issues/4764,['Performance'],1,1,ReactiveX_RxJava_pull_4764.diff
ReactiveX/RxJava,2.x: cleanup & coverage 10/24-2,"- better coverage of `Flowable` operators
- cleanup of operator internals
- better coverage of standard Schedulers.
- rewrite of `takeUntil` to avoid `onSubscribe()` races.
",2016-10-24 21:59:30,2016-10-25 07:51:05,https://api.github.com/repos/ReactiveX/RxJava/issues/4763,"['Bug', 'Cleanup', 'Coverage']",1254,338,ReactiveX_RxJava_pull_4763.diff
ReactiveX/RxJava,"2.x: cleanup, fixes, coverage 10/24-1","- Remove unused or unnecessary code paths.
- Fix cancellation bugs in `Flowable` operators.
- Unify `MapNotification`, `Materialize`, `OnErrorReturn` last element backpressure under the same helper class.
- Move `FlowableBlockingIterator` into `FlowableBlockingIterable`.
- Reuse parts of `FlowableSequenceEqual` in `FlowableSequenceEqualSingle`.
",2016-10-24 14:14:20,2016-10-24 15:17:16,https://api.github.com/repos/ReactiveX/RxJava/issues/4761,"['Bug', 'Cleanup', 'Coverage']",2136,1030,ReactiveX_RxJava_pull_4761.diff
ReactiveX/RxJava,2.x: Add Single.fromObservable(ObservableSource),"- adds an overload to create a Single from an ObservableSource
",2016-10-24 13:26:55,2016-10-24 13:55:58,https://api.github.com/repos/ReactiveX/RxJava/issues/4760,['Enhancement'],60,3,ReactiveX_RxJava_pull_4760.diff
ReactiveX/RxJava,1.x: Add cache() to Single,"#4702

Uses the same test as the Observable one.
",2016-10-24 04:18:51,2016-10-24 22:14:58,https://api.github.com/repos/ReactiveX/RxJava/issues/4757,['Enhancement'],104,0,ReactiveX_RxJava_pull_4757.diff
ReactiveX/RxJava,2.x: fix window-timed test leaking an MBE that affects unrelated tests,"The `FlowableWindowWithTimeTest.restartTimerMany` did not wait for its source to receive the cancellation and subsequent tests could delay this cancel.

Related: #4750
",2016-10-22 17:08:48,2016-10-22 17:35:30,https://api.github.com/repos/ReactiveX/RxJava/issues/4755,['Test-Failures'],17,7,ReactiveX_RxJava_pull_4755.diff
ReactiveX/RxJava,2.x: Remove some unused fields,"Remove some unused fields that are either
- present in their parent class
- not set
",2016-10-22 12:23:27,2016-10-22 12:40:58,https://api.github.com/repos/ReactiveX/RxJava/issues/4754,['Cleanup'],1,16,ReactiveX_RxJava_pull_4754.diff
ReactiveX/RxJava,Add more new marble diagrams & update old ones,,2016-10-21 22:38:37,2016-10-21 22:56:34,https://api.github.com/repos/ReactiveX/RxJava/issues/4752,[],76,27,ReactiveX_RxJava_pull_4752.diff
ReactiveX/RxJava,2.x: fix Flowable.concatMapEager hang due to bad request management,"`Flowable.concatMapEager`'s drain loop when encountering a finished inner jumped back to the beginning of the loop but disregarded the potentially changed request amount and just stopped emitting. The fix is to use the typical request management approach of reading the current request at the beginning of the loop and then committing the emission amount before trying to leave the loop.

Related: #4620

In addition `TestHelper.assertError` has been changed to attach the whole unexpected exception to the `AssertionError`. 
",2016-10-21 22:37:56,2016-10-22 07:40:18,https://api.github.com/repos/ReactiveX/RxJava/issues/4751,"['Bug', 'Test-Failures']",52,37,ReactiveX_RxJava_pull_4751.diff
ReactiveX/RxJava,New 2.x marble diagrams,"Adds some new marble diagrams and adjusts some for operators that now return Single/Maybe/Completable where they used to return Observable in 1.x.
",2016-10-21 21:06:40,2016-10-21 21:23:38,https://api.github.com/repos/ReactiveX/RxJava/issues/4749,['Documentation'],39,39,ReactiveX_RxJava_pull_4749.diff
ReactiveX/RxJava,2.x: distinctUntilChanged to store the selected key instead of the value,"Fix `distinctUntilChanged` to store the selected key instead of the input value.

Reported in #4743 
",2016-10-21 17:05:14,2016-10-21 18:13:49,https://api.github.com/repos/ReactiveX/RxJava/issues/4747,['Bug'],178,117,ReactiveX_RxJava_pull_4747.diff
ReactiveX/RxJava,1.x: Remove unused helper class previously used by extend().,,2016-10-21 15:34:38,2016-10-21 17:41:38,https://api.github.com/repos/ReactiveX/RxJava/issues/4745,['Cleanup'],0,16,ReactiveX_RxJava_pull_4745.diff
ReactiveX/RxJava,2.x: Fixed Javadoc for Disposables.fromFuture,,2016-10-21 15:23:27,2016-10-21 17:19:15,https://api.github.com/repos/ReactiveX/RxJava/issues/4744,['Documentation'],3,3,ReactiveX_RxJava_pull_4744.diff
ReactiveX/RxJava,"2.x: coverage, fixes, cleanup 10/21-1","- fix `Flowable.materialize()` terminal signal emission in face of backpressure
- fix `Flowable.onErrorReturn()` terminal signal emission in face of backpressure
- cleanup `Flowable.publish()` and enable operator fusion on its input
- fix `Flowable.flatMapSingle()` and `Flowable.flatMapMaybe()` termination detection
- compact `Flowable.blockingSubscribe()` and `Observable.blockingSubscribe()`
- compact `Flowable.subscribeOn()`
",2016-10-21 12:06:49,2016-10-21 15:47:07,https://api.github.com/repos/ReactiveX/RxJava/issues/4742,"['Bug', 'Cleanup', 'Coverage']",927,671,ReactiveX_RxJava_pull_4742.diff
ReactiveX/RxJava,1.x: Error when tracking exception with unknown cause,"#4737
",2016-10-21 01:38:39,2016-10-22 17:58:53,https://api.github.com/repos/ReactiveX/RxJava/issues/4740,['Bug'],51,1,ReactiveX_RxJava_pull_4740.diff
ReactiveX/RxJava,"2.x: coverage, fixes, cleanup 10/20-2","I cut this short so there is time for the **2.0.0-RC release preparations**.
- Introduce `SimplePlainQueue` where `poll` doesn't throw, avoiding the need for try-catches where the queue is one of the standard lock-free queues.
- Fix `FlatMap` error, cancellation and resource management.
- Coverage of some `Flowable` operators
- Removal of impossible and unused code paths.
",2016-10-20 19:46:45,2016-10-20 20:39:15,https://api.github.com/repos/ReactiveX/RxJava/issues/4738,"['Bug', 'Cleanup', 'Coverage']",977,290,ReactiveX_RxJava_pull_4738.diff
ReactiveX/RxJava,"2.x: cleanup, fixes, coverage 10/20-1","- Finished covering `Observable` operators to a reasonable level (the remaining are either impossible or only reachable by probabilistic race)
- Synced operator coverage between `Observable` and `Flowable`
- Started covering `Flowable` operators
- Cleaning up a few `Flowable` operators (cache, concatMap)
- fix `onBackpressureBuffer(long, Action, BufferOverflowStrategy)` return type
- fix `concatMapDelayError` wrong barrier mode selected
",2016-10-20 14:17:39,2016-10-20 15:31:32,https://api.github.com/repos/ReactiveX/RxJava/issues/4736,"['Bug', 'Cleanup', 'Coverage']",2275,469,ReactiveX_RxJava_pull_4736.diff
ReactiveX/RxJava,"2.x: coverage, minor fixes, cleanup 10/19-2","- Improve coverage of a few `Observable` operators
- move some classes into their solo user parent class
- `checkDisposed` now calls `dispose`/`cancel` twice to have better conditional coverage of those methods
",2016-10-19 21:46:54,2016-10-20 06:45:03,https://api.github.com/repos/ReactiveX/RxJava/issues/4732,"['Cleanup', 'Coverage']",890,294,ReactiveX_RxJava_pull_4732.diff
ReactiveX/RxJava,2.x: Delegate null Collections down to onError in toList,"- if null from a collection supplier is returned delegate to onError
- adapted Flowable & Observable
- unified exception message
",2016-10-19 16:53:53,2016-10-19 19:25:52,https://api.github.com/repos/ReactiveX/RxJava/issues/4731,['Cleanup'],71,6,ReactiveX_RxJava_pull_4731.diff
ReactiveX/RxJava,"2.x: coverage, fixes, cleanup, copy to Flowable 10/19-1","- Explain `Observable.observeOn` unboundedness
- improve `Observable` operator coverage
- copy test methods over to `Flowable` operators
- apply fixes to `Flowable` operators
- add missing calls to `RxJavaPlugins.onError()`
- add more time to RS TCK test of `observeOn`
",2016-10-19 14:45:14,2016-10-19 15:47:22,https://api.github.com/repos/ReactiveX/RxJava/issues/4730,"['Bug', 'Cleanup', 'Coverage']",3679,421,ReactiveX_RxJava_pull_4730.diff
ReactiveX/RxJava,Merge FlowableEmitter.BackpressureMode into BackpressureStrategy,"This is the implementation of #4727 
",2016-10-19 10:53:31,2016-10-19 11:50:36,https://api.github.com/repos/ReactiveX/RxJava/issues/4729,['Cleanup'],234,121,ReactiveX_RxJava_pull_4729.diff
ReactiveX/RxJava,1.x: remove AsyncEmitter deprecations,"discussed in #4580
",2016-10-18 23:30:28,2016-10-19 07:10:51,https://api.github.com/repos/ReactiveX/RxJava/issues/4725,['Cleanup'],7,1530,ReactiveX_RxJava_pull_4725.diff
ReactiveX/RxJava,"2.x: coverage, fixes, enhancements, cleanup 10/18-1","- improve coverage of more `Observable` operators
- reduce allocation of `ConnectableObservable.connect(Consumer)` and `ConnectableFlowable.connect(Consumer)`
- enable fusion on `Observable.observeOn`
- fix fusion of `Observable.just`
- remove `flatMapIterable(Function, int)` overload and have `flatMapIterable(Function)` use the flatten operator.
- fix `Observable.replay()` potential emission before `onSubscribe` call
",2016-10-18 15:23:19,2016-10-18 16:20:47,https://api.github.com/repos/ReactiveX/RxJava/issues/4723,"['Bug', 'Cleanup', 'Coverage', 'Enhancement']",1783,295,ReactiveX_RxJava_pull_4723.diff
ReactiveX/RxJava,2.x: remove variance from the input source of retryWhen,"The variance of the `retryWhen` operator doesn't infere properly with java 8. This PR removes the `? extends` from the function's input `Observable`.

Reported in: https://twitter.com/HansWurst315/status/788108336285753344
",2016-10-17 21:27:33,2016-10-17 21:44:09,https://api.github.com/repos/ReactiveX/RxJava/issues/4720,['Bug'],8,8,ReactiveX_RxJava_pull_4720.diff
ReactiveX/RxJava,2.x: Distinct Operator - delegate null Collection down to onError,"- returning null as a Collection in the callable didn't go to onError
- adopted flowable & observable
",2016-10-17 16:08:10,2016-10-17 17:30:04,https://api.github.com/repos/ReactiveX/RxJava/issues/4718,['Bug'],30,2,ReactiveX_RxJava_pull_4718.diff
ReactiveX/RxJava,2.x: coverage and cleanup 10/17-1,"A small set of coverage and cleanup of `Observable` operators.
",2016-10-17 11:27:18,2016-10-17 17:15:53,https://api.github.com/repos/ReactiveX/RxJava/issues/4717,"['Cleanup', 'Coverage']",411,124,ReactiveX_RxJava_pull_4717.diff
ReactiveX/RxJava,"1.x: fix subscribe(Action1 [, Action1]) to report isUnsubscribed","The lambda version didn't report `isUnsubscribed()` as before because of the removal of the `SafeSubscriber` wrapping. This PR makes sure it reports consistently again.

Repored in: #4715

Note that there is no `unsafeSubscribe(SingleSubscriber)` so a regular `subscribe(SingleSubscriber)` by default won't report `isUnsubscribed() == true` unless the implementation of `onSuccess` and `onError` - controlled by the user - doesn't call `unsubscribe` on itself.
",2016-10-17 08:34:02,2016-10-17 17:16:45,https://api.github.com/repos/ReactiveX/RxJava/issues/4716,['Bug'],77,32,ReactiveX_RxJava_pull_4716.diff
ReactiveX/RxJava,2.x: test sync from Observable to Flowable 10/16-1,"- copy the recent unit tests from `Observable` to `Flowable`
- fix the same bugs
- perform the same cleanups
- compact the same operators
- factor out fusion method and constants to `QueueFuseable`
- have `Flowable.toList(Callable)` return `Single`
",2016-10-16 14:29:41,2016-10-17 06:58:52,https://api.github.com/repos/ReactiveX/RxJava/issues/4714,"['Bug', 'Cleanup', 'Coverage']",5655,633,ReactiveX_RxJava_pull_4714.diff
ReactiveX/RxJava,"2.x: coverage, cleanup, fixes 10/15-2","- more `Observable` coverage
- make `Observable.sequenceEqual` return `Single<Boolean>`
- reimplement `Observable.distinct()`
- fix `Observable.combineLatest` error management
- remove or compact unused code paths
- fix `Observable.flatMap` maxConcurrency behavior with scalars, use of unbounded queue
- fix `Observable.timeInterval` not saving the `Disposable` 
",2016-10-15 22:47:40,2016-10-16 09:23:22,https://api.github.com/repos/ReactiveX/RxJava/issues/4712,"['Bug', 'Cleanup', 'Coverage']",1796,370,ReactiveX_RxJava_pull_4712.diff
ReactiveX/RxJava,2.x: Decouple stream operators from Function interface.,"This allows a single class to implement itself as an operator for all stream types. A similar change was recently made to the transformer types.

From https://github.com/ReactiveX/RxJava/pull/4672#issuecomment-252417909.
",2016-10-15 18:15:19,2016-10-15 18:36:12,https://api.github.com/repos/ReactiveX/RxJava/issues/4711,['Enhancement'],39,25,ReactiveX_RxJava_pull_4711.diff
ReactiveX/RxJava,2.x: Remove checked exceptions from transformer interfaces.,"These functions are for transforming the stream shape, not doing work. Any operation that would throw a checked exception should happen inside the stream, not when shaping it.

Closes #4709.
",2016-10-15 18:01:27,2016-10-19 16:01:23,https://api.github.com/repos/ReactiveX/RxJava/issues/4710,['Enhancement'],17,133,ReactiveX_RxJava_pull_4710.diff
ReactiveX/RxJava,"2.x: coverage, fixes, cleanup 10/15-1","- improve coverage of `Observable` operators
- remove unnecessary code paths
- fix `publish(Function)` latecommer behavior
- remove `bufferSize` overloads of `publish` as there is no need to buffer anything for an `Observable`
- simplify `Observable.publish`
",2016-10-15 16:36:13,2016-10-15 17:17:54,https://api.github.com/repos/ReactiveX/RxJava/issues/4708,"['Bug', 'Cleanup', 'Coverage']",1615,603,ReactiveX_RxJava_pull_4708.diff
ReactiveX/RxJava,2.x: Fix Flowable.elementAt on empty sources. Plus sync tests,"- fixes Flowable.elementAt on an empty source 
- sync tests between Observable & Flowable elementAt
",2016-10-15 12:22:03,2016-10-15 12:44:59,https://api.github.com/repos/ReactiveX/RxJava/issues/4707,['Bug'],63,3,ReactiveX_RxJava_pull_4707.diff
ReactiveX/RxJava,"2.x: cleanup, coverage, fixes 10/14-2","- more `Observable` operator coverage
- enable fusion with `filter` and `fromCallable`
- change order of size parameter in timed `buffer` and `window` operators
- fix minor mistakes in operators
",2016-10-14 21:45:57,2016-10-14 22:31:08,https://api.github.com/repos/ReactiveX/RxJava/issues/4706,"['Cleanup', 'Coverage']",1407,261,ReactiveX_RxJava_pull_4706.diff
ReactiveX/RxJava,"2.x: coverage, cleanup fixes 10/14-1","- improve coverage of `Observable` operators
- remove impossible or unused code paths
- fix `Observable.flatMap`'s dispose behavior and error accumulation
",2016-10-14 14:34:11,2016-10-14 16:59:37,https://api.github.com/repos/ReactiveX/RxJava/issues/4705,"['Cleanup', 'Coverage']",1777,471,ReactiveX_RxJava_pull_4705.diff
ReactiveX/RxJava,2.x: coverage and cleanup 10/13-1,"Improve coverage of `Subject`s and `FlowableProcessor`s, remove impossible paths, cleanup code.
",2016-10-13 12:25:40,2016-10-14 06:58:46,https://api.github.com/repos/ReactiveX/RxJava/issues/4701,"['Cleanup', 'Coverage']",2303,237,ReactiveX_RxJava_pull_4701.diff
ReactiveX/RxJava,2.x: Clean up null usages by using ObjectHelper.requireNonNull,"Instead of using an if statement to check for `null`, `ObjectHelper.requireNonNull` will be used now. This reduces a lot of duplicated code. Also I found a few places (mostly zip operators) where the wrong Throwable was being onError'd.

In addition for one of the Completable operators the CompositeException call has been fixed. In addition I found another one that was wrong.
",2016-10-12 21:40:37,2016-10-12 21:57:09,https://api.github.com/repos/ReactiveX/RxJava/issues/4699,['Cleanup'],146,611,ReactiveX_RxJava_pull_4699.diff
ReactiveX/RxJava,2.x: coverage and cleanup 10/12-1,"- Add coverage to remaining `Completable` operators
- Fix inner Throwable order for `CompletablePeek`
- Compact/rewrite a few operators
",2016-10-12 13:51:42,2016-10-12 15:50:20,https://api.github.com/repos/ReactiveX/RxJava/issues/4696,"['Cleanup', 'Coverage']",1372,269,ReactiveX_RxJava_pull_4696.diff
ReactiveX/RxJava,2.x: CompositeException fix order of Exceptions,"After looking at #4692 I found a few more exceptions which were passed in the wrong order to CompositeException.
",2016-10-12 08:24:01,2016-10-12 09:35:31,https://api.github.com/repos/ReactiveX/RxJava/issues/4695,['Cleanup'],13,13,ReactiveX_RxJava_pull_4695.diff
ReactiveX/RxJava,2.x - improve timer javadoc,"Make it clearer what gets emitted (0L).
",2016-10-12 01:27:25,2016-10-12 07:07:28,https://api.github.com/repos/ReactiveX/RxJava/issues/4694,['Documentation'],12,12,ReactiveX_RxJava_pull_4694.diff
ReactiveX/RxJava,1.x: improve timer javadoc,"Javadoc was correct but not very helpful. Had to look further down in the javadoc to the `@return` section to see what value was emitted.
",2016-10-12 01:16:46,2016-10-12 07:06:54,https://api.github.com/repos/ReactiveX/RxJava/issues/4693,['Documentation'],2,2,ReactiveX_RxJava_pull_4693.diff
ReactiveX/RxJava,"2.x: coverage, fixes and cleanup 10/11-2","- cover remaining `Maybe` operators
- cover `Single` operators
- cover some of the `Completable` operators
- fix missing `onSubscribe` calls
- compact a few operator implementations
- fix the order of inner Throwables on certain `CompositeException` emissions
",2016-10-11 22:11:31,2016-10-12 07:04:56,https://api.github.com/repos/ReactiveX/RxJava/issues/4692,"['Bug', 'Cleanup', 'Coverage']",3765,334,ReactiveX_RxJava_pull_4692.diff
ReactiveX/RxJava,"2.x: BaseTestConsumer add assertValueAt(index, Predicate<T>) ","Fixes #4688
- adds assertValueAt(index, Predicate) to BaseTestConsumer
",2016-10-11 16:05:19,2016-10-11 16:40:33,https://api.github.com/repos/ReactiveX/RxJava/issues/4690,['Enhancement'],141,6,ReactiveX_RxJava_pull_4690.diff
ReactiveX/RxJava,2.x: coverage and cleanup 10/11-1,"This PR enhances the coverage of `Maybe` operators (run out of time for this batch, 5 remaining) and fixes an NPE bug in `Maybe.doOnEvent` due to not saving the `Disposable`. Some inner receivers no longer implement `Disposable` as `isDisposed` is unreachable and not really necessary.

In addition `Maybe.toCompletable` was removed in favor of `Maybe.ignoreElement()`.
",2016-10-11 14:42:39,2016-10-11 15:24:33,https://api.github.com/repos/ReactiveX/RxJava/issues/4689,"['Cleanup', 'Coverage']",3209,263,ReactiveX_RxJava_pull_4689.diff
ReactiveX/RxJava,2.x: Add Observable.rangeLong & Flowable.rangeLong,"Will fix #4683
- adds Observable.rangeLong()
- adds Flowable.rangeLong()

both implementations are copied same for the unit tests.

What should we do about the range overflow check? We could use BigDecimal to check that.
",2016-10-11 13:26:17,2016-10-11 15:29:22,https://api.github.com/repos/ReactiveX/RxJava/issues/4687,['Enhancement'],918,0,ReactiveX_RxJava_pull_4687.diff
ReactiveX/RxJava,2.: Fix flatMapX over-cancellation in case of an inner error,"A non-delayed error set the cancellation flag and thus any subsequent drain would just quit instead of delivering the error.

(And while I'm at it, I'll try to figure out a way to not get killed by OOMKiller).

Reported in #4684.
",2016-10-10 07:53:11,2016-10-10 16:11:05,https://api.github.com/repos/ReactiveX/RxJava/issues/4686,['Bug'],93,8,ReactiveX_RxJava_pull_4686.diff
ReactiveX/RxJava,2.x: Test static from methods and add Maybe.fromSingle & fromCompletable,"- add Maybe.fromSingle by reusing MaybeFromSingle
- add Maybe.fromCompletable by resuing MaybeFromCompletable
- remove anonymous classes in various operators
- add tests for
  - Completable.fromAction()
  - Completable.fromCallable()
  - Completable.fromObservable()
  - Completable.fromPublisher()
  - Completable.fromRunnable()
  - Completable.fromSingle()
  - Maybe.fromAction()
  - Maybe.fromCallable()
  - Maybe.fromCompletable()
  - Maybe.fromRunnable()
  - Maybe.fromSingle()
  - Single.fromCallable()
",2016-10-09 10:49:08,2016-10-11 07:29:01,https://api.github.com/repos/ReactiveX/RxJava/issues/4685,['Enhancement'],945,33,ReactiveX_RxJava_pull_4685.diff
ReactiveX/RxJava,Update Mockito to 2.1.0,"There are no changes from RC-2 to 2.1.0, so should be good to go 😄 
",2016-10-07 12:54:04,2016-10-10 07:22:04,https://api.github.com/repos/ReactiveX/RxJava/issues/4682,['Test'],1,1,ReactiveX_RxJava_pull_4682.diff
ReactiveX/RxJava,2.x: Fix Flowable + Single elementAt and elementAtOrError operators on empty sources,"This will fix #4680
- elementAtOrError(1) on an empty source just leaves the new Single hanging without signalling onError()
- elementAt(1) on an empty source just leaves the Maybe hanging without signalling onComplete()
- I also noticed that elementAt() with a default value on an empty source did not work either.
",2016-10-07 08:49:50,2016-10-07 09:48:01,https://api.github.com/repos/ReactiveX/RxJava/issues/4681,['Bug'],84,4,ReactiveX_RxJava_pull_4681.diff
ReactiveX/RxJava,2.x: fix flatMapX calling SpscLinkedArrayQueue.offer concurrently,"I forgot to synchronize the offer part of the new flatMapX operators (since of course, Spsc is for single producer only but here there could be concurrent non fast-path queueing of values). 

(There is an MpscLinkedArrayQueue in JCTools but I'm not confident in it and don't want to use MpscLinkedQueue due to the node allocation.)
",2016-10-06 19:19:09,2016-10-06 20:55:18,https://api.github.com/repos/ReactiveX/RxJava/issues/4678,['Bug'],18,6,ReactiveX_RxJava_pull_4678.diff
ReactiveX/RxJava,1.x: Cleanups from making NotificationLite stateless.,,2016-10-06 18:20:09,2016-10-06 19:08:15,https://api.github.com/repos/ReactiveX/RxJava/issues/4677,['Cleanup'],1,31,ReactiveX_RxJava_pull_4677.diff
ReactiveX/RxJava,1.x: Make identity function a singleton.,,2016-10-06 17:55:11,2016-10-06 19:08:58,https://api.github.com/repos/ReactiveX/RxJava/issues/4676,['Cleanup'],11,6,ReactiveX_RxJava_pull_4676.diff
ReactiveX/RxJava,2.x: add javadoc and unit test to the recently changed XTransformers,"This PR adds the javadoc and crash-testing for each XTransformer interface changed by #4672.
",2016-10-06 14:41:51,2016-10-06 19:05:37,https://api.github.com/repos/ReactiveX/RxJava/issues/4674,['Cleanup'],230,10,ReactiveX_RxJava_pull_4674.diff
ReactiveX/RxJava,2.x Remove Function from transformer interfaces to allow a single obj…,"This pull request removes Function from the super type of the various Transformer interfaces. While these are technically functions, the problem is that if they all extend Function then you cannot have a single object instance that can implement multiple Transformer interfaces. The goal is to be able to call a function that returns an object that can be passed to Observable.compose or Single.Compose and so on.

This was an issue with RxLifecycle project. See this for more info: https://github.com/trello/RxLifecycle/issues/39
",2016-10-05 18:48:35,2016-10-06 14:17:12,https://api.github.com/repos/ReactiveX/RxJava/issues/4672,['Feature-Request'],40,25,ReactiveX_RxJava_pull_4672.diff
ReactiveX/RxJava,2.x: Fix javadoc for Single.flatMapObservable,"- wrong return type was described
- some git merging information was added
",2016-10-05 10:33:32,2016-10-05 10:47:32,https://api.github.com/repos/ReactiveX/RxJava/issues/4669,"['Cleanup', 'Documentation']",1,2,ReactiveX_RxJava_pull_4669.diff
ReactiveX/RxJava,Limit gradle memory to avoid kill 137,"I read that decreasing the memory amount Gradle itself uses may help avoid such kills, let's try it.
",2016-10-05 08:45:47,2016-10-05 08:59:36,https://api.github.com/repos/ReactiveX/RxJava/issues/4668,['Build'],2,0,ReactiveX_RxJava_pull_4668.diff
ReactiveX/RxJava,"2.x: flatMap{Completable, Maybe, Single} operators","This PR adds `Observable.flatMapCompletable(Function<T, CompletableSource>)` and `Flowable.flatMapCompletable(Function<T, CompletableSource>)`, both resulting in `Completable` (+ support for fusing back to the original type).

**Edit**

Added `flatMapMaybe` and `flatMapSingle` variants to both `Flowable` and `Observable`.
",2016-10-04 18:29:48,2016-10-05 08:11:35,https://api.github.com/repos/ReactiveX/RxJava/issues/4667,['Enhancement'],4176,2,ReactiveX_RxJava_pull_4667.diff
ReactiveX/RxJava,2.x: coverage and cleanup 10/04-1,"- Improve coverage
- remove unused, unnecessary or impossible code paths
- fix order of inner exceptions in the reported `CompositeException` in various operators
- `Maybe.ignoreElement()` now returns `Completable`
",2016-10-04 13:41:51,2016-10-04 16:51:30,https://api.github.com/repos/ReactiveX/RxJava/issues/4666,"['Bug', 'Cleanup', 'Enhancement']",3126,119,ReactiveX_RxJava_pull_4666.diff
ReactiveX/RxJava,2.x: cleanup and fixes 10/03-2,"- More coverage
- fix some composite exception ordering
- fix a few bugs
",2016-10-03 22:12:09,2016-10-04 06:52:09,https://api.github.com/repos/ReactiveX/RxJava/issues/4663,['Cleanup'],2690,217,ReactiveX_RxJava_pull_4663.diff
ReactiveX/RxJava,2.x: cleanup and coverage 10/03,"- remove unused methods and classes
- make sure `Maybe.toFlowable` and `Maybe.toObservable` allows macro-fusion back to the original type
- improve coverage of various components
",2016-10-03 14:18:51,2016-10-03 15:23:23,https://api.github.com/repos/ReactiveX/RxJava/issues/4661,['Cleanup'],2808,701,ReactiveX_RxJava_pull_4661.diff
ReactiveX/RxJava,Update gradle to v3.1,,2016-10-02 18:29:21,2016-10-02 18:55:19,https://api.github.com/repos/ReactiveX/RxJava/issues/4660,[],1,1,ReactiveX_RxJava_pull_4660.diff
ReactiveX/RxJava,Update gradle to v3.1,,2016-10-02 18:29:10,2016-10-02 18:55:24,https://api.github.com/repos/ReactiveX/RxJava/issues/4659,[],1,1,ReactiveX_RxJava_pull_4659.diff
ReactiveX/RxJava,2.x: Observable.compose to use ObservableTransformer,"This changes the `Observable.compose` type to `ObservableTransformer` to reduce the type-argument/inference problem. The other base types have been previously updated to their respective transfomer types.
",2016-10-02 10:28:31,2016-10-02 13:29:52,https://api.github.com/repos/ReactiveX/RxJava/issues/4658,['Cleanup'],7,10,ReactiveX_RxJava_pull_4658.diff
ReactiveX/RxJava,Upcast ConcurrentHashMap to Map to avoid compatibility issue,"Resovles #4653

See http://stackoverflow.com/a/32955708/61158
",2016-10-01 09:16:22,2016-10-01 09:42:59,https://api.github.com/repos/ReactiveX/RxJava/issues/4654,['Bug'],4,4,ReactiveX_RxJava_pull_4654.diff
ReactiveX/RxJava,Switch Maybe and Single to use their Transformers in compose(),"Resolves #4650 
",2016-10-01 07:48:34,2016-10-01 08:08:37,https://api.github.com/repos/ReactiveX/RxJava/issues/4651,['Cleanup'],19,16,ReactiveX_RxJava_pull_4651.diff
ReactiveX/RxJava,1.x: rework Single internals to reduce overhead and stack depth,"This PR makes the `Single.OnSubscribe` as the primary means to execute the subscribe action in `Single` and former couple of reused `Observable` operators are now recreated with `Single.OnSubscribe`.

Because `Single` is now marked final, we can't remove the former `Observable.Operator` and `Observable.OnSubscribe` entry points (but may be deprecated in a separate PR).
",2016-09-30 13:31:28,2016-10-02 10:10:15,https://api.github.com/repos/ReactiveX/RxJava/issues/4648,['Cleanup'],1271,374,ReactiveX_RxJava_pull_4648.diff
ReactiveX/RxJava,"2.x: Merge AmbArray and AmbIterable into Amb for Single, Maybe and Completable types","This PR addresses #4633
- Merge SingleAmbArray and SingleAmbIterable operators into SingleAmb
- Merge MaybeAmbArray and MaybeAmbIterable operators into MaybeAmb
- Merge CompletableAmbArray and CompletableAmbIterable operators into CompletableAmb
",2016-09-30 11:53:14,2016-09-30 12:22:35,https://api.github.com/repos/ReactiveX/RxJava/issues/4647,['Cleanup'],242,403,ReactiveX_RxJava_pull_4647.diff
ReactiveX/RxJava,2.x Signal NPE ObservableAmb FlowableAmb,"This PR addresses #4640
",2016-09-29 23:32:44,2016-09-30 07:01:49,https://api.github.com/repos/ReactiveX/RxJava/issues/4645,['Bug'],46,20,ReactiveX_RxJava_pull_4645.diff
ReactiveX/RxJava,1.x: SafeSubscriber not to call RxJavaHooks before delivering the original error.,"Before the introduction of `RxJavaHooks`, the `SafeSubscriber._onError` called the original error handler with the exception it received which was by default an empty handler. The default `RxJavaHooks.onError` behavior, however is to signal errors to the uncaught exception handler of the caller thread which leads to unnecessary logging or app crashes even though the error itself is to be handled properly.

This PR restores the `SafeSubscriber._onError` to skip the `RxJavaHooks` and call the original handler directy so old tracking code should still get all safe error while newer hooking doesn't get called.

Related: #4332.
",2016-09-29 20:29:26,2016-09-30 18:39:25,https://api.github.com/repos/ReactiveX/RxJava/issues/4641,['Bug'],24,2,ReactiveX_RxJava_pull_4641.diff
ReactiveX/RxJava,2.x: fix Mockito 2.1 changes using deprecated API of its own,"`anyListOf()` is deprecated in Mockito 2.1.0-RC.2 and the GitHub diff can't show such uses.

(In addition, there was a missing `serialVersionUID` in another PR.)
",2016-09-29 18:04:21,2016-09-29 18:21:12,https://api.github.com/repos/ReactiveX/RxJava/issues/4639,['Cleanup'],19,16,ReactiveX_RxJava_pull_4639.diff
ReactiveX/RxJava,2.x: Remove unused methods in BasicFuseableObserver,,2016-09-29 14:47:40,2016-09-29 15:16:51,https://api.github.com/repos/ReactiveX/RxJava/issues/4637,['Cleanup'],0,22,ReactiveX_RxJava_pull_4637.diff
ReactiveX/RxJava,Update Mockito to 2.1.0-RC.2,"Equivalent of #4634 , but now for the 2.x branch.
",2016-09-29 13:55:45,2016-09-29 14:33:48,https://api.github.com/repos/ReactiveX/RxJava/issues/4636,['Test'],84,238,ReactiveX_RxJava_pull_4636.diff
ReactiveX/RxJava,Upgrade Mockito to 2.1.0-RC.2,"The second release candidate of Mockito 2 has been released, which is mostly backwards compatible with your code base. I had to remove the deprecated usage of `Matchers` and replace it with the new `Mockito` equivalent matchers. This solved several ambiguity issues where both `Mockito` and `Matchers` were imported in the same file. Other than that all tests were passing locally, so let's see if CI agrees too.

Thanks a lot for using Mockito and if you have any feedback, we are eager to hear from you!
",2016-09-29 10:32:49,2016-09-29 18:02:03,https://api.github.com/repos/ReactiveX/RxJava/issues/4634,"['Feature-Request', 'Test']",67,272,ReactiveX_RxJava_pull_4634.diff
ReactiveX/RxJava,2.x: Clean up SingleFlatMap,,2016-09-29 09:04:20,2016-09-29 09:32:47,https://api.github.com/repos/ReactiveX/RxJava/issues/4632,[],125,36,ReactiveX_RxJava_pull_4632.diff
ReactiveX/RxJava,2.x: Don't wrap with CompositeException when there is only one error,,2016-09-29 06:46:31,2016-09-29 07:03:18,https://api.github.com/repos/ReactiveX/RxJava/issues/4631,['Cleanup'],6,2,ReactiveX_RxJava_pull_4631.diff
ReactiveX/RxJava,2.x: Add Completable.fromRunnable(),"addresses #4628

> There's `Maybe.fromRunnable` but `Completable` is missing this method.
",2016-09-29 03:03:24,2016-09-29 06:57:29,https://api.github.com/repos/ReactiveX/RxJava/issues/4629,['Enhancement'],95,0,ReactiveX_RxJava_pull_4629.diff
ReactiveX/RxJava,"2.x: Use predicates in BaseTestConsumer assertError(Class/Throwable) to remove duplicate code, tests tweaks to remove few IDE warnings","Messages and error checking was duplicates between all three assertError overloads.
",2016-09-28 18:43:18,2016-09-28 18:59:12,https://api.github.com/repos/ReactiveX/RxJava/issues/4627,"['Enhancement', 'Test']",27,58,ReactiveX_RxJava_pull_4627.diff
ReactiveX/RxJava,2.x: Replace 'resource' observers with plain 'disposable' observers in tests.,"This makes the resource observers unused internally and I'm curious as to whether they deserve to stick around in the public API. Any thoughts?
",2016-09-28 15:22:36,2016-09-28 19:05:13,https://api.github.com/repos/ReactiveX/RxJava/issues/4625,['Cleanup'],4,4,ReactiveX_RxJava_pull_4625.diff
ReactiveX/RxJava,2.x: enable operator fusion in onBackpressureBuffer,"This PR enables operator fusion in `onBackpressureBuffer`. The main benefit is that given a non-backpressured source, using `observeOn` now reuses `onBackpressureBuffer`'s (un)bounded queue seamlessly.
",2016-09-28 09:17:31,2016-09-28 13:43:48,https://api.github.com/repos/ReactiveX/RxJava/issues/4622,['Enhancement'],94,10,ReactiveX_RxJava_pull_4622.diff
ReactiveX/RxJava,1.x: NotificationLite - reduce allocations,"A lot of commonly used operators allocated an instance of `NotificationLite` as a field in a subscriber but for no great type-safety benefit. I've cut these fields by converting all instance methods of `NotificationLite` to static methods and removing the `NotificationLite.instance()` method.

The changes are trivial till you get to the `Subjects` that would pass instances of `NotificationLite` in methods of the `SubjectSubscriptionManager`. Still simple changes but reviewing these is a good idea.

RxJava2 goes a bit further in the internals of `NotificationLite`. I'd like to leave changes to the internals beyond making methods static for another PR if appropriate.
",2016-09-28 07:32:10,2016-09-28 08:12:27,https://api.github.com/repos/ReactiveX/RxJava/issues/4621,['Cleanup'],194,284,ReactiveX_RxJava_pull_4621.diff
ReactiveX/RxJava,2.x: Make CompositeExcpetion thread-safe like 1.x and also fix some issues,"Right now CompositeExcpetion has several issues:
- `CompositeException(Throwable... exceptions)` doesn't deduplicate exceptions and flatten CompositeExceptions like `CompositeException(Iterable<? extends Throwable> errors)`
- If using `CompositeException(Iterable<? extends Throwable> errors)` to create CompositeException, `suppress` cannot be used.
- `suppress` doesn't update `cause`.
- `suppress` doesn't deduplicate exceptions and flatten CompositeExceptions.
- `suppress` and `Throwable.addSuppressed` are pretty confusing for Java 7+ users. Without looking at the implementation, it's hard to figure out the differences.

This PR made the following changes:
- Remove `CompositeException.suppress` so that it's easy to make CompositeException thread-safe.
  - This may cause some performance lost in some path rarely happening, e.g., an excpetion is thrown from `onError`, but that's not a big deal.
  - Since `suppress` is removed, it doesn't make sense to create an empty CompositeException, so `isEmpty` is removed and defense codes are added.
- Defense codes for bad exceptions.
- Deduplicate excepctions and flatten CompositeExceptions for `CompositeException(Throwable... exceptions)`.
",2016-09-28 04:41:39,2016-09-28 08:12:14,https://api.github.com/repos/ReactiveX/RxJava/issues/4619,"['Bug', 'Cleanup']",103,134,ReactiveX_RxJava_pull_4619.diff
ReactiveX/RxJava,2.x: Add Single.flatMapMaybe,,2016-09-27 14:21:07,2016-09-27 14:59:52,https://api.github.com/repos/ReactiveX/RxJava/issues/4617,['Enhancement'],251,4,ReactiveX_RxJava_pull_4617.diff
ReactiveX/RxJava,2.x: Add Completable.andThen(MaybeSource),,2016-09-27 12:32:36,2016-09-27 13:14:35,https://api.github.com/repos/ReactiveX/RxJava/issues/4616,['Enhancement'],203,1,ReactiveX_RxJava_pull_4616.diff
ReactiveX/RxJava,2.x: Add Maybe.flatMapSingle,"Gave that implementation a try. Feedback is welcome I think there are improvements that can be done.
",2016-09-27 10:03:03,2016-09-27 13:33:42,https://api.github.com/repos/ReactiveX/RxJava/issues/4614,['Enhancement'],268,1,ReactiveX_RxJava_pull_4614.diff
ReactiveX/RxJava,2.x: improve performance of Observable.flatMapIterable,"This PR improves the performance of `flatMapIterable` by inlining the consumption of the generated `Iterable`. The performance improvement comes from direct iteration and emission plus removing the overhead of the regular `flatMap` as such source mappings are inherently synchronous.
### Benchmark

i7 4790, Windows 7 x64, Java 8u102, JMH 1.13, ops/s - bigger is better

![image](https://cloud.githubusercontent.com/assets/1269832/18866111/a5a228b6-849e-11e6-9b53-c59df8f32d59.png)

10x overhead reduction in flattening a single element `Iterable`.

![image](https://cloud.githubusercontent.com/assets/1269832/18866190/187bce50-849f-11e6-9e44-473464457c3c.png)

Half the overhead compared to (an already optimized) `Flowable.flatMapIterable`.

![image](https://cloud.githubusercontent.com/assets/1269832/18866147/d93d6686-849e-11e6-9bdb-7837c55efddc.png)

Nice improvement on the cross-range benchmark (stream 1 million element split into N outer and M inner elements where N \* M = 1 million):

![image](https://cloud.githubusercontent.com/assets/1269832/18866180/005367d4-849f-11e6-9925-9b9d2a33a618.png)

Also quite better than `Flowable.flatMapIterable`.
",2016-09-27 08:43:29,2016-09-27 13:43:33,https://api.github.com/repos/ReactiveX/RxJava/issues/4612,['Performance'],418,4,ReactiveX_RxJava_pull_4612.diff
ReactiveX/RxJava,1.x @Beta and @Experimental annotations are not longer annotated with itself,"This PR addresses #4608
",2016-09-26 21:10:06,2016-09-26 21:22:57,https://api.github.com/repos/ReactiveX/RxJava/issues/4610,['Cleanup'],0,2,ReactiveX_RxJava_pull_4610.diff
ReactiveX/RxJava,2.x: Factor out typical TestObserver/TestSubscriber methods,"This PR introduces a new abstract internal class `BaseTestConsumer` which now hosts the `assertX` methods of `TestSubscriber` and `TestObserver` which were duplicates before.
",2016-09-26 19:58:11,2016-09-26 21:28:13,https://api.github.com/repos/ReactiveX/RxJava/issues/4609,['Enhancement'],784,1360,ReactiveX_RxJava_pull_4609.diff
ReactiveX/RxJava,2.x: TestSubscriber & TestObserver add assertValue(Predicate),,2016-09-26 12:37:01,2016-09-26 13:18:16,https://api.github.com/repos/ReactiveX/RxJava/issues/4607,"['Enhancement', 'Test']",186,3,ReactiveX_RxJava_pull_4607.diff
ReactiveX/RxJava,2.x: Verify same onNext / onError null behavior across all Subjects and Processors,,2016-09-26 12:16:25,2016-09-26 13:05:37,https://api.github.com/repos/ReactiveX/RxJava/issues/4606,['Cleanup'],210,21,ReactiveX_RxJava_pull_4606.diff
ReactiveX/RxJava,"2.x: add flattenAs{Observable,Flowable} to Single and Maybe","This PR adds `Single.flattenAsObservable`, `Single.flattenAsFlowable`, `Maybe.flattenAsObservable` and `Maybe.flattenAsFlowable` to map a success value into an `Iterable` sequence and stream it as `Flowable` or `Observable`. It is more efficient than `Single.toFlowable().flatMapIterable()`.
",2016-09-25 22:20:12,2016-09-29 07:30:13,https://api.github.com/repos/ReactiveX/RxJava/issues/4604,['Enhancement'],1466,9,ReactiveX_RxJava_pull_4604.diff
ReactiveX/RxJava,2.x: RxJavaPlugins - Don't pass null throwable down to Error Handler,,2016-09-25 19:53:12,2016-09-25 20:13:05,https://api.github.com/repos/ReactiveX/RxJava/issues/4603,['Cleanup'],29,8,ReactiveX_RxJava_pull_4603.diff
ReactiveX/RxJava,2.x: benchmark just() and fromCallable() throughput,"This PR adds benchmarks for measuring `just()` and `fromCallable()` when using `subscribeOn`, `observeOn` and `subscribeOn().observeOn()` with them.
# Benchmark baseline
- i7 4770K, Windows 7 x64, Java 8u102, JMH 1.13
- throughput ops/s, larger is better
## just

![image](https://cloud.githubusercontent.com/assets/1269832/18817630/bf4c4c9a-8365-11e6-87ea-13b9e2f5303c.png)

![image](https://cloud.githubusercontent.com/assets/1269832/18817657/69047e10-8366-11e6-9a63-6b0878e55097.png)
## fromCallable

![image](https://cloud.githubusercontent.com/assets/1269832/18817631/c850e922-8365-11e6-8e7b-f60c2b9bdbaa.png)

![image](https://cloud.githubusercontent.com/assets/1269832/18817654/5cfcd46e-8366-11e6-9eb7-50e1b872f377.png)
## just vs. fromCallable

![image](https://cloud.githubusercontent.com/assets/1269832/18817632/d7109ac0-8365-11e6-9936-e287477965e5.png)
",2016-09-25 19:26:02,2016-09-25 19:56:43,https://api.github.com/repos/ReactiveX/RxJava/issues/4602,['Performance'],457,0,ReactiveX_RxJava_pull_4602.diff
ReactiveX/RxJava,2.x: Sync behaviour between UnicastProcessor & UnicastSubject + add a few test cases,,2016-09-25 16:56:30,2016-09-25 17:17:46,https://api.github.com/repos/ReactiveX/RxJava/issues/4601,['Bug'],147,5,ReactiveX_RxJava_pull_4601.diff
ReactiveX/RxJava,2.x: don't show started unit tests,"Unfortunately, test reporting can't be coalesced so our almost 6000 tests overflow the Travis' window and making it more difficult to see what went wrong (especially from mobile). 

However, Travis times the build out if it doesn't detect standard output emission for more than 10 minutes; our tests take 12 minutes on average.

By not showing started but showing skipped (of which we have 200 scattered around), the timeout should not happen and the output is not bloated.
",2016-09-25 16:46:37,2016-09-25 17:28:34,https://api.github.com/repos/ReactiveX/RxJava/issues/4600,['Build'],31,1,ReactiveX_RxJava_pull_4600.diff
ReactiveX/RxJava,Update javadoc to 1.2.0 and 2.0.0-RC3,"Update public javadocs to 1.2.0 and 2.0.0-RC3.
",2016-09-25 16:28:08,2016-09-25 16:30:17,https://api.github.com/repos/ReactiveX/RxJava/issues/4599,['Documentation'],290454,36531,ReactiveX_RxJava_pull_4599.diff
ReactiveX/RxJava,2.x: Add missing @Test annotation on tests,,2016-09-25 09:48:32,2016-09-25 17:42:05,https://api.github.com/repos/ReactiveX/RxJava/issues/4597,['Test'],11,0,ReactiveX_RxJava_pull_4597.diff
ReactiveX/RxJava,2.x: Remove takeFirst(predicate) in Observable & Flowable,,2016-09-23 22:23:34,2016-09-23 22:49:21,https://api.github.com/repos/ReactiveX/RxJava/issues/4595,[],6,63,ReactiveX_RxJava_pull_4595.diff
ReactiveX/RxJava,2.x: Enhance NPE messages,"Now all NPE thrown internally are having this standard message
",2016-09-23 21:59:33,2016-09-23 22:28:51,https://api.github.com/repos/ReactiveX/RxJava/issues/4593,[],42,42,ReactiveX_RxJava_pull_4593.diff
ReactiveX/RxJava,2.x: UnicastSubject fix onTerminate,,2016-09-23 20:55:57,2016-09-23 21:18:16,https://api.github.com/repos/ReactiveX/RxJava/issues/4592,['Bug'],71,3,ReactiveX_RxJava_pull_4592.diff
ReactiveX/RxJava,2.x: Report errors from onError to Plugin when done,"For the first one that I found I even wrote a test. Then I started noticing more missing spots. If wanted I could port that one test to every operator that I touched. Though I didn't really find tests testing that errors are propagated through the Plugin API.
",2016-09-23 12:18:41,2016-09-23 15:55:22,https://api.github.com/repos/ReactiveX/RxJava/issues/4590,['Bug'],94,20,ReactiveX_RxJava_pull_4590.diff
ReactiveX/RxJava,"2.x: Add singleOrError, firstOrError, lastOrError & elementAtOrError to Observable and Flowable","Closes #4588
",2016-09-23 09:59:11,2016-09-23 21:19:00,https://api.github.com/repos/ReactiveX/RxJava/issues/4589,['Enhancement'],584,21,ReactiveX_RxJava_pull_4589.diff
ReactiveX/RxJava,2.x: Add error assertion with predicate to TestSubscriber and TestObserver,"Added support for error assertions with to TestSubscriber requested in #4498 to support custom error evaluation. Removes the need to implement equals and hashCode in exceptions.
",2016-09-22 23:15:39,2016-09-23 06:53:13,https://api.github.com/repos/ReactiveX/RxJava/issues/4586,['Enhancement'],261,2,ReactiveX_RxJava_pull_4586.diff
ReactiveX/RxJava,2.x: Evaluate Schedule initialization via Callable,"This implements the solution proposed in #4572 - to initialize the Schedulers via a Callable, rather than directly via a value.
",2016-09-22 22:24:17,2016-09-26 07:50:39,https://api.github.com/repos/ReactiveX/RxJava/issues/4585,['Enhancement'],325,78,ReactiveX_RxJava_pull_4585.diff
ReactiveX/RxJava,"2.x fix Flowable.create() not reporting null values properly, unify","exception msg across

Reported on [Stackoverflow](http://stackoverflow.com/questions/39622458/flowableemitter-doesnt-signal-error-when-onnext-got-null).

There was no proper null check in the various emitters. I've also unified the message pattern across all `create()` emitters.
",2016-09-22 18:26:51,2016-09-22 19:07:56,https://api.github.com/repos/ReactiveX/RxJava/issues/4583,['Bug'],339,14,ReactiveX_RxJava_pull_4583.diff
ReactiveX/RxJava,2.x: Add missing Maybe tests for concatWith & onErrorResumeNext,"They had no tests previously
",2016-09-22 13:34:48,2016-09-22 14:39:43,https://api.github.com/repos/ReactiveX/RxJava/issues/4582,['Test'],79,0,ReactiveX_RxJava_pull_4582.diff
ReactiveX/RxJava,2.x: Remove some dead code,"Also what about IntFunction it's right now in the public API however not used. So the question is does Rx want to expose that interface?
",2016-09-22 13:27:14,2016-09-22 16:05:59,https://api.github.com/repos/ReactiveX/RxJava/issues/4581,['Cleanup'],0,28,ReactiveX_RxJava_pull_4581.diff
ReactiveX/RxJava,rename AsyncEmitter to Emitter,"as per discussion in #4577, renaming `AsyncEmitter` to `Emitter` via deprecation.

There is a catch though. `CompletableEmitter` is correctly named now and depends on `AsyncEmitter` via the method:

``` java
 void setCancellation(AsyncEmitter.Cancellable c);
```

When can we break the api of that class?
",2016-09-22 10:51:49,2016-09-24 20:39:11,https://api.github.com/repos/ReactiveX/RxJava/issues/4580,['Cleanup'],1641,89,ReactiveX_RxJava_pull_4580.diff
ReactiveX/RxJava,2.x: convert the Observable operators to return Single/Maybe,"This PR updates many `Observable` operators to return `Single`, `Maybe` or `Completable`:
- count() -> Single
- elementAt() -> Maybe
- elementAt(T) -> Single
- first(T) -> Single
- firstElement() -> Maybe
- ignoreElements() -> Completable
- lastElement() -> Maybe
- reduce(BiFunction) -> Maybe
- reduce(Callable, BiFunction) -> Single
- reduceWith(U, BiFunction) -> Single
- single(T) -> Single
- singleElement() -> Maybe

and deletes Observable.toSingle, Observable.toMaybe and Observable.toCompletable.

In addition, `Flowable.reduce(BiFunction)` now returns `Maybe<T>`.

Related: #4321
",2016-09-22 09:34:56,2016-09-22 13:37:08,https://api.github.com/repos/ReactiveX/RxJava/issues/4579,['Enhancement'],1800,382,ReactiveX_RxJava_pull_4579.diff
ReactiveX/RxJava,"2.x: count, elementAt, ingoreElements, last, single, reduce, reduceWith to return non-Flowable","This PR updates many `Flowable` operators to return `Single`, `Maybe` or `Completable`:
- `count()` -> `Single`
- `elementAt()` -> `Maybe`
- `elementAt(T)` -> `Single`
- `first(T)` -> `Single`
- `firstElement()` -> `Maybe`
- `ignoreElements()` -> `Completable`
- `reduce(Callable, BiFunction)` -> `Single`
- `reduceWith(U, BiFunction)` -> `Single`
- `single(T)` -> `Single`
- `singleElement()` -> `Maybe`

and deletes `Flowable.toSingle`, `Flowable.toMaybe` and `Flowable.toCompletable`.

`Flowble.reduce(BiFunction)` was not yet changed from `Single` to `Maybe` (to allow empty sources to be reduced to empty Maybe).

Related: #4321
",2016-09-21 22:29:56,2016-09-22 06:58:15,https://api.github.com/repos/ReactiveX/RxJava/issues/4576,['Enhancement'],1895,491,ReactiveX_RxJava_pull_4576.diff
ReactiveX/RxJava,"2.x: collect, toList, toSortedList, toMap, toMultimap to return Single","This PR makes the following operators return `Single`:
- `collect`
- `collectInto`
- `toList`
- `toSortedList`
- `toMap`
- `toMultimap`

and changes the documentation to mention `Single` instead as well. (There are some whitespace removals I forgot previously).
",2016-09-21 17:49:11,2016-09-21 19:58:17,https://api.github.com/repos/ReactiveX/RxJava/issues/4574,['Enhancement'],2368,363,ReactiveX_RxJava_pull_4574.diff
ReactiveX/RxJava,"2.x: make any() and all() return Single, patch up tests","This PR changes the return type of `any()` and `all()` to `Single`.

I've also did a small change to `TestObserver` by having it implement the other `XObserver` types. This resulted in one extra method `onSuccess` to be added but now you can subscribe `TestObserver` to `Single`, `Maybe` and `Completable` without conversion yet still `test()` them with the same convenient API.

``` java
Flowable.range(1, 10).any(v -> true).test().assertResult(true);
```
",2016-09-21 09:39:12,2016-09-21 15:31:11,https://api.github.com/repos/ReactiveX/RxJava/issues/4573,['Enhancement'],1658,273,ReactiveX_RxJava_pull_4573.diff
ReactiveX/RxJava,2.x: last() to return Single,"This PR changes the return type of `last()` to `Single<T>` and updates the relevant locations.

Originally, it was implemented as `takeLast(1).single()` so to reduce impact, all other original uses now have this inlined.
",2016-09-20 16:51:54,2016-09-20 21:30:36,https://api.github.com/repos/ReactiveX/RxJava/issues/4570,['Enhancement'],356,124,ReactiveX_RxJava_pull_4570.diff
ReactiveX/RxJava,1.x: mark RxJavaPlugins.registerErrorHandler as deprecated,"This marks `RxJavaPlugins#registerErrorHandler` and `RxJavaPlugins#getErrorHandler` as deprecated and documents `RxJavaHooks#setOnError` and `RxJavaHooks#getOnError` as its alternatives.

Related to #4566
",2016-09-20 09:41:31,2016-09-21 20:48:48,https://api.github.com/repos/ReactiveX/RxJava/issues/4569,[],5,0,ReactiveX_RxJava_pull_4569.diff
ReactiveX/RxJava,Add extra Maybe iterable Amb tests for overlapped emissions,"- Asserting that downstream will get the results of the first source that began emission, even if multiple sources have overlapped emissions
- Testing Success and Error paths
",2016-09-20 01:11:26,2016-09-20 07:34:12,https://api.github.com/repos/ReactiveX/RxJava/issues/4567,['Test'],47,0,ReactiveX_RxJava_pull_4567.diff
ReactiveX/RxJava,2.x: Enhance NPE message in Create functions of all Base Reactive Types,,2016-09-15 14:43:00,2016-09-15 15:37:38,https://api.github.com/repos/ReactiveX/RxJava/issues/4561,['Cleanup'],9,9,ReactiveX_RxJava_pull_4561.diff
ReactiveX/RxJava,2.x: Fix typo in Single + Maybe defer(),,2016-09-15 09:06:29,2016-09-15 09:29:32,https://api.github.com/repos/ReactiveX/RxJava/issues/4560,['Cleanup'],2,2,ReactiveX_RxJava_pull_4560.diff
ReactiveX/RxJava,1.x: safeguard against building with 2.* tags,"This PR adds a safeguard so that when releasing, mis-tagging the 1.x branch won't build and release `io.reactivex:rxjava:2.*` (2.x goes into `io.reactivex.rxjava2:rxjava:2.*`).

Since I can't try this locally (or can't really try a real tag&release), the PR will get a few commits along the way.
",2016-09-15 07:20:13,2016-09-15 08:16:28,https://api.github.com/repos/ReactiveX/RxJava/issues/4556,['Build'],7,0,ReactiveX_RxJava_pull_4556.diff
ReactiveX/RxJava,1.x: enhance generics doOnError doOnRequest,"want to able to call `doOnError(Action1<Object>)` and similarly enhanced `doOnRequest` while I was about it.
",2016-09-14 23:02:50,2016-09-22 07:00:39,https://api.github.com/repos/ReactiveX/RxJava/issues/4555,['Cleanup'],38,6,ReactiveX_RxJava_pull_4555.diff
ReactiveX/RxJava,"2.x: make internal naming consistent, refactor some classes 9/14-2","- Make internal naming of components consistent with the base reactive type
- move `io.reactivex.internal.subscribers.flowable.*` to `io.reactivex.internal.subscribers`
- move `io.reactivex.internal.subscribers.observable.*` to `io.reactivex.internal.observers`
",2016-09-14 19:43:53,2016-09-14 19:58:51,https://api.github.com/repos/ReactiveX/RxJava/issues/4554,['Cleanup'],1438,1082,ReactiveX_RxJava_pull_4554.diff
ReactiveX/RxJava,"2.x: cleanup of style and other minor things, 9/14-1","This PR has 781 lines changed across 511 files so GitHub won't display the complete diff. It is advised to check this out and do a diff in your IDE.

Notable changes:
- replace mention of `onCompleted` with `onComplete`
- remove `public` from constructors of package-private classes (some may think the class was intended to be public but usually isn't)
- few minor whitespace addition around operators (so the code doesn't look so cluttered to me when I have view/debug older code or unit tests contributed a while ago)
- add missing `.` from the end of the first sencence in javadocs
- removed empty `/** */` comments above the `serialVersionUID` fields
- use checkstyle tool version 6.19 plus a few more checkstyle rules
- fix ObservableRedo asnyc reentrancy problem by serializing the subject
",2016-09-14 15:19:04,2016-09-14 16:33:17,https://api.github.com/repos/ReactiveX/RxJava/issues/4552,['Cleanup'],1847,1720,ReactiveX_RxJava_pull_4552.diff
ReactiveX/RxJava,1.2 preparation cleanup and Experimental/Beta/Deprecated adjustments,"This PR contains some cleanup, javadoc fixes as well as the API changes for 1.2:
### Promote beta to standard
- `rx.Observable.create(SyncOnSubscribe<S, T>)`
- `rx.Observable.doOnRequest(Action1<Long>)`
- `rx.Observable.flatMap(Func1<? super T, ? extends Observable<? extends R>>, Func1<? super Throwable, ? extends Observable<? extends R>>, Func0<? extends Observable<? extends R>>, int)`
- `rx.Observable.flatMap(Func1<? super T, ? extends Observable<? extends R>>, int)`
- `rx.Observable.flatMap(Func1<? super T, ? extends Observable<? extends U>>, Func2<? super T, ? super U, ? extends R>, int)`
- `rx.Observable.flatMapIterable(Func1<? super T, ? extends Iterable<? extends R>>, int)`
- `rx.Observable.flatMapIterable(Func1<? super T, ? extends Iterable<? extends U>>, Func2<? super T, ? super U, ? extends R>, int)`
- `rx.Observable.fromCallable(Callable<? extends T>)`
- `rx.Observable.toSingle()`
- _ _
- `rx.Single.fromCallable(Callable<? extends T>)`
- _ _
- `rx.SingleSubscriber<T>`
- _ _
- `rx.observables.ConnectableObservable.autoConnect()`
- `rx.observables.ConnectableObservable.autoConnect(int, Action1<? super Subscription>)`
- `rx.observables.ConnectableObservable.autoConnect(int)`
- _ _
- `rx.observables.SyncOnSubscribe<S, T>`
- _ _
- `rx.subjects.AsyncSubject.getThrowable()`
- `rx.subjects.AsyncSubject.getValue()`
- `rx.subjects.AsyncSubject.hasCompleted()`
- `rx.subjects.AsyncSubject.hasThrowable()`
- `rx.subjects.AsyncSubject.hasValue()`
- _ _
- `rx.subjects.BehaviorSubject.getThrowable()`
- `rx.subjects.BehaviorSubject.getValue()`
- `rx.subjects.BehaviorSubject.getValues()`
- `rx.subjects.BehaviorSubject.getValues(T[])`
- `rx.subjects.BehaviorSubject.hasCompleted()`
- `rx.subjects.BehaviorSubject.hasThrowable()`
- `rx.subjects.BehaviorSubject.hasValue()`
- _ _
- `rx.subjects.PublishSubject.getThrowable()`
- `rx.subjects.PublishSubject.hasCompleted()`
- `rx.subjects.PublishSubject.hasThrowable()`
- _ _
- `rx.subjects.ReplaySubject.getThrowable()`
- `rx.subjects.ReplaySubject.getValue()`
- `rx.subjects.ReplaySubject.getValues()`
- `rx.subjects.ReplaySubject.getValues(T[])`
- `rx.subjects.ReplaySubject.hasAnyValue()`
- `rx.subjects.ReplaySubject.hasCompleted()`
- `rx.subjects.ReplaySubject.hasThrowable()`
- `rx.subjects.ReplaySubject.hasValue()`
- `rx.subjects.ReplaySubject.size()`
### Promote experimental to standard

None.
### Promote to beta
- `rx.BackpressureOverflow`
- `rx.Observable.concatDelayError(Iterable<? extends Observable<? extends T>>)`
- `rx.Observable.concatDelayError(Observable<? extends Observable<? extends T>>)`
- `rx.Observable.concatEager(Iterable<? extends Observable<? extends T>>, int)`
- `rx.Observable.concatEager(Iterable<? extends Observable<? extends T>>)`
- `rx.Observable.concatEager(Observable<? extends Observable<? extends T>>, int)`
- `rx.Observable.concatEager(Observable<? extends Observable<? extends T>>)`
- `rx.Observable.concatEager(Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>)`
- `rx.Observable.concatEager(Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>)`
- `rx.Observable.concatEager(Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>)`
- `rx.Observable.concatEager(Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>)`
- `rx.Observable.concatEager(Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>)`
- `rx.Observable.concatEager(Observable<? extends T>, Observable<? extends T>, Observable<? extends T>, Observable<? extends T>)`
- `rx.Observable.concatEager(Observable<? extends T>, Observable<? extends T>, Observable<? extends T>)`
- `rx.Observable.concatEager(Observable<? extends T>, Observable<? extends T>)`
- `rx.Observable.concatMapDelayError(Func1<? super T, ? extends Observable<? extends R>>)`
- `rx.Observable.concatMapEager(Func1<? super T, ? extends Observable<? extends R>>, int, int)`
- `rx.Observable.concatMapEager(Func1<? super T, ? extends Observable<? extends R>>, int)`
- `rx.Observable.concatMapEager(Func1<? super T, ? extends Observable<? extends R>>)`
- `rx.Observable.delaySubscription(Observable<U>)`
- `rx.Observable.distinctUntilChanged(Func2<? super T, ? super T, Boolean>)`
- `rx.Observable.mergeDelayError(Observable<? extends Observable<? extends T>>, int)`
- `rx.Observable.onBackpressureBuffer(long, Action0, Strategy)`
- `rx.Observable.switchMapDelayError(Func1<? super T, ? extends Observable<? extends R>>)`
- `rx.Observable.switchOnNextDelayError(Observable<? extends Observable<? extends T>>)`
- `rx.Observable.toCompletable()`
- `rx.Observable.toSortedList(Func2<? super T, ? super T, Integer>, int)`
- `rx.Observable.toSortedList(int)`
- `rx.Observable.using(Func0<Resource>, Func1<? super Resource, ? extends Observable<? extends T>>, Action1<? super Resource>, boolean)`
- _ _
- `rx.observables.BlockingObservable.subscribe()`
- `rx.observables.BlockingObservable.subscribe(Action1<? super T>, Action1<? super Throwable>, Action0)`
- `rx.observables.BlockingObservable.subscribe(Action1<? super T>, Action1<? super Throwable>)`
- `rx.observables.BlockingObservable.subscribe(Action1<? super T>)`
- `rx.observables.BlockingObservable.subscribe(Observer<? super T>)`
- `rx.observables.BlockingObservable.subscribe(Subscriber<? super T>)`
- _ _
- `rx.Completable`
- _ _
- `rx.Single.defer(Callable<Single<T>>)`
- `rx.Single.delay(long, TimeUnit, Scheduler)`
- `rx.Single.delay(long, TimeUnit)`
- `rx.Single.delaySubscription(Observable<?>)`
- `rx.Single.doAfterTerminate(Action0)`
- `rx.Single.doOnError(Action1<Throwable>)`
- `rx.Single.doOnSubscribe(Action0)`
- `rx.Single.doOnSuccess(Action1<? super T>)`
- `rx.Single.doOnUnsubscribe(Action0)`
- `rx.Single.lift(Operator<? extends R, ? super T>)`
- `rx.Single.onErrorResumeNext(Func1<Throwable, ? extends Single<? extends T>>)`
- `rx.Single.onErrorResumeNext(Single<? extends T>)`
- `rx.Single.toBlocking()`
- `rx.Single.toCompletable()`
- `rx.Single.using(Func0<Resource>, Func1<? super Resource, ? extends Single<? extends T>>, Action1<? super Resource>, boolean)`
- `rx.Single.using(Func0<Resource>, Func1<? super Resource, ? extends Single<? extends T>>, Action1<? super Resource>)`
- _ _
- `rx.exceptions.CompositeException.CompositeException(Throwable...)`
- _ _
- `rx.exceptions.Exceptions.throwOrReport(Throwable, Observer<?>, Object)`
- `rx.exceptions.Exceptions.throwOrReport(Throwable, Observer<?>)`
- `rx.exceptions.Exceptions.throwOrReport(Throwable, SingleSubscriber<?>)`
- _ _
- `rx.singles.BlockingSingle<T>``
### Removed
- `rx.Observable.extend(Func1<OnSubscribe<T>, R>)`
- `rx.Observable.fromAsync()`
- _ _
- `rx.Completable.CompletableSubscriber`
- `rx.Completable.CompletableOnSubscribe`
- `rx.Completable.CompletableLift`
- `rx.Completable.CompletableTransform`
",2016-09-14 10:27:23,2016-09-15 07:04:27,https://api.github.com/repos/ReactiveX/RxJava/issues/4549,"['API promotion', 'Cleanup']",538,1123,ReactiveX_RxJava_pull_4549.diff
ReactiveX/RxJava,Add switchIfEmpty(SingleSource) method.,"If you have Maybe, and do a switchIfEmpty with a Single,
you are semantically guaranteed to never get an onComplete
event.  Thus the result of the operation should be a Single
rather than a Maybe.  Let's add a convenience method for
doing this for you.
",2016-09-13 16:40:50,2016-09-22 16:59:45,https://api.github.com/repos/ReactiveX/RxJava/issues/4546,['Enhancement'],32,2,ReactiveX_RxJava_pull_4546.diff
ReactiveX/RxJava,2.x: cleanup of some javadoc errors and mentions of 'Nbp',"- fix some javadoc typos
- replace javadoc mentioning of ""unsubscribe"" with either ""cancel"" or ""dispose""
- some minor algorithm reorganizations based on IntelliJ analysis
- remove the mention of ""Nbp"" from the code and documentation (it refers to an earlier naming scheme for Observables and Observers)
",2016-09-13 12:43:01,2016-09-13 14:39:40,https://api.github.com/repos/ReactiveX/RxJava/issues/4542,['Cleanup'],2706,2699,ReactiveX_RxJava_pull_4542.diff
ReactiveX/RxJava,2.x: small cleanup and TCK fix,"- Change the `Callable<Publisher<T>>` parameter of `timeout` to plain `Publisher<T>` to simplify the API surface; use `defer(Callable<Publisher<T>>)` as input instead
- change the parameter order of `timeout` from `(long, TimeUnit, Publisher, Scheduler)` to `(long, Timeunit, Scheduler, Publisher)` to better match the general pattern of time-unit-scheduler.
- `Observable.timeout` has been updated similarly
- Add `FlowableAwaitOnSubscribeTck` to workaround the case when calling `onNext` (indirectly) from `onSubscribe` may be unexpected (plus randomly fails the observeOn TCK test).
",2016-09-13 08:31:22,2016-09-13 09:04:10,https://api.github.com/repos/ReactiveX/RxJava/issues/4541,"['Cleanup', 'Test-Failures']",267,348,ReactiveX_RxJava_pull_4541.diff
ReactiveX/RxJava,2.x: Add Create test with CancelAble for all types and add more MaybeCreateTest cases,"`setCancellable` was not tested before.
",2016-09-13 07:35:58,2016-09-13 08:21:14,https://api.github.com/repos/ReactiveX/RxJava/issues/4540,['Test'],245,0,ReactiveX_RxJava_pull_4540.diff
ReactiveX/RxJava,2.x: add most relevant ~100 operators' Reactive-Streams TCK tests,"This PR adds about ~100 Reactive-Streams Test Compatibility Kit (TCK) tests of RxJava's most relevant operators and operation modes.

The PR also contains a behavior fix for `unsubscribeOn` that now stops propagating events if the cancelled because it may take arbitrary time for the scheduled cancellation to reach the upstream which generally keeps emitting in the meantime.
",2016-09-12 21:15:42,2016-09-13 06:41:43,https://api.github.com/repos/ReactiveX/RxJava/issues/4538,['Test'],3288,12,ReactiveX_RxJava_pull_4538.diff
ReactiveX/RxJava,2.x: last Maybe operators,"This PR adds the last couple of `Maybe` operators `timeout` and `unsubscribeOn`.

@abersnaze Let me know if I missed an operator or you want some overload.

In the subsequent PRs, I'll change the return types of some classical operators to better indicate the cardinality they have (`Single`, `Completable`).
",2016-09-12 17:50:48,2016-09-12 18:20:08,https://api.github.com/repos/ReactiveX/RxJava/issues/4537,['Enhancement'],923,0,ReactiveX_RxJava_pull_4537.diff
ReactiveX/RxJava,Observable.timeout/Flowable.timeout should unsubscribe from underlying subscription on dispose,,2016-09-12 16:58:32,2016-09-12 17:21:50,https://api.github.com/repos/ReactiveX/RxJava/issues/4536,['Bug'],102,2,ReactiveX_RxJava_pull_4536.diff
ReactiveX/RxJava,"2.x: more cleanup and fixed checker, Maybe.takeUntil","- Fix missed javadoc mistakes, fix the checker that hid those mistakes in instance methods' javadoc due to a bug
- add `Maybe.takeUntil`
",2016-09-12 14:25:37,2016-09-12 14:47:41,https://api.github.com/repos/ReactiveX/RxJava/issues/4533,"['Cleanup', 'Enhancement']",705,208,ReactiveX_RxJava_pull_4533.diff
ReactiveX/RxJava,2.x: PublishSubject enhance NPE when onNext(null) is called,,2016-09-12 11:10:02,2016-09-12 11:49:48,https://api.github.com/repos/ReactiveX/RxJava/issues/4531,['Cleanup'],1,1,ReactiveX_RxJava_pull_4531.diff
ReactiveX/RxJava,"2.x: cleanup 9/12-1, more Maybe operators, more source code checking","- more `Maybe` operators: `onTerminateDetach`, `repeat`, `retry`
- fixed missing `Backpressure:` entries of the javadoc where the base type uses Flowable/Publisher
- new base type source parser and check for javadoc mistakes: wrong type mentions, a/an use
- fixes of those javadoc mistakes
",2016-09-12 10:16:55,2016-09-12 12:26:52,https://api.github.com/repos/ReactiveX/RxJava/issues/4530,"['Cleanup', 'Enhancement']",1817,164,ReactiveX_RxJava_pull_4530.diff
ReactiveX/RxJava,2.x: Fix MaybeTimber by using scheduler and unit,"Also one question why does `CompletableTimer` check `if (!sd.isDisposed()) {` before replacing but SingleTimer does not? I adjusted MaybeTimber to SingleTimer so I didn't add the check there either.

However I feel like this should be consistent, can you elaborate which one is wanted?
",2016-09-12 09:25:49,2016-09-12 15:41:34,https://api.github.com/repos/ReactiveX/RxJava/issues/4529,['Enhancement'],227,29,ReactiveX_RxJava_pull_4529.diff
ReactiveX/RxJava,"2.x: add Maybe operators, add annotation and source code checker tests","- add `Maybe` operators: `delay`, `hide`, `isEmpty`, `onErrorComplete`, `onErrorResumeNext`, `onExceptionResumeNext`
- add more fusion interfaces and mark `Maybe.just` and `Maybe.empty` as `ScalarCallable`.
- added unit test to verify base reactive classes have proper scheduler and backpressure annotations (wherever appropriate)
- added unit test to verify the javadoc of the main reactive types have the **Backpressure:** and **Scheduler:** sections in them (via scanning the source files if it can find it possible, works for me)
- added unit test to verify that when **Scheduler:** section mentions a method name, it actually matches the method the javadoc is there for (lots of copy-paste errors were found this way)
- fix the annotations and documentation errors detected above
- the backpressure javadoc section checker for 3 types are currently disabled as I'm out of time for tonight.
",2016-09-11 23:03:12,2016-09-12 06:40:25,https://api.github.com/repos/ReactiveX/RxJava/issues/4528,"['Cleanup', 'Enhancement']",3867,300,ReactiveX_RxJava_pull_4528.diff
ReactiveX/RxJava,2.x: Remove unused declarations,,2016-09-11 11:31:01,2016-09-11 13:58:18,https://api.github.com/repos/ReactiveX/RxJava/issues/4527,['Cleanup'],1,56,ReactiveX_RxJava_pull_4527.diff
ReactiveX/RxJava,2.x: More usage of ObjectHelper,,2016-09-11 10:52:44,2016-09-11 11:11:07,https://api.github.com/repos/ReactiveX/RxJava/issues/4526,[],23,55,ReactiveX_RxJava_pull_4526.diff
ReactiveX/RxJava,2.x: Fix Generics T[] in Zip & CombineLatest,"Fixes #4524

Test for combineLatest fill follow
",2016-09-10 11:12:38,2016-09-10 12:13:54,https://api.github.com/repos/ReactiveX/RxJava/issues/4525,['Bug'],275,49,ReactiveX_RxJava_pull_4525.diff
ReactiveX/RxJava,Observable/Flowable/Completable/Single.delay should always call onError on the provided Scheduler,"Fixes #4521 
",2016-09-09 20:26:47,2016-09-09 20:46:53,https://api.github.com/repos/ReactiveX/RxJava/issues/4522,['Enhancement'],139,42,ReactiveX_RxJava_pull_4522.diff
ReactiveX/RxJava,2.x: add more Maybe operators 9/09-1,"This PR adds some more `Maybe` operators:
- `ambWith`
- `cache`
- `concatWith`
- `contains`
- `count`
- `defaultIfEmpty`
- `delay`
- `switchIfEmpty`
- `zipWith`

Plus a small cleanup and additional `TestHelper` test support (check double onSubscribe calls, dispose() state management).
",2016-09-09 11:11:20,2016-09-09 15:33:49,https://api.github.com/repos/ReactiveX/RxJava/issues/4519,['Enhancement'],2090,10,ReactiveX_RxJava_pull_4519.diff
ReactiveX/RxJava,"2.x: Add missing Resource Observer for Maybe, Completable & Single and adjust some Javadoc","Fixes #4517
",2016-09-09 10:26:21,2016-09-09 15:49:15,https://api.github.com/repos/ReactiveX/RxJava/issues/4518,['Enhancement'],969,39,ReactiveX_RxJava_pull_4518.diff
ReactiveX/RxJava,"2.x: fix Single.using, add unit tests and coverage","I've forgotten to create a branch so the first part of todays coverage work [landed in 2.x direct](https://github.com/ReactiveX/RxJava/commit/1145819b658983807e0cede5ba2c7d5ac1117baa)
- removed unused methods from various classes
- compacted `SpscArrayQueue`
- added null checks to `SpscLinkedArrayQueue.offer()` and `MpscLinkedQueue.offer()`
- fixed `ResourceObserver` not calling `onStart`
- Added direct NotificationLite-emission methods to `AppendOnlyLinkedArrayList`, updated `SerializedObserver` and `SerializedSubscriber` to use it directly instead of the former indirection
- `TestObserver.isDisposed` now reports true if terminal events were received (#4514)
- `ResourceSubscriber` to use `SubscriptionHelper`'s deferred Subscription/requesting management
- added unit tests to cover `DisposableXObserver`s
- `SerializedObserver` and `SerializedSubscriber` now have proper unit tests each

This current PR fixes `Single.using` not properly managing the resource and adds unit tests to verify the behavior along with a few extra coverage improvements.
",2016-09-08 21:58:10,2016-09-08 22:38:06,https://api.github.com/repos/ReactiveX/RxJava/issues/4516,"['Bug', 'Cleanup', 'Coverage']",669,76,ReactiveX_RxJava_pull_4516.diff
ReactiveX/RxJava,2.x: fix switchMap bad cancellation,"Both `switchMap` implementations didn't properly cancel the current inner consumer (but instead cancelled the outer 'connection' only).

Reported in #4512.
",2016-09-08 15:58:54,2016-09-08 16:13:03,https://api.github.com/repos/ReactiveX/RxJava/issues/4513,['Bug'],34,3,ReactiveX_RxJava_pull_4513.diff
ReactiveX/RxJava,2.x: Adjust some JavaDoc in Emitters,,2016-09-08 12:41:53,2016-09-08 13:32:45,https://api.github.com/repos/ReactiveX/RxJava/issues/4509,['Cleanup'],8,6,ReactiveX_RxJava_pull_4509.diff
ReactiveX/RxJava,2.x: Add exception message in SingleFromCallable,,2016-09-08 12:19:20,2016-09-08 12:37:09,https://api.github.com/repos/ReactiveX/RxJava/issues/4508,['Cleanup'],1,1,ReactiveX_RxJava_pull_4508.diff
ReactiveX/RxJava,2.x: add Reactive-Streams TCK infrastructure and couple of tests,"This PR sets up the build to run TestNG tests as well and adds the Reactive-Streams TCK to allow validating our operators.

Included tests are: `just`, `fromArray`, `fromIterable`, `concat`, `merge`.

Note that the TCK tests for invalid `request()` amount which, according to the spec, should be reported to the running `Subscriber` via `onError`. Unfortunately, this is a very expensive requirement (requiring half-serialization all the time) and we are not going to support it in RxJava 2. Negative requests are bugs in operators and should be fixed, we only provide a notification about such situations in the `RxJavaPlugins.onError` for those who want to check for such errors. 

Therefore, the `FlowableTCK` has been added with does the required behavior by the TCK and can be used as `FlowableTCK.wrap(flowable)` when returning from the TCK's `createPublisher(long)`.
",2016-09-08 12:18:09,2016-09-08 12:38:25,https://api.github.com/repos/ReactiveX/RxJava/issues/4507,['Test'],449,9,ReactiveX_RxJava_pull_4507.diff
ReactiveX/RxJava,"2.x: fix operator RefCount, disable FindBugs (due to Travis OOM)","This PR fixes the operators `refCount` (ensure proper call order to onXXX), disables FindBugs due to out-of-memory kills on Travis and increases the half-time sleep of a flaky unit-test.
",2016-09-08 09:36:00,2016-09-08 10:22:09,https://api.github.com/repos/ReactiveX/RxJava/issues/4506,"['Bug', 'Build']",33,28,ReactiveX_RxJava_pull_4506.diff
ReactiveX/RxJava,2.x: Ignore Checkstyle failures,,2016-09-08 09:09:36,2016-09-08 09:13:12,https://api.github.com/repos/ReactiveX/RxJava/issues/4505,['Build'],1,0,ReactiveX_RxJava_pull_4505.diff
ReactiveX/RxJava,"2.x: Add Disposable Observer for Maybe, Completable & Single","Also any reason the Dispoable is called `s`? Is it still from the Subscription time?

Fixes #4501 
",2016-09-08 09:02:03,2016-09-08 09:18:34,https://api.github.com/repos/ReactiveX/RxJava/issues/4504,['Enhancement'],155,1,ReactiveX_RxJava_pull_4504.diff
ReactiveX/RxJava,2.x: add system properties to adjust thread priorities of Schedulers,"This PR adds the ability to specify the default thread priorities of `computation()`, `io()`, `newThread()` and `single()` schedulers via system properties. I've added the property names to the `Schedulers` javadoc.

Related: #4389.
",2016-09-08 08:45:24,2016-09-08 13:00:40,https://api.github.com/repos/ReactiveX/RxJava/issues/4503,['Enhancement'],75,7,ReactiveX_RxJava_pull_4503.diff
ReactiveX/RxJava,2.x: Replace `finallyDo` references with `doAfterTerminate`,"This should be less confusing.
",2016-09-08 08:42:18,2016-09-08 09:18:47,https://api.github.com/repos/ReactiveX/RxJava/issues/4502,"['Cleanup', 'Documentation']",4,4,ReactiveX_RxJava_pull_4502.diff
ReactiveX/RxJava,1.x: Remove trailing whitespace,"Dunno whether this is wanted or not in 1.x. If not just close this PR. 
",2016-09-08 07:46:17,2016-09-08 08:00:28,https://api.github.com/repos/ReactiveX/RxJava/issues/4500,['Cleanup'],10455,10455,ReactiveX_RxJava_pull_4500.diff
ReactiveX/RxJava,2.x,"I just do a test!
i am so sorry..
",2016-09-08 07:26:49,2016-09-08 07:40:50,https://api.github.com/repos/ReactiveX/RxJava/issues/4499,[],250595,107321,ReactiveX_RxJava_pull_4499.diff
ReactiveX/RxJava,2.x: Add Checkstyle for Trailing Whitespace,"This will add checkstyle though it should not be executed together with Travis and hence does not fail the PR if there are. Also running `./gradlew checkstyleMain` gives a list of places where trailing whitespace exists.
",2016-09-07 15:31:27,2016-09-08 07:42:36,https://api.github.com/repos/ReactiveX/RxJava/issues/4497,['Cleanup'],19,2,ReactiveX_RxJava_pull_4497.diff
ReactiveX/RxJava,2.x: Remove trailing whitespace,"Removed them like this:

`find . -type f -name ""*.java"" | xargs sed -i '' -e's/[ \t]*$//' ""$1""`

I think it's best to review this locally or by appending `?w=1` to this URL to let GitHub ignore white space changes.
",2016-09-07 14:54:35,2016-09-07 15:27:56,https://api.github.com/repos/ReactiveX/RxJava/issues/4496,['Cleanup'],22422,22422,ReactiveX_RxJava_pull_4496.diff
ReactiveX/RxJava,"2.x: more Maybe operators, minor cleanups 9/07-1","- minor Javadoc corrections
- Note: some Maybe operators shifted within the file
- add to `Maybe`: `concatArrayDelayError`, `concatArrayEager`, `concatEager`, `concatDelayError`, `mergeArrayDelayError`, `mergeDelayError`, `sequenceEqual`, `timer`, `using`, `zip`, `zipArray`
- improve coverage of `Observable`, `Single` and `Maybe`.
- Move tests from `ObservableTests` into `ObservableTest` drop the former.
",2016-09-07 13:06:41,2016-09-07 14:48:09,https://api.github.com/repos/ReactiveX/RxJava/issues/4493,"['Cleanup', 'Coverage', 'Enhancement']",3840,1137,ReactiveX_RxJava_pull_4493.diff
ReactiveX/RxJava,"2.x: reduce blockingX overhead, move internal observers to common pkg","This PR compacts the `blockingX` operators by extending `CountDownLatch` and implementing `SingleObserver`, `CompletableObserver` and `MaybeObserver` with the necessary blocking await mechanics.

Benchmark comparison (i7 4770, Windows 7 x64, Java 8u102):

![image](https://cloud.githubusercontent.com/assets/1269832/18291535/868c4d6a-7488-11e6-99f7-43415f79e5e4.png)

In addition, the internal package `subscribers.single` and `subscribers.completable` has been removed and the classes moved into `io.reactivex.internal.observers` package. The old blocking enum helpers were removed as well.

The `BlockingSingleSubscriber` and `BlockingSingleObserver` abstract classes have been renamed to `BlockingBaseX` to avoid name confusion (they have nothing to do with the `Single` type).
",2016-09-06 21:24:13,2016-09-07 06:57:55,https://api.github.com/repos/ReactiveX/RxJava/issues/4491,"['Cleanup', 'Performance']",333,350,ReactiveX_RxJava_pull_4491.diff
ReactiveX/RxJava,2.x: rename emitters #isCancelled to #isDisposed,"Renames Observable/Single/CompletableEmitter#isCancelled to #isDisposed.

This now causes a bit of a weird situation where most (not all) Emitter classes implement `Disposable` as well, so both interfaces expose the same `#isDisposed` method. Before the `#isCancelled` methods were basically just calling `#isDisposed` or had the same implementation. 

Suggestions on how to improve this?
",2016-09-06 18:06:55,2016-09-06 20:38:15,https://api.github.com/repos/ReactiveX/RxJava/issues/4490,['Cleanup'],16,36,ReactiveX_RxJava_pull_4490.diff
ReactiveX/RxJava,"2.x: add new methods to Maybe, Observable and Single from 4481","This PR adds just the new methods from #4481 to allow a much cleaner change of return types later on.
",2016-09-06 15:44:23,2016-09-06 16:32:17,https://api.github.com/repos/ReactiveX/RxJava/issues/4488,['Enhancement'],561,19,ReactiveX_RxJava_pull_4488.diff
ReactiveX/RxJava,2.x: Completable enhance doOnEvent to reduce allocations,,2016-09-06 13:30:04,2016-09-06 15:13:50,https://api.github.com/repos/ReactiveX/RxJava/issues/4486,['Enhancement'],104,17,ReactiveX_RxJava_pull_4486.diff
ReactiveX/RxJava,"2.x: Flowable.reduce() to return Single, macro fusion","This PR adds the baseline for changing `Flowable` and `Observable` operators to return `Single`, `Completable` or `Maybe` but in case the user wants to go back to the original type via `toFlowable` or `toObservable` we switch to a natively `Flowable`/`Observable` operator (macro-fusion).

Benchmark comparison (i7 4790, Windows 7 x64, Java 8u102):

![image](https://cloud.githubusercontent.com/assets/1269832/18269896/98ffbf80-742a-11e6-91b7-23b03bec8b8c.png)

No changes were applied to `Observable` yet hence the roughly same result there. `Flowable.reduce()` has been updated plus there is a new `FlowableReduce` instead of `scan().last()`.
",2016-09-06 10:09:34,2016-09-06 15:14:05,https://api.github.com/repos/ReactiveX/RxJava/issues/4484,"['Enhancement', 'Performance']",1191,718,ReactiveX_RxJava_pull_4484.diff
ReactiveX/RxJava,2.x: Reuse SingleDoOnEvent,,2016-09-06 09:19:47,2016-09-06 12:25:15,https://api.github.com/repos/ReactiveX/RxJava/issues/4483,[],21,130,ReactiveX_RxJava_pull_4483.diff
ReactiveX/RxJava,2.x: Fix Generic issue in Single,,2016-09-06 08:28:02,2016-09-06 13:05:08,https://api.github.com/repos/ReactiveX/RxJava/issues/4482,[],1,1,ReactiveX_RxJava_pull_4482.diff
ReactiveX/RxJava,Integrate Maybe and Single into Observable. *** DO NOT MERGE,"I've been working on the this for too long in the background and want to get this out for review even though many of the units tests don't pass yet. Its a bit rough at the moment but there was a couple of things that I wanted to talk about.
1. does it make sense to have ignoreElements where there is a toCompletable.
2. the same goes for single when there is a toSingle.
3. moved toFuture to Single since it seems to fit better.
",2016-09-06 05:54:48,2016-09-12 18:20:56,https://api.github.com/repos/ReactiveX/RxJava/issues/4481,['Enhancement'],659,1305,ReactiveX_RxJava_pull_4481.diff
ReactiveX/RxJava,Integrate Maybe and Single into Observable. *** DO NOT MERGE ***,"I've been working on the this for too long in the background and want to get this out for review even though many of the units tests don't pass yet.

Its a bit rough at the moment but there was a couple of things that I wanted to talk about.
1. does it make sense to have `ignoreElements` where there is a `toCompletable`.
2. the same goes for `single` when there is a `toSingle`.
3. moved `toFuture` to Single since it seems to fit better.
",2016-09-06 05:51:11,2016-09-06 05:51:55,https://api.github.com/repos/ReactiveX/RxJava/issues/4480,[],246493,107321,ReactiveX_RxJava_pull_4480.diff
ReactiveX/RxJava,2.x: Add doOnEvent to Single & Completable,,2016-09-06 05:11:01,2016-09-06 06:55:25,https://api.github.com/repos/ReactiveX/RxJava/issues/4479,['Enhancement'],186,1,ReactiveX_RxJava_pull_4479.diff
ReactiveX/RxJava,Fix typo Javadocs TestObserver,,2016-09-05 17:34:56,2016-09-05 17:54:28,https://api.github.com/repos/ReactiveX/RxJava/issues/4478,['Documentation'],29,29,ReactiveX_RxJava_pull_4478.diff
ReactiveX/RxJava,1.1.10 javadoc,"Update Javadoc 1.1.10 on gh-pages
",2016-09-05 12:52:10,2016-09-05 12:52:58,https://api.github.com/repos/ReactiveX/RxJava/issues/4474,['Documentation'],75102,2232,ReactiveX_RxJava_pull_4474.diff
ReactiveX/RxJava,2.x: coverage and fixes 9/03-2,"- enable fusion with `Observable.map`
- remove impossible branches in some classes
- add more tests to cover tool classes
- fix `Observable.range()` entering regular emission if fusion-drain is interrupted
- fix `FullArbiter` and `ObservableFullArbiter` not cancelling/disposing the incoming Subscription/Disposable in some cases
",2016-09-03 13:21:55,2016-09-03 14:38:36,https://api.github.com/repos/ReactiveX/RxJava/issues/4469,"['Bug', 'Cleanup', 'Coverage']",4338,411,ReactiveX_RxJava_pull_4469.diff
ReactiveX/RxJava,"2.x: coverage, bugfixes, 9/03-1","- Fixed bugs in `Flowable.sequenceEqual`, `Flowable.zip` when errors are delayed, `Flowable.onBackpressureBuffer` when errors are delayed
- Fixed mentions of `NbpX` in some places
- Synchronized unit tests between `Observable` and `Flowable`
",2016-09-02 22:19:28,2016-09-02 22:53:48,https://api.github.com/repos/ReactiveX/RxJava/issues/4468,"['Bug', 'Cleanup', 'Coverage']",3425,560,ReactiveX_RxJava_pull_4468.diff
ReactiveX/RxJava,"2.x: add more Maybe operators, fix a few javadoc mistakes","- Move `verifyPositive` into `ObjectHelper`
- Fix javadoc of `Flowable.subscribe()` and `Observable.subscribe()` mentioning `Subscription` from 1.x
- `Maybe`: add `amb`, `concat`, `concatArray`, `merge`, `mergeArray`, `concatMap`, `subscribe`, `subscribeWith`, `doOnEvent`
",2016-09-02 13:33:23,2016-09-02 16:04:03,https://api.github.com/repos/ReactiveX/RxJava/issues/4467,"['Documentation', 'Enhancement']",3093,344,ReactiveX_RxJava_pull_4467.diff
ReactiveX/RxJava,1.x: Deprecate Notification.createOnCompleted,"Fix #4462 

It might just as well shine some light into which method should be used and explain why there are 2
",2016-09-02 09:26:10,2016-09-02 14:01:53,https://api.github.com/repos/ReactiveX/RxJava/issues/4466,['Cleanup'],2,0,ReactiveX_RxJava_pull_4466.diff
ReactiveX/RxJava,1.x: Remove some unused fields,,2016-09-01 23:18:36,2016-09-02 07:00:04,https://api.github.com/repos/ReactiveX/RxJava/issues/4463,['Cleanup'],3,11,ReactiveX_RxJava_pull_4463.diff
ReactiveX/RxJava,1.x: Single add doOnEach,"Really not that happy with `onNotification.call(Notification.<T>createOnNext(t));` do you guys have any other way of doing this? There's no way of creating a Notification that has the `onCompleted` plus a value. A new one could be introduced there though. Also the `doOnEachSuccess` test feels clunky.

Also why does Single when using the `do` methods does the job by using an Observable? And later converting it back to a Single again. Is it due to the way Single was implemented in 1.x? With Completable there is no converting of back and forth needed.

Javadoc will follow once we sorted out the few nits here.

Fixes #4457 
",2016-09-01 23:02:27,2016-09-05 12:18:01,https://api.github.com/repos/ReactiveX/RxJava/issues/4461,['Enhancement'],192,24,ReactiveX_RxJava_pull_4461.diff
ReactiveX/RxJava,1.x: Completable add doOnEach,"First part of #4457 

Is it okay that I reused Notification like that?

Also are there any Java 6 Generics missing? It would be nice if this project was set up to target Java SDK 6, as my default seems to be Java 8 and I don't get any errors shown in the IDE.
",2016-09-01 20:09:07,2016-09-02 06:47:05,https://api.github.com/repos/ReactiveX/RxJava/issues/4460,['Enhancement'],61,2,ReactiveX_RxJava_pull_4460.diff
ReactiveX/RxJava,2.x: rename Observable and Single #doOnCancel to #doOnDispose,"#4456

Completable already used .doOnDispose() however I renamed the arguments to match Observable and Single
",2016-09-01 17:58:30,2016-09-01 18:45:58,https://api.github.com/repos/ReactiveX/RxJava/issues/4458,['Cleanup'],70,70,ReactiveX_RxJava_pull_4458.diff
ReactiveX/RxJava,"2.x: start reimplementing Maybe with up-to-date javadoc, tests and algo","This PR reimplements the `Maybe` with more up-to-date algorithms (the original was a copy-paste of some older Single and Completable code it seems) and adds javadoc and tests along the way. Not all operators have been rewritten yet (and no placeholders). Early adopters should refer to the `toX` methods on the base reactive types. The PR also adds the `RxJavaPlugins` hooks to support `Maybe`.

In addition, I've fixed javadoc mistakes in the other base reactive types (referring to the wrong types).
",2016-09-01 13:32:00,2016-09-01 14:25:58,https://api.github.com/repos/ReactiveX/RxJava/issues/4454,"['Cleanup', 'Enhancement']",4828,4000,ReactiveX_RxJava_pull_4454.diff
ReactiveX/RxJava,Wrap InterruptedException with an unchecked exception in TestSubscriber#awaitValueCount().,"In its current form, `awaitValueCount()` is the only `TestSubscriber#await*`method that throws a checked exception (that is, `InterruptedException`), whereas the others wrap it with a `IllegalStateException`. This spreads a try-catch disease throughout the entire code base where `awaitValueCount()` is used. One can argue that why not just declaring the exception in the caller method footprint: Because you might be implementing an interface (e.g. `Runnable`) which does not allow any exceptions in its footprint. This patch wraps the `InterruptedException` with an unchecked exception in `TestSubscriber#awaitValueCount()`.
",2016-09-01 10:33:25,2016-09-01 13:35:38,https://api.github.com/repos/ReactiveX/RxJava/issues/4453,['Enhancement'],9,5,ReactiveX_RxJava_pull_4453.diff
ReactiveX/RxJava,enhance generics on onErrorResumeNext and onErrorReturn,"`Func1<Throwable,...>` parameter should be `Func1<? super Throwable, ...>`
",2016-09-01 02:23:19,2016-09-01 06:54:14,https://api.github.com/repos/ReactiveX/RxJava/issues/4452,['Cleanup'],5,5,ReactiveX_RxJava_pull_4452.diff
ReactiveX/RxJava,"2.x: fixes, cleanup, coverage 8/31-1","- Improve coverage of internal classes
- Turn more empty enums into classes with private constructors
- Fix `Single.subscribeOn` and `Completable.subscribeOn` disposable management.
- Create a compact `FutureSubscriber` and `FutureObserver` classes, drop their former enums
- Deprecate `Disposables.from` methods, add `Disposables.fromX` methods where X = argument type
- Fix error management in `Completable.mergeX` operators.
- Remove unused methods from internal classes
",2016-08-31 12:18:58,2016-08-31 13:36:00,https://api.github.com/repos/ReactiveX/RxJava/issues/4450,"['Bug', 'Cleanup', 'Coverage', 'Test']",2398,855,ReactiveX_RxJava_pull_4450.diff
ReactiveX/RxJava,Fix withLatestFrom's tparam,,2016-08-31 03:09:55,2016-08-31 07:27:17,https://api.github.com/repos/ReactiveX/RxJava/issues/4447,['Bug'],10,10,ReactiveX_RxJava_pull_4447.diff
ReactiveX/RxJava,"1.x: cleanup, javadoc, Completable.fromEmitter","- Add javadoc to `AsyncEmitter.BackpressureMode` (#4199)
- Deprecate `Observable.fromAsync`, add `Observable.fromEmitter` instead (#4255)
- Add `Completable.fromEmitter()` (#4356)
- Add missing placeholder `@since` tags
- Fix some generics error `RxJavaHooks`
- Add race helper to `TestUtil`
- Fix javadoc warnings
",2016-08-30 09:04:54,2016-08-30 13:59:39,https://api.github.com/repos/ReactiveX/RxJava/issues/4442,"['Cleanup', 'Documentation', 'Enhancement']",815,88,ReactiveX_RxJava_pull_4442.diff
ReactiveX/RxJava,Fix FlowableOnBackpressureBufferStrategy,"Fix buffered objects not propagated downstream in FlowableOnBackpressureBufferStrategy
Fix drop strategy logic in FlowableOnBackpressureBufferStrategy
Add unit test for FlowableOnBackpressureBufferStrategy, copied from FlowableOnBackpressureBufferTest, there is still some work needed to have a better coverage
",2016-08-30 08:30:41,2016-08-31 07:28:20,https://api.github.com/repos/ReactiveX/RxJava/issues/4441,['Bug'],137,4,ReactiveX_RxJava_pull_4441.diff
ReactiveX/RxJava,2.x: Subject/Processor improvements & small cleanup,"- open up `verifyPositive` as protected for validation convenience in subclasses
- improve size and state handling of `DeferredScalarSubscription`
- enable async-fusion on `AsyncSubject` and `AsyncProcessor`, compact the classes
- **behavior change** `AsyncX.hasValue()` returns false until the terminal state has been reached
- compact the classes `PublishSubject`, `PublishProcessor`, `BehaviorSubject`, `BehaviorProcessor`, `ReplaySubject` and `ReplayProcessor`
- enable async-fusion on `UnicastSubject`, compact the class
- rename `BaseXQueueDisposable` to `BasicXQueueDisposable` to match `BasicXQueueSubscription`
- introduce `DeferredScalarDisposable`, refactor `DeferredScalarObserver`
- adjust tests that asserted on the former parameter names
- subjects and processors can now be created with newing up their constructor: `new PublishSubject<>()`; there is no mandatory shared state between the `Observer` part and the `Observable` part because both are now stateless on their own.
",2016-08-29 10:30:00,2016-08-29 17:47:49,https://api.github.com/repos/ReactiveX/RxJava/issues/4437,"['Cleanup', 'Enhancement']",2321,2213,ReactiveX_RxJava_pull_4437.diff
ReactiveX/RxJava,2.x: Maybe for lazy Optional,"In #4321 I hit on the problem of needing a lazy object that could either be zero or one value. In that issue the idea of switching the return value of `reduce(R, Func2<R,T,R>)` from `Observable<R>` to `Single<R>` because that operator can only ever produce an Observable that emits exactly one value. The problem was that `reduce(Func2<T,T,T>)` could not be changed to `Single<T>` because the source Observable could be empty and therefore not produce one and only one value.

To solve this problem I mentioned we could create a lazy type that represents either 1 or no value could fill the gap between `Completable` and `Single<T>`.

This PR is for the introduction of the `Maybe<T>` type.
",2016-08-29 05:01:43,2016-09-01 06:53:04,https://api.github.com/repos/ReactiveX/RxJava/issues/4436,['Feature-Request'],4451,0,ReactiveX_RxJava_pull_4436.diff
ReactiveX/RxJava,"2.x: cleanup, behavior clarifications, fixes, coverage 8/28-1","- Add tests
- fix mistakes in `TestObserver`
- Combine `DisposableHelper` and its inner `Disposed` enum
- Compact `NotificationLite` and its inner `Complete` enum
- Fix NPE in `ListCompositeDisposable` constructor
- Fix `DeferredScalarObserver` fusion and state management
- Turned a few empty enums into classes with private constructor: coverage can't cover them 100% otherwise. These empty enums have a constructor in their bytecode which never gets called and thus there's always 10 instructions / 2 method calls missing.
- Removed `TestObserver.awaitDone()`, one should always await with timeout
",2016-08-28 14:58:43,2016-08-28 20:56:08,https://api.github.com/repos/ReactiveX/RxJava/issues/4435,"['Bug', 'Cleanup', 'Coverage', 'Test']",3237,234,ReactiveX_RxJava_pull_4435.diff
ReactiveX/RxJava,"2.x: cleanup, bugfixes, coverage 8/27-2","- Remove unused code
- Improve coverage of `Single`, `Completable` and `Observable`
- Fix minor bugs in operators
",2016-08-27 18:53:05,2016-08-27 19:36:36,https://api.github.com/repos/ReactiveX/RxJava/issues/4434,"['Bug', 'Cleanup', 'Coverage']",3667,166,ReactiveX_RxJava_pull_4434.diff
ReactiveX/RxJava,Fix typo.,,2016-08-27 17:43:38,2016-08-27 18:09:37,https://api.github.com/repos/ReactiveX/RxJava/issues/4433,[],1,1,ReactiveX_RxJava_pull_4433.diff
ReactiveX/RxJava,Fix typo.,,2016-08-27 16:59:31,2016-08-27 17:20:58,https://api.github.com/repos/ReactiveX/RxJava/issues/4432,[],1,1,ReactiveX_RxJava_pull_4432.diff
ReactiveX/RxJava,"2.x: coverage, fixes, cleanup 8/27-1","- updated `Single.cache()` to be lock-free, to allocate less and work properly
- added test coverage to some classes
- remove unused internal `EmptyObserver`
- update `PublishSubject` to support cross-cancellation
- update `TestHelper.race` to use the current thread for one of the tasks
",2016-08-26 21:48:29,2016-08-26 22:12:01,https://api.github.com/repos/ReactiveX/RxJava/issues/4431,"['Bug', 'Cleanup']",959,229,ReactiveX_RxJava_pull_4431.diff
ReactiveX/RxJava,"2.x Improve coverage, fix bugs","The new tests revealed some bugs (nothing major).
",2016-08-26 13:07:13,2016-08-26 18:43:05,https://api.github.com/repos/ReactiveX/RxJava/issues/4430,"['Bug', 'Test']",3430,211,ReactiveX_RxJava_pull_4430.diff
ReactiveX/RxJava,2.x: collect - handle post terminal events  - Observable,"Post-terminal event handling for `Observable.collect`.

Added three unit tests that failed on original logic.
",2016-08-26 06:11:35,2016-08-26 06:40:14,https://api.github.com/repos/ReactiveX/RxJava/issues/4428,"['Bug', 'Cleanup']",292,85,ReactiveX_RxJava_pull_4428.diff
ReactiveX/RxJava,1.x: fromAsync - handle post-terminal events,"`fromAsync` did not handle post-terminal events properly when overflow occurs.

Added three unit tests that failed on original logic.
",2016-08-26 04:13:59,2016-08-26 06:41:31,https://api.github.com/repos/ReactiveX/RxJava/issues/4427,['Bug'],110,1,ReactiveX_RxJava_pull_4427.diff
ReactiveX/RxJava,"1.x: Remove 'Completable' prefix from nested interfaces, move its subscription to top-level.","This is only the `Completable` part of #4420. It does not make `CompletableSubscriber` an abstract class nor create `Single.Operator`.
",2016-08-25 15:55:23,2016-08-30 07:12:49,https://api.github.com/repos/ReactiveX/RxJava/issues/4425,['Enhancement'],393,233,ReactiveX_RxJava_pull_4425.diff
ReactiveX/RxJava,"Update javadoc 1.1.9, add dirs and 2.0.0-RC1 doc","- Moved old javadocs under `/1.x/javadoc/version_number`
- Added `/2.x/javadoc/`
- Updated `/javadoc` to have the 1.1.9 documentation

There was a small hiccup with the 2.x release as the javadoc didn't properly generate (bad link and missing css). I've included the locally generated javadoc here which is titled 2.0.0-DP0-SNAPSHOT at the moment.
",2016-08-25 08:23:19,2016-08-25 08:24:52,https://api.github.com/repos/ReactiveX/RxJava/issues/4424,['Documentation'],232349,1129,ReactiveX_RxJava_pull_4424.diff
ReactiveX/RxJava,1.x: Add to() conversion function to all stream types.,"This deprecates extend() on Observable, which is a less powerful version of these functions.
",2016-08-25 01:01:08,2016-08-25 07:51:18,https://api.github.com/repos/ReactiveX/RxJava/issues/4423,['Enhancement'],85,7,ReactiveX_RxJava_pull_4423.diff
ReactiveX/RxJava,2.x: add subscribeWith to get back the subscriber/observer fluently,"This PR adds the `subscribeWith` methods to the base reactive types to mainly help with the 1.x to 2.x changeover as 2.x `subscribe(Subscriber)` return void instead of the resource/cancellation/unsubscription type `Disposable`. See the javadocs and the unit test for example use.

Related: #4400
",2016-08-24 20:28:49,2016-08-24 22:49:39,https://api.github.com/repos/ReactiveX/RxJava/issues/4422,['Enhancement'],178,2,ReactiveX_RxJava_pull_4422.diff
ReactiveX/RxJava,"2.x: fixes, cleanups, renames","Changes:
- fix spelling mistakes
- more consistent parameter naming scheme based on #1353 (but incomplete, RC2)
- fix bugs due to wrong variable naming
- compact logic expressions
- fix `Completable.doAfterTerminate` not called the right time
- `onErrorReturnValue` renamed to `onErrorReturnItem`

@DavidMGross once this PR has been merged, it would be great you submitted one that has `//TODO` markers on those lines that need attention. The naming scheme you suggested doesn't come intuitively to me so I may skip many of them without the markers.
",2016-08-24 19:29:58,2016-08-24 20:02:46,https://api.github.com/repos/ReactiveX/RxJava/issues/4421,"['Bug', 'Cleanup', 'Documentation']",1778,1855,ReactiveX_RxJava_pull_4421.diff
ReactiveX/RxJava,1.x: Add extend() for Single and Completable.,"Matches `Observable.extend()`. These are all `@Experimental` (including `Observable`). Perhaps we want to rename them all `to()` to match 2.x?
",2016-08-24 17:16:17,2016-08-24 19:57:12,https://api.github.com/repos/ReactiveX/RxJava/issues/4419,[],284,1,ReactiveX_RxJava_pull_4419.diff
ReactiveX/RxJava,1.x: Sync doOnEach java doc,"The other `doOnEach` function has the right java doc. Terminal events such as `onCompleted` / `onError` are also included in `doOnEach`.
",2016-08-24 09:17:29,2016-08-24 09:34:05,https://api.github.com/repos/ReactiveX/RxJava/issues/4418,['Documentation'],1,1,ReactiveX_RxJava_pull_4418.diff
ReactiveX/RxJava,"2.x: add assembly tracking, minor fixes and cleanup","Notable changes:
- renamed `amb(sources...)` to `ambArray(sources...)` to be consistent with the naming of other operators with varargs input
- Renamed some other varargs operators ot `xArray` to be consistent
- Added `RxJavaPlugins.onAssembly()` to operators, note that no other infrastructure (such as `enableAssemblyTracking` was added; companion libraries may later utilize these hooks to inject the necessary wrapper classes.
- Extended `RxJavaPlugins.onAssembly()` to support `ConnectableX` operators
- Renamed `FlowProcessor` into `FlowableProcessor` to avoid future confusion with JDK 9's `Flow.Processor`
- Removed common value extraction methods from `Subject` and `FlowableProcessor` and left them in the implementations
- Made common terminal state checking methods of `Subject` and `FlowableProcessor` as abstract since all subtypes can implement them reasonably
- fixed copy-paste errors in javadocs, such as wrong class named, referencing non-existent backpressure
",2016-08-24 09:07:49,2016-08-24 15:36:19,https://api.github.com/repos/ReactiveX/RxJava/issues/4417,"['Cleanup', 'Enhancement']",1206,1175,ReactiveX_RxJava_pull_4417.diff
ReactiveX/RxJava,2.x: API removals and renames,"Notable changes:
- delete `concat` 5-9 arguments, use `concat(just(...))` or `concatArray(...)` instead
- delete `withLatestFrom` 5-8 arguments
- rename `merge(Publisher...)` into `mergeArray(Publisher...)` to disambiguate
- rename `merge(int, int, Publisher...)` into `mergeArray(int, int, Publisher...)` to disambiguate
- delete `merge(int, Publisher...)` overload
- rename `mergeDelayError(Publisher...)` into `mergeArrayDelayError(Publisher...)` to disambiguate
- rename `mergeDelayError(int, int, Publisher...)` into `mergeArrayDelayError(int, int, Publisher...)` to disambiguate
- delete `mergeDelayError(int, Publisher...)` overload
- delete `takeLatestBuffer` overloads
",2016-08-23 16:43:34,2016-08-24 06:45:21,https://api.github.com/repos/ReactiveX/RxJava/issues/4413,['Cleanup'],23,1876,ReactiveX_RxJava_pull_4413.diff
ReactiveX/RxJava,"2.x: cleanup, enhancements 8/23-1","Notable changes:
- Introduce `Emitter<T>` as a base interface for `FlowableEmitter` and `ObservableEmitter`, use it for the `generate()` operators to be the push surface.
- Hide fusion-related methods in `TestSubscriber` and `TestObserver`, remove `test()` method overload from the base reactive classes, introduce `SubscriberFusion` and `ObserverFusion` helper in the test source set
- Enable fusion on `Observable.range()`.
- Move `Observer`-related tests into the `observers` test package.
",2016-08-23 09:31:36,2016-08-23 15:11:54,https://api.github.com/repos/ReactiveX/RxJava/issues/4410,"['Cleanup', 'Enhancement']",767,321,ReactiveX_RxJava_pull_4410.diff
ReactiveX/RxJava,"2.x: add missing ops, cleanup, fusion fixes","Notable changes:
- Implement `concatEager` and its variants
- Implement `onTerminateDetach`
- Implement `distinctUntilChanged(BiPredicate)`
- Replace `EmptyDisposable.INSTANCE` with `Disposables.empty()` due to clash with fusion (sending an INSTANCE tells a fusion-enabled source to not expect onNext values yet the test still send those - this was a problem with EmptySubscription.INSTANCE a while back too). Also added javadoc warning about its use
- add `ObservableScalarXMap` optimization to `Observable.xMap(Function)` and their operator's `subscribeActual`
- Make `ObservableJust` `ScalarCallable` and sync-fuseable with `ScalarDisposable` (similar to `Flowable.just()`)
- Make `Observable.bufferSize()` public for convenience.
- Fix `flatMap` fused `Callable` handling
- Renamed `Objects` to `ObjectHelper` to avoid accidental bad imports of `java.util.Objects` of Java 8.
",2016-08-22 12:55:12,2016-08-23 07:55:26,https://api.github.com/repos/ReactiveX/RxJava/issues/4403,"['Bug', 'Cleanup', 'Enhancement']",3946,1553,ReactiveX_RxJava_pull_4403.diff
ReactiveX/RxJava,2.x: Avoid potential NPE when onError throws.,"t2 was only initialized if canceling threw an exception. In the happy path it would have never been initialized so when onError threw the call to suppress() would NPE.
",2016-08-21 21:48:02,2016-08-22 07:00:34,https://api.github.com/repos/ReactiveX/RxJava/issues/4398,['Bug'],5,2,ReactiveX_RxJava_pull_4398.diff
ReactiveX/RxJava,1.x: Fix multiple values produced by throttleFirst with TestScheduler,"When throttleFirst was operating on a TestScheduler, it delivered all items passed to it untill TestScheduler's time would change to a non-zero value.
",2016-08-21 14:55:29,2016-08-21 15:27:43,https://api.github.com/repos/ReactiveX/RxJava/issues/4397,['Bug'],44,2,ReactiveX_RxJava_pull_4397.diff
ReactiveX/RxJava,2.x: Observable test change dispose to cancel,,2016-08-21 11:36:04,2016-08-21 14:53:47,https://api.github.com/repos/ReactiveX/RxJava/issues/4396,['Cleanup'],1,1,ReactiveX_RxJava_pull_4396.diff
ReactiveX/RxJava,2.x: Completable.test cancel TestSubscriber when wanted,,2016-08-21 11:35:28,2016-08-21 12:06:58,https://api.github.com/repos/ReactiveX/RxJava/issues/4395,['Cleanup'],4,1,ReactiveX_RxJava_pull_4395.diff
ReactiveX/RxJava,2.x: Single.test cancel TestSubscriber when wanted,,2016-08-21 10:59:04,2016-08-21 12:05:07,https://api.github.com/repos/ReactiveX/RxJava/issues/4394,['Cleanup'],5,1,ReactiveX_RxJava_pull_4394.diff
ReactiveX/RxJava,2.x: Completable.test cancel TestSubscriber when wanted,"Also should not `cancelled` be renamed to `shouldDispose`? Also the java doc might need a repolish then.
",2016-08-21 10:57:21,2016-08-21 11:30:40,https://api.github.com/repos/ReactiveX/RxJava/issues/4393,[],0,0,ReactiveX_RxJava_pull_4393.diff
ReactiveX/RxJava,2.x: Remove explicit StackOverflow check as its a VirtualMachineError.,"Looks like [the linked comment](https://github.com/ReactiveX/RxJava/issues/748#issuecomment-32471495) was misinterpreted (but not in a way that affected the implementation) as Scala considered StackOverflowError as non-fatal but RxJava always considered it fatal. As such, its explicit check was redundant.
",2016-08-21 05:05:21,2016-08-21 08:43:00,https://api.github.com/repos/ReactiveX/RxJava/issues/4391,['Cleanup'],1,4,ReactiveX_RxJava_pull_4391.diff
ReactiveX/RxJava,1.x: Remove explicit StackOverflow check as its a VirtualMachineError.,"Looks like [the linked comment](https://github.com/ReactiveX/RxJava/issues/748#issuecomment-32471495) was misinterpreted (but not in a way that affected the implementation) as Scala considered StackOverflowError as non-fatal but RxJava always considered it fatal. As such, its explicit check was redundant.
",2016-08-21 05:05:19,2016-08-21 08:41:53,https://api.github.com/repos/ReactiveX/RxJava/issues/4390,['Cleanup'],1,4,ReactiveX_RxJava_pull_4390.diff
ReactiveX/RxJava,2.x: Remove reference counted Disposable public type.,"This is a very specific use case to provide as a first-party type which can always be added back later should there be sufficient demand.
",2016-08-21 01:00:26,2016-08-21 08:33:19,https://api.github.com/repos/ReactiveX/RxJava/issues/4388,['Cleanup'],0,196,ReactiveX_RxJava_pull_4388.diff
ReactiveX/RxJava,2.x: Remove unused test methods from safe observer/subscriber.,,2016-08-21 00:25:25,2016-08-21 08:36:04,https://api.github.com/repos/ReactiveX/RxJava/issues/4387,['Cleanup'],2,10,ReactiveX_RxJava_pull_4387.diff
ReactiveX/RxJava,2.x: Move error consumer helper to internal API.,,2016-08-21 00:22:52,2016-08-21 08:35:10,https://api.github.com/repos/ReactiveX/RxJava/issues/4386,['Cleanup'],19,27,ReactiveX_RxJava_pull_4386.diff
ReactiveX/RxJava,2.x: Free upstream resources when default observer/subscriber is canceled.,,2016-08-21 00:22:47,2016-08-21 08:34:44,https://api.github.com/repos/ReactiveX/RxJava/issues/4385,['Cleanup'],6,1,ReactiveX_RxJava_pull_4385.diff
ReactiveX/RxJava,2.x: Do not promise a new instance where we return a singleton.,,2016-08-21 00:10:16,2016-08-21 00:39:48,https://api.github.com/repos/ReactiveX/RxJava/issues/4384,['Cleanup'],2,2,ReactiveX_RxJava_pull_4384.diff
ReactiveX/RxJava,2.x: Remove double dash on RxThreadFactory thread names.,"Also optimize name creation to avoid `StringBuilder` having to expand its underlying `char[]`.
",2016-08-20 23:53:10,2016-08-21 00:18:09,https://api.github.com/repos/ReactiveX/RxJava/issues/4383,['Cleanup'],10,13,ReactiveX_RxJava_pull_4383.diff
ReactiveX/RxJava,2.x: Correctly dereference subscription before comparing against null.,,2016-08-20 22:54:25,2016-08-21 00:16:21,https://api.github.com/repos/ReactiveX/RxJava/issues/4382,['Bug'],3,3,ReactiveX_RxJava_pull_4382.diff
ReactiveX/RxJava,2.x: Correct factory method name for converting an RS Publisher.,,2016-08-20 16:05:52,2016-08-20 17:30:36,https://api.github.com/repos/ReactiveX/RxJava/issues/4381,['Cleanup'],4,5,ReactiveX_RxJava_pull_4381.diff
ReactiveX/RxJava,2.x: Remove test scheduler factory.,"This method is misleading in that it's a factory next to a bunch of accessor methods to shared resources. The TestScheduler constructor is public and can be used directly.
",2016-08-20 16:02:28,2016-08-20 17:28:12,https://api.github.com/repos/ReactiveX/RxJava/issues/4380,['Cleanup'],22,32,ReactiveX_RxJava_pull_4380.diff
ReactiveX/RxJava,2.x: Move single-use top-level type to nested class of its only use.,,2016-08-20 16:02:20,2016-08-20 17:29:32,https://api.github.com/repos/ReactiveX/RxJava/issues/4379,['Cleanup'],26,46,ReactiveX_RxJava_pull_4379.diff
ReactiveX/RxJava,"2.x: implement ops, add javadoc, remove unused components 8/19-2","Notable changes:
- use JMH 1.13
- fix javadoc generator exclude pattern
- add javadoc to many components
- remove `Observers` and `Subscribers` - all their function is available via subscribe() and/or by implementing the abstract `XObserver`/`XSubscriber` provided
- remove `Schedulers.immediate()`
- remove `Single.subscribe(Subscriber)`, `Single.subscribe(Observer)`, `Completable.subscribe(Subscriber)` and `Completable.subscribe(Observer)`
- remove `CompletableSerializedObserver` and `SingleSerializedObserver` and their parent package
- implement `Single.takeUntil`, `Single.flatMapCompletable`
- update the time-shift handling in the default `Scheduler.schedulePeriodically()` to match 1.x
- fix `Single.subscribeOn` disposable management
- renamed `Subject.hasSubscribers` to `Subject.hasObservers`
",2016-08-19 20:03:22,2016-08-19 20:20:36,https://api.github.com/repos/ReactiveX/RxJava/issues/4378,"['Cleanup', 'Documentation', 'Enhancement']",2300,1887,ReactiveX_RxJava_pull_4378.diff
ReactiveX/RxJava,"2.x: added missing ops, cleanup 8/19-1","Notable changes:
- renamed and added safe `create` support to `Observable`, `Single` and `Completable`
- added some javadoc
- added `test()` method to `Single` and `Completable`
- factored out `ErrorMode` into `internal.util` (used by various `concat` operators)
",2016-08-19 09:36:48,2016-08-19 15:13:10,https://api.github.com/repos/ReactiveX/RxJava/issues/4375,"['Cleanup', 'Documentation', 'Enhancement']",1653,418,ReactiveX_RxJava_pull_4375.diff
ReactiveX/RxJava,2.x: Implement ObservableHide for also masking the Disposable.,,2016-08-18 21:51:21,2016-08-18 22:09:22,https://api.github.com/repos/ReactiveX/RxJava/issues/4372,['Enhancement'],81,2,ReactiveX_RxJava_pull_4372.diff
ReactiveX/RxJava,2.x: move blocking operators into the base classes,"This PR removes the `BlockingFlowable` and `BlockingObservable` classes and moves the blocking operators into the respective reactive classes and names prefixed with `blocking`.

In addition, many of the mentions of `Flowable` has been replaced with `Observable` in `Observable`.

Related: #4366.
",2016-08-18 20:28:59,2016-08-18 20:59:39,https://api.github.com/repos/ReactiveX/RxJava/issues/4371,"['Cleanup', 'Enhancement']",2384,1661,ReactiveX_RxJava_pull_4371.diff
ReactiveX/RxJava,"2.x: remove Try+Optional, introduce Notification","This PR removes the `Try` and `Optional` classes and (re)introduces `Notification<T>`.

There are several ways to implement it. This PR uses the abstract class + private subclasses approach that saves on instance size.

Related discussion: #4365.
",2016-08-18 17:24:47,2016-08-18 18:24:04,https://api.github.com/repos/ReactiveX/RxJava/issues/4370,['Enhancement'],502,749,ReactiveX_RxJava_pull_4370.diff
ReactiveX/RxJava,"2.x: add withLatestFrom many, cleanups and other enhancements","Notable changes:
- implemented `withLatestFrom` with multiple other sources (both `Flowable` and `Observable`)
- added missing `Exceptions.throwIfFatal()` after catching throwables
- added `SequentialDisposable` and replaced internal use of `SerialDisposable` with it
- added `package-info.java` to public packages
- added javadoc to some interfaces and methods
- removed `@Experimental` tags and set those methods to `@since 2.0`
- added `HalfSerializer` to deal with single onNext and multiple onError/onComplete callers
",2016-08-18 12:39:54,2016-08-18 14:28:18,https://api.github.com/repos/ReactiveX/RxJava/issues/4368,"['Cleanup', 'Documentation', 'Enhancement']",3095,441,ReactiveX_RxJava_pull_4368.diff
ReactiveX/RxJava,2.x collect - handle post terminal events,"Just looking at moving some recent 1.x bug fixes and tests over to 2.x.

This is my first PR in 2.x so before I proceed adding more tests from 1.x (to this PR) I want to get some feedback on my approach. In particular in the test `testCollectorFailureDoesNotResultInTwoErrorEmissions` is the `Flowable` creation method ok?
",2016-08-18 07:16:59,2016-08-23 12:02:34,https://api.github.com/repos/ReactiveX/RxJava/issues/4364,['Bug'],326,54,ReactiveX_RxJava_pull_4364.diff
ReactiveX/RxJava,"2.x: test sync, fix retryWhen/redoWhen/publish(Function)","Notable changes:
- Implement the `onBackpressureBuffer` with overflow strategy; change the strategy to plain enum.
- Additional unit tests from 1.x
- Implement `publish(Function)` properly to support latecommers.
- Split `FlowableRedo` into `FlowableRetryWhen` and `FlowableRepeatWhen`.
- Make sure `take(0)` still triggers upstream subscription that is immediately cancelled.
",2016-08-17 12:30:43,2016-08-18 07:07:41,https://api.github.com/repos/ReactiveX/RxJava/issues/4361,"['Cleanup', 'Enhancement', 'Test']",1797,423,ReactiveX_RxJava_pull_4361.diff
ReactiveX/RxJava,2.x: factor out inner classes from the base reactive types,"This PR factors out the anonymous inner classes from the base reactive types and introduces the appropriate classes and methods in `*Helper` enums.
",2016-08-16 20:17:40,2016-08-17 06:00:36,https://api.github.com/repos/ReactiveX/RxJava/issues/4360,['Cleanup'],1493,874,ReactiveX_RxJava_pull_4360.diff
ReactiveX/RxJava,Add missing @Test annotation,"This annotation has been accidentally omitted when resolving a conflict during the merging of:
96feb27e1b90cb93a64295de077cffb1a7d9ea9b and 98cccec27252f30578cd3cf1b7aeddcb9837a2fd
into:
d6bf9d15c6802c74d8e5a3fc4f908a2d01d3d335

We made PRs for both versions 1.x and 2.x.

We found the missing annotation while processing RxJava's git repository using a tool for structured code merge that we're developing as part of the Envision IDE: www.pm.inf.ethz.ch/research/envision.html
",2016-08-16 17:24:29,2016-08-16 17:36:40,https://api.github.com/repos/ReactiveX/RxJava/issues/4359,['Test'],1,0,ReactiveX_RxJava_pull_4359.diff
ReactiveX/RxJava,Add missing @Test annotation,"This annotation has been accidentally omitted when resolving a conflict during the merging of:
96feb27e1b90cb93a64295de077cffb1a7d9ea9b and 98cccec27252f30578cd3cf1b7aeddcb9837a2fd
into:
d6bf9d15c6802c74d8e5a3fc4f908a2d01d3d335

We made PRs for both versions 1.x and 2.x.

We found the missing annotation while processing RxJava's git repository using a tool for structured code merge that we're developing as part of the Envision IDE: www.pm.inf.ethz.ch/research/envision.html
",2016-08-16 17:24:26,2016-08-16 18:00:12,https://api.github.com/repos/ReactiveX/RxJava/issues/4358,['Test'],1,0,ReactiveX_RxJava_pull_4358.diff
ReactiveX/RxJava,"2.x: switch to throwing Action, switchMapDelayError, other cleanup","Notable changes:
- Replace the use of `Runnable` in the base reactive types to `Action` whose `run` method can throw a checked exception.
- Fix javadoc referencing 1.x types no longer available.
- The `switchMap` operator has been enhanced to support delaying errors.
- Update `concat(Iterable)` to use `concatMapDelayError` because Iterable can't throw just anytime but on the boundary, reducing the per-element overhead.
- `FlowableEmitter` has been enhanced with a `serialize()` method that serializes calls to `onXXX` methods.
- Factored out `FlowableEmitter.Cancellable` into `io.reactivex.functions` as it will be used by the other base reactive types with their `XEmitter` implementations.
- Added `AtomicThrowable` with convenience methods that use `ExceptionHelper`'s terminal atomics with `Throwable`s.
",2016-08-16 11:19:50,2016-08-16 13:56:31,https://api.github.com/repos/ReactiveX/RxJava/issues/4357,"['Cleanup', 'Enhancement']",996,575,ReactiveX_RxJava_pull_4357.diff
ReactiveX/RxJava,2.x: sync Completable javadoc and related changes,"This PR mainly adds `Scheduler:` descriptions to `Completable`, removes deprecated operators or unnecessary aliases. In addition, blocking methods now are named `blockingAwait` and `blockingGet`.
",2016-08-16 08:19:11,2016-08-16 08:35:22,https://api.github.com/repos/ReactiveX/RxJava/issues/4355,['Cleanup'],663,533,ReactiveX_RxJava_pull_4355.diff
ReactiveX/RxJava,2.x: Expose values and errors as unmodifiable snapshots not shared mutable lists.,,2016-08-16 04:14:13,2016-08-16 17:47:19,https://api.github.com/repos/ReactiveX/RxJava/issues/4354,[],8,8,ReactiveX_RxJava_pull_4354.diff
ReactiveX/RxJava,2.x: Accept subclasses of Throwable for asserting failure.,,2016-08-16 03:57:11,2016-08-16 07:04:48,https://api.github.com/repos/ReactiveX/RxJava/issues/4353,['Cleanup'],1,1,ReactiveX_RxJava_pull_4353.diff
ReactiveX/RxJava,2.x: Sync Single javadoc with 1.x,"This PR adds javadoc to the `Single` methods, fixes a few API differences.
",2016-08-15 10:17:24,2016-08-15 10:46:48,https://api.github.com/repos/ReactiveX/RxJava/issues/4352,"['Cleanup', 'Documentation']",2162,118,ReactiveX_RxJava_pull_4352.diff
ReactiveX/RxJava,Use Throwable to catch Error when get Android version,"When do JUnit testing with RxRingBuffer, we may have Android platform
classes defined, but contains no Android environment.

So when we call PlatformDependent.resolveAndroidApiVersion in JUnit
testing, an UnsatisfiedLinkError will throw when calling
SystemProperties.native_get(String, String).

The UnsatisfiedLinkError is not an Exception, so the test failed because
of an uncatched exception.

Fix this by catch the Throwable instead of Exception to catch Error.
",2016-08-15 06:44:45,2016-08-15 12:35:06,https://api.github.com/repos/ReactiveX/RxJava/issues/4351,['Android'],1,1,ReactiveX_RxJava_pull_4351.diff
ReactiveX/RxJava,2.x: Observable + Flowable fix some typos,,2016-08-14 08:46:36,2016-08-14 09:05:07,https://api.github.com/repos/ReactiveX/RxJava/issues/4349,['Cleanup'],5,5,ReactiveX_RxJava_pull_4349.diff
ReactiveX/RxJava,2.x: sync Javadoc of Observable (copy&adjust Flowable's),"This PR adds Javadoc to `Observable` by mainly copying and adjusting `Flowable`'s documentation.

In addition, the method set was synced as well and placeholders added for unported 1.x operators.

The drill is the same as before: after CI, I merge this and reviewers can post PRs with necessary fixes.
",2016-08-12 12:58:12,2016-08-12 15:32:48,https://api.github.com/repos/ReactiveX/RxJava/issues/4346,"['Cleanup', 'Documentation']",10454,527,ReactiveX_RxJava_pull_4346.diff
ReactiveX/RxJava,Release 1.1.9 update changes.md,"Update CHANGES.md with the release log.
",2016-08-12 07:01:01,2016-08-12 07:13:02,https://api.github.com/repos/ReactiveX/RxJava/issues/4345,['Information'],39,0,ReactiveX_RxJava_pull_4345.diff
ReactiveX/RxJava,2.x: Fix some typos in Flowable + Observer documentation,,2016-08-11 19:16:56,2016-08-11 19:28:35,https://api.github.com/repos/ReactiveX/RxJava/issues/4344,['Cleanup'],16,16,ReactiveX_RxJava_pull_4344.diff
ReactiveX/RxJava,Remove tabs indent and redundant space.,"- Remove tabs indent and redundant space.
  - Currently tabs and spaces are mixed up in the code so just unify them.
",2016-08-11 18:24:25,2016-08-11 18:36:29,https://api.github.com/repos/ReactiveX/RxJava/issues/4343,['Cleanup'],89,89,ReactiveX_RxJava_pull_4343.diff
ReactiveX/RxJava,2.x: sync javadoc of Flowable,"This PR adds the Javadoc to the `Flowable` plus removes some deprecated or unnecessary operator overloads.

By the sheer amount of documentation, `Flowable` can't be reviewed on GitHub. Once the CI passes, I'll merge it and people who wish to review it can immediately start a PR to fix any documentation mistakes.
",2016-08-11 17:46:12,2016-08-11 18:01:25,https://api.github.com/repos/ReactiveX/RxJava/issues/4342,"['Cleanup', 'Documentation']",12084,553,ReactiveX_RxJava_pull_4342.diff
ReactiveX/RxJava,2.x: Remove conditional resource management from async listeners.,"Rename them to have a 'Resource' prefix.
",2016-08-10 20:05:12,2016-08-10 20:21:57,https://api.github.com/repos/ReactiveX/RxJava/issues/4338,['Cleanup'],46,122,ReactiveX_RxJava_pull_4338.diff
ReactiveX/RxJava,"2.x: move DisposableObserver to public area, add some javadocs","Move `DisposableObserver` to `io.reactivex.observers` + some documentation.

Related: #4082.
",2016-08-10 17:02:20,2016-08-10 17:31:11,https://api.github.com/repos/ReactiveX/RxJava/issues/4337,['Cleanup'],38,17,ReactiveX_RxJava_pull_4337.diff
ReactiveX/RxJava,2.x: Add 'WithUpstream' interfaces to connectable implementations.,,2016-08-10 14:30:25,2016-08-10 15:50:27,https://api.github.com/repos/ReactiveX/RxJava/issues/4333,['Enhancement'],46,26,ReactiveX_RxJava_pull_4333.diff
ReactiveX/RxJava,Added Observable.concat(Iterable),"See #4329 

I also adjusted the test as it was testing the wrong thing before.
",2016-08-10 13:15:18,2016-08-10 16:33:39,https://api.github.com/repos/ReactiveX/RxJava/issues/4330,['Enhancement'],27,1,ReactiveX_RxJava_pull_4330.diff
ReactiveX/RxJava,1.x: compact MultipleAssignment- and Serial-Subscriptions,"This PR reduces the allocation in `MultipleAssignmentSubscription` and `SerialSubscription` by introducing a shared, compact underlying container `SequentialSubscription`.

I've updated `Worker.schedulePeriodically` to use it directly.

In addition, there is a behavior change with `MultipleAssignmentSubscription`: it no longer retains the last `Subscription` as it was likely to cause retention problems (and otherwise didn't make sense to me).

The `SequentialSubscription` feature weak versions of the mutation methods that don't retry if there was a concurrent mutation: for some operations, not winning such races is fine.

/cc @JakeWharton @davidmoten @artem-zinnatullin 
",2016-08-10 09:41:42,2016-08-11 11:34:10,https://api.github.com/repos/ReactiveX/RxJava/issues/4328,['Performance: allocation'],269,124,ReactiveX_RxJava_pull_4328.diff
ReactiveX/RxJava,2.x: Extract 'WithUpstream' interfaces.,"This allows use with types that do not extend directly from their base stream types.
",2016-08-09 22:02:56,2016-08-10 06:52:10,https://api.github.com/repos/ReactiveX/RxJava/issues/4326,['Cleanup'],250,208,ReactiveX_RxJava_pull_4326.diff
ReactiveX/RxJava,2.x: Switch the connected stream types to track their upstream.,,2016-08-09 14:31:23,2016-08-09 21:51:48,https://api.github.com/repos/ReactiveX/RxJava/issues/4325,['Cleanup'],34,34,ReactiveX_RxJava_pull_4325.diff
ReactiveX/RxJava,2.x: Skip static factories when converting between stream types.,"Also rename Publisher->Completable factory method and operator implementation to match other stream types.
",2016-08-09 14:04:37,2016-08-09 14:24:07,https://api.github.com/repos/ReactiveX/RxJava/issues/4324,['Cleanup'],46,42,ReactiveX_RxJava_pull_4324.diff
ReactiveX/RxJava,2.x: No scheduler change happens for timeInterval() and timestamp().,,2016-08-09 13:45:05,2016-08-09 14:00:38,https://api.github.com/repos/ReactiveX/RxJava/issues/4323,['Cleanup'],16,16,ReactiveX_RxJava_pull_4323.diff
ReactiveX/RxJava,1.x: add TestSubscriber.assertValuesAndClear,"This PR adds an ~~`assertAndConsume`~~ `assertValuesAndClear` method to `TestSubscriber` to assert on value content and then clear the internal value list. This helps asserting on received values without the need to list all previously seen values in `assertValues`. 

On a sidenote, `getOnNextEvents()` returns the internal list and one can call `clear()` on it.
",2016-08-09 10:25:25,2016-08-11 11:59:47,https://api.github.com/repos/ReactiveX/RxJava/issues/4322,"['Enhancement', 'Test']",89,12,ReactiveX_RxJava_pull_4322.diff
ReactiveX/RxJava,2.x: Switch (almost) all remaining chain operators to ObservableWithUpstream.,,2016-08-09 01:28:58,2016-08-09 07:11:44,https://api.github.com/repos/ReactiveX/RxJava/issues/4319,['Cleanup'],53,78,ReactiveX_RxJava_pull_4319.diff
ReactiveX/RxJava,2.x: Switch (almost) all chain operators to FlowableWithUpstream.,,2016-08-09 00:34:24,2016-08-09 07:10:28,https://api.github.com/repos/ReactiveX/RxJava/issues/4318,['Cleanup'],144,270,ReactiveX_RxJava_pull_4318.diff
ReactiveX/RxJava,"2.x: Rename create to unsafeCreate, add ""safe"" create methods.","This is a proposal to solve #4255 but for 2.x and closes #4286 built around one goal: make the `create` methods actually usable by developers!

Currently the advice given to most developers using 1.x is avoid `create` unless you are absolutely 100% sure you understand backpressure and cancellation, and even then avoid it if possible. This method is a trap that most new developers fall into. _The method is named ""create"", after all, so it must be how I create these things!_ I want to make that statement not only correct, but advisable (at least when the still-convenient ""from"" methods are not suitable, such as when wrapping callback-based APIs).

Because `Observable`, `Single`, and `Completable` are backpressure-free, this amounts to just suppressing downstream notifications when disposed. This doesn't seem too controversial.

The most controversial part is that I have renamed `Flowable.fromAsync` to `Flowable.create` thus making it the canonical way for users to create `Flowable`s directly. I'm much less opinionated on this change, but it felt wrong to have an `Flowable.unsafeCreate` with no associated `create` and `fromAsync` is the ""safest"" version we have.
",2016-08-08 20:11:48,2016-08-09 07:07:06,https://api.github.com/repos/ReactiveX/RxJava/issues/4317,"['Cleanup', 'Enhancement']",969,661,ReactiveX_RxJava_pull_4317.diff
ReactiveX/RxJava,2.x: Normalize empty and never sources.,,2016-08-08 15:04:58,2016-08-08 16:01:28,https://api.github.com/repos/ReactiveX/RxJava/issues/4316,['Cleanup'],59,30,ReactiveX_RxJava_pull_4316.diff
ReactiveX/RxJava,"2.x: Use ArrayListSupplier in more places, add HashMapSupplier.",,2016-08-08 14:50:05,2016-08-08 15:06:53,https://api.github.com/repos/ReactiveX/RxJava/issues/4315,['Enhancement'],78,104,ReactiveX_RxJava_pull_4315.diff
ReactiveX/RxJava,2.x: Rename FlowableSource to FlowableWithUpstream to match ObservableWithUpstream.,,2016-08-08 14:12:36,2016-08-08 14:30:03,https://api.github.com/repos/ReactiveX/RxJava/issues/4314,['Cleanup'],16,16,ReactiveX_RxJava_pull_4314.diff
ReactiveX/RxJava,2.x: Update observable wrapper to correct name to fix compilation.,,2016-08-08 14:03:02,2016-08-08 14:07:14,https://api.github.com/repos/ReactiveX/RxJava/issues/4313,[],1,1,ReactiveX_RxJava_pull_4313.diff
ReactiveX/RxJava,1.x: Schedulers.from() to call RxJavaHooks.onScheduleAction,"The `ExecutorScheduler` wrapper did not call the `RxJavaHooks.onScheduledAction()` to decorate actions sent to a custom scheduler.
",2016-08-08 13:07:06,2016-08-08 13:30:49,https://api.github.com/repos/ReactiveX/RxJava/issues/4311,['Bug'],52,6,ReactiveX_RxJava_pull_4311.diff
ReactiveX/RxJava,2.x: fix SubscriptionArbiter reentrancy/cancel bug,"This PR fixes the case when a call to request() prevented cancellation of the arbiter if the call never returned, thus locking out the drain loop from the cancellation call.

The PR makes sure `request()` is only called outside the guarded region.

1.x is not affected because unsubscription and requesting go on separate ""channels"".

The PR also fixes `FlowableRedo` by serializing the repeat signal `Processor`.
",2016-08-08 11:19:59,2016-08-08 13:53:23,https://api.github.com/repos/ReactiveX/RxJava/issues/4310,['Bug'],56,19,ReactiveX_RxJava_pull_4310.diff
ReactiveX/RxJava,2.x: Remove unused exceptions in public API,"As wanted in #4306 
",2016-08-08 07:58:34,2016-08-08 14:45:43,https://api.github.com/repos/ReactiveX/RxJava/issues/4309,['Cleanup'],91,201,ReactiveX_RxJava_pull_4309.diff
ReactiveX/RxJava,2.x: Promote Observable to Single/Flowable adapters to top-level types.,,2016-08-08 04:33:17,2016-08-08 06:55:29,https://api.github.com/repos/ReactiveX/RxJava/issues/4308,['Cleanup'],133,72,ReactiveX_RxJava_pull_4308.diff
ReactiveX/RxJava,2.x: Promote lift implementations to top-level types.,,2016-08-07 23:30:07,2016-08-08 06:54:21,https://api.github.com/repos/ReactiveX/RxJava/issues/4307,['Cleanup'],135,25,ReactiveX_RxJava_pull_4307.diff
ReactiveX/RxJava,2.x: Rename source/publisher wrapper class to more semantic 'from' name.,,2016-08-07 21:42:27,2016-08-08 13:55:04,https://api.github.com/repos/ReactiveX/RxJava/issues/4305,['Cleanup'],42,42,ReactiveX_RxJava_pull_4305.diff
ReactiveX/RxJava,2.x: Add missing license headers,"Now every file has a license header.
",2016-08-07 21:42:11,2016-08-07 21:59:59,https://api.github.com/repos/ReactiveX/RxJava/issues/4304,['Cleanup'],39,0,ReactiveX_RxJava_pull_4304.diff
ReactiveX/RxJava,2.x: Move single and completable observers to correct package.,,2016-08-07 21:14:23,2016-08-07 21:32:54,https://api.github.com/repos/ReactiveX/RxJava/issues/4303,['Cleanup'],2,2,ReactiveX_RxJava_pull_4303.diff
ReactiveX/RxJava,2.x: Rename Completable Base Interface Types for consistency,"Addresses #4044 
",2016-08-07 20:25:28,2016-08-07 20:53:14,https://api.github.com/repos/ReactiveX/RxJava/issues/4302,['Cleanup'],342,311,ReactiveX_RxJava_pull_4302.diff
ReactiveX/RxJava,2.x: Rename ObservableSource to ObservableWithUpstream,"To unblock #4300 
",2016-08-07 20:17:53,2016-08-07 20:51:42,https://api.github.com/repos/ReactiveX/RxJava/issues/4301,['Cleanup'],60,60,ReactiveX_RxJava_pull_4301.diff
ReactiveX/RxJava,2.x: Rename Observable Base Interface Types for consistency,"Addresses #4044.
",2016-08-07 18:20:05,2016-08-07 21:32:19,https://api.github.com/repos/ReactiveX/RxJava/issues/4300,['Cleanup'],809,777,ReactiveX_RxJava_pull_4300.diff
ReactiveX/RxJava,2.x: Rename Flowable Base Interface Types for consistency,"Addresses #4044
",2016-08-07 18:12:54,2016-08-07 18:40:06,https://api.github.com/repos/ReactiveX/RxJava/issues/4299,['Cleanup'],91,53,ReactiveX_RxJava_pull_4299.diff
ReactiveX/RxJava,2.x: Clarify behavior of RxJavaPlugins.reset() in javadoc,"Noticed in RxAndroid https://github.com/ReactiveX/RxAndroid/pull/316#discussion_r73783555
",2016-08-07 12:55:18,2016-08-10 16:40:53,https://api.github.com/repos/ReactiveX/RxJava/issues/4298,['Documentation'],1,1,ReactiveX_RxJava_pull_4298.diff
ReactiveX/RxJava,2.x: Rename Single Base Interface Types for consistency,"Addresses #4044
",2016-08-07 10:39:18,2016-08-07 17:54:55,https://api.github.com/repos/ReactiveX/RxJava/issues/4297,['Cleanup'],401,369,ReactiveX_RxJava_pull_4297.diff
ReactiveX/RxJava,2.x: Observable.range fix Exception message,,2016-08-07 10:08:12,2016-08-07 10:47:25,https://api.github.com/repos/ReactiveX/RxJava/issues/4296,['Cleanup'],1,1,ReactiveX_RxJava_pull_4296.diff
ReactiveX/RxJava,2.x: Add serialized single subscriber wrapper.,"There's already one for observer, subscriber, and completable subscriber.
",2016-08-07 06:34:06,2016-08-07 08:44:35,https://api.github.com/repos/ReactiveX/RxJava/issues/4295,['Enhancement'],49,0,ReactiveX_RxJava_pull_4295.diff
ReactiveX/RxJava,2.x: Inline generic-free runnable and long consumer method.,,2016-08-07 05:30:06,2016-08-07 08:30:08,https://api.github.com/repos/ReactiveX/RxJava/issues/4294,['Cleanup'],166,163,ReactiveX_RxJava_pull_4294.diff
ReactiveX/RxJava,2.x: Correct default subscriber name.,,2016-08-07 05:29:24,2016-08-07 08:32:43,https://api.github.com/repos/ReactiveX/RxJava/issues/4293,['Cleanup'],154,154,ReactiveX_RxJava_pull_4293.diff
ReactiveX/RxJava,2.x: Actually apply custom scheduler when applying future.,"Correct annotatoin declaration as well.
",2016-08-07 00:44:47,2016-08-07 08:20:02,https://api.github.com/repos/ReactiveX/RxJava/issues/4292,['Bug'],48,6,ReactiveX_RxJava_pull_4292.diff
ReactiveX/RxJava,2.x: Promote anonymous Observables to top-level types.,,2016-08-06 23:05:44,2016-08-08 13:54:13,https://api.github.com/repos/ReactiveX/RxJava/issues/4291,['Cleanup'],186,74,ReactiveX_RxJava_pull_4291.diff
ReactiveX/RxJava,2.x: Eliminate an extra allocation and indirection in periodic scheduling.,,2016-08-06 22:35:18,2016-08-07 18:18:28,https://api.github.com/repos/ReactiveX/RxJava/issues/4290,[],3,6,ReactiveX_RxJava_pull_4290.diff
ReactiveX/RxJava,2.x: Elide more create/callback wrappers in favor of direct Observables.,,2016-08-06 21:47:55,2016-08-06 22:46:43,https://api.github.com/repos/ReactiveX/RxJava/issues/4289,['Cleanup'],29,28,ReactiveX_RxJava_pull_4289.diff
ReactiveX/RxJava,"2.x: move Exceptions to public area, + ExceptionHelper","Related: #4280.

The `Exceptions.propagate` and `Exceptions.throwIfFatal` are too useful to be hidden in an internal package so this PR moves them into the public `io.reactivex.exceptions` package. The terminal atomics related to Throwable containers lives in the `ExceptionHelper` enum.
",2016-08-06 09:24:23,2016-08-06 21:52:49,https://api.github.com/repos/ReactiveX/RxJava/issues/4288,['Cleanup'],337,308,ReactiveX_RxJava_pull_4288.diff
ReactiveX/RxJava,2.x: Elide ObservableWrapper for empty and never.,,2016-08-06 04:29:45,2016-08-06 08:53:39,https://api.github.com/repos/ReactiveX/RxJava/issues/4287,['Cleanup'],10,10,ReactiveX_RxJava_pull_4287.diff
ReactiveX/RxJava,2.x: Remove defunct 'Nbp' prefix from Observable interfaces.,,2016-08-06 03:01:10,2016-08-06 08:52:41,https://api.github.com/repos/ReactiveX/RxJava/issues/4285,['Cleanup'],18,18,ReactiveX_RxJava_pull_4285.diff
ReactiveX/RxJava,1.x: Make Observable takeUntil documentation more explicit,,2016-08-05 08:41:51,2016-08-05 09:02:36,https://api.github.com/repos/ReactiveX/RxJava/issues/4282,['Documentation'],2,2,ReactiveX_RxJava_pull_4282.diff
ReactiveX/RxJava,1.x: Remove needless static field for initialization in IndexedRingBuffer.,"Equivalent of #4269 
",2016-08-04 09:45:47,2016-08-04 09:59:59,https://api.github.com/repos/ReactiveX/RxJava/issues/4281,['Cleanup'],2,2,ReactiveX_RxJava_pull_4281.diff
ReactiveX/RxJava,1.x: update gradle to v2.14.1,"Was released a while ago and since it's an ""important update to v2.14"", here it is.

Release notes: https://docs.gradle.org/2.14.1/release-notes
",2016-08-03 15:48:37,2016-08-04 10:03:08,https://api.github.com/repos/ReactiveX/RxJava/issues/4279,['Build'],2,2,ReactiveX_RxJava_pull_4279.diff
ReactiveX/RxJava,2.x: Functional interfaces now throw,"It had a bit of a cascading effect.
",2016-08-03 14:12:30,2016-08-06 08:51:43,https://api.github.com/repos/ReactiveX/RxJava/issues/4278,['Enhancement'],2299,2783,ReactiveX_RxJava_pull_4278.diff
ReactiveX/RxJava,1.x: distinctUntilChanged change erroneous behavior,"#### 📘 PR summary

Fix behavior change of `distinctUntilChanged`  introduced in the version `1.1.7` of RxJava

Related to: #4034
",2016-08-03 11:46:49,2016-08-03 13:06:58,https://api.github.com/repos/ReactiveX/RxJava/issues/4276,[],1,1,ReactiveX_RxJava_pull_4276.diff
ReactiveX/RxJava,2.x: test sync and missing operators (8/02),"- Add `rebatchRequests` which delegates to `observeOn` with the help of an internal `ImmediateThinScheduler` that only executes tasks immediately. Still not planning to expose an immediate scheduler.
- Fix `FlowableMapNotification`'s type signature, no need to restrict it to return `Publisher<R>` but can go with `R` itself.
- Make sure `flatMap` doesn't reorder scalars and elements of the same inner source.
- Change parameter ordering on `mergeDelayError(Iterator)` overloads.
",2016-08-02 14:37:58,2016-08-03 10:09:54,https://api.github.com/repos/ReactiveX/RxJava/issues/4273,"['Bug', 'Enhancement', 'Test']",981,170,ReactiveX_RxJava_pull_4273.diff
ReactiveX/RxJava,"toMultimap - prevent post terminal emissions, reduce allocations","- switched to `OnSubscribe`
- switched to use `DeferredScalarSubscriberSafe`
- previous source failed to handle post terminal emissions 
- added 4 unit tests
",2016-08-02 01:18:29,2016-08-02 07:29:15,https://api.github.com/repos/ReactiveX/RxJava/issues/4270,"['Bug', 'Cleanup']",362,197,ReactiveX_RxJava_pull_4270.diff
ReactiveX/RxJava,Remove needless static field for initialization.,,2016-08-01 17:44:27,2016-08-01 20:20:22,https://api.github.com/repos/ReactiveX/RxJava/issues/4269,['Cleanup'],5,2,ReactiveX_RxJava_pull_4269.diff
ReactiveX/RxJava,2.x: test sync and operator fixes,"- rename `finallyDo` (deprecated in 1.x) to `doAfterTerminate`
- upgrade sized `buffer()`, fix backpressure bug
- add post-complete helper methods
- fix `toSingle` not complaining about an empty/longer source
- `RxJavaPlugins` to reset the base-type lifecycle callbacks as well
",2016-08-01 09:39:12,2016-08-02 07:46:54,https://api.github.com/repos/ReactiveX/RxJava/issues/4268,"['Bug', 'Test']",2323,276,ReactiveX_RxJava_pull_4268.diff
ReactiveX/RxJava,2.x: add dedicated concat for array of publishers,"This PR adds a dedicated `concat` implementation that works with the source array. The main benefit is that there is no need to serialize emissions because the source array can't throw (unlike `concatMap` where there could be an onError from the main source while an inner source is running). Plus, there is a new `concatArrayDelayError` version.
",2016-08-01 06:51:39,2016-08-02 07:20:11,https://api.github.com/repos/ReactiveX/RxJava/issues/4266,['Enhancement'],201,11,ReactiveX_RxJava_pull_4266.diff
ReactiveX/RxJava,remove unnecessary map call in sequenceEquals operator,"This PR is a performance improvement in `sequenceEquals` where I removed a call to `map` that appears unnecessary.
",2016-08-01 04:34:30,2016-08-01 05:15:42,https://api.github.com/repos/ReactiveX/RxJava/issues/4265,['Cleanup'],1,9,ReactiveX_RxJava_pull_4265.diff
ReactiveX/RxJava,Adds Observable.sorted method,"This PR Observable.sorted Method, I hope it addresses this #4263 correctly. 
",2016-07-31 19:45:20,2016-08-02 11:37:37,https://api.github.com/repos/ReactiveX/RxJava/issues/4264,"['Enhancement', 'Feature-Request']",146,24,ReactiveX_RxJava_pull_4264.diff
ReactiveX/RxJava,"doOnEach - reduce allocations, report to RxJavaHooks","as discussed in #4260 
- call `RxJavaHooks.onError` for secondary errors
- reduced allocations (`ActionSubscriber` -> `ActionObserver`, `Operator` -> `OnSubscribe`)
- added 5 unit tests
",2016-07-31 06:16:25,2016-07-31 10:51:57,https://api.github.com/repos/ReactiveX/RxJava/issues/4262,['Cleanup'],315,105,ReactiveX_RxJava_pull_4262.diff
ReactiveX/RxJava,1.x: concatDelayError multiple arguments,"This PR adds multiple arguments to concatDelayError operator

Related to: #4152 
",2016-07-31 00:35:15,2016-08-10 16:23:15,https://api.github.com/repos/ReactiveX/RxJava/issues/4261,['Enhancement'],577,0,ReactiveX_RxJava_pull_4261.diff
ReactiveX/RxJava,Fix javadoc on RxJavaHooks.setOnError,"as per title
",2016-07-29 07:31:35,2016-07-29 07:57:04,https://api.github.com/repos/ReactiveX/RxJava/issues/4257,['Documentation'],1,1,ReactiveX_RxJava_pull_4257.diff
ReactiveX/RxJava,1.x: fix SingleTest generics warnings,"This fixes the generics warnings in the new `Single.flatMapCompletable` unit tests.
",2016-07-28 14:09:54,2016-07-28 14:23:38,https://api.github.com/repos/ReactiveX/RxJava/issues/4254,"['Cleanup', 'Test']",4,4,ReactiveX_RxJava_pull_4254.diff
ReactiveX/RxJava,1.x: Deprecate Observable.create(),"Finally we have `Observable.fromAsync()` and it's time to prevent users from using `Observable.create()`.
",2016-07-28 13:31:19,2016-07-31 08:42:06,https://api.github.com/repos/ReactiveX/RxJava/issues/4253,[],4,0,ReactiveX_RxJava_pull_4253.diff
ReactiveX/RxJava,"collect, DeferredScalarSubscriber - prevent multiple terminal emissions","As per discussion in #4242, if an operator maps an `onNext` emission to an `onError` emission downstream then it needs be defensive about another event being sent from upstream even if upstream has been unsubscribed.
- `DeferredScalarSubscriber` has been updated with a `done` flag
- moved tests from `ObservableTests` to new class `OnSubscribeCollectTest`
- added three tests of post error emissions
- added factory failure test  
",2016-07-28 11:51:26,2016-07-29 07:24:11,https://api.github.com/repos/ReactiveX/RxJava/issues/4252,"['Bug', 'Cleanup']",318,60,ReactiveX_RxJava_pull_4252.diff
ReactiveX/RxJava,"toMap - prevent multiple terminal events, support backpressure","As per discussion in #4242, if an operator maps an `onNext` emission to an `onError` emission downstream then it needs be defensive about an `onCompleted` being sent from upstream even if upstream has been unsubscribed.

Includes three unit tests that failed on the original code. The fix also has the side effect of enabling gc of `map` when the factory fails (`onError` was called on the child, not `this` so `map` was not set to null).
",2016-07-28 06:58:04,2016-07-30 06:57:04,https://api.github.com/repos/ReactiveX/RxJava/issues/4251,"['Bug', 'Cleanup']",210,78,ReactiveX_RxJava_pull_4251.diff
ReactiveX/RxJava,onBackpressureDrop - prevent multiple terminal events,"As per discussion in #4242, if an operator maps an `onNext` emission to an `onError` emission downstream then it needs be defensive about an `onCompleted` being sent from upstream even if upstream has been unsubscribed.

Includes three unit tests that failed on the original code and another that gives coverage of the onBackpressureDrop action being called.
",2016-07-28 03:30:33,2016-07-28 06:16:16,https://api.github.com/repos/ReactiveX/RxJava/issues/4250,"['Bug', 'Cleanup']",162,4,ReactiveX_RxJava_pull_4250.diff
ReactiveX/RxJava,"Value, Variable and Immutable first implementation","Hi,
there is a simple implementation for an observable value, in the mutable or immutable form.
This helps me to share some state (like configuration) when in some case is important to catch every change (using normal subscription) and in other case is useful get only the current value.

I hope this helps,
thanks for software,
Francesco
",2016-07-27 20:57:54,2016-07-29 12:06:39,https://api.github.com/repos/ReactiveX/RxJava/issues/4249,[],184,0,ReactiveX_RxJava_pull_4249.diff
ReactiveX/RxJava,1.x: SyncOnSubscribe fix typo and java doc,,2016-07-27 15:32:16,2016-07-27 15:47:21,https://api.github.com/repos/ReactiveX/RxJava/issues/4248,"['Cleanup', 'Documentation']",2,2,ReactiveX_RxJava_pull_4248.diff
ReactiveX/RxJava,OperatorReduce - prevent multiple terminal events,"As per discussion in #4242, if an operator maps an `onNext` emission to an `onError` emission downstream then it needs be defensive about an `onCompleted` being sent from upstream even if upstream has been unsubscribed.

Includes a unit test that failed on the original code.

Also renamed test class to match tested class.
",2016-07-27 12:11:52,2016-07-28 06:15:27,https://api.github.com/repos/ReactiveX/RxJava/issues/4246,"['Bug', 'Cleanup']",294,140,ReactiveX_RxJava_pull_4246.diff
ReactiveX/RxJava,OperatorAny - prevent multiple terminal events,"As per discussion in #4242, if an operator maps an `onNext` emission to an `onError` emission downstream then it needs be defensive about an `onCompleted` being sent from upstream even if upstream has been unsubscribed.

Includes a unit test that failed on the original code.
",2016-07-27 11:45:20,2016-07-28 06:14:41,https://api.github.com/repos/ReactiveX/RxJava/issues/4245,"['Bug', 'Cleanup']",126,2,ReactiveX_RxJava_pull_4245.diff
ReactiveX/RxJava,OperatorAll - prevent multiple terminal events,"As per discussion in #4242, if an operator maps an `onNext` emission to an `onError` emission downstream then it needs be defensive about an `onCompleted` being sent from upstream even if upstream has been unsubscribed.

Includes a unit test that failed on the original code.
",2016-07-27 11:36:41,2016-07-27 21:05:29,https://api.github.com/repos/ReactiveX/RxJava/issues/4244,"['Bug', 'Cleanup']",125,2,ReactiveX_RxJava_pull_4244.diff
ReactiveX/RxJava,rename Map and Filter test classes now that have moved to OnSubscribe,"a bit of cleanup
",2016-07-26 21:32:23,2016-07-27 07:25:27,https://api.github.com/repos/ReactiveX/RxJava/issues/4243,['Cleanup'],2,2,ReactiveX_RxJava_pull_4243.diff
ReactiveX/RxJava,Fix retryWhen/repeatWhen potential concurrent reentry when resubscribing,"When the function's returned Observable signals the resubscription in the operator `redo` (which is the base for `repeatWhen` and `retryWhen`). It is possible an asyncronous source triggers the function (and thus the same `Observable`) from another thread while the first is still coming back from the resubscription itself.

This PR serializes the dispatching `BehaviorSubject` to prevent such concurrent execution of the when chain.

This may or may not be the source of the failure of #4175 but I can't reproduce the failure with the 1.x branch. /cc @davidmoten.
",2016-07-25 19:10:33,2016-07-27 21:07:55,https://api.github.com/repos/ReactiveX/RxJava/issues/4241,['Bug'],2,2,ReactiveX_RxJava_pull_4241.diff
ReactiveX/RxJava,save allocation in OperatorSkipTimed,"as per title, combined `AtomicBoolean` with an `Action`.
",2016-07-25 04:25:51,2016-07-27 07:48:08,https://api.github.com/repos/ReactiveX/RxJava/issues/4239,['Performance: allocation'],122,81,ReactiveX_RxJava_pull_4239.diff
ReactiveX/RxJava,1.x: Fix typo eigth to eighth,"Found another one
",2016-07-24 11:57:54,2016-07-24 12:08:51,https://api.github.com/repos/ReactiveX/RxJava/issues/4238,['Cleanup'],13,13,ReactiveX_RxJava_pull_4238.diff
ReactiveX/RxJava,reduce allocations in OnSubscribeGroupJoin,"as per title
",2016-07-23 23:37:05,2016-07-24 06:41:01,https://api.github.com/repos/ReactiveX/RxJava/issues/4237,['Performance: allocation'],36,29,ReactiveX_RxJava_pull_4237.diff
ReactiveX/RxJava,save allocations in OnSubscribeJoin,"as per title.

Would have been nicer to extend `CompositeSubscription` but is final.
",2016-07-23 23:17:10,2016-07-24 06:39:37,https://api.github.com/repos/ReactiveX/RxJava/issues/4236,['Performance: allocation'],28,22,ReactiveX_RxJava_pull_4236.diff
ReactiveX/RxJava,1.x: Fix some typos,,2016-07-23 13:01:05,2016-07-23 13:11:37,https://api.github.com/repos/ReactiveX/RxJava/issues/4234,"['Cleanup', 'Documentation']",17,17,ReactiveX_RxJava_pull_4234.diff
ReactiveX/RxJava,save allocation in OnSubscribeAutoConnect,"Another one. I'll keep rolling through the operators to pick up more. 

@akarnokd Are you ok with `@SuppressWarnings(""serial"")` instead of `private static final long serialVersionUID = ...`? 
",2016-07-23 12:23:30,2016-07-23 12:41:04,https://api.github.com/repos/ReactiveX/RxJava/issues/4233,['Performance: allocation'],7,5,ReactiveX_RxJava_pull_4233.diff
ReactiveX/RxJava,save allocation in OnSubscribeAmb,"`Selection` class can extend `AtomicReference` to save an allocation
",2016-07-23 12:03:32,2016-07-23 12:14:13,https://api.github.com/repos/ReactiveX/RxJava/issues/4232,"['Enhancement', 'Performance']",9,10,ReactiveX_RxJava_pull_4232.diff
ReactiveX/RxJava,CachedThreadScheduler should wait until the previous action (if any) …,"…completes before releasing a worker to the pool. Fixes #4230.
",2016-07-23 08:28:39,2016-07-23 12:24:03,https://api.github.com/repos/ReactiveX/RxJava/issues/4231,['Bug'],78,2,ReactiveX_RxJava_pull_4231.diff
ReactiveX/RxJava,1.x: fix replay() retaining reference to the child Subscriber,"In #3470, a flat cache of Subscribers has been introduced that is versioned and gets only updated if there are new Subscribers coming, old Subscribers leaving _and_ a value comes through - improving performance if lots of Subscribers come and go between main onNext signals. This cache is not cleared but rebuilt therefore child Subscribers unsubscribing were still referenced through it and everything beyond - leading to memory leak on sensitive systems.

The fix is to cut the link to the child Subscriber in `InnerProducer` on unsubscription. A secondary action also empties the cache if all Subscribers are gone.

Reported in #4228 .
",2016-07-22 18:39:50,2016-07-23 07:14:43,https://api.github.com/repos/ReactiveX/RxJava/issues/4229,['Bug'],103,5,ReactiveX_RxJava_pull_4229.diff
ReactiveX/RxJava,1.x: Single.flatMapCompletable,"Addresses #4216 

Happy to receive feedback on the implementation. Also should I take the documentation from `flatMapObservable` and adjust it?
",2016-07-22 09:35:42,2016-07-27 20:58:07,https://api.github.com/repos/ReactiveX/RxJava/issues/4226,['Enhancement'],179,0,ReactiveX_RxJava_pull_4226.diff
ReactiveX/RxJava,1.x: PublishSubject fail-fast when backpressured,"This PR modifies the `PublishSubject` to fail fast if the child Subscriber can't keep up. Therefore, instead of some other operator failing somewhere downstream, the `MissingBackpressureException` now points to the `PublishSubject` instead. 

In addition, there were complaints in #3850 that cross-unsubscription doesn't stop another Subscriber from receiving events if it comes after the unsubscribe() call in the dispatch loop. Since `PublishSubject` now tracks request - which is the main extra overhead - it is trivial to add the necessary eager check for the unsubscribed state.

Benchmark comparison (i7 4790, Windows 7 x64, Java 8u102)

![image](https://cloud.githubusercontent.com/assets/1269832/17052414/a30acf84-4ffd-11e6-88ae-1fc5d28a6d12.png)

As expected, this adds some overhead although most noticeably for the mid-range only. Short-lived publishing is now slightly faster even.

Interestingly, many benchmarks behave oddly in these 1000s range - we could be hitting some JIT threshold. While in other benchmarks, the warmup iteration numbers keep increasing as JIT does its work but here, it starts out quite nicely then drops 25% and stays that way. I'm on windows so JMH -perfasm doesn't work.

If this direction is accepted, I'll update `BehaviorSubject`, `timer()` and `interval()` do do the same tracking.
",2016-07-22 09:23:17,2016-07-27 21:08:36,https://api.github.com/repos/ReactiveX/RxJava/issues/4225,['Enhancement'],303,62,ReactiveX_RxJava_pull_4225.diff
ReactiveX/RxJava,1.x: PublishSubject perf,"This PR benchmarks the overhead in `PublishSubject` to give a baseline for upcoming behavior correction (backpressure fail-fast, more eager child isUnsubscribed() checking).

Benchmark (i7 4790, Windows 7 x64, Java 8u102, ops/s - bigger is better):

![image](https://cloud.githubusercontent.com/assets/1269832/17049741/617b9386-4fef-11e6-9d08-27352d676221.png)
",2016-07-22 07:30:46,2016-07-22 07:42:37,https://api.github.com/repos/ReactiveX/RxJava/issues/4224,['Performance'],62,0,ReactiveX_RxJava_pull_4224.diff
ReactiveX/RxJava,2.x: subscribeOn allow cancelling before the actual subscription happens (just like 1.x),"This PR fixes the `subscribeOn` operator to allow cancellation before the actual subscription to the source takes place - just like how 1.x works.
",2016-07-21 08:14:38,2016-07-22 08:24:55,https://api.github.com/repos/ReactiveX/RxJava/issues/4222,['Bug'],104,72,ReactiveX_RxJava_pull_4222.diff
ReactiveX/RxJava,1.x: Optimize hot path in OnSubscribeOnAssembly,,2016-07-20 21:48:10,2016-07-28 12:46:19,https://api.github.com/repos/ReactiveX/RxJava/issues/4220,[],23,37,ReactiveX_RxJava_pull_4220.diff
ReactiveX/RxJava,"2.x: Test sync, +groupJoin, +join, +onTerminateDetach","- add `groupJoin`, `join`, `onTerminateDetach`
- fix missing cancellation in `FlowableFlattenIterable`
- fix `fromIterable` error handling
- added several unit test methods and classes from 1.x
",2016-07-19 16:10:57,2016-07-22 08:24:26,https://api.github.com/repos/ReactiveX/RxJava/issues/4217,['Enhancement'],4993,19,ReactiveX_RxJava_pull_4217.diff
ReactiveX/RxJava,1.x: fix assembly tracking replacing original exception,"Modify the assembly tracking logic to not replace the exception flowing through but to attach the tracking exception to the end of the causal chain (if possible).

Fixes #4212
",2016-07-19 13:07:01,2016-07-20 21:17:11,https://api.github.com/repos/ReactiveX/RxJava/issues/4215,['Bug'],92,34,ReactiveX_RxJava_pull_4215.diff
ReactiveX/RxJava,1.x: Do not hide original exception with RxJavaHooks.enableAssemblyTracking(),"Part of #4212.
",2016-07-19 12:36:20,2016-07-20 20:56:36,https://api.github.com/repos/ReactiveX/RxJava/issues/4213,[],112,106,ReactiveX_RxJava_pull_4213.diff
ReactiveX/RxJava,2.x: use generic type instead of Object in combineLatest and zip,"As discussed in https://github.com/ReactiveX/RxJava/issues/1277#issuecomment-233357354

This PR gives a stricter type signature for `combineLatest`, `zip`, `zipArray` and `zipIterable`. It replaces occurrences of `Object` with its generic type `T`. In practice users will not need to type-cast arrays in the combine function anymore.
",2016-07-18 17:03:38,2016-07-19 17:51:48,https://api.github.com/repos/ReactiveX/RxJava/issues/4211,['Enhancement'],28,26,ReactiveX_RxJava_pull_4211.diff
ReactiveX/RxJava,1.x: merge/flatMap to keep scalar/inner element relative order,"This PR changes flatmap to make sure there is no element reordering happening on the fast-paths.

Related: #4206.
",2016-07-18 07:40:29,2016-07-20 21:04:10,https://api.github.com/repos/ReactiveX/RxJava/issues/4209,"['Bug', 'Enhancement']",57,4,ReactiveX_RxJava_pull_4209.diff
ReactiveX/RxJava,2.x: test sync + cleanup,"- More unit tests ported;
- `TestObserver` cleanup and sync with `TestSubscriber`;
- fix travis to run with Java 7 instead of 8;
- added AnimalSniffer;
- cleaned up `combineLatest`, introduced `combineLatestDelayError`;
- test names are as in 1.x, please don't complain about the `test` prefix in the method names!
",2016-07-14 11:15:00,2016-07-18 16:43:47,https://api.github.com/repos/ReactiveX/RxJava/issues/4204,"['Enhancement', 'Test']",3291,612,ReactiveX_RxJava_pull_4204.diff
ReactiveX/RxJava,"2.x: sync unit tests of Completable, add missing features","Don't worry about not all things tested in this PR, anything extra relative to 1.x will be covered after the sync.
",2016-07-13 10:16:32,2016-07-14 06:58:33,https://api.github.com/repos/ReactiveX/RxJava/issues/4195,"['Enhancement', 'Test']",2099,191,ReactiveX_RxJava_pull_4195.diff
ReactiveX/RxJava,"2.x: +fromAsync, distinctUC, skip, take overloads, fix TestSubscriber API","This PR adds a few operators and overloads from 1.x
- `fromAsync`
- `just` - 10 arguments
- `distinctUntilChanged(BiPredicate<? super T, ? super T> comparer)`
- `skip` timed - default scheduler
- `take` timed - default scheduler
- `toCompletable`

In addition, this PR fixes the API of TestSubscriber by making the initial value primitive `long` and having 0 as no initial request instead of the trickery with `null`.
",2016-07-12 08:33:02,2016-07-13 06:51:23,https://api.github.com/repos/ReactiveX/RxJava/issues/4192,"['Cleanup', 'Enhancement']",1771,85,ReactiveX_RxJava_pull_4192.diff
ReactiveX/RxJava,Fix grammar error in RxJavaHooks javadocs,,2016-07-11 13:48:44,2016-07-11 14:12:00,https://api.github.com/repos/ReactiveX/RxJava/issues/4191,['Documentation'],1,1,ReactiveX_RxJava_pull_4191.diff
ReactiveX/RxJava,2.x: implement concat(Map)Eager(DelayError) and expose concat(Map)DelayError overload,"Started a syncing process between 1.x and 2.x operators (based on [this diff](https://gist.github.com/akarnokd/4a391527e099412cad87d3dffbfef762)). The first set is the addition of the eager version of `concat` and `concatMap`. In addition, all of them get a `XDelayError` overloads as well.
",2016-07-11 08:57:30,2016-07-12 06:54:23,https://api.github.com/repos/ReactiveX/RxJava/issues/4190,['Enhancement'],1010,8,ReactiveX_RxJava_pull_4190.diff
ReactiveX/RxJava,Update 1.1.7 javadoc files,"I've extracted the javadoc.jar from the release into a subdir 1.1.7 and replaced the root files as well.

/cc @DavidMGross 
",2016-07-10 16:39:03,2016-07-11 05:27:59,https://api.github.com/repos/ReactiveX/RxJava/issues/4189,['Documentation'],75965,1423,ReactiveX_RxJava_pull_4189.diff
ReactiveX/RxJava,"1.x: add missing headers, add SuppressWarnings","I still forget about these sometimes.
",2016-07-10 14:20:45,2016-07-10 14:36:49,https://api.github.com/repos/ReactiveX/RxJava/issues/4188,['Cleanup'],65,0,ReactiveX_RxJava_pull_4188.diff
ReactiveX/RxJava,"Move status icons to top, add maven version badge.","Plus, this should also fix the snapshot versions which were broken (they are with 0.0.1-SNAPSHOT on bintray) because of yesterday's Nebula plugin problems.
",2016-07-10 11:29:58,2016-07-10 11:39:01,https://api.github.com/repos/ReactiveX/RxJava/issues/4187,['Documentation'],4,6,ReactiveX_RxJava_pull_4187.diff
ReactiveX/RxJava,Release 1.1.7 changes.md update,"Applying #4149 to CHANGES.md
",2016-07-09 21:16:57,2016-07-10 06:54:23,https://api.github.com/repos/ReactiveX/RxJava/issues/4184,['Information'],70,0,ReactiveX_RxJava_pull_4184.diff
ReactiveX/RxJava,1.x: no need to run gradle assembe by travis,"By default, Travis runs `gradle assemble` and if it fails, there seems to be no way to specify `--stacktrace` for it other than disabling it entirely. The `buildViaTravis.sh` does a full build anyway.

I'm posting this as Nebula fails in the assembly phase for some reason but by default, nothing else is printed.
",2016-07-09 18:44:14,2016-07-09 20:02:26,https://api.github.com/repos/ReactiveX/RxJava/issues/4183,['Build'],45,37,ReactiveX_RxJava_pull_4183.diff
ReactiveX/RxJava,"1.x: add missing RxJavaHooks options, fix bugs","These PR adds the remaining hooks which weren't even tested with the original RxJavaPlugins plus a full coverage of the RxJavaHooks itself.

This is a mandatory addition and 1.1.7 can't be released without it (i.e., with an incomplete RxJavaHooks that is).
",2016-07-09 15:40:05,2016-07-09 20:22:42,https://api.github.com/repos/ReactiveX/RxJava/issues/4182,['Enhancement'],815,70,ReactiveX_RxJava_pull_4182.diff
ReactiveX/RxJava,1.x: increase Coverage of some classes,"The problem with deprecated API is that it pulls down the coverage percentage.
",2016-07-09 12:26:54,2016-07-09 20:44:00,https://api.github.com/repos/ReactiveX/RxJava/issues/4181,"['Coverage', 'Test']",390,14,ReactiveX_RxJava_pull_4181.diff
ReactiveX/RxJava,1.x: change test heap size to avoid 137,"It appears that since we added jacoco to the build, it fails sometimes with error 137 which is the code for the system killing the JVM for running out of memory. It is likely the coverage data plus some test's excessive memory use (I don't know which ones) try to go above the current 2GB limit.

This is an experiment.
",2016-07-08 21:18:32,2016-07-09 07:46:02,https://api.github.com/repos/ReactiveX/RxJava/issues/4180,['Test-Failures'],7,7,ReactiveX_RxJava_pull_4180.diff
ReactiveX/RxJava,1.x: new fromAsync to bridge the callback world with the reactive,"This PR adds a new source operator: `fromAsync()` that let's bridge the callback-style world with the reactive world by providing a push surface and offers options to handle backpressure.
",2016-07-08 19:36:15,2016-07-10 06:36:10,https://api.github.com/repos/ReactiveX/RxJava/issues/4179,['Enhancement'],1402,2,ReactiveX_RxJava_pull_4179.diff
ReactiveX/RxJava,1.x: improve coverage of rx.Observable methods,"This PR improves the coverage of `rx.Observable` methods plus 
- fixes a javadoc issue 
- fixes an enum-coverage anomaly in Notification (now it is simply biased towards onNext signals)
- removes `equals()` from `TestException` as it caused anomalies with deduplication inside `CompositeException`
- fixes 3 PMD rule violations (2 suppressed, 1 corrected)
- `timestamp` and `timeInterval` now use the `Schedulers.computation()` as the source for the current time instead of `Schedulers.immediate()` which can't be properly hooked. By default, they both return `System.currentTimeMillis()`.
",2016-07-08 11:24:22,2016-07-08 20:43:43,https://api.github.com/repos/ReactiveX/RxJava/issues/4178,"['Coverage', 'Test']",2488,289,ReactiveX_RxJava_pull_4178.diff
ReactiveX/RxJava,"1.x: optimize collect, reduce and takeLast(1)","This PR reduces the overhead with `collect`, `reduce` and `takeLast` and introduces the `DeferredScalarSubscriber` to support similar unbounded-in single-out scenarios.

Benchmark comparison (i7 4770K, Windows 7 x64, Java 8u92)

![image](https://cloud.githubusercontent.com/assets/1269832/16669829/ba5541cc-4497-11e6-9827-097ac686bcf2.png)

Relative to each other: (each practically returning the very last value)

![image](https://cloud.githubusercontent.com/assets/1269832/16669793/a35183fa-4497-11e6-9a93-36f7effe7e3b.png)
",2016-07-07 21:10:16,2016-07-08 07:05:40,https://api.github.com/repos/ReactiveX/RxJava/issues/4176,['Performance'],907,208,ReactiveX_RxJava_pull_4176.diff
ReactiveX/RxJava,1.x: benchmark reduce and takeLast(1),"Adds benchmarks to measure the overhead of `reduce()`, `takeLast(1)` and `collect()`.

Results (i7 4770K, Windows 7 x64, Java 8u92) ops/s, larger is better.

![image](https://cloud.githubusercontent.com/assets/1269832/16664818/2f0235f4-4482-11e6-8844-8e294bbcabd9.png)
",2016-07-07 18:21:03,2016-07-07 18:58:17,https://api.github.com/repos/ReactiveX/RxJava/issues/4174,['Performance'],106,0,ReactiveX_RxJava_pull_4174.diff
ReactiveX/RxJava,1.x: allow customizing GenericScheduledExecutorService via RxJavaHooks,"This PR adds a customization point to  `RxJavaHooks` that let's one create different `ScheduledExecutorService` instances for the `GenericScheduledExecutorService` utility.

To apply the hook (or remove it), one has to restart the `Schedulers` via `shutdown()` and then `start()`. Note that the latter had to be made public as well.

Related #4171.
",2016-07-07 13:29:58,2016-07-10 06:36:37,https://api.github.com/repos/ReactiveX/RxJava/issues/4173,['Enhancement'],136,8,ReactiveX_RxJava_pull_4173.diff
ReactiveX/RxJava,1.x: add missing backpressure descriptions and update old ones,"This PR adds or updates places where the `Backpressure:` description was missing or outdated.

Unfortunately, GitHub has a hard limit on diff size per file so reviewers have to use their own local diff.
",2016-07-07 11:20:52,2016-07-07 20:09:38,https://api.github.com/repos/ReactiveX/RxJava/issues/4172,['Documentation'],1051,136,ReactiveX_RxJava_pull_4172.diff
ReactiveX/RxJava,1.x: Detect concurrent emission in observeOn and throw ISE instead of MBE,"We've recently faced `MissingBackpressureException` which actually was not related to backpressure. 

After investigation it appeared that we were writing to `PublishSubject` from multiple threads which broke queue in `observeOn`: `queue.offer()` returned false not because it reached capacity limit but because another thread already written to exact same index.

This PR throws `IllegalStateException` instead of `MissingBackpressureException` in case if it has detected concurrent data emission + suggests user to serialize data emission to avoid this problem.
",2016-07-06 15:10:26,2016-07-08 08:34:50,https://api.github.com/repos/ReactiveX/RxJava/issues/4169,[],80,20,ReactiveX_RxJava_pull_4169.diff
ReactiveX/RxJava,2.x: reduce overhead of blocking first/last/single,"Optimize the reception, less allocation, less overhead in general.

Benchmark comparison (i7 4790, Windows 7 x64, Java 8u92)

![image](https://cloud.githubusercontent.com/assets/1269832/16583761/065268fc-42b8-11e6-86a1-4ac91da80c97.png)
",2016-07-05 11:58:47,2016-07-06 08:27:02,https://api.github.com/repos/ReactiveX/RxJava/issues/4167,['Performance'],372,228,ReactiveX_RxJava_pull_4167.diff
ReactiveX/RxJava,2.x: measure overhead of toBlocking() first and last,"This updates the perf classes a bit and adds a blocking benchmark.

![image](https://cloud.githubusercontent.com/assets/1269832/16580974/5ff08e54-42a7-11e6-889e-cfbb5c0bdecb.png)
",2016-07-05 09:56:39,2016-07-05 11:06:08,https://api.github.com/repos/ReactiveX/RxJava/issues/4166,['Performance'],133,34,ReactiveX_RxJava_pull_4166.diff
ReactiveX/RxJava,2.x: fix wrong reference check in FlattenIterable,"This was due to bad rewrite of field updater to atomic reference.
",2016-07-05 08:16:19,2016-07-05 08:52:50,https://api.github.com/repos/ReactiveX/RxJava/issues/4165,['Bug'],57,5,ReactiveX_RxJava_pull_4165.diff
ReactiveX/RxJava,"2.x: enable op-fusion on GroupBy, doOnX, fix mistakes in map and filter","This short PR enables operator fusion on `groupBy` and on the `doOnNext`, `doOnError`, `doOnComplete` and `doOnEach` operators.

In addition, it fixes small mistakes in `map` and `filter` and adds a method to `TestSubscriber` to print better fusion-assertion failure message.
",2016-07-02 19:11:19,2016-07-05 06:50:32,https://api.github.com/repos/ReactiveX/RxJava/issues/4160,['Enhancement'],477,101,ReactiveX_RxJava_pull_4160.diff
ReactiveX/RxJava,2.x: Enable fusion-consumers,"This PR enables fusion-consumers such as `observeOn`, `flatMap`, `zip`, `concatMap`; makes `UnicastProcessor` async-fuseable (used by `window`); fixes a few hidden issues with operators and has convenience renames of `SubscriptionHelper.validateX`. In addition, it features the new `FlowableFlattenIterable` used by `flatMapIterable` and `concatMapIterable`.
",2016-07-01 14:50:11,2016-07-02 16:23:07,https://api.github.com/repos/ReactiveX/RxJava/issues/4157,['Enhancement'],3387,1464,ReactiveX_RxJava_pull_4157.diff
ReactiveX/RxJava,Ability to create custom schedulers with behavior based on composing operators.,"based on #4115

Allows the use of operators for controlling the timing around when actions scheduled on workers are actually done. This makes it possible to layer additional behavior on an existing `Scheduler`. The main parameter is a function that flattens an `Observable<Completable>` into just one `Completable`. There must be a chain of operators connecting the returned value to the source Observable otherwise any work scheduled on the Scheduler will not be executed.

When `scheduler.createWorker()` is invoked a `Completable` is onNext'd to the combinator to be flattened. If the `Completable` is not immediately subscribed to an calls to `worker.schedule(...)` are buffered. Once the `Completable` is subscribed to actions are then scheduled on the actual Scheduler. When the `Worker` is unsubscribed the `Completable` emits an onComplete and triggers any behavior in the flattening operator. The `Observable<Completable>` and all `Completable`s give to the flattening function never onError.

Slowing down the rate to no more than than 1 a second.

``` java
 Scheduler slowSched = new ScheduleWhen(workers -> {
    // use concatenate to make each worker happen one at a time.
    return Completable.concat(workers.map(worker -> {
        // delay the starting of the next worker by 1 second.
        return worker.delay(1, TimeUnit.SECONDS);
    }));
 }, Schedulers.computation());
```

Limit the amount concurrency two at a time without creating a new fix size thread pool:

``` java
 Scheduler limitSched = new ScheduleWhen(workers -> {
    // use merge max concurrent to two at a time
    return Completable.merge(workers, 2);
 }, Schedulers.computation());
```
",2016-06-30 23:20:57,2016-07-09 17:22:16,https://api.github.com/repos/ReactiveX/RxJava/issues/4154,['Feature-Request'],586,0,ReactiveX_RxJava_pull_4154.diff
ReactiveX/RxJava,2.x: enable scalar and async fuseable sources and intermediates,"This PR enables operator fusion for scalar and knowingly single-element sources.

There are no fusion-consumers yet.
",2016-06-30 12:55:35,2016-07-01 09:54:06,https://api.github.com/repos/ReactiveX/RxJava/issues/4151,['Enhancement'],1117,640,ReactiveX_RxJava_pull_4151.diff
ReactiveX/RxJava,Fix the initialization of Completable.complete(),"I forgot to invert the noHook -> useHook change.
",2016-06-29 13:22:24,2016-06-29 13:49:09,https://api.github.com/repos/ReactiveX/RxJava/issues/4146,['Test'],4,4,ReactiveX_RxJava_pull_4146.diff
ReactiveX/RxJava,Observable direct rest,"This concludes the architecture switch for 2.x.
",2016-06-29 10:56:33,2016-06-29 16:30:27,https://api.github.com/repos/ReactiveX/RxJava/issues/4145,['Enhancement'],1222,1304,ReactiveX_RxJava_pull_4145.diff
ReactiveX/RxJava,Applied skeletal implementation to interface migration refactoring,"This is a semantics-preserving refactoring.
- We are evaluating a research prototype automated refactoring Eclipse plug-in called [Migrate Skeletal Implementation to Interface](https://github.com/khatchad/Migrate-Skeletal-Implementation-to-Interface-Refactoring). We have applied the tool to your project in the hopes of receiving feedback.
- The approach is very conservative and you should not observe many source code changes.
- The source code should be semantically equivalent to the original.
- We have run tests prior to applying to the tool and following the application. All tests pass.

Thank you for your help in this evaluation!
",2016-06-28 17:35:23,2016-06-29 17:09:54,https://api.github.com/repos/ReactiveX/RxJava/issues/4143,['Question'],29,131,ReactiveX_RxJava_pull_4143.diff
ReactiveX/RxJava,"1.x: add RxJavaHooks tests, fix small bugs","This PR adds unit tests for the new `RxJavaHooks` facility and fixes
- Small mistakes in calling the right hook.
- Dealing with constant `Completable` sources such as `complete()` and `never()`: they executed the hook on class initialization so they couldn't be properly overridden later via an `onCreate` hook. (This could affect the other constants and will be addressed separately.)
",2016-06-28 11:14:16,2016-06-29 12:47:28,https://api.github.com/repos/ReactiveX/RxJava/issues/4142,"['Bug', 'Test']",428,20,ReactiveX_RxJava_pull_4142.diff
ReactiveX/RxJava,2.x: upgrade to Gradle 2.14,"Upgrade to 2.14.
",2016-06-28 08:38:32,2016-06-28 09:41:55,https://api.github.com/repos/ReactiveX/RxJava/issues/4141,['Build'],30,26,ReactiveX_RxJava_pull_4141.diff
ReactiveX/RxJava,"1.x: Change Completable.subscribe(onError, onComplete) to (onComplete, onError)","Closes #3851, closes #4137.
",2016-06-27 17:29:28,2016-06-28 01:55:19,https://api.github.com/repos/ReactiveX/RxJava/issues/4140,['Enhancement'],52,52,ReactiveX_RxJava_pull_4140.diff
ReactiveX/RxJava,2.x: fix flaky tests,"This PR should fix some test timing out otherwise sensitive to thread hiccups.
#4138
#4109
#4054
",2016-06-27 15:10:55,2016-06-27 15:30:40,https://api.github.com/repos/ReactiveX/RxJava/issues/4139,['Test-Failures'],7,7,ReactiveX_RxJava_pull_4139.diff
ReactiveX/RxJava,"2.x: enable fuseable sources, adjust operators","- adds an operator `hide` to allow hiding and breaking optimizations
- update `filter` to support fusions: queue and conditional
- `range` now supports fusion: sync-queue and conditional
- `fromArray` now supports fusion: sync-queue and conditional
- `fromIterable` now supports fusion: sync-queue and conditional
- enhanced `TestSubscriber` methods to return this - allows chaining the assertions
- extended `TestSubscriber` to act as a consumer for queue-fusion
- introduced `FlowableSource` as an intermediate type for operators: allows discovering the upstream in a standard way, allows the IDE to generate a constructor with a source value.
- added `BasicQueueSubscription` that locks down unused `Queue` methods plus is a container for an atomic long value useful for request/wip tracking.
",2016-06-27 09:24:59,2016-06-27 12:54:37,https://api.github.com/repos/ReactiveX/RxJava/issues/4136,['Enhancement'],1259,279,ReactiveX_RxJava_pull_4136.diff
ReactiveX/RxJava,2.x update branch and year in contributing and readme md,"Target 2.x and (C) 2016.
",2016-06-27 06:22:58,2016-06-28 01:55:09,https://api.github.com/repos/ReactiveX/RxJava/issues/4135,['Documentation'],4,4,ReactiveX_RxJava_pull_4135.diff
ReactiveX/RxJava,2.x: cleanup and test renames,"This PR adds the missing `@Override` annotations and renames the `Observable` unit tests to conform a single name pattern.
",2016-06-27 05:54:31,2016-06-27 06:13:44,https://api.github.com/repos/ReactiveX/RxJava/issues/4134,['Cleanup'],127,118,ReactiveX_RxJava_pull_4134.diff
ReactiveX/RxJava,Refactor private constructor checker into a utility class,"Move into `TestUtil.checkUtilityClass()`.
",2016-06-27 05:29:11,2016-06-27 20:58:54,https://api.github.com/repos/ReactiveX/RxJava/issues/4133,"['Cleanup', 'Test']",111,139,ReactiveX_RxJava_pull_4133.diff
ReactiveX/RxJava,1.x: run Findbugs on main only,,2016-06-26 09:55:19,2016-06-26 10:19:06,https://api.github.com/repos/ReactiveX/RxJava/issues/4131,['Build'],1,0,ReactiveX_RxJava_pull_4131.diff
ReactiveX/RxJava,2.x: run Findbugs on main only,"Don't run findbugs for the perf and test packages.
",2016-06-26 09:31:42,2016-06-26 09:45:01,https://api.github.com/repos/ReactiveX/RxJava/issues/4130,['Build'],1,0,ReactiveX_RxJava_pull_4130.diff
ReactiveX/RxJava,2.x: cleanup of PMD suggestions,"This PR adjusts the PMD rules and fixes about 300 suggestions.
",2016-06-26 08:31:25,2016-06-26 09:11:02,https://api.github.com/repos/ReactiveX/RxJava/issues/4129,['Cleanup'],518,559,ReactiveX_RxJava_pull_4129.diff
ReactiveX/RxJava,2.x: Reduce the visibility of internal methods.,,2016-06-26 05:37:40,2016-06-26 06:21:40,https://api.github.com/repos/ReactiveX/RxJava/issues/4128,['Cleanup'],4,4,ReactiveX_RxJava_pull_4128.diff
ReactiveX/RxJava,2.x: Correct method name for Flowable-->Observable.,,2016-06-26 05:37:07,2016-06-26 06:20:34,https://api.github.com/repos/ReactiveX/RxJava/issues/4127,['Cleanup'],1,1,ReactiveX_RxJava_pull_4127.diff
ReactiveX/RxJava,Remove XResource classes,"This PR removes the `XResource` types and replaces them with `XDisposable` or `XSubscription` where necessary.
",2016-06-25 20:54:29,2016-06-25 21:10:44,https://api.github.com/repos/ReactiveX/RxJava/issues/4126,['Cleanup'],457,674,ReactiveX_RxJava_pull_4126.diff
ReactiveX/RxJava,1.x: Test all private Constructors,,2016-06-25 20:03:01,2016-06-27 05:13:13,https://api.github.com/repos/ReactiveX/RxJava/issues/4125,['Test'],214,106,ReactiveX_RxJava_pull_4125.diff
ReactiveX/RxJava,"Switch some Observable ops to direct, map fuseable","- Switch a few `Observable` operators to direct implementations (reduces allocation)
- Update `map` to support operator fusion; there are no sources or consumer yet though.
- Adjust `BasicFuseableX` to have different default conveniences
- Modify `CompositeResource` to indicate success of the mutator methods
- increase timeout of `FlowableOnBackpressureDropTest.testFixBackpressureWithBuffer`
",2016-06-25 18:34:35,2016-06-25 18:51:57,https://api.github.com/repos/ReactiveX/RxJava/issues/4124,"['Cleanup', 'Enhancement']",237,141,ReactiveX_RxJava_pull_4124.diff
ReactiveX/RxJava,"Refactor ConditionalSubscriber, add base fuseable Subscribers","This PR refactors `ConditionalSubscriber` and renames its method to `tryOnNext`. In addition, two new abstract subscriber types were added: `BasicFuseableSubscriber` and `BasicFuseableConditionalSubscriber` to help writing operators that support fusion (queue and/or conditional).
",2016-06-25 16:41:05,2016-06-25 17:21:41,https://api.github.com/repos/ReactiveX/RxJava/issues/4122,['Enhancement'],572,9,ReactiveX_RxJava_pull_4122.diff
ReactiveX/RxJava,2.x: provide an explanation why certain tests are ignored,"The same as #4118, but for 2.x
",2016-06-25 13:36:56,2016-06-25 13:54:57,https://api.github.com/repos/ReactiveX/RxJava/issues/4120,"['Cleanup', 'Test']",11,12,ReactiveX_RxJava_pull_4120.diff
ReactiveX/RxJava,"1.x: increase coverage of internal utils, remove unused/unnecessary items","Increase coverage of internal utils, remove unused and unnecessary items.
",2016-06-25 13:25:18,2016-06-25 13:55:09,https://api.github.com/repos/ReactiveX/RxJava/issues/4119,['Cleanup'],523,424,ReactiveX_RxJava_pull_4119.diff
ReactiveX/RxJava,1.x: provide an explanation why certain tests are ignored,"During code reading I've found some tests that are ignored but don't have a record why they are being ignored. Some of them have meaningful explanations present as line comments, so I decided to make them the parameters of `@Ignore` annotation, so it will be correct.
",2016-06-25 12:05:27,2016-06-25 13:13:35,https://api.github.com/repos/ReactiveX/RxJava/issues/4118,['Test'],4,5,ReactiveX_RxJava_pull_4118.diff
ReactiveX/RxJava,1.x: increase coverage of producers,"Increase coverage of `XProudcer`s.
",2016-06-25 11:51:03,2016-06-25 12:02:31,https://api.github.com/repos/ReactiveX/RxJava/issues/4117,['Test'],416,0,ReactiveX_RxJava_pull_4117.diff
ReactiveX/RxJava,2.x: Add Findbugs,"Taken from the 1.x branch
",2016-06-25 10:37:50,2016-06-25 11:34:40,https://api.github.com/repos/ReactiveX/RxJava/issues/4116,['Build'],16,1,ReactiveX_RxJava_pull_4116.diff
ReactiveX/RxJava,2.x: Case IO acronym like a word.,"This is already being done in the library, and is fairly [standard practice](https://google.github.io/styleguide/javaguide.html#s5.3-camel-case).
",2016-06-25 01:01:10,2016-06-25 05:31:57,https://api.github.com/repos/ReactiveX/RxJava/issues/4114,['Cleanup'],24,24,ReactiveX_RxJava_pull_4114.diff
ReactiveX/RxJava,2.x: Parallelize unit test execution for speed!,"This gives me a 57% reduction in execution time.
",2016-06-24 23:54:05,2016-06-25 15:35:47,https://api.github.com/repos/ReactiveX/RxJava/issues/4113,"['Build', 'Test']",6,2,ReactiveX_RxJava_pull_4113.diff
ReactiveX/RxJava,2.x: Switch the last SerialResource to manual resource management.,,2016-06-24 23:45:02,2016-06-25 05:28:20,https://api.github.com/repos/ReactiveX/RxJava/issues/4112,['Enhancement'],4,108,ReactiveX_RxJava_pull_4112.diff
ReactiveX/RxJava,2.x: Simplify boolean disposables which run code on dispose.,,2016-06-24 22:57:08,2016-06-25 06:03:00,https://api.github.com/repos/ReactiveX/RxJava/issues/4111,['Enhancement'],106,124,ReactiveX_RxJava_pull_4111.diff
ReactiveX/RxJava,2.x: Remove explicit cancel flags where it can be inferred.,,2016-06-24 21:02:09,2016-06-25 06:48:13,https://api.github.com/repos/ReactiveX/RxJava/issues/4110,['Cleanup'],23,52,ReactiveX_RxJava_pull_4110.diff
ReactiveX/RxJava,2.x: Invert subscription validation return type for better semantics.,,2016-06-24 19:19:51,2016-06-24 20:07:10,https://api.github.com/repos/ReactiveX/RxJava/issues/4108,['Cleanup'],178,240,ReactiveX_RxJava_pull_4108.diff
ReactiveX/RxJava,2.x: make sure the helper returns true if the pre-swap value was null,"The original behavior was somewhat inconsistent: if the target was null before the cancel/dispose, the method didn't return true indicating a successful swap for the current thread. Now that many `cancelled` flag has been removed, it has to consistently trigger the remaining cleanup actions.
",2016-06-24 19:02:58,2016-06-24 20:31:21,https://api.github.com/repos/ReactiveX/RxJava/issues/4107,['Bug'],8,4,ReactiveX_RxJava_pull_4107.diff
ReactiveX/RxJava,2.x: Remove explicit cancel flags where it can be inferred.,"I suspect there's quite a few of these all over. These are just the ones I noted while doing other changes.
",2016-06-24 18:36:16,2016-06-24 18:51:21,https://api.github.com/repos/ReactiveX/RxJava/issues/4106,['Enhancement'],33,80,ReactiveX_RxJava_pull_4106.diff
ReactiveX/RxJava,2.x: Remove some superfluous reads before writes.,,2016-06-24 16:55:29,2016-06-24 17:14:31,https://api.github.com/repos/ReactiveX/RxJava/issues/4105,['Cleanup'],11,33,ReactiveX_RxJava_pull_4105.diff
ReactiveX/RxJava,2.x: prepare the operator-fusion enhancement,"This PR adds 3 operator-fusion related interfaces: 
- `QueueSubscription` will support fusion for `Flowable` - avoid creating queues, avoid cost of multiple enqueue-dequeue, reduce `request()` overhead
- `QueueDisposable` will support fusion for `Observable` - avoid creating queues, avoid cost of multiple enqueue-dequeue
- `ScalarCallable` - indicate a scalar constant source

In addition `ConditionalSubscriber` is marked and will be moved to the new package and its method renamed to `tryOnNext`.

Unlike Reactor-Core (and Rsc), there is no `Fuseable` marker interface. The ability of fusing is indicated by calling `onSubscribe` with the above `QueueX` enabled instances and then called back via `requestFusion`. This allows having less duplicated code compared to Reactor/Rsc - at the cost of usually one extra field to store the `QueueX` value that may be null.
",2016-06-24 10:21:20,2016-06-24 10:38:11,https://api.github.com/repos/ReactiveX/RxJava/issues/4103,['Enhancement'],292,0,ReactiveX_RxJava_pull_4103.diff
ReactiveX/RxJava,2.x: Expose isDisposed method on Disposable.,"This is a fairly ""dumb"" addition. There's lots of room for follow-up improvement in the utilization of base helper classes and even removing some now-duplicated state management.

Closes #4075.
",2016-06-24 05:24:23,2016-06-24 16:02:27,https://api.github.com/repos/ReactiveX/RxJava/issues/4102,['Enhancement'],843,294,ReactiveX_RxJava_pull_4102.diff
ReactiveX/RxJava,2.x: Switch a SerialResource use to SerialDisposable.,,2016-06-23 23:01:26,2016-06-24 06:58:09,https://api.github.com/repos/ReactiveX/RxJava/issues/4101,['Cleanup'],4,5,ReactiveX_RxJava_pull_4101.diff
ReactiveX/RxJava,2.x: Add PMD,"Basically taken from the 1.x branch
",2016-06-23 21:50:25,2016-06-23 22:04:36,https://api.github.com/repos/ReactiveX/RxJava/issues/4100,['Build'],268,0,ReactiveX_RxJava_pull_4100.diff
ReactiveX/RxJava,1.x: Add Findbugs,"Continuing from #3164 .

Parsing the generated Findbugs output file it not as trivial as with PMD since it does contain some meta information. 

Let me know whether this is wanted or not and if so how it can be pursued. 

By default all rules from Findbugs are enabled and one can opt out using `excludeFilter = file('findbugs-filter.xml)` inside the `findbugs` block, which will then contain something alone the lines of [this](http://findbugs.sourceforge.net/manual/filter.html).
",2016-06-23 21:47:42,2016-06-25 10:19:04,https://api.github.com/repos/ReactiveX/RxJava/issues/4099,['Build'],23,8,ReactiveX_RxJava_pull_4099.diff
ReactiveX/RxJava,1.x: update map() and filter() to implement OnSubscribe directly,"This change reduces the indirection and allocation count when using `map` or `filter`.
",2016-06-23 21:32:15,2016-06-25 06:07:44,https://api.github.com/repos/ReactiveX/RxJava/issues/4097,['Enhancement'],120,35,ReactiveX_RxJava_pull_4097.diff
ReactiveX/RxJava,2.x: convert Observable OnSubscribe to direct implementation,"First part of converting the OnSubscribe operators of `Observable` into direct implementors of `Observable` - saves allocation.

Don't worry about the unnecessary parenthesis, will be removed in a future PR.
",2016-06-23 19:42:09,2016-06-23 19:55:31,https://api.github.com/repos/ReactiveX/RxJava/issues/4096,['Enhancement'],191,192,ReactiveX_RxJava_pull_4096.diff
ReactiveX/RxJava,2.x: Invert request validation return type for better semantics.,,2016-06-23 19:36:38,2016-06-23 19:50:26,https://api.github.com/repos/ReactiveX/RxJava/issues/4095,['Cleanup'],80,121,ReactiveX_RxJava_pull_4095.diff
ReactiveX/RxJava,"2.x: Remove EmptySubscriber, start to remove NbpEmptySubscriber.","Follow up from comments in #4083 and #4085.
",2016-06-23 15:23:58,2016-06-23 17:43:15,https://api.github.com/repos/ReactiveX/RxJava/issues/4094,['Cleanup'],96,114,ReactiveX_RxJava_pull_4094.diff
ReactiveX/RxJava,1.x: exclude some text files from license checks,"By default, the `license` plugin warns about MDs and text files. In addition, this excluded the JCTools queues and the beta/experimental annotations because they kept their original license header.
",2016-06-23 12:42:07,2016-06-25 06:07:21,https://api.github.com/repos/ReactiveX/RxJava/issues/4093,['Build'],4,0,ReactiveX_RxJava_pull_4093.diff
ReactiveX/RxJava,"1.x: add AnimalSniffer to the build process, fix and suppress violations","This PR adds the AnimalSniffer plugin to check for Java 6 API violations.

Related issue: #4067.
",2016-06-23 11:50:51,2016-06-25 06:05:25,https://api.github.com/repos/ReactiveX/RxJava/issues/4092,['Build'],129,17,ReactiveX_RxJava_pull_4092.diff
ReactiveX/RxJava,1.x: apply fixes based on PMD suggestions,"Some notable changes:
- move fields to the beginning of a class
- remove unnecessary modifiers and initializers
- avoid creating objects to early
- update most drain algorithm to use the (more modern) `while (e != r)` pattern
- PMD has a few incorrect checks: complaining about a final local that gets used in an inner class
- adding braces to ifs
- documenting deliberately empty methods
- fix internal field and method namings
- delegate to `Exceptions.propagate`
",2016-06-23 11:09:27,2016-06-25 05:42:36,https://api.github.com/repos/ReactiveX/RxJava/issues/4091,['Cleanup'],1040,1013,ReactiveX_RxJava_pull_4091.diff
ReactiveX/RxJava,Rename Throwable parameter from exception to throwable,"- Exception extends Throwable so it's incorrect to generalize the Throwable as `exception`
",2016-06-23 10:54:45,2016-06-23 11:59:51,https://api.github.com/repos/ReactiveX/RxJava/issues/4090,['Cleanup'],3,3,ReactiveX_RxJava_pull_4090.diff
ReactiveX/RxJava,"1.x: fix some flaky tests, add more timeout to others","Some tests are sensitive to Travis hiccups. This adds more timeout to some and reduces heavyness on others.
",2016-06-23 07:33:26,2016-06-23 07:49:20,https://api.github.com/repos/ReactiveX/RxJava/issues/4088,['Test-Failures'],215,211,ReactiveX_RxJava_pull_4088.diff
ReactiveX/RxJava,2.x: Normalize request validation using SubscriptionHelper.,,2016-06-23 05:33:31,2016-06-23 07:04:22,https://api.github.com/repos/ReactiveX/RxJava/issues/4087,['Cleanup'],27,38,ReactiveX_RxJava_pull_4087.diff
ReactiveX/RxJava,1.x: Remove unnecessary dependency in build.gradle,,2016-06-23 05:28:18,2016-06-23 07:14:22,https://api.github.com/repos/ReactiveX/RxJava/issues/4086,['Build'],0,2,ReactiveX_RxJava_pull_4086.diff
ReactiveX/RxJava,2.x: Merge NbpCancelledSubscriber into NbpEmptySubscriber.,"The NBP version of #4083.
",2016-06-23 05:12:14,2016-06-23 07:07:19,https://api.github.com/repos/ReactiveX/RxJava/issues/4085,['Cleanup'],29,80,ReactiveX_RxJava_pull_4085.diff
ReactiveX/RxJava,2.x: More uses of SubscriptionHelper.,,2016-06-23 04:56:53,2016-06-23 07:00:52,https://api.github.com/repos/ReactiveX/RxJava/issues/4084,['Cleanup'],11,44,ReactiveX_RxJava_pull_4084.diff
ReactiveX/RxJava,2.x: Merge CancelledSubscriber into EmptySubscriber.,,2016-06-23 04:34:39,2016-06-23 07:18:08,https://api.github.com/repos/ReactiveX/RxJava/issues/4083,['Cleanup'],16,62,ReactiveX_RxJava_pull_4083.diff
ReactiveX/RxJava,2.x: Do not leak the DISPOSED marker instance into public API.,"If this were to be used by public code it could have have Very Bad™ effects by causing operators to think that they already disposed resources when they actually had not. Since `Disposable` is stateless it's safe for `disposed()` and `empty()` to be synonymous, although that might change in the future so both methods are retained.
",2016-06-23 02:58:10,2016-06-23 06:51:26,https://api.github.com/repos/ReactiveX/RxJava/issues/4081,['Cleanup'],5,1,ReactiveX_RxJava_pull_4081.diff
ReactiveX/RxJava,2.x: Replace custom empty Disposables with global instance.,"I keep thinking I found all of these and then more crop up...
",2016-06-22 20:50:19,2016-06-22 21:10:24,https://api.github.com/repos/ReactiveX/RxJava/issues/4080,['Cleanup'],4,14,ReactiveX_RxJava_pull_4080.diff
ReactiveX/RxJava,2.x: Re-use the single empty Disposable instance everywhere.,,2016-06-22 20:10:21,2016-06-22 20:28:06,https://api.github.com/repos/ReactiveX/RxJava/issues/4078,['Cleanup'],4,13,ReactiveX_RxJava_pull_4078.diff
ReactiveX/RxJava,Annotation links in README.md yield 404 error,"The links for `@Beta` and `@Experimental` in the `README.md` point to the master branch. These URLs yield 404 not found when clicked. 
",2016-06-22 19:41:13,2016-06-22 19:52:30,https://api.github.com/repos/ReactiveX/RxJava/issues/4077,['Documentation'],6,6,ReactiveX_RxJava_pull_4077.diff
ReactiveX/RxJava,2.x: Some small tweaks to Disposables.,"- Use BooleanDisposable for Runnables.
- Change BooleanDisposable to use null for disposed instead of keeping a marker instance.
- Eliminate static factory for CompositeDisposable since its constructors are already public.
",2016-06-22 19:31:33,2016-06-22 19:46:21,https://api.github.com/repos/ReactiveX/RxJava/issues/4076,['Enhancement'],19,57,ReactiveX_RxJava_pull_4076.diff
ReactiveX/RxJava,2.x: Use more DisposableHelper and SubscriptionHelper in operators.,,2016-06-22 17:52:38,2016-06-22 18:08:02,https://api.github.com/repos/ReactiveX/RxJava/issues/4074,['Cleanup'],19,68,ReactiveX_RxJava_pull_4074.diff
ReactiveX/RxJava,2.x: Dereference atomic ref before identity comparison.,"This returns false 100% of the time otherwise.
",2016-06-22 16:00:01,2016-06-22 16:19:54,https://api.github.com/repos/ReactiveX/RxJava/issues/4072,['Bug'],1,1,ReactiveX_RxJava_pull_4072.diff
ReactiveX/RxJava,2.x: Inline last uses of caching DisposableHelper's constant.,,2016-06-22 15:59:38,2016-06-22 16:18:06,https://api.github.com/repos/ReactiveX/RxJava/issues/4071,['Cleanup'],5,9,ReactiveX_RxJava_pull_4071.diff
ReactiveX/RxJava,2.x: Merge SerialDisposable and MultipleAssignmentDisposable.,"Closes #4057 although doesn't address the name of the class.
",2016-06-22 15:48:17,2016-06-22 16:55:11,https://api.github.com/repos/ReactiveX/RxJava/issues/4070,['Enhancement'],100,205,ReactiveX_RxJava_pull_4070.diff
ReactiveX/RxJava,Remove second type parameter from Subject and FlowProcessor.,"Closes #4056.
",2016-06-22 15:32:27,2016-06-22 15:45:08,https://api.github.com/repos/ReactiveX/RxJava/issues/4069,['Enhancement'],124,128,ReactiveX_RxJava_pull_4069.diff
ReactiveX/RxJava,1.x: Add PMD code checking tool to the build process,"This PR adds a PMD plugin to the build process to check a set of coding rules.

At this point, I don't think rule violations should fail the build.

Unfortunately, I don't know about a service, like codecov-io, that could post the check results as comments under a PR, therefore, the current build just prints the first ~100 violations into the build log:

https://travis-ci.org/ReactiveX/RxJava/builds/139539158#L240

https://travis-ci.org/ReactiveX/RxJava/builds/139539158#L5508
",2016-06-22 15:17:44,2016-06-22 20:42:51,https://api.github.com/repos/ReactiveX/RxJava/issues/4068,['Build'],268,0,ReactiveX_RxJava_pull_4068.diff
ReactiveX/RxJava,1.x: Ignore local.properties file,,2016-06-22 12:23:29,2016-06-22 12:34:35,https://api.github.com/repos/ReactiveX/RxJava/issues/4066,['Cleanup'],4,1,ReactiveX_RxJava_pull_4066.diff
ReactiveX/RxJava,1.x: ignore .pmd file in root directory,"The PMD tool in local IDE tends to create this custom file. Add a rule to ignore it.
",2016-06-22 11:57:40,2016-06-22 12:20:06,https://api.github.com/repos/ReactiveX/RxJava/issues/4065,['Cleanup'],3,0,ReactiveX_RxJava_pull_4065.diff
ReactiveX/RxJava,1.x: Add PMD,"As discussed in #3164

Right now there are 10243 PMD rule violations. 

For now I activated all checks though it is recommend to disable some of them.
",2016-06-22 09:55:20,2016-06-22 17:12:18,https://api.github.com/repos/ReactiveX/RxJava/issues/4064,['Build'],309,0,ReactiveX_RxJava_pull_4064.diff
ReactiveX/RxJava,1.x: scan & reduce give javadoc about unsharing the initialValue,"Replacement for #3959.
",2016-06-22 09:26:09,2016-06-22 13:29:26,https://api.github.com/repos/ReactiveX/RxJava/issues/4063,['Documentation'],34,4,ReactiveX_RxJava_pull_4063.diff
ReactiveX/RxJava,1.x: add package-info.java to the public packages,"This PR adds the missing `package-info.java` files to the public packages.

(http://reactivex.io/RxJava/javadoc/ looks awkward with all those empty descriptions).
",2016-06-22 08:57:49,2016-06-22 13:37:34,https://api.github.com/repos/ReactiveX/RxJava/issues/4062,['Documentation'],192,2,ReactiveX_RxJava_pull_4062.diff
ReactiveX/RxJava,"1.x: coverage improvements, small adjustments","- update to JUnit 4.12
- remove deprecated use of `junit.framework.Assert`
- update to Mockito 1.10.19
- Notification.accept() now uses switch (note that Jacoco can't properly cover enum switches as it only sees the default and impossible path is not taken).
- in `Scheduler.schedulePeriodically`, move the unsubscribe check after the action to prevent unnecessary schedule of the next iteration.
- remove the inner counted loop from `SerializedObserver` as being unnecessary
- increate timeout in `OperatorSwitchTest`
- add `CompletableSubscriberTest`
- extend `Scheduler`, `SerializedObserver`, 
",2016-06-22 08:04:09,2016-06-22 09:05:35,https://api.github.com/repos/ReactiveX/RxJava/issues/4060,['Cleanup'],648,136,ReactiveX_RxJava_pull_4060.diff
ReactiveX/RxJava,2.x: cleanup a few additional SubscriptionHelper locations,"Follow up to #4058 .
",2016-06-22 07:43:05,2016-06-22 08:02:10,https://api.github.com/repos/ReactiveX/RxJava/issues/4059,['Cleanup'],59,23,ReactiveX_RxJava_pull_4059.diff
ReactiveX/RxJava,Use DisposableHelper and SubscriptionHelper to reduce duplication.,"A lot of operators contained their own marker instance and class definition of Disposable or Subscription. This changes almost all of them to use the shared instance provided by their respective helper class. Some duplication still exists but can be cleaned up in a subsequent change.
",2016-06-22 06:48:10,2016-06-22 07:19:38,https://api.github.com/repos/ReactiveX/RxJava/issues/4058,"['Bug', 'Enhancement']",192,1076,ReactiveX_RxJava_pull_4058.diff
ReactiveX/RxJava,2.x: Update conversion method name to reflect new base type names.,,2016-06-21 22:36:30,2016-06-22 06:54:54,https://api.github.com/repos/ReactiveX/RxJava/issues/4055,['Cleanup'],1,1,ReactiveX_RxJava_pull_4055.diff
ReactiveX/RxJava,2.x: Convert SchedulerSupport annotation to accept a string value.,"Closes #4052.
",2016-06-21 22:01:36,2016-06-21 22:16:17,https://api.github.com/repos/ReactiveX/RxJava/issues/4053,['Enhancement'],952,963,ReactiveX_RxJava_pull_4053.diff
ReactiveX/RxJava,1.x: fix ReplaySubject anomaly around caughtUp by removing that optimization,"Adding the backpressure support to `ReplaySubject` exposed a race condition around the `caughtUp` optimization.

The problem occurs when the source thread has caught up after `drain()` returned true but at the same time, a concurrent `drain()` starts running (due to a subscribe() process finishing or requesting on top of the previous `Long.MAX_VALUE`). This concurrent drain may think the replay hasn't started yet (by finding `rp.node` null) or seeing that the buffer has more elements (that may get double emitted).

The current solution is to remove this optimization until we come up with a correct optimization.

Related: #4028.
",2016-06-21 16:11:46,2016-06-22 07:43:40,https://api.github.com/repos/ReactiveX/RxJava/issues/4051,['Bug'],99,144,ReactiveX_RxJava_pull_4051.diff
ReactiveX/RxJava,1.x: fixes and coverage improvements,"- update to JUnit 4.12
- remove deprecated use of `junit.framework.Assert`
- update to Mockito 1.10.19
- Notification.accept() now uses switch (note that Jacoco can't properly cover enum switches as it only sees the default and impossible path is not taken).
- in `Scheduler.schedulePeriodically`, move the unsubscribe check after the action to prevent unnecessary schedule of the next iteration.
- remove the inner counted loop from `SerializedObserver` as being unnecessary
- increate timeout in `OperatorSwitchTest`
- add `CompletableSubscriberTest`
- extend `Scheduler`, `SerializedObserver`, 
",2016-06-21 14:18:51,2016-06-22 08:03:29,https://api.github.com/repos/ReactiveX/RxJava/issues/4050,"['Cleanup', 'Test']",1041,284,ReactiveX_RxJava_pull_4050.diff
ReactiveX/RxJava,2.x: make Flowable operators extend Flowable directly to reduce allocation,"Relatively straightforward, although manual an tedious, refactoring of the Flowable operators. The number of files is this large because for consistency, the tests have been renamed as well.
",2016-06-21 11:40:31,2016-06-21 11:55:06,https://api.github.com/repos/ReactiveX/RxJava/issues/4049,['Information'],1287,924,ReactiveX_RxJava_pull_4049.diff
ReactiveX/RxJava,2.x: Publish code coverage results to codecov.io,"Same as #4046 except the badge link.
",2016-06-20 21:40:48,2016-06-20 22:03:42,https://api.github.com/repos/ReactiveX/RxJava/issues/4048,['Build'],19,0,ReactiveX_RxJava_pull_4048.diff
ReactiveX/RxJava,1.x: Publish code coverage results to codecov.io,"This is an example built in my repo: https://codecov.io/gh/zsxwing/RxJava/
",2016-06-20 20:32:19,2016-06-20 21:25:23,https://api.github.com/repos/ReactiveX/RxJava/issues/4046,['Build'],20,0,ReactiveX_RxJava_pull_4046.diff
ReactiveX/RxJava,"2.x: Single operators factored out, headers added","`Single` operators factored out and made them extend `Single` directly. Added missing headers.
",2016-06-20 20:10:17,2016-06-20 20:29:12,https://api.github.com/repos/ReactiveX/RxJava/issues/4045,['Information'],2387,1022,ReactiveX_RxJava_pull_4045.diff
ReactiveX/RxJava,"2.x: factor out Completable ops, unify disposed markers","- Moved the operators of Completable into their respective classes. Updated them to extend `Completable` directly.
- Fixed a large set of inconsistend `Disposable` management among the `Observable` operators.
",2016-06-20 17:29:49,2016-06-20 18:01:43,https://api.github.com/repos/ReactiveX/RxJava/issues/4043,['Information'],2595,2289,ReactiveX_RxJava_pull_4043.diff
ReactiveX/RxJava,2.x: Use XConsumable in Completable and Single,"Update to `Completable` and `Single` to use `CompletableConsumable` and `SingleConsumable` as input.
",2016-06-20 12:38:59,2016-06-20 13:07:55,https://api.github.com/repos/ReactiveX/RxJava/issues/4042,['Information'],311,252,ReactiveX_RxJava_pull_4042.diff
ReactiveX/RxJava,2.x: Update Observable's ops to work with ObservableConsumable,"This PR updates the `Observable` method signatures to accept `ObservableConsumable`, similar to how `Flowable` methods accept `Publisher`.

The architecture switch may take a couple of more PRs. I'll try to limit the change amount in each.
",2016-06-20 10:49:57,2016-06-20 11:02:00,https://api.github.com/repos/ReactiveX/RxJava/issues/4041,['Information'],445,430,ReactiveX_RxJava_pull_4041.diff
ReactiveX/RxJava,"1.x: add missing javadoc elements, fix some descriptions","- Fixes to Javadoc warnings
- Type arguments
- Missing descriptions
",2016-06-20 07:16:31,2016-06-20 20:57:34,https://api.github.com/repos/ReactiveX/RxJava/issues/4039,['Documentation'],339,67,ReactiveX_RxJava_pull_4039.diff
ReactiveX/RxJava,Fix typos in NullFunction javadoc,,2016-06-20 04:34:51,2016-06-20 05:17:28,https://api.github.com/repos/ReactiveX/RxJava/issues/4038,['Documentation'],2,2,ReactiveX_RxJava_pull_4038.diff
ReactiveX/RxJava,1.x: Added zip function with Observable array.,"As discussed in #4035 with @akarnokd 
",2016-06-19 16:47:08,2016-06-20 17:54:41,https://api.github.com/repos/ReactiveX/RxJava/issues/4036,['Feature-Request'],110,0,ReactiveX_RxJava_pull_4036.diff
ReactiveX/RxJava,1.x: distinctUntilChanged with direct value comparator - alternative,"Alternative implementation to #4001.
",2016-06-19 11:43:26,2016-06-20 17:43:26,https://api.github.com/repos/ReactiveX/RxJava/issues/4034,['Feature-Request'],97,17,ReactiveX_RxJava_pull_4034.diff
ReactiveX/RxJava,2.x: Update groupID and readme.md,"This PR updates the readme and changes the group ID.

I'm going to merge this and hope the new group id shows up at https://oss.jfrog.org/artifactory/libs-snapshot/io/reactivex/ (may take several attempts, depending on how cooperative the nebula plugin is.)
",2016-06-19 08:53:42,2016-06-19 09:08:02,https://api.github.com/repos/ReactiveX/RxJava/issues/4031,['Build'],25,2,ReactiveX_RxJava_pull_4031.diff
ReactiveX/RxJava,2.x: first step switching to the reduced-allocation architecture,"This is the first step towards the new architecture where operator implementations are themselves of the base type instead of a 2-3 layer indirection as in 1.x.

This PR removes the instance field `onSubscribe` from the base reactive classes and introduces `subscribeActual` to be overridden with the custom operator logic now on. Existing operators are still working through the classical OnSubscribe/Lift indirection and will be updated in subsequent PRs.

Naming and existence of `subscribeActual` is up for (post-merge) discussion. To recap, the method is needed so that the default `subscribe` method can be made final and ensure plugin hooks can be called (once available). The method is protected and only affects operator implementors that chose to extend the base reactive classes directly. 

The alternative is to leave `subscribe` abstract and add a hook to every operator method (for example, see [this](https://github.com/reactor/reactive-streams-commons/blob/master/src/main/java/rsc/publisher/Px.java#L50) and [this](https://github.com/reactor/reactive-streams-commons/blob/master/src/main/java/rsc/publisher/Px.java#L162).
",2016-06-18 22:03:30,2016-06-19 08:14:22,https://api.github.com/repos/ReactiveX/RxJava/issues/4030,['Enhancement'],292,217,ReactiveX_RxJava_pull_4030.diff
ReactiveX/RxJava,1.x: fix Completable.onErrorComplete(Func1) not relaying function crash,"The catch around the predicate didn't actually signal the CompositeException.

Discovered in #4025
",2016-06-17 21:46:19,2016-06-18 15:21:06,https://api.github.com/repos/ReactiveX/RxJava/issues/4027,['Bug'],27,1,ReactiveX_RxJava_pull_4027.diff
ReactiveX/RxJava,1.x: expand and explain cache() in more detail,"This PR rephrases the `cache` documentation a bit and adds workaround for stopping and forgetting the cached values.

Related: #3007.
",2016-06-17 21:22:15,2016-06-18 15:53:36,https://api.github.com/repos/ReactiveX/RxJava/issues/4026,['Documentation'],61,19,ReactiveX_RxJava_pull_4026.diff
ReactiveX/RxJava,1.x: update doOnEach(Observer) javadoc,"Fixes the documentation problem reported in #3721.
",2016-06-17 20:39:20,2016-06-17 20:47:50,https://api.github.com/repos/ReactiveX/RxJava/issues/4024,['Documentation'],4,3,ReactiveX_RxJava_pull_4024.diff
ReactiveX/RxJava,1.x: fix timed replay() replaying old data for late subscribers,"In the current master, `replay` only trucates its buffer if an event is received. This means if a subscriber subscribes between two events, the operator may replay old events. This PR skips those events. The operator is now consistent with the recently updated `ReplaySubject`.

The old behavior was somewhat expected by a few unit tests that have been updated.

Related: #3917, #3918. 
",2016-06-17 20:17:12,2016-06-22 07:44:08,https://api.github.com/repos/ReactiveX/RxJava/issues/4023,['Bug'],69,5,ReactiveX_RxJava_pull_4023.diff
ReactiveX/RxJava,Improve unit test for `publish()`,,2016-06-17 18:48:24,2016-06-17 19:12:41,https://api.github.com/repos/ReactiveX/RxJava/issues/4021,['Test'],5,8,ReactiveX_RxJava_pull_4021.diff
ReactiveX/RxJava,1.x: add AsyncCompletableSubscriber that exposes unsubscribe(),"This PR adds a default, abstract base class with unsubscription support for `Completable`'s `CompletableSubscriber`.

Pros: direct, slim class

Cons: people probably used `subscriber(Action0)` or `subscribe(Subscriber)` so far.

Related: #4017 
",2016-06-17 18:17:39,2016-06-21 21:22:42,https://api.github.com/repos/ReactiveX/RxJava/issues/4020,['Enhancement'],226,0,ReactiveX_RxJava_pull_4020.diff
ReactiveX/RxJava,1.x: make the latest CompositeSubscription test more robust.,"Make sure there is enough time for the test and the latch is always counted down.

/cc @artem-zinnatullin 
",2016-06-17 16:31:38,2016-06-18 18:26:36,https://api.github.com/repos/ReactiveX/RxJava/issues/4019,['Test'],50,45,ReactiveX_RxJava_pull_4019.diff
ReactiveX/RxJava,1.x: Update Gradle to 2.14,"Release notes: https://docs.gradle.org/2.14/release-notes
",2016-06-17 14:39:34,2016-06-17 15:39:17,https://api.github.com/repos/ReactiveX/RxJava/issues/4018,['Build'],30,26,ReactiveX_RxJava_pull_4018.diff
ReactiveX/RxJava,Add specificity to documentation for AsyncSubject,"This documentation answers questions I had while reading it.
",2016-06-17 05:47:55,2016-06-17 09:02:28,https://api.github.com/repos/ReactiveX/RxJava/issues/4014,['Documentation'],4,2,ReactiveX_RxJava_pull_4014.diff
ReactiveX/RxJava,"1.x: Deprecate TestObserver, enhance TestSubscriber a bit","This PR deprecates `TestObserver` in favor of the richer `TestSubscriber`.

In addition, `TestSubscriber` gets 3 new methods and 1 deprecation:
- `getCompletions()` to return the onCompleted count as int instead of Notifications
- `getValueCount()` returns the committed number of onNext events for thread-safe checking of values up to this count
- `awaitValueCount` repeatedly sleeps up to a timeout and waits till the committed onNext count reaches/passes the expected amount.
",2016-06-16 14:57:47,2016-06-22 09:09:10,https://api.github.com/repos/ReactiveX/RxJava/issues/4011,"['Enhancement', 'Test']",302,116,ReactiveX_RxJava_pull_4011.diff
ReactiveX/RxJava,1.x: Release 1.1.6 CHANGES.md,"Release 1.1.6 CHANGES.md

:+1: for the full release.
",2016-06-15 21:48:25,2016-06-15 23:43:37,https://api.github.com/repos/ReactiveX/RxJava/issues/4008,['Information'],29,0,ReactiveX_RxJava_pull_4008.diff
ReactiveX/RxJava,1.x: new hook management proposal,"This PR adds a new, in-between, hook manager class, `RxJavaHooks` that allows runtime hooking of `Observable`, `Single`, `Completable` and `Schedulers` components and is aimed to be more versatile than the `RxJavaPlugins`.

Since `RxJavaPlugins` is public API, it can't be just removed, therefore, `RxJavaHooks` by default delegates to it but that delegation can be completely disabled via `clear()`.
#### Usage

Call the `setOn` methods with an appropriate function to manipulate the object being hooked:

``` java
RxJavaHooks.setOnComputationScheduler(s -> Schedulers.immediate());

RxJavaHooks.setObservableCreate(o -> { System.out.println(""Creating: "" + o); return o; });
```

You can also get the current hooks via the `getOn` methods, allowing chaining multiple hooks if necessary. Changing and retrieving the hooks are thread safe, although it is recommended you change them in quiet times.

Operator writers should usually not call the `onXXX` methods on `RxJavaHooks` except `RxJavaHooks.onError()`; It is useful when they have to signal a `Throwable` that can't be delivered to a `Subscriber`.

Calling `reset()` will restore the original delegation hooks.

This PR also features a way of tracking the assembly locations, that is where `Observable.create()` was invoked internally or externally, via `enableAssemblyTracking`. It changes the creation hooks of all 3 base types by adding an `OnSubscribeOnAssemblyX` wrapper. This operator will replace the Throwable flowing through `onError` and wraps it via the new `AssemblyStackTraceException`. 

Both the wrapper and the exception contain a string representation of the captured stacktrace, this helps ""printing"" out that information in a debugging session by simply viewing the field contents.

This tracking can be enabled at any time and affects sequences created afterwards. To stop the tracking, use `resetAssemblyTracking` to restore the default delegate callbacks to `RxJavaPlugins` or `clearAssemblyTracking` to restore the empty hooks (only affecting the `onCreate` hooks).

For frameworks, the `RxJavaHooks` can be locked down, preventing changing the hooks.

If you are using `RxJavaPlugins` existing features, you don't have to do anything; tests will work as before.
#### Performance impact

A default `RxJavaHooks` incurs a 2-4 level indirection in method calls. `onNext` calls are not affected.

A clear `RxJavaHooks` incurs a volatile read (very cheap) followed by a branch (predictable). `onNext` calls are not affected.

A tracking-enabled RxJavaHooks incurs an estimated 1000-3000 cycles overhead for each source creation and operator application. The `AssemblyStackTraceException` itself doesn't fill in its own stacktrace but takes only the captured stacktrace string and has mostly the cost of an object allocation. Due to the in-between nature of tracking, `onXXX` calls get through another indirection at each operator. For example, `range(1, 5).map(v -> v).filter(v -> true).subscribe()` will have 3 extra layers (one for each `.`). I believe these are acceptable overheads because the tracking feature is for tracking down crashes and not performance problems.
#### Discussion

Not all hook methods have been replicated completely on `RxJavaHooks`. For one, I wanted a minimal working prototype that passes existing tests. Second, those that are left out are not even tested (`onSubscribeError`, `onLift`). If the **concept** of this PR is accepted, those can be added along with their unit tests. Also further Javadoc will be added in the same case.

Names and structure are not set in stone.
",2016-06-14 14:22:17,2016-06-23 07:05:25,https://api.github.com/repos/ReactiveX/RxJava/issues/4007,"['Discussion', 'Enhancement']",1696,225,ReactiveX_RxJava_pull_4007.diff
ReactiveX/RxJava,1.x: fix Spsc queues reporting not empty but then poll() returns null,"In the spsc queues, the indexes were written before the actual elements and thus a concurrent `isEmpty` check would report a non-empty queue but a `poll` would still return `null`. The fix swaps the two writes.

Note that this an inconsistency in the original JCTools code and not the lack of keeping up with it.
",2016-06-13 10:55:47,2016-06-15 18:21:27,https://api.github.com/repos/ReactiveX/RxJava/issues/4005,['Bug'],43,16,ReactiveX_RxJava_pull_4005.diff
ReactiveX/RxJava,1.x: added distinctUntilChanged(comparator),"For some cases, `Observable.distinctUntilChanged(keySelector)` isn't enough. For example, when data consists of 2+ objects with ID, you cannot simply summarize them and use it as a key. Also often there are stream of arrays of data which can't be distincted easily and generically.
So I think `Observable.distinctUntilChanged(comparator)` would be helpful. I use kinda tricky implementation, but think, it is okey. Firstly I tried to add ctor to OperatorDistinctUntilChanged(), but it was... too bad.

**p.s.** I was really confused by 

> If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request (on a branch other than master, 1.x, 2.x, or gh-pages).

and spent some time trying to create some sort of temporal branch here (newbie me). But finally looked up into PRs and so that it is okey to PR into 1.x. Is it an error in .md-file?
",2016-06-09 15:32:06,2016-06-19 13:16:34,https://api.github.com/repos/ReactiveX/RxJava/issues/4001,['Feature-Request'],201,55,ReactiveX_RxJava_pull_4001.diff
ReactiveX/RxJava,1.x: fix reset() shutting down everything other than the schedulers,"The reset shut down all the main schedulers and the helper pools, causing the failure in #3993 .

@hzsweers, you were right with the need for the instance-shutdown method.
",2016-06-07 08:17:28,2016-06-07 23:06:52,https://api.github.com/repos/ReactiveX/RxJava/issues/3996,['Bug'],41,23,ReactiveX_RxJava_pull_3996.diff
ReactiveX/RxJava,Dummy commit,,2016-06-06 23:09:55,2016-06-06 23:10:00,https://api.github.com/repos/ReactiveX/RxJava/issues/3994,[],1,0,ReactiveX_RxJava_pull_3994.diff
ReactiveX/RxJava,Remove instance of Atomic*FieldUpdater,"Hi,

Based on the PR #3488 and the issue #3459 
I thought all the instance of Atomic*FieldUpdater has been removed and replaced.
",2016-06-06 03:45:56,2016-06-06 03:50:59,https://api.github.com/repos/ReactiveX/RxJava/issues/3991,[],2,4,ReactiveX_RxJava_pull_3991.diff
ReactiveX/RxJava,Add more time to certain tests that failed under heavy CI load,"Sometimes, the heavy Travis CI load (or throttling) makes a few tests fail with timeout. This increases the timeout for some of them to reduce the likelihood.
",2016-06-03 10:42:27,2016-06-03 10:49:11,https://api.github.com/repos/ReactiveX/RxJava/issues/3987,['Test-Failures'],4,4,ReactiveX_RxJava_pull_3987.diff
ReactiveX/RxJava,Add Schedulers.reset() for better testing,"Resolves #3985

This adds a `reset()` method to `Schedulers`, with the main benefit being improved testing support. This does slightly tweak the internal API of `Schedulers` to use a `getInstance()` approach to allow lazy init. This way we don't have to replace the singleton instance during `reset()` and allow it to lazily re-evaluate upon next usage. Otherwise, if you change your scheduler hook, you'd always have to make sure you set it before you call `Schedulers.reset()`.

Will run perf tests overnight in case, I'm not sure how much of a tradeoff moving to an internal `getInstance()` approach costs, if anything.

CC @zsxwing
",2016-06-03 05:55:13,2016-06-06 21:41:21,https://api.github.com/repos/ReactiveX/RxJava/issues/3986,['Enhancement'],91,11,ReactiveX_RxJava_pull_3986.diff
ReactiveX/RxJava,1.x: benchmark just and Single,"This PR adds a comparison benchmark for working with `Observable.just` and `Single.just`.

Results: (i7 4790, Win 7 x64, Java 8u92)

![image](https://cloud.githubusercontent.com/assets/1269832/15705865/476ebcd2-27f1-11e6-8468-4cd02962f31a.png)
- `one`: custom Observable emitting a single item with backpressure
- `scalar`: `Observable.just(1)`
- `scalarHidden`: `just(1).asObservable()`
- `single`: `Single.just(1)`
- `singleHidden`: wrapping with `Single.create`
- `plain`: just subscribe
- `Concat`: use `concatMap` to map it to a scalar (operator not available in Single)
- `Merge` : use `flatMap` to map it to a scalar/singe
- `Switch` : use `switchMap` to map it to a scalar (operator not available in Single)

My guess is that single is slower because that `Observable.OnSubscribe` vs `Single.OnSubscribe` wrapping game.
",2016-06-01 10:13:18,2016-06-01 11:02:27,https://api.github.com/repos/ReactiveX/RxJava/issues/3982,['Performance'],341,0,ReactiveX_RxJava_pull_3982.diff
ReactiveX/RxJava,1.x: document zip() eagerness,"See #3960 and #3124.
",2016-06-01 08:30:18,2016-06-02 06:17:26,https://api.github.com/repos/ReactiveX/RxJava/issues/3981,['Documentation'],189,8,ReactiveX_RxJava_pull_3981.diff
ReactiveX/RxJava,2.x: Design.md +extension +fusion,"Added sections from #3935.
",2016-06-01 07:45:13,2016-06-17 08:29:01,https://api.github.com/repos/ReactiveX/RxJava/issues/3980,['Documentation'],242,8,ReactiveX_RxJava_pull_3980.diff
ReactiveX/RxJava,1.x: remove remaining field updaters,"This PR removes the remaining `AtomicXFieldUpdater`s from the library because reflection is somewhat problematic on Android.

This also deprecates the internal `BackpressureUtils.getAndAddRequest` to indicate `requested` field updater should not be used anymore.
",2016-06-01 07:32:12,2016-06-01 19:08:25,https://api.github.com/repos/ReactiveX/RxJava/issues/3979,['Cleanup'],90,121,ReactiveX_RxJava_pull_3979.diff
ReactiveX/RxJava,1.x: Use the correct Throwable to set the cause for CompositeException,"The cause of #3679 is we use a wrong Throwable (its cause has been set) to set the cause and `initCause` will throw an exception. Hence, the cause chain is not created correctly. In this PR, it searches the root cause (which doesn't have a cause) and use it to call `initCause`.
",2016-06-01 03:15:53,2016-06-01 23:17:38,https://api.github.com/repos/ReactiveX/RxJava/issues/3977,['Bug'],62,4,ReactiveX_RxJava_pull_3977.diff
ReactiveX/RxJava,1.x: lift into Subject,"See #2458.

This PR shows a way to implement lifting into a Subject. It is possible to lift on the front and the back side. The main idea is to add behavior to a Subject while presenting it to the outside world still as a Subject.

I'm not 100% certain the value of this because one has to write operators for this to work (relying on the `rx.internal.operators` is not recommended). The front-side operator can be simpler since it doesn't have to deal with unsubscription and backpressure as the wrapped Subjects don't have that capability on their front anyway.
",2016-05-31 15:21:22,2016-06-14 08:17:06,https://api.github.com/repos/ReactiveX/RxJava/issues/3975,['Enhancement'],400,0,ReactiveX_RxJava_pull_3975.diff
ReactiveX/RxJava,1.x: add terminal clarification to switchMap operators,"See #3576 .
",2016-05-31 13:41:28,2016-06-01 03:52:37,https://api.github.com/repos/ReactiveX/RxJava/issues/3974,['Documentation'],14,0,ReactiveX_RxJava_pull_3974.diff
ReactiveX/RxJava,1.x: request rebatch operator,"This is a follow-up on #3964 but with a separate operator on `Observable`.
",2016-05-31 08:39:59,2016-06-01 21:53:27,https://api.github.com/repos/ReactiveX/RxJava/issues/3971,['Enhancement'],71,0,ReactiveX_RxJava_pull_3971.diff
ReactiveX/RxJava,1.x fix long-chained xWith() operator stack overflow,"This PR fixes the case when operators of pattern `xWith` chained into a long sequence causes `StackOverflowError` because the subscription call-stack gets deep.

Operators affected and fixes:
- `Observable.ambWith()`
- `Observable.mergeWith()`
- `Observable.concatWith()`
- `Observable.startWith()`
- `Observable.zipWith()`
- `Completable.ambWith()`
- `Completable.mergeWith()`
- `Completable.concatWith()`
- `Completable.startWith()`
- `Single.zipWith()`

The PR contains some tidy-up of existing functionality and introducing short operators that delegate to the ""big"" operators for the purpose of identification.
",2016-05-27 12:13:43,2016-05-31 08:15:30,https://api.github.com/repos/ReactiveX/RxJava/issues/3969,['Bug'],784,114,ReactiveX_RxJava_pull_3969.diff
ReactiveX/RxJava,1.x: add multi-other withLatestFrom operators,"Add `withLatestFrom` operator version that can take 2 to N other sources and combine them with the main source.

Related: #3779.
",2016-05-26 09:07:46,2016-06-16 21:57:17,https://api.github.com/repos/ReactiveX/RxJava/issues/3966,['Enhancement'],903,3,ReactiveX_RxJava_pull_3966.diff
ReactiveX/RxJava,1.x: add optional tracking of worker creation sites + report it on error,"This is an alternative to #3937 to capture worker creation sites for `computation`, `io` and `newThread` schedulers.
",2016-05-25 22:58:35,2016-05-31 08:16:04,https://api.github.com/repos/ReactiveX/RxJava/issues/3965,['Enhancement'],444,143,ReactiveX_RxJava_pull_3965.diff
ReactiveX/RxJava,1.x: observeOn + immediate scheduler to be a request rebatcher,"This PR removes the `immediate()` scheduler ""optimization"" from `observeOn` and treats it as a common scheduler. Since `observeOn` has a stable request pattern, this turns it into a rebatching operator. No matter what the downstream requests, the upstream will requests of the specified size (with 25% as low water mark; i.e., replenishment after 75%). Since `immediate` is synchronous, this will run the drain loop, non-reentrant, on the caller thread.

I found this mode of operation very handy in my Reactive-RPC prototype and a simple streaming echo RPC call; it prevents going unbounded and bloating the message sender threads:

``` java
// remote
public Observable<Integer> echo(RpcStreamContext<?> ctx, Observable<Integer> in) {
   return in.observeOn(Schedulers.immediate(), 16);
}

// client
api.echo(Observable.range(1, 100_000)).observeOn(Schedulers.immediate(), 32)
.subscribe(System.out::println, Throwable::printStackTrace);
```
",2016-05-25 20:46:37,2016-05-31 08:15:45,https://api.github.com/repos/ReactiveX/RxJava/issues/3964,['Enhancement'],25,5,ReactiveX_RxJava_pull_3964.diff
ReactiveX/RxJava,Composite exception should update cause to match the correct throwable that's first in the chain,"Fixes https://github.com/ReactiveX/RxJava/issues/3679 
",2016-05-25 19:54:19,2016-06-01 13:46:58,https://api.github.com/repos/ReactiveX/RxJava/issues/3963,['Bug'],19,1,ReactiveX_RxJava_pull_3963.diff
ReactiveX/RxJava,1.x: scan with an initial factory callback,"This PR adds an overload to `scan` which allows specifying an initial value factory. The initial value factory is invoked for each incoming Subscriber individually and provides a non-shared starting point for the `scan` operation.

I propose the `scan(Func2 accumulator, Func0 initialFactory)` parameter order because some Java 8+ compilers can't properly disambiguate with `scan(R initialValue, Func2 accumulator)`, thinking that R can be made `Func0`. 

Related: #3667
",2016-05-21 09:35:17,2016-06-22 09:09:58,https://api.github.com/repos/ReactiveX/RxJava/issues/3959,['Enhancement'],98,0,ReactiveX_RxJava_pull_3959.diff
ReactiveX/RxJava,1.x: just() construction to call the onCreate execution hook,"This PR adds the call to `RxJavaObservableExecutionHook.onCreate()` to the `just()` - `ScalarSynchronousObservable` construction.

Related: #2656.
",2016-05-21 08:55:34,2016-05-23 23:15:32,https://api.github.com/repos/ReactiveX/RxJava/issues/3958,['Bug'],92,10,ReactiveX_RxJava_pull_3958.diff
ReactiveX/RxJava,"1.x: javac- and javadoc-related cleanup in components, part 2","Next round of cleanup, still about 100 cases remain in `Completable` and `Observable`, but those will most likely conflict with open PRs.
",2016-05-18 22:04:18,2016-05-24 20:40:35,https://api.github.com/repos/ReactiveX/RxJava/issues/3951,['Cleanup'],289,56,ReactiveX_RxJava_pull_3951.diff
ReactiveX/RxJava,"1.x: javac- and javadoc-related cleanup in components, part 2 final","This PR clears the cast warnings introduced by the need to be JDK 9 compilable.
",2016-05-18 20:32:38,2016-05-18 21:03:42,https://api.github.com/repos/ReactiveX/RxJava/issues/3950,['Cleanup'],46,8,ReactiveX_RxJava_pull_3950.diff
ReactiveX/RxJava,"1.x: javac- and javadoc-related cleanup in components, part 1","My Eclipse warned me about several hundred javac and javadoc errors which could hide other significant warnings. This PR is the first part to fix those warnings. Note that `Observable` and `Single` itself is full of those as well (several hundred in each).
",2016-05-18 12:00:33,2016-05-18 20:16:13,https://api.github.com/repos/ReactiveX/RxJava/issues/3949,['Cleanup'],532,89,ReactiveX_RxJava_pull_3949.diff
ReactiveX/RxJava,"Add Completable.andThen(Completable), deprecate endWith()","See #3947 
",2016-05-18 09:47:23,2016-05-23 23:37:46,https://api.github.com/repos/ReactiveX/RxJava/issues/3948,['Cleanup'],31,15,ReactiveX_RxJava_pull_3948.diff
ReactiveX/RxJava,fix exception message from observer to subscriber,,2016-05-16 12:19:08,2016-05-17 22:06:02,https://api.github.com/repos/ReactiveX/RxJava/issues/3944,['Cleanup'],1,1,ReactiveX_RxJava_pull_3944.diff
ReactiveX/RxJava,Update branches names in CONTRIBUTING:md,,2016-05-15 22:25:05,2016-05-18 22:32:56,https://api.github.com/repos/ReactiveX/RxJava/issues/3943,['Documentation'],1,1,ReactiveX_RxJava_pull_3943.diff
ReactiveX/RxJava,1.x: add Completable.safeSubscribe option + RxJavaPlugins hook support,"Add option to safely subscribe a `CompletableSubscriber` / regular `Subscriber` and handle `onXXX` failures.

See also: #3938

Naming and whether or not the safe wrapping should be the default is open to discussion.
",2016-05-14 08:10:57,2016-06-01 17:06:52,https://api.github.com/repos/ReactiveX/RxJava/issues/3942,['Enhancement'],685,109,ReactiveX_RxJava_pull_3942.diff
ReactiveX/RxJava,1.x: fix Single.flatMap not composing subscription through,"See #3940.
",2016-05-14 07:30:11,2016-05-17 19:57:36,https://api.github.com/repos/ReactiveX/RxJava/issues/3941,['Bug'],44,2,ReactiveX_RxJava_pull_3941.diff
ReactiveX/RxJava,1.x: Add missing error handler call in Completable,,2016-05-13 18:21:46,2016-05-14 22:44:04,https://api.github.com/repos/ReactiveX/RxJava/issues/3938,['Discussion'],54,0,ReactiveX_RxJava_pull_3938.diff
ReactiveX/RxJava,1.x: Change the workers to capture the stack trace,"Watched @dlew presentation of the pit falls of debugging RxJava https://www.youtube.com/watch?v=QdmkXL7XikQ&feature=youtu.be&t=38m12s

This change is to create an exception when a thread based `Scheduler.Worker` is constructed and reused it for all subsequent scheduled actions to increase the readability of uncaught and fatal exceptions that bubble up to the schedulers but spread the cost out across many scheduled actions.

A future improvement to spread the cost out even more, that I didn't want to do in the first attempt, would to create the exception when `Scheduler.io()` is called and reuse the exception across multiple `Worker`s.

The example from the presentation

```
import rx.Observable;
import rx.schedulers.Schedulers;

public class Main {
    public static void main(String[] args) throws InterruptedException {
        Observable.empty()
                .first()
                .subscribeOn(Schedulers.io())
                .subscribe();

        Thread.sleep(100);
    }
}
```

Used to print this just this exception with no mention the Main class.

```
Exception in thread ""RxIoScheduler-2"" java.lang.IllegalStateException: Exception thrown on Scheduler.Worker thread. Add `onError` handling.
    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:65)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
Caused by: rx.exceptions.OnErrorNotImplementedException: Sequence contains no elements
    at rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call(InternalObservableUtils.java:374)
    at rx.internal.util.InternalObservableUtils$ErrorNotImplementedAction.call(InternalObservableUtils.java:1)
    at rx.internal.util.ActionSubscriber.onError(ActionSubscriber.java:44)
    at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:157)
    at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:120)
    at rx.internal.operators.OperatorSubscribeOn$1$1.onError(OperatorSubscribeOn.java:59)
    at rx.internal.operators.OperatorSingle$ParentSubscriber.onCompleted(OperatorSingle.java:116)
    at rx.internal.operators.OperatorTake$1.onCompleted(OperatorTake.java:56)
    at rx.internal.operators.EmptyObservableHolder.call(EmptyObservableHolder.java:44)
    at rx.internal.operators.EmptyObservableHolder.call(EmptyObservableHolder.java:1)
    at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:50)
    at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:1)
    at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:50)
    at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:1)
    at rx.Observable.unsafeSubscribe(Observable.java:8460)
    at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94)
    at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker$1.call(CachedThreadScheduler.java:222)
    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:60)
    ... 7 more
Caused by: java.util.NoSuchElementException: Sequence contains no elements
    ... 19 more
```

But will now print the exception above but with an additional caused by

```
Caused by: rx.internal.schedulers.SchedulerContextException: Asynchronous work scheduled at
    at rx.internal.schedulers.NewThreadWorker.<init>(NewThreadWorker.java:36)
    at rx.internal.schedulers.CachedThreadScheduler$ThreadWorker.<init>(CachedThreadScheduler.java:235)
    at rx.internal.schedulers.CachedThreadScheduler$CachedWorkerPool.get(CachedThreadScheduler.java:86)
    at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker.<init>(CachedThreadScheduler.java:187)
    at rx.internal.schedulers.CachedThreadScheduler.createWorker(CachedThreadScheduler.java:173)
    at rx.internal.operators.OperatorSubscribeOn.call(OperatorSubscribeOn.java:42)
    at rx.internal.operators.OperatorSubscribeOn.call(OperatorSubscribeOn.java:1)
    at rx.Observable.subscribe(Observable.java:8553)
    at rx.Observable.subscribe(Observable.java:8520)
    at rx.Observable.subscribe(Observable.java:8316)
    at rx.schedulers.Main.main(Main.java:10)
```
",2016-05-13 17:49:01,2016-06-22 13:34:53,https://api.github.com/repos/ReactiveX/RxJava/issues/3937,['Enhancement'],119,9,ReactiveX_RxJava_pull_3937.diff
ReactiveX/RxJava,1.x: promote UnicastSubject to be a standard+experimental Subject,"Plus, the unsubscribe indirection has been inlined, making `State` implement `Subscription` directly (instead of `Action0` + `Subscriptions.create`).
",2016-05-13 09:56:06,2016-06-01 21:54:18,https://api.github.com/repos/ReactiveX/RxJava/issues/3936,['API promotion'],21,11,ReactiveX_RxJava_pull_3936.diff
ReactiveX/RxJava,Clean-up of the 2.x Design.md document,"I went through all the pending comments that weren't addressed.
",2016-05-12 21:04:30,2016-06-01 07:37:08,https://api.github.com/repos/ReactiveX/RxJava/issues/3935,"['Discussion', 'Documentation']",21,40,ReactiveX_RxJava_pull_3935.diff
ReactiveX/RxJava,1.x: TestSubscriber extra info on assertion failures,"This PR adds extra information to assertion failure messages on `TestSubscriber` and `TestObserver`, indicating:
- the listener didn't receive any `onCompleted` calls, which is an indication of hung or skipping operation,
- there were errors received, indicating a failure in the event generation process.

Previously, if there was something wrong with the sequence, the order and type of assertions were mostly unhelpful: if `assertValues` was first, the lack of values failure could hide a revealing onError call. If the `assertNoErrors()` was first, the error is visible but no way of knowing how far the sequence got.

Now, it is generally okay to use `assertValues` first, which along the difference, will print the lack of completion and the number of exceptions received, plus, the `AssertionError` will have its cause initialized to the actual or composited exception. The message format thus changes:

```
original assertion message with details (0 completions) (+1 error)
...
caused by
...
```

This extra information saved me a lot of time in 2.x and Rsc development.

Note that this change doesn't make the `assertXXX`s also assert for completion or error at all. If the values match, but there is an additional error instead of completion, one has to assert that separately, just like now.
",2016-05-12 20:38:54,2016-05-23 23:20:20,https://api.github.com/repos/ReactiveX/RxJava/issues/3934,"['Enhancement', 'Test']",165,25,ReactiveX_RxJava_pull_3934.diff
ReactiveX/RxJava,1.x: add groupBy overload with evictingMapFactory,"I have a long running stream using `groupBy` that over time will accumulate 10s of millions of keys. If I can specify an evicting map to `groupBy` then I'll be able to keep it down to ~10,000 keys. 

This PR supports this use case and could be used with Guava's `CacheBuilder` like this:

``` java
Func1<Action1<K>, Map<K, Object>> mapFactory = 
    action -> CacheBuilder.newBuilder()
              .maximumSize(1000)
              .expireAfterAccess(12, TimeUnit.HOUR)
              .removalListener(key -> action.call(key))
              .<K, Object> build().asMap();
observable
    .groupBy(keySelector, elementSelector, mapFactory)
    ...
```

I'll enhance this PR with more unit tests if this looks a good direction.
",2016-05-12 07:39:20,2016-06-25 09:46:50,https://api.github.com/repos/ReactiveX/RxJava/issues/3931,['Feature-Request'],344,10,ReactiveX_RxJava_pull_3931.diff
ReactiveX/RxJava,Update RxJava Javadoc to  1.1.5,"Closes #3925
",2016-05-11 03:40:35,2016-05-11 17:19:10,https://api.github.com/repos/ReactiveX/RxJava/issues/3928,['Documentation'],62670,886,ReactiveX_RxJava_pull_3928.diff
ReactiveX/RxJava,1.x: fix RxRingBuffer-pool depending on the computation scheduler,"This PR fixed the `ObjectPool` dependency on the `Schedulers.computation()` which can be replaced via plugin hooks causing unexpected and long sleeps (i.e., when `computation()` is replaced by `immediate()`).

See #3923.

I'd also consider removing the `RxRingBuffer` entirely.
",2016-05-09 21:01:40,2016-05-10 19:51:02,https://api.github.com/repos/ReactiveX/RxJava/issues/3924,['Bug'],41,31,ReactiveX_RxJava_pull_3924.diff
ReactiveX/RxJava,1.x: fix using() resource cleanup when factory throws or being non-eager,"The operator `using` didn't call the resource cleanup code if the `observableFactory.call()` code crashed. In addition, a non-eager using didn't call the resource cleanup if one subscribed with `unsafeSubscribe` or the subscription to the generated `Observable` crashed.

Related: #3921 
",2016-05-09 14:01:55,2016-05-10 21:23:57,https://api.github.com/repos/ReactiveX/RxJava/issues/3922,['Bug'],116,37,ReactiveX_RxJava_pull_3922.diff
ReactiveX/RxJava,"1.x: Subscriber.NOT_SET Long -> long, saves an unboxing per instance","Somehow, Subscriber.NOT_SET was object `Long` instead of primitive `long`.
",2016-05-09 06:45:43,2016-05-10 19:51:29,https://api.github.com/repos/ReactiveX/RxJava/issues/3919,['Cleanup'],1,1,ReactiveX_RxJava_pull_3919.diff
ReactiveX/RxJava,1.x: ReplaySubject now supports backpressure,"In addition, the behavior of time-limited mode has been changed. Late subscribers will now skip stale data.

Related issue: #3917
",2016-05-08 19:37:09,2016-06-15 21:53:14,https://api.github.com/repos/ReactiveX/RxJava/issues/3918,['Enhancement'],1066,875,ReactiveX_RxJava_pull_3918.diff
ReactiveX/RxJava,Release 1.1.5 CHANGES.md update,"Emergency release.
",2016-05-05 19:39:53,2016-05-05 20:04:52,https://api.github.com/repos/ReactiveX/RxJava/issues/3913,['Information'],6,0,ReactiveX_RxJava_pull_3913.diff
ReactiveX/RxJava,1.x: fix filter() default-requesting and thus going unbounded,"Forgot that `Subscriber` defaults to requesting `Long.MAX_VALUE` unless suppressed and apparently there was no verification of filter's backpressure behavior; the two existing tests didn't really check for the delivery pattern.
",2016-05-05 18:51:54,2016-05-05 19:29:46,https://api.github.com/repos/ReactiveX/RxJava/issues/3912,['Bug'],18,3,ReactiveX_RxJava_pull_3912.diff
ReactiveX/RxJava,1.x: Single.retryWhen javadoc clarifications,"See #3774
",2016-05-05 09:58:19,2016-05-05 19:31:16,https://api.github.com/repos/ReactiveX/RxJava/issues/3909,['Documentation'],22,4,ReactiveX_RxJava_pull_3909.diff
ReactiveX/RxJava,1.x: DoOnUnsubscribe javadoc clarifications,"See #3877
",2016-05-05 09:40:35,2016-05-05 19:31:31,https://api.github.com/repos/ReactiveX/RxJava/issues/3907,['Documentation'],12,4,ReactiveX_RxJava_pull_3907.diff
ReactiveX/RxJava,1.x: Release 1.1.4 CHANGES.md update,"Release 1.1.4 CHANGES.md update.

:+1: for the release.
",2016-05-03 20:31:37,2016-05-04 18:30:43,https://api.github.com/repos/ReactiveX/RxJava/issues/3906,['Information'],34,0,ReactiveX_RxJava_pull_3906.diff
ReactiveX/RxJava,1.x: fix singleOrDefault() backpressure if source is empty,"Issue #3892 is a goldmine for missing backpressure problems. This PR fixes the case when `singleOrDefault` encounters an empty source and has to emit some default value. Fixed via setting the `SingleProducer` on the child on termination.
",2016-05-02 17:05:26,2016-05-02 22:50:48,https://api.github.com/repos/ReactiveX/RxJava/issues/3905,['Bug'],31,25,ReactiveX_RxJava_pull_3905.diff
ReactiveX/RxJava,1.x: Fix Completable swallows OnErrorNotImplementedException,"Fixed https://github.com/ReactiveX/RxJava/issues/3860
",2016-05-01 21:27:53,2016-05-02 07:08:42,https://api.github.com/repos/ReactiveX/RxJava/issues/3904,['Bug'],25,0,ReactiveX_RxJava_pull_3904.diff
ReactiveX/RxJava,Spare a few redundant calls in SleepingAction around determining the …,"…delay value
- Remove redundant outer conditional.
- Skip calling into System.currentTimeMillis(), which could potentially result in different values.
",2016-05-01 18:51:13,2016-05-02 05:25:29,https://api.github.com/repos/ReactiveX/RxJava/issues/3903,['Cleanup'],8,9,ReactiveX_RxJava_pull_3903.diff
ReactiveX/RxJava,Small code style consistency fix for WeakSingleProducer,"Handling the case of 0 requests with the same code style as SingleDelayedProducer and SingleProducer.
",2016-04-29 22:40:39,2016-05-02 17:03:38,https://api.github.com/repos/ReactiveX/RxJava/issues/3901,['Cleanup'],19,18,ReactiveX_RxJava_pull_3901.diff
ReactiveX/RxJava,AssertionError should be treated as fatal,"Many test frameworks throw an `AssertionError` to indicate a failure.  For example, mock objects created using EasyMock will throw an `AssertionError` immediately if the mock receives an unexpected method call.  When using `onErrorResumeNext()`, this error may be silently swallowed.  And since this type of exception is not a part of normal program flow (it is only used in tests), it should not be up to the application to handle these errors specifically.

According to the Java documentation on throwables, I would actually expect RxJava to treat all `Error` subclasses as fatal, but perhaps there are other reasons not to do so.  My first thought was to register a global error handling plugin which would rethrow `AssertionError`s, but `onErrorResumeNext()` prevents the error from reaching the plugin.  
",2016-04-29 21:20:42,2016-05-25 21:11:10,https://api.github.com/repos/ReactiveX/RxJava/issues/3899,['Feature-Request'],26,2,ReactiveX_RxJava_pull_3899.diff
ReactiveX/RxJava,1.x: Add missing license headers,"This PR simply adds missing license header to main and test files.
",2016-04-29 18:54:02,2016-04-29 19:36:23,https://api.github.com/repos/ReactiveX/RxJava/issues/3898,['Cleanup'],368,15,ReactiveX_RxJava_pull_3898.diff
ReactiveX/RxJava,1.x: Give more time to OperatorSwitchTest.switchAsyncHeavily,"`OperatorSwitchTest.switchAsyncHeavily` sometimes times out. Could be due to Travis or an actual bug which doesn't deliver the last few elements.
",2016-04-29 18:32:58,2016-04-29 18:40:50,https://api.github.com/repos/ReactiveX/RxJava/issues/3897,['Test-Failures'],5,2,ReactiveX_RxJava_pull_3897.diff
ReactiveX/RxJava,1.x: OperatorMapPair should unsubscribe on crash eagerly,"Found another one.
",2016-04-28 20:27:06,2016-04-29 20:42:32,https://api.github.com/repos/ReactiveX/RxJava/issues/3896,['Bug'],117,28,ReactiveX_RxJava_pull_3896.diff
ReactiveX/RxJava,1.x: cast() should unsubscribe on crash eagerly,"Similar issue as in #3890.
",2016-04-28 19:57:36,2016-04-29 20:42:49,https://api.github.com/repos/ReactiveX/RxJava/issues/3895,['Bug'],79,25,ReactiveX_RxJava_pull_3895.diff
ReactiveX/RxJava,1.x: enable backpressure with from(Future).,"The `from(Future)` operator was not refitted for backpressure.

Reported in: #3892.
",2016-04-28 17:30:34,2016-04-29 21:43:53,https://api.github.com/repos/ReactiveX/RxJava/issues/3893,['Bug'],32,19,ReactiveX_RxJava_pull_3893.diff
ReactiveX/RxJava,1.x: map() and filter() should unsubscribe on crash eagerly,"In current master, when the function in `map` or `filter` crashes, the error is propagated but the upstream is not immediately unsubscribed but expected to happen eventually due to some other operator or `SafeSubscriber`.

The fix, and also the restructuring of the unsubscription chain, makes sure the crash also unsubscribes immediately (unless a fatal one).

Related: [StackOverflow question](http://stackoverflow.com/questions/35343474/why-does-it-need-onbackpressure-here-for-click-events)
",2016-04-28 12:25:36,2016-04-29 20:44:33,https://api.github.com/repos/ReactiveX/RxJava/issues/3890,['Bug'],179,60,ReactiveX_RxJava_pull_3890.diff
ReactiveX/RxJava,1.x: proposal: onTerminateDetach - detach upstream/downstream for GC,"By default, operators have final link to their child Subscriber and they never clear the upstream's Producer. If the end subscriber is referenced, for example in a `CompositeSubscription`, that keeps an entire chain of objects alive and can cause memory leaks (a use case common on Android).

This proposed operator detaches the structures and nulls out references if the sequence terminates or the downstream unsubscribes - at the cost of atomic operations and mandatory volatile read for each onNext(). 

I know this issue has been brought up several times, but instead of adding the overhead to every operator, I propose an operator that can be applied when the developer really needs it (i.e., could be part of the usual compose(subscribeOn/observeOn) setup).

On the implementation side, this requires deferred `Producer`/`request()` handling because requests from downstream may appear even before the upstream calls `setProducer` (if at all) and we can't use the base class' behavior for this.
",2016-04-27 20:50:58,2016-05-03 20:12:02,https://api.github.com/repos/ReactiveX/RxJava/issues/3888,['Enhancement'],350,0,ReactiveX_RxJava_pull_3888.diff
ReactiveX/RxJava,Have undeliverable errors on subscribe() sent to plugin error handler.,"This change will make sure if the `Subscriber` has unsubscribed, the non-fatal error is sent to the plugin error handler at least. I.e.,

``` java
Observable.create(s -> {
    s.onError(new RuntimeException());
    throw new IllegalArgumentException();
}).subscribe();
```

In addition, if the original code threw `RuntimeException` in case the `subscriber.onError()` threw. I've changed this to `OnErrorFailedException` but not sure the original type was intentional or just left out.
",2016-04-27 14:10:12,2016-04-29 18:14:36,https://api.github.com/repos/ReactiveX/RxJava/issues/3887,['Cleanup'],17,12,ReactiveX_RxJava_pull_3887.diff
ReactiveX/RxJava,throwIfFatal() now throws OnCompletedFailedException,"Otherwise, if there's an error in onCompleted, the exception is
swallowed and unreported.

Fixes #3885
",2016-04-27 14:06:23,2016-04-29 05:56:57,https://api.github.com/repos/ReactiveX/RxJava/issues/3886,['Bug'],25,0,ReactiveX_RxJava_pull_3886.diff
ReactiveX/RxJava,1.x: fix multiple chained Single.doAfterTerminate not calling actions,"Resolves #3881.

The bug is caused by the impedance mismatch between `Observable`'s `Subscriber` and `Single`'s `SingleSubscriber`. The original code called `onNext()` which immediately signalled an `onSuccess` but also caused an unsubscription, preventing a delivery of `onCompleted()` in the inner Single.

The fix keeps `onSuccess`/`onError` rails intact  throughout the chain.
",2016-04-27 09:42:51,2016-04-29 21:43:36,https://api.github.com/repos/ReactiveX/RxJava/issues/3883,['Bug'],184,1,ReactiveX_RxJava_pull_3883.diff
ReactiveX/RxJava,1.x: TestSubscriber/TestObserver print values if number of items doesn't match,"Otherwise you have to manually print/debug values if test failed.
",2016-04-25 11:24:26,2016-04-29 17:46:47,https://api.github.com/repos/ReactiveX/RxJava/issues/3880,"['Enhancement', 'Test']",28,2,ReactiveX_RxJava_pull_3880.diff
ReactiveX/RxJava,Expose scheduler factories which accept thread factories.,"This allows hooks to create schedulers whose threads have different priorities.

Closes #3724.
",2016-04-22 22:01:41,2016-04-29 18:13:19,https://api.github.com/repos/ReactiveX/RxJava/issues/3879,['Enhancement'],218,40,ReactiveX_RxJava_pull_3879.diff
ReactiveX/RxJava,remove unused field baseCapacity from onBackpressureBuffer,"as per title
",2016-04-22 06:37:55,2016-04-22 22:45:05,https://api.github.com/repos/ReactiveX/RxJava/issues/3874,['Cleanup'],0,2,ReactiveX_RxJava_pull_3874.diff
ReactiveX/RxJava,Deprecate remaining public scheduler types.,"A continuation of some work done in #3856 of removing uninstantiable types from the public API (via deprecation).
",2016-04-20 18:48:15,2016-04-21 07:06:35,https://api.github.com/repos/ReactiveX/RxJava/issues/3871,['Cleanup'],316,252,ReactiveX_RxJava_pull_3871.diff
ReactiveX/RxJava,Fix an unsubscribe race in EventLoopWorker,"There is an unsubscribe race condition similar to #3842 in `CachedThreadScheduler.EventLoopWorker` and `EventLoopsScheduler.EventLoopWorker`. Image the following execution order:

| Execution Order | thread 1 | thread 2 |
| --- | --- | --- |
| 1 |  | submit task A |
| 2 |  | submit task B |
| 3 | unsubscribe Worker |  |
| 4 | unsubscribe task A |  |
| 5 |  | task A won't run as it's unsubscribed |
| 6 |  | run task B |
| 7 | unsubscribe task B |  |

So task B will run but its previous task A will be skipped.

This PR adds a check before running an action and moves `workerUnderConcurrentUnsubscribeShouldNotAllowLaterTasksToRunDueToUnsubscriptionRace` to `AbstractSchedulerConcurrencyTests` to test all concurrent schedulers.
",2016-04-20 05:09:26,2016-04-20 17:03:05,https://api.github.com/repos/ReactiveX/RxJava/issues/3868,['Cleanup'],63,37,ReactiveX_RxJava_pull_3868.diff
ReactiveX/RxJava,1.x: improve ExecutorScheduler worker unsubscription some more,"As per discussion in #3842, there was an outstanding possibility that unsubscription of a `Worker` would not cancel all tasks waiting in the queue. This PR addresses that possibility. I attempted to provoke the condition in a unit test but didn't manage it. Nethertheless I think this change completes the protection desired in #3842.

I do have mixed feelings about the possible double calling of `queue.clear()` (once in the `run()` method and once in the `unsubscribe()` method. Any preferences?
",2016-04-19 08:23:41,2016-04-20 17:15:37,https://api.github.com/repos/ReactiveX/RxJava/issues/3867,['Cleanup'],6,3,ReactiveX_RxJava_pull_3867.diff
ReactiveX/RxJava,1.x: Add Single.toCompletable(),"Closes #3865.
",2016-04-18 16:01:49,2016-04-19 06:18:23,https://api.github.com/repos/ReactiveX/RxJava/issues/3866,['Enhancement'],48,0,ReactiveX_RxJava_pull_3866.diff
ReactiveX/RxJava,1.x: optimize concatMapIterable/flatMapIterable,"This PR reduces the overhead of `concatMapIterable`/`flatMapIterable` by not wrapping them into `Observable.from` sources but handling the generated `Iterable`s directly.

Since `Iterable`s are inherently synchronous, there is no difference between the two operators that now use the common underlying operator (i.e., flatMap can't chose a different source because it can't tell if an `Iterable` source is not ready or not; `hasNext()` is for indicating completion, not temporary lack of data).

Benchmark (i7 4790, Window 7 x64, Java 8u77):

![image](https://cloud.githubusercontent.com/assets/1269832/14599483/e3c72978-0557-11e6-8a3e-833381399646.png)

`Iterable-M` is the current master, `Plain` is using `concatMap(Observable::from)` as a reference.

The `count=1` cases are bit slower because there is no good way of detecting if an `Iterable` holds only a single element, unlike with `just()`, and have to instantiate the full infrastructure even for a single element.

The same table using the master as baseline:

![image](https://cloud.githubusercontent.com/assets/1269832/14599552/5258f7e0-0558-11e6-8d1d-4eacca60805b.png)
",2016-04-18 09:26:46,2016-05-03 20:18:49,https://api.github.com/repos/ReactiveX/RxJava/issues/3864,['Performance'],838,4,ReactiveX_RxJava_pull_3864.diff
ReactiveX/RxJava,1.x: fix from(Iterable) error handling of Iterable/Iterator,"The `from(Iterable)` ignored non-fatal exceptions thrown by the `Iterable` and `Iterator`.

Apart from wrapping the calls into `try-catch`, the overal emission algorithm has been changed:
- It calls `hasNext` only once for each available value. Since the subscribe() checks for an outright empty `Iterable`, the drain loop runs only if it wasn't empty and does another `hasNext` check immediately to complete immediately if possible.
- It uses what I call a fast-flow algorithm to avoid decrementing the requested amount (this) if there were more requests issued during the emission.
",2016-04-17 00:31:52,2016-04-21 19:58:08,https://api.github.com/repos/ReactiveX/RxJava/issues/3862,['Bug'],325,49,ReactiveX_RxJava_pull_3862.diff
ReactiveX/RxJava,Provide factories for creating the default scheduler instances.,"Unlike other hooks, the `RxJavaSchedulersHook` has no access to the real `Scheduler` instances in order to do wrapping/delegation. With these factory methods, a hook can access what would otherwise be the instance used since there is often no other means of creating these specialized schedulers.

For Android this wrapping/delegation use-case is important for UI testing. We have a means to tell the testing framework when the app is idle and to do that we need to hook into the schedulers to know when they're empty. This is easy to do currently, but you cannot wrap the real instance and instead have to supply alternate implementations which might subtly alter the behavior under test.

These three methods are referenced in #3724, and I think providing the defaults is useful as well as eventually adding overloads which take `ThreadFactory` instances for each.
",2016-04-13 21:19:56,2016-04-18 10:34:37,https://api.github.com/repos/ReactiveX/RxJava/issues/3856,['Enhancement'],81,24,ReactiveX_RxJava_pull_3856.diff
ReactiveX/RxJava,1.x: ConcatMap vs ConcatMapIterable perf,"This PR adds a perf class to measure the difference between `concatMap()` and `concatMapIterable()` to support performance work

[Results](https://gist.github.com/akarnokd/86f5507ba4dec6a19fdf5b4bf7d7578f) on my machine (i7 4770K, Windows 7 x64, Java 8u77):

![image](https://cloud.githubusercontent.com/assets/1269832/14477915/8206a302-0111-11e6-82dd-d0e3cf70b8b8.png)
",2016-04-12 22:51:46,2016-04-14 17:51:04,https://api.github.com/repos/ReactiveX/RxJava/issues/3853,['Performance'],181,0,ReactiveX_RxJava_pull_3853.diff
ReactiveX/RxJava,Remove unused local.,,2016-04-10 21:53:58,2016-04-11 06:03:52,https://api.github.com/repos/ReactiveX/RxJava/issues/3849,['Cleanup'],1,3,ReactiveX_RxJava_pull_3849.diff
ReactiveX/RxJava,1.x: deanonymize Observable inner classes,"This PR factors out many anonymous inner classes into named classes and moves them outside `Observable`.

This cleanup makes the `Observable` more compact and helps debugging by showing more meaningful names in stacktraces.
",2016-04-10 17:50:09,2016-04-14 17:50:27,https://api.github.com/repos/ReactiveX/RxJava/issues/3848,['Cleanup'],825,444,ReactiveX_RxJava_pull_3848.diff
ReactiveX/RxJava,1.x: Release 1.1.3 CHANGES.md update,"Update to the CHANGES.md file.

(Without the flatMap and replay perf enhancements.)
",2016-04-08 21:58:15,2016-04-08 22:25:05,https://api.github.com/repos/ReactiveX/RxJava/issues/3846,['Information'],38,0,ReactiveX_RxJava_pull_3846.diff
ReactiveX/RxJava,1.x: fix delaySubscription(Observable) unsubscription before triggered,"The serial subscription in the `delaySubscription(Observable)` operator was not chained properly and thus an unsubscription before any events by the other didn't prevent the subscription to the main source.

Reported in #3844
",2016-04-08 19:56:42,2016-04-08 21:45:03,https://api.github.com/repos/ReactiveX/RxJava/issues/3845,['Bug'],118,9,ReactiveX_RxJava_pull_3845.diff
ReactiveX/RxJava,1.x: improve ExecutorScheduler worker unsubscription,"I noticed that when a worker built from `Schedulers.from(Executors.newFixedThread(1))` is unsubscribed the use of a `CompositeSubscription` to track task subscriptions means that the tasks may be unsubscribed in any old order (`CompositeSubscription` holds its subscriptions in a `HashSet`).  This means that if the worker is given task A and task B then the race can prevent A from running but allow B to run! I've included a unit test in this PR that demos it. Fails every time on my machine on the first loop.

This  PR is really for discussion about the problem and possible fixes.

I have included a possible fix which is to track overall subscription using a volatile boolean and check that boolean before running any task. If this was considered the way to go some further simplification would take place in the operator (might not need to check individual task subscriptions).

I haven't checked other schedulers for this sort of problem yet.
",2016-04-07 19:58:17,2016-04-08 18:15:47,https://api.github.com/repos/ReactiveX/RxJava/issues/3842,"['Cleanup', 'Enhancement']",41,1,ReactiveX_RxJava_pull_3842.diff
ReactiveX/RxJava,2.x,,2016-04-07 16:12:25,2016-04-07 16:24:02,https://api.github.com/repos/ReactiveX/RxJava/issues/3841,[],163880,107287,ReactiveX_RxJava_pull_3841.diff
ReactiveX/RxJava,1.x: fix concatMap scalar/empty source behavior,"There were two tiny problems with the rewritten `concatMap` operator, mainly due to copy-paste error:
- When a scalar was concatenated, the `active` field was not set and thus the next prefetched source overwrote it.
- When the scalar was set on the arbiter, its custom producer didn't check for n > 0 zero causing instant emission always. Generally Producer.request(0) is allowed and should be no-op (unlike RS).
- When an empty() was encountered as a last source, the it didn't trigger the check for completion afterwards.
",2016-04-07 15:41:42,2016-04-08 20:06:27,https://api.github.com/repos/ReactiveX/RxJava/issues/3840,['Bug'],72,4,ReactiveX_RxJava_pull_3840.diff
ReactiveX/RxJava,1.x: fix takeLast() backpressure,"The counted and timed versions of `takeLast` had a concurrency bug which allowed concurrent emission from the underlying queue that holds onto the values till the upstream completes. When timed correctly, both an `onCompleted()` and a `request()` that went from 0 to n could enter the emit() method and break the internal state of the non-concurrent queue. Note that this queue doesn't have to be concurrent by nature because the operator can emit only _after_ the upstream completes (`offer()` never runs concurrently with `poll()` unlike in `observeOn`).

In addition, the emission didn't immediately complete if the queue was emptied and requested == 0. In this operator, the fact that the queue became empty is the indicator of completion.

Both issues can be fixed with the `postCompleteXXX` mechanics in `BackpressureUtils`.

Since the operator has to store `null` values, the `postCompleteXXX` had to be extended with an exit transform overload to allow converting the `NotificationLite` values back to regular `T`/`null`.
",2016-04-07 11:37:54,2016-04-08 21:39:57,https://api.github.com/repos/ReactiveX/RxJava/issues/3839,['Bug'],396,242,ReactiveX_RxJava_pull_3839.diff
ReactiveX/RxJava,1.x: fix switchMap/switchOnNext producer retention and backpressure,"This PR fixes the producer retention problem and backpressure problem in `switchMap`/`switchOnNext`.

In the original, when an inner source completed, its producer was still referenced after it. If there was no new inner source or the next inner source didn't set a new producer, the operator leaked the previous inner source's internals. The fix involves nulling out the producer field when the inner source completes (and is still the current one).

The original had an additional bug due to a race condition between the request arbitration and switching inner sources. In some cases, the switch didn't properly forward the remaining request amount to the new inner source, causing hangs. In some other cases, both the old and new inner sources were able to emit, causing overflow. The fix involves a new queue-drain loop with some emitter-loop help to work out the state transitions.
",2016-04-06 11:21:34,2016-04-07 06:59:56,https://api.github.com/repos/ReactiveX/RxJava/issues/3836,['Bug'],325,179,ReactiveX_RxJava_pull_3836.diff
ReactiveX/RxJava,1.x: Add TestSingleSubscriber,"https://github.com/ReactiveX/RxJava/issues/3785
",2016-04-06 03:06:24,2016-05-31 13:16:57,https://api.github.com/repos/ReactiveX/RxJava/issues/3834,['Enhancement'],862,0,ReactiveX_RxJava_pull_3834.diff
ReactiveX/RxJava,TestScheduler: Fix race condition in queue,,2016-04-05 14:31:36,2016-04-05 15:00:04,https://api.github.com/repos/ReactiveX/RxJava/issues/3832,[],19,12,ReactiveX_RxJava_pull_3832.diff
ReactiveX/RxJava,1.x: Add system property for disabling usage of Unsafe API,"Part of #3459, related to #3815.
",2016-04-04 14:47:58,2016-04-04 17:08:13,https://api.github.com/repos/ReactiveX/RxJava/issues/3829,['Enhancement'],7,1,ReactiveX_RxJava_pull_3829.diff
ReactiveX/RxJava,1.x: AsyncSubject now supports backpressure,"`AsyncSubject` can trivially support backpressure when it emits a single item by setting the `SingleProducer` on the child `Subscriber` instead of calling `onNext` immediately.
",2016-04-04 10:20:12,2016-04-04 17:50:32,https://api.github.com/repos/ReactiveX/RxJava/issues/3828,['Enhancement'],53,6,ReactiveX_RxJava_pull_3828.diff
ReactiveX/RxJava,simplify OperatorObserveOn now that error is a non-volatile field,"This is a minor simplification in `OperatorObserveOn` where a temporary variable was created to avoid unnecessary additional reads of what used to be the volatile field `error`.  The field was changed to be non-volatile a while back so the temporary variable is no longer required. 

I assume it would have very minor perf impact (I haven't run them).  
",2016-04-04 09:13:30,2016-04-04 11:05:04,https://api.github.com/repos/ReactiveX/RxJava/issues/3827,[],4,6,ReactiveX_RxJava_pull_3827.diff
ReactiveX/RxJava,1.x: Fix TestSubscriber.create doc,"the docs of TestSubscriber.create(Subscriber) and TestSubscriber.create(Observer) got mixed up.
I just swapped them.
",2016-04-04 03:00:07,2016-04-04 07:01:33,https://api.github.com/repos/ReactiveX/RxJava/issues/3826,['Cleanup'],5,5,ReactiveX_RxJava_pull_3826.diff
ReactiveX/RxJava,1.x: Fix ObserveOnTest. testQueueFullEmitsErrorWithVaryingBufferSize,"The test had some non-deterministic machinery to trigger the failure.
",2016-04-03 01:58:23,2016-04-03 02:06:14,https://api.github.com/repos/ReactiveX/RxJava/issues/3825,['Test-Failures'],19,55,ReactiveX_RxJava_pull_3825.diff
ReactiveX/RxJava,1.x: javac 9 compatibility fixes,"The type inference of javac in JDK 9 has been changed in an incompatible way, marking many generics-related code invalid.

The most common problems:
- The inference calculates `Observable<? extends T>` but from its perspective, a call to `subscribe()` with a `Subscriber<T>` is ambiguous as it matches `subscribe(Observer<? super T>)` and `subscribe(Subscriber<? super T>)`. Somehow, the more specific class is not considered as a valid choice. Downcasting to `Observable<T>` fixes the error.
- `A<?>[]` no longer accepts `A<Ti>` elements, requires the use of raw types to get around

The tests appear to compile fine.

Note that I couldn't find a working IDE for JDK 9 and had to revert to command line trickery:

```
@echo off

dir /s /B src\main\java\rx\*.java > sources.txt
dir /s /B src\test\java\rx\*.java >> sources.txt

""c:\program files\java\jdk-9\bin\javac.exe"" -cp C:/temp/rx/junit.jar;C:/temp/rx/mockito.jar @sources.txt 

del sources.txt
```
",2016-04-03 01:48:22,2016-04-04 18:13:48,https://api.github.com/repos/ReactiveX/RxJava/issues/3824,['Build'],63,60,ReactiveX_RxJava_pull_3824.diff
ReactiveX/RxJava,1.x: DoAfterTerminate handle if action throws,"Fixes the bug reported in #3435.
",2016-04-02 23:51:07,2016-04-04 18:11:37,https://api.github.com/repos/ReactiveX/RxJava/issues/3823,['Bug'],50,10,ReactiveX_RxJava_pull_3823.diff
ReactiveX/RxJava,1.x: make defensive copy of the properties in RxJavaPlugins,"Possible solution to #3749.
",2016-04-02 23:09:11,2016-04-04 18:39:52,https://api.github.com/repos/ReactiveX/RxJava/issues/3822,['Bug'],5,1,ReactiveX_RxJava_pull_3822.diff
ReactiveX/RxJava,1.x: Add assertSubscribed() to TestSubscriber analog to assertUnsubscribed(),"`assertUnsubscribed()` exists, `assertSubscribed()` was missing
",2016-04-02 22:14:03,2016-06-22 07:50:12,https://api.github.com/repos/ReactiveX/RxJava/issues/3821,['Enhancement'],25,0,ReactiveX_RxJava_pull_3821.diff
ReactiveX/RxJava,Making RxPlugins reset() public,"Discussions found here: https://github.com/ReactiveX/RxJava/issues/2297
",2016-04-01 16:28:53,2016-04-29 18:15:18,https://api.github.com/repos/ReactiveX/RxJava/issues/3820,['Enhancement'],13,2,ReactiveX_RxJava_pull_3820.diff
ReactiveX/RxJava,1.x fromCallable() @Experimental -> @Beta,"Part of #3816
",2016-03-31 19:59:46,2016-04-07 06:57:15,https://api.github.com/repos/ReactiveX/RxJava/issues/3818,['API promotion'],2,2,ReactiveX_RxJava_pull_3818.diff
ReactiveX/RxJava,1.x: Upgrading AsyncOnSubscribe from Experimental to Beta,,2016-03-31 19:56:08,2016-06-25 13:58:46,https://api.github.com/repos/ReactiveX/RxJava/issues/3817,['API promotion'],10,10,ReactiveX_RxJava_pull_3817.diff
ReactiveX/RxJava,1.x Provide public constant instead of UnsafeAccess.isUnsafeAvailable(),"Motivation: save some nanoseconds on JVM and a little bit more on Android, new construction will also be easier for JIT.
",2016-03-31 18:03:55,2016-04-18 10:43:11,https://api.github.com/repos/ReactiveX/RxJava/issues/3815,['Cleanup'],41,42,ReactiveX_RxJava_pull_3815.diff
ReactiveX/RxJava,1.x: Fix prolonged Producer retention in switchOnNext,"There are two cases when the operator `switchOnNext` / `switchMap` retained parts of an earlier source through its `Producer` via the arbiter structure:
- when a backpressure-supporting source was followed by a unsupporting source which never sets a new Producer, keeping the old one there indefinitely
- when a backpressure-supporting source terminated but was not followed by any other source for longer period of time

The fix swaps in a null-producer when a new source is encountered and when an old source terminates. The swap is guarded by the current index so outdated events won't interfere with newer sequences.

**Edit**

Fixed a `ConcurrentModificationException` because the `queue` wasn't nulled out after assigning it to `localQueue`. Plus, I've added a test to check the async-source and async-inner doesn't cause backpressure exceptions.
",2016-03-31 14:14:53,2016-04-06 09:29:12,https://api.github.com/repos/ReactiveX/RxJava/issues/3814,['Bug'],136,7,ReactiveX_RxJava_pull_3814.diff
ReactiveX/RxJava,1.x: fix merge/flatMap crashing on an inner scalar of null,"This crash happens on contention where a scalar null value has to go through the scalar-queue which doesn't support nulls and requires NotificationLite transformations. (The drain side had the proper `getValue` in place already.)

Reported in #3808.
",2016-03-29 15:17:22,2016-03-29 20:00:07,https://api.github.com/repos/ReactiveX/RxJava/issues/3809,['Bug'],20,3,ReactiveX_RxJava_pull_3809.diff
ReactiveX/RxJava,1.x: Fix typos in documentation and some code,,2016-03-28 14:07:24,2016-03-29 07:23:21,https://api.github.com/repos/ReactiveX/RxJava/issues/3803,['Cleanup'],104,104,ReactiveX_RxJava_pull_3803.diff
ReactiveX/RxJava,1.x: Add Completable.andThen(Single),"https://github.com/ReactiveX/RxJava/issues/3730
",2016-03-27 03:49:17,2016-03-30 21:18:54,https://api.github.com/repos/ReactiveX/RxJava/issues/3799,['Enhancement'],300,1,ReactiveX_RxJava_pull_3799.diff
ReactiveX/RxJava,Changed just() function in Observable class to varargs.,"Just functions in Observable class were overloaded unnecessarily with increasing arguments from 1 to 10.
Marked all those methods as deprecated and defined one more overloaded just function with varargs as:
`@SuppressWarnings(""unchecked"")
    public static <T> Observable<T> just(T... t) {
        return from(t);
    }`

This will reduce the code redundancy and make it more elegant.
",2016-03-26 00:21:59,2016-03-26 20:57:27,https://api.github.com/repos/ReactiveX/RxJava/issues/3798,[],565,508,ReactiveX_RxJava_pull_3798.diff
ReactiveX/RxJava,"2.x: add ConsumableX to the base types, update method signatures","This PR factors out the `XSubscriber` types, makes sure the base types implement `ConsumableX`
and methods accepting X in some way now accept `ConsumableX` type.

Wrapping into the base types are not yet eliminated.
",2016-03-24 16:32:36,2016-06-17 08:57:20,https://api.github.com/repos/ReactiveX/RxJava/issues/3797,"['Cleanup', 'Enhancement']",1181,901,ReactiveX_RxJava_pull_3797.diff
ReactiveX/RxJava,1.x: observeOn now replenishes with constant rate,"This PR makes sure `observeOn` requests replenishments in a fixed and predictable quantity of 75% of the `bufferSize`, that is, if an emission counter reaches `0.75 * bufferSize`, that amount is requested and the emission counter is reset to zero. This requires saving the emission count between drain runs. If the bufferSize is 1 or 2, the replenishment will trigger after every 1 or 2 items.

Note that there is only one sensitive operator-builder, `AsyncOnSubscribe`, which is mostly affected by the request pattern as it facilitates user code to respond with an Observable sequence of the requested amount.

In addition, since `observeOn` now supports setting the buffer size, it can act as a rebatching operator via the help of `Schedulers.immediate()`.
",2016-03-23 23:43:45,2016-04-08 20:56:14,https://api.github.com/repos/ReactiveX/RxJava/issues/3795,['Enhancement'],75,28,ReactiveX_RxJava_pull_3795.diff
ReactiveX/RxJava,1.x: Fix Observable delay methods typos in documenation,,2016-03-23 11:16:44,2016-03-23 21:06:51,https://api.github.com/repos/ReactiveX/RxJava/issues/3791,"['Cleanup', 'Documentation']",3,3,ReactiveX_RxJava_pull_3791.diff
ReactiveX/RxJava,1.x: Expose Single.lift(),"Closes #3161.
",2016-03-23 00:57:21,2016-03-23 22:32:49,https://api.github.com/repos/ReactiveX/RxJava/issues/3790,['API promotion'],2,3,ReactiveX_RxJava_pull_3790.diff
ReactiveX/RxJava,1.x: Prevent Single.zip() of zero Singles,"Closes #3784.
",2016-03-23 00:29:43,2016-03-23 22:33:02,https://api.github.com/repos/ReactiveX/RxJava/issues/3789,['Bug'],28,1,ReactiveX_RxJava_pull_3789.diff
ReactiveX/RxJava,1.x: fix GroupBy delaying group completion till all groups were emitted,"In 1.1.1, `groupBy` was fixed to properly honor backpressure on the outer `Observable`. The change included a drain loop that emitted `onCompleted()` to the groups only when all `GroupedObservable`s were drained from the main queue. This delayed the group's completion unnecessarily causing the `concat` operator to hang in some source-consumer cases such as #3775.

This PR fixes the behavior by signalling `onCompleted()` to the groups the moment the main completes. 

Note, however, that concatenating groups is eventually prone to hangs due to the groups not completing until the source completes, thus `concat` can't switch to the next source. One should use `flatMap` or `concatMapEager` instead.
",2016-03-21 18:51:33,2016-03-23 22:32:34,https://api.github.com/repos/ReactiveX/RxJava/issues/3787,['Bug'],30,7,ReactiveX_RxJava_pull_3787.diff
ReactiveX/RxJava,2.x: rename and refactor classes to match the design document,"This PR renames and moves classes around to match the design document.

In addition, JMH version is updated to 1.11.3 and Gradle to 2.12.

Internal classes haven't been renamed yet and I plan to do it after this PR is merged.

This PR can't be effectively reviewed on GitHub. I suggest a clean checkout to your local IDE and see the proposed structure there.
",2016-03-19 11:48:35,2016-03-23 22:31:53,https://api.github.com/repos/ReactiveX/RxJava/issues/3783,['Cleanup'],134671,134674,ReactiveX_RxJava_pull_3783.diff
ReactiveX/RxJava,2.x design decisions,"This is a first draft of the design document for the 2.x branch.
We are interested in collecting any feedback from the community (implementers but also pure users).

This present document is the collaborative work of @abersnaze, @benjchristensen, @stealthcode, and @stevegury. But we encourage anyone to propose improvements/clarifications via pull-request.
",2016-03-19 00:26:39,2016-04-07 11:03:55,https://api.github.com/repos/ReactiveX/RxJava/issues/3782,"['Discussion', 'Information']",281,47,ReactiveX_RxJava_pull_3782.diff
ReactiveX/RxJava,1.x: Add an operator to throttle data via controlling the requests going upstream,"Came across an interesting use case where someone needed a way to get an external signal (unknown to the subscriber) to throttle the data going through an observable chain.
",2016-03-18 23:42:27,2016-06-22 13:01:19,https://api.github.com/repos/ReactiveX/RxJava/issues/3781,['Enhancement'],429,0,ReactiveX_RxJava_pull_3781.diff
ReactiveX/RxJava,Upgrading SyncOnSubscribe from experimental to beta,,2016-03-18 19:20:34,2016-03-31 20:00:27,https://api.github.com/repos/ReactiveX/RxJava/issues/3780,['API promotion'],9,8,ReactiveX_RxJava_pull_3780.diff
ReactiveX/RxJava,1.x: Release 1.1.2 CHANGES.md update,"Preparing for release 1.1.2.
",2016-03-18 08:02:39,2016-03-18 22:21:38,https://api.github.com/repos/ReactiveX/RxJava/issues/3778,['Information'],38,0,ReactiveX_RxJava_pull_3778.diff
ReactiveX/RxJava,observeOn: allow configurable buffer size,"The observeOn operator is backed by a small queue of 128 slots that may
overflow quickly on slow producers.  This could only be avoided by
adding a backpressure operator before the observeOn (not only
inconvenient, but also taking a perf. hit as it forces hops between two
queues).

This patch allows modifying the default queue size on the observeOn
operator.

Fixes: #3751
Signed-off-by: Galo Navarro anglorvaroa@gmail.com
",2016-03-17 22:52:47,2016-03-23 22:41:13,https://api.github.com/repos/ReactiveX/RxJava/issues/3777,['Enhancement'],150,12,ReactiveX_RxJava_pull_3777.diff
ReactiveX/RxJava,"Add Single.onErrorResumeNext(Func1<Throwable, Single>)","Second part of #3652, follow-up to #3655.
",2016-03-15 20:11:20,2016-03-15 20:22:10,https://api.github.com/repos/ReactiveX/RxJava/issues/3772,[],147,1,ReactiveX_RxJava_pull_3772.diff
ReactiveX/RxJava,1.x: observeOn - fix in-sequence termination/unsubscription,"This fixes `observeOn` not completing immediately if the downstream requested exactly the remaining amount. The original version required a new request from downstream to trigger the delivery of the terminal event.

This also fixes the rare failure in `testNoMoreRequestsAfterUnsubscribe` because the unsubscription is now checked in-sequence and doesn't trigger the unwanted replenishment request.
",2016-03-15 00:49:00,2016-03-16 13:50:25,https://api.github.com/repos/ReactiveX/RxJava/issues/3768,"['Bug', 'Test-Failures']",34,11,ReactiveX_RxJava_pull_3768.diff
ReactiveX/RxJava,1.x: Update Gradle wrapper to 2.12,"Release notes https://docs.gradle.org/2.12/release-notes

> Gradle 2.12 has the fastest build script compilation speeds of any Gradle version to date.
",2016-03-15 00:10:45,2016-03-15 23:53:27,https://api.github.com/repos/ReactiveX/RxJava/issues/3767,['Build'],2,2,ReactiveX_RxJava_pull_3767.diff
ReactiveX/RxJava,1.x: Add Single.onErrorResumeNext(Func),"Closes #3440, closes #3731, closes #3472 (whoa, 3 issues at a time!)
",2016-03-14 23:39:49,2016-03-15 23:57:39,https://api.github.com/repos/ReactiveX/RxJava/issues/3766,['Enhancement'],184,47,ReactiveX_RxJava_pull_3766.diff
ReactiveX/RxJava,1.x: switchOnNextDelayError and switchMapDelayError,"This PR adds a delayError version to the `switchOnNext` / `switchMap` operators.
",2016-03-14 23:25:22,2016-03-15 23:11:23,https://api.github.com/repos/ReactiveX/RxJava/issues/3765,['Enhancement'],401,166,ReactiveX_RxJava_pull_3765.diff
ReactiveX/RxJava,Added java6 project using retrolambda,"Since #3668 was merged we should now be able to build a separate artifact for Java 6, while continuing to maintain the main project using Java 8. This splits the project into 'rxjava' and 'rxjava-java6', which compiles the same source code using retrolambda, and uses the animalsniffer plugin to ensure that we are not inadvertently using APIs introduced after Java 6.
",2016-03-14 18:43:00,2016-06-17 07:34:17,https://api.github.com/repos/ReactiveX/RxJava/issues/3764,['Build'],140882,149839,ReactiveX_RxJava_pull_3764.diff
ReactiveX/RxJava,1.x: combineLatestDelayError,"This PR exposes the `delayError` option in `combineLatest` as `combineLatestDelayError`.

(Note that we have convenience overloads with 2-9 sources that could also use an overload, but that just expands the API surface drastically.)
",2016-03-14 16:22:55,2016-03-14 22:07:50,https://api.github.com/repos/ReactiveX/RxJava/issues/3763,['Enhancement'],132,2,ReactiveX_RxJava_pull_3763.diff
ReactiveX/RxJava,1.x: Deprecate CompositeException constructor with message prefix,"Before this PR messagePrefix was never used :dancer: 

If you guys want I can revert the change on CompositeExceptionTest.java:177. I just thought that way it' be nicer.

About the message is there any reason for having a space after the dot?
",2016-03-14 16:06:05,2016-03-23 21:07:12,https://api.github.com/repos/ReactiveX/RxJava/issues/3762,['Cleanup'],18,4,ReactiveX_RxJava_pull_3762.diff
ReactiveX/RxJava,1.x: optimize merge/flatMap for empty sources,"This PR improves the overhead when one merges/flatMaps `empty()` sequences.

Benchmark results: (i7 4770K, Windows 7 x64, Java 8u72):

![image](https://cloud.githubusercontent.com/assets/1269832/13749421/a04a35c6-ea01-11e5-8b02-53ad07517453.png)

For rare `empty()`, the overhead seems to be around the noise level.
",2016-03-14 15:27:53,2016-05-02 21:04:01,https://api.github.com/repos/ReactiveX/RxJava/issues/3761,"['Enhancement', 'Performance']",119,0,ReactiveX_RxJava_pull_3761.diff
ReactiveX/RxJava,1.x: fix ExecutorScheduler and GenericScheduledExecutorService reorder bug,"This PR relates to the failure of `errorThrownIssue1685`.

The underlying problem was with the `GenericScheduledExecutorService`. By being multi-threaded, tasks scheduled from the same thread one after the other may get reordered because different worker threads inside the pool could pick them up at the same time. In this case, there is no guarantee they keep their FIFO order.

_(I currently have no idea how one can use trampolining for this case; subsequent tasks may have any relative delays in respect to each other.)_

The solution creates N single threaded `ScheduledExecutorService`s and getInstance() hands one of them out. In turn `ExecutorService` takes one in its worker upfront.

However, there is still the problem when the programmer uses a multi-threaded `ScheduledExecutorService` with `Schedulers.from()` when the same issue comes back. A solution to that problem would be to always use the new `GenericScheduledExecutorService` for delaying timed tasks.
",2016-03-14 14:35:37,2016-03-17 17:56:43,https://api.github.com/repos/ReactiveX/RxJava/issues/3760,"['Bug', 'Test-Failures']",91,25,ReactiveX_RxJava_pull_3760.diff
ReactiveX/RxJava,1.x: concatMap full rewrite + delayError + performance,"This is a full rewrite of the `concat`/`concatMap` operator with the following properties:
- using `OnSubscribe` to save on the allocation of `lift`
- `concatDelayError` and `concatMapDelayError` to delay errors to the very end
- new trampolining logic that also subscribes to the next source even if requested is zero
- using `concatMap` or `concatMapDelayError` on a scalar source now bypasses the operator completely and uses `ScalarSynchronousObservable.scalarFlatMap` as well.
- the operator now detects `just` and `empty` sources and bypasses subscribing accordingly
- added `ExceptionsUtils` to work with composite exceptions and terminal state; useful for other similar delaying operators later on.
- `concat` is now implemented as `concatMap(v -> v)` which saves on the allocation of an entire `map` operator
- `OperatorWindowWithSizeTest.testBackpressureOuterInexact` had to be ignored because `window` doesn't honor backpressure properly and it is fixed in #3678; once it has been resolved, the test can be reenabled
- Added varargs constructor to `CompositeException` for convenience; avoids creating a list when the number of initial exceptions are known upfront.

Performance comparison to baseline (i7 4770K, Windows 7 x64, Java 8u72):

![image](https://cloud.githubusercontent.com/assets/1269832/13744915/603866a8-e9eb-11e5-8711-8feb24fbb872.png)
",2016-03-14 12:56:51,2016-03-15 23:10:59,https://api.github.com/repos/ReactiveX/RxJava/issues/3759,"['Enhancement', 'Performance']",769,254,ReactiveX_RxJava_pull_3759.diff
ReactiveX/RxJava,1.x: Operator sample emits last sampled value before termination.,"Changes:
- `OperatorSampleWithTime` emits last stored value if it is set before `onCompleted`
- `OperatorSampleWithObservable` emits last sampled value if source or sample complete.

As discussed in https://github.com/ReactiveX/RxJava/issues/3657.
",2016-03-14 02:03:25,2016-03-23 21:06:21,https://api.github.com/repos/ReactiveX/RxJava/issues/3757,['Enhancement'],41,3,ReactiveX_RxJava_pull_3757.diff
ReactiveX/RxJava,1.x: clarify join/groupJoin no ordering guarantees,"Original issue: #3616.
",2016-03-14 00:50:45,2016-03-14 17:10:15,https://api.github.com/repos/ReactiveX/RxJava/issues/3756,['Documentation'],6,0,ReactiveX_RxJava_pull_3756.diff
ReactiveX/RxJava,1.x: fix attempt 2 for testErrorThrownIssue1685,"I hope this fixes the test once and for all.
",2016-03-13 23:47:38,2016-03-13 23:54:21,https://api.github.com/repos/ReactiveX/RxJava/issues/3755,['Test-Failures'],3,2,ReactiveX_RxJava_pull_3755.diff
ReactiveX/RxJava,1.x: measure flatMap/concatMap performance when used as filter,"This PR adds a perf class to measure the overhead of using `empty()` when the `flatMap`/`concatMap` emulates `filter`.

This will establish the comparison baseline for `flatMap`/`concatMap` optimization as requested in #1653.

The baseline [numbers](https://gist.github.com/akarnokd/243a09e28edfc27aeb0d) (i7 4770K, Windows 7 x64, Java 8u72):

![image](https://cloud.githubusercontent.com/assets/1269832/13731994/629ce62c-e977-11e5-9f32-82dc404c792f.png)

Comparing `flatMap` against `concatMap`:

![image](https://cloud.githubusercontent.com/assets/1269832/13731998/a15586b2-e977-11e5-82c5-b33e458cb5a9.png)

Here, mask indicates the and-mask that makes emitting `empty` less frequent: 0 = always, 1 = every other, 3 = every fourth, 7 = every eighth. This also means that `rangeEmpty` starts emitting more and more values with higher mask value hence the different throughput values.
",2016-03-13 23:02:31,2016-03-13 23:18:00,https://api.github.com/repos/ReactiveX/RxJava/issues/3754,['Performance'],119,0,ReactiveX_RxJava_pull_3754.diff
ReactiveX/RxJava,1.x: fix SerializedObserverTest.testNotificationDelay,"This PR fixes the `SerializedObserverTest.testNotificationDelay` test to use reentrancy to verify the buffer in `SerializedObserver` is properly drained. For now, it loops 10,000 times to see if the CI brings up the issue again. Takes 400ms on my machine but I'll probably reduce it to 1,000 times.

(The previous version was a bit convoluted with all those countdowns that didn't properly lock out the other thread).

Reported in issue #1389
",2016-03-13 22:01:12,2016-03-14 16:53:53,https://api.github.com/repos/ReactiveX/RxJava/issues/3753,"['Test', 'Test-Failures']",44,54,ReactiveX_RxJava_pull_3753.diff
ReactiveX/RxJava,1.x: Single.using(),"This PR adds the factory method `using()` +1 overload to `Single` as requested in #3732.

For convenience, I've also added `Single.subscribe(Observer)`.
",2016-03-13 16:37:17,2016-03-14 16:40:08,https://api.github.com/repos/ReactiveX/RxJava/issues/3752,['Enhancement'],746,10,ReactiveX_RxJava_pull_3752.diff
ReactiveX/RxJava,1.x: Fix the test Issue1685 not waiting long enough.,"The tests started regularly failing on travis. This PR increases the waiting time to 2 seconds in total.
",2016-03-10 12:21:56,2016-03-10 12:31:52,https://api.github.com/repos/ReactiveX/RxJava/issues/3745,['Test-Failures'],3,1,ReactiveX_RxJava_pull_3745.diff
ReactiveX/RxJava,1.x: new operators buffer(While/Until) with predicate-based boundary,"The need for a buffer operator that splits the source sequence into continuous non-overlapping buffers based on the values in the sequence comes up from time to time. For, me, it reached the point where I'd consider adding operator(s) with this functionality into RxJava.

There are two variants of the required functionality: split before the element is added to the buffer: `bufferWhile`; and split after the element has been added to the buffer: `bufferUntil`.  Both cases, the predicate has to return `true` to trigger a split and emission of the current buffer.

I've added 2-2 overloads of these methods to `Observable` where the second overloads allow specifying the expected capacity use of the buffers (for performance reasons). These operators don't support backpressure and go unbounded, just like `buffer(Observable)` and others.

In the operator itself, I've added backpressured versions of `bufferWhile` and `bufferUntil`, which use a prefetch queue and a request-dependent queue-drain approach. It is up for a discussion what to do with these (provided this PR is of interest at all): 1) use them as the basis for the methods instead, 2) expose them through a different name and 3) drop them.
",2016-03-09 13:25:20,2016-06-14 08:18:19,https://api.github.com/repos/ReactiveX/RxJava/issues/3744,"['Discussion', 'Enhancement']",991,0,ReactiveX_RxJava_pull_3744.diff
ReactiveX/RxJava,Add doOnSubscribe for Single,"Ref #3740.

I didn't write much unit tests for `doOnSubscribe` because it internally uses `OperatorDoOnSubscribe` which is well covered.
",2016-03-02 23:46:17,2016-03-03 22:09:17,https://api.github.com/repos/ReactiveX/RxJava/issues/3741,['Enhancement'],59,0,ReactiveX_RxJava_pull_3741.diff
ReactiveX/RxJava,Creating Observable#create overloads for SyncOnSubscribe and AsyncOnSubscribe,"This is to facilitate the discovery of methods for creating observables that respect back pressure semantics. Currently the `Observable#create(OnSubscribe)` static method is the easiest method to discover for creating an observable which does not provide clear facilities for managing back pressure. 
",2016-03-02 01:25:19,2016-03-03 21:22:34,https://api.github.com/repos/ReactiveX/RxJava/issues/3738,['Enhancement'],95,24,ReactiveX_RxJava_pull_3738.diff
ReactiveX/RxJava,Avoid swallowing errors in Completable,"Instead, deliver them up to the thread's uncaught exception handler.

Fixes reactivex/rxjava#3726
",2016-02-24 21:14:05,2016-03-02 19:14:40,https://api.github.com/repos/ReactiveX/RxJava/issues/3733,[],109,17,ReactiveX_RxJava_pull_3733.diff
ReactiveX/RxJava,scan should pass upstream a request of Long.MAX_VALUE,"Changes in 1.1.1. for the `scan` operator introduced a bug in requesting where when the initial request was for max value the `scan` operator requested one less than that value of upstream (which affects fast-path producers).

I believe this bug only affects 1.1.1 (haven't looked at 2.x).

This PR includes a test that failed on the original code.
",2016-02-23 22:28:39,2016-02-24 17:46:17,https://api.github.com/repos/ReactiveX/RxJava/issues/3727,['Bug'],23,1,ReactiveX_RxJava_pull_3727.diff
ReactiveX/RxJava,Add maxConcurrent parameter to flatMapIterable,"Refs #3711. Should these new overloaded functions be annotated with `@Beta`?
",2016-02-19 14:21:23,2016-03-03 22:10:12,https://api.github.com/repos/ReactiveX/RxJava/issues/3722,['Enhancement'],66,0,ReactiveX_RxJava_pull_3722.diff
ReactiveX/RxJava,1.x: Add vararg of Subscriptions to CompositeSubscription.,,2016-02-18 18:38:49,2016-06-17 08:37:28,https://api.github.com/repos/ReactiveX/RxJava/issues/3720,['Enhancement'],165,16,ReactiveX_RxJava_pull_3720.diff
ReactiveX/RxJava,Documentation fix.,,2016-02-18 13:49:28,2016-02-18 17:56:07,https://api.github.com/repos/ReactiveX/RxJava/issues/3719,['Documentation'],1,1,ReactiveX_RxJava_pull_3719.diff
ReactiveX/RxJava,new method concatMapIterable #3713,"new method concatMapIterable #3713
",2016-02-17 19:10:30,2016-02-24 19:20:33,https://api.github.com/repos/ReactiveX/RxJava/issues/3718,['Enhancement'],51,0,ReactiveX_RxJava_pull_3718.diff
ReactiveX/RxJava,Update information about jar size in README.md,"The latest version of rxjava is 978K long.
",2016-02-17 12:49:01,2016-02-17 16:53:51,https://api.github.com/repos/ReactiveX/RxJava/issues/3717,['Information'],1,1,ReactiveX_RxJava_pull_3717.diff
ReactiveX/RxJava,1.x: Add maxConcurrent parameter to concatMapEager,"Relevant issue #3710 
",2016-02-15 23:53:08,2016-04-07 06:56:38,https://api.github.com/repos/ReactiveX/RxJava/issues/3714,['Enhancement'],74,8,ReactiveX_RxJava_pull_3714.diff
ReactiveX/RxJava,Add takeUntil support in Single,"As discussed in #3708

This adds `takeUntil(Observable)` and `takeUntil(Single)` support in `Single`. It was mostly just adapting the logic from the existing `OperatorTakeUntil` and adjusting it for accepting a `Single` and sending a `CancelattionException` in the event of a submission from `other` prior to a terminal event in the source `Single`.

Any feedback is appreciated it, this is my first time contributing an implementation to this project. Particularly wondering if it's worth keeping both overloads or if the user should just coerce their `other` to one type or ther other. Also particularly looking for feedback on what information to include in the `CancellationException`.
",2016-02-15 09:42:22,2016-02-23 18:58:31,https://api.github.com/repos/ReactiveX/RxJava/issues/3712,['Enhancement'],523,8,ReactiveX_RxJava_pull_3712.diff
ReactiveX/RxJava,1.x: make Completable.subscribe() report isUnsubscribed consistently,"The empty and lambda-based `Completable.subscribe()` returns a `Subscription` whose `isUnsubscribed` should be consistent with the rest of the reactive objects by returning true if the sequence terminated (not just when one truly cancelled it).
",2016-02-14 10:48:48,2016-02-15 09:21:25,https://api.github.com/repos/ReactiveX/RxJava/issues/3707,['Bug'],145,1,ReactiveX_RxJava_pull_3707.diff
ReactiveX/RxJava,Update RxJava Javadoc to 1.1.1,"Generated by `./gradlew -Prelease.version=1.1.1 clean javadoc` using Java 7 after applying #3704
",2016-02-14 08:15:21,2016-02-14 20:46:49,https://api.github.com/repos/ReactiveX/RxJava/issues/3705,['Documentation'],70020,3852,ReactiveX_RxJava_pull_3705.diff
ReactiveX/RxJava,1.x: Make the javadoc task generate correct docs,"This PR modified the javadoc task to make it generate the same format of http://reactivex.io/RxJava/javadoc/index.html. `gradle/stylesheet.css` is copied from https://github.com/ReactiveX/RxJava/blob/gh-pages/javadoc/stylesheet.css

This supports both Java 7 and Java 8. However, docs generated by Java 8 have a totally different style. Hence we should use Java 7 to generate javadoc and publish it to http://reactivex.io/RxJava/javadoc/index.html.
",2016-02-14 08:14:52,2016-02-16 19:47:07,https://api.github.com/repos/ReactiveX/RxJava/issues/3704,"['Build', 'Documentation']",487,0,ReactiveX_RxJava_pull_3704.diff
ReactiveX/RxJava,1.x: fix mapNotification's last item backpressure handling,"The previous algorithm used a 2 element queue but it was possible the drain loop got captured and the queue wasn't enough, causing `MissingBackpressureException`.

The new algorithm uses the requested field's most significant bit to indicate a completed state. If the terminal events reach it with non-zero request or a post-terminal request finds a zero request amount, the last item is emitted.

In addition, the upstream's producer may arrive after the first request thus the class includes the usual arbitration logic inlined. If the upstream doesn't set a `Producer` but just emits values, the production/backpressure checks are bypassed.

```
rx.internal.operators.OperatorFlatMapTest > testFlatMapTransformsMaxConcurrentNormalLoop FAILED
    java.lang.AssertionError: Unexpected onError events: 1
        at rx.observers.TestSubscriber.assertNoErrors(TestSubscriber.java:309)
        at rx.internal.operators.OperatorFlatMapTest.testFlatMapTransformsMaxConcurrentNormal(OperatorFlatMapTest.java:419)
        at rx.internal.operators.OperatorFlatMapTest.testFlatMapTransformsMaxConcurrentNormalLoop(OperatorFlatMapTest.java:395)
        Caused by:
        rx.exceptions.MissingBackpressureException
            at rx.internal.operators.OperatorMapNotification$SingleEmitter.offerAndComplete(OperatorMapNotification.java:173)
            at rx.internal.operators.OperatorMapNotification$MapNotificationSubscriber.onCompleted(OperatorMapNotification.java:80)
            at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.slowpath(OnSubscribeFromIterable.java:101)
            at rx.internal.operators.OnSubscribeFromIterable$IterableProducer.request(OnSubscribeFromIterable.java:73)
            at rx.internal.producers.ProducerArbiter.emitLoop(ProducerArbiter.java:186)
            at rx.internal.producers.ProducerArbiter.setProducer(ProducerArbiter.java:129)
            at rx.internal.operators.OperatorMapNotification$MapNotificationSubscriber.setProducer(OperatorMapNotification.java:74)
            at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:49)
            at rx.internal.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:32)
            at rx.Observable$2.call(Observable.java:162)
            at rx.Observable$2.call(Observable.java:154)
            at rx.Observable$2.call(Observable.java:162)
            at rx.Observable$2.call(Observable.java:154)
            at rx.Observable.subscribe(Observable.java:8426)
            at rx.Observable.subscribe(Observable.java:8393)
            at rx.internal.operators.OperatorFlatMapTest.testFlatMapTransformsMaxConcurrentNormal(OperatorFlatMapTest.java:416)
            ... 1 more
```
",2016-02-12 21:39:25,2016-02-19 09:49:02,https://api.github.com/repos/ReactiveX/RxJava/issues/3702,['Bug'],208,163,ReactiveX_RxJava_pull_3702.diff
ReactiveX/RxJava,1.x: Add Completable.doOnCompleted and deprecate Completable.doOnComplete,"Closes #3700.
",2016-02-12 20:16:34,2016-02-14 10:24:25,https://api.github.com/repos/ReactiveX/RxJava/issues/3701,['Cleanup'],23,12,ReactiveX_RxJava_pull_3701.diff
ReactiveX/RxJava,1.x: GroupBy Regression Test Case,"This is passing against 1.1.1 with the back-ported OperatorGroupBy, but would be good to have it in as a regression test.

See also: #3698
",2016-02-12 04:02:41,2016-02-19 09:50:00,https://api.github.com/repos/ReactiveX/RxJava/issues/3699,['Test'],221,0,ReactiveX_RxJava_pull_3699.diff
ReactiveX/RxJava,1.x: fix ScalarSynchronousObservable expects EventLoopsScheduler from,"Schedulers.computation()

When one installs a scheduler hook which makes Schedulers.computation() return a different scheduler, the constant function in ScalarSynchronousObservable crashes if that hasn't been initialized.
",2016-02-11 22:59:01,2016-02-12 19:57:08,https://api.github.com/repos/ReactiveX/RxJava/issues/3697,['Bug'],7,15,ReactiveX_RxJava_pull_3697.diff
ReactiveX/RxJava,1.x: Added Single execution hooks,"Resolves #3595
",2016-02-11 21:45:48,2016-03-17 12:13:16,https://api.github.com/repos/ReactiveX/RxJava/issues/3696,['Enhancement'],313,16,ReactiveX_RxJava_pull_3696.diff
ReactiveX/RxJava,Release 1.1.1 changes.md,"Preparation for 1.1.1
",2016-02-11 10:45:30,2016-02-11 20:58:57,https://api.github.com/repos/ReactiveX/RxJava/issues/3695,['Information'],86,0,ReactiveX_RxJava_pull_3695.diff
ReactiveX/RxJava,1.x: #3618 adding source links for @Beta and @Experimental,"cherry-pick #3623 to 1.x
",2016-02-11 05:38:39,2016-02-11 18:12:35,https://api.github.com/repos/ReactiveX/RxJava/issues/3694,[],6,3,ReactiveX_RxJava_pull_3694.diff
ReactiveX/RxJava,Update nebula gradle plugin,"Cherry-pick of the gradle nebula plugin upgrade in 1.x branch.
",2016-02-11 01:30:24,2016-02-11 05:26:01,https://api.github.com/repos/ReactiveX/RxJava/issues/3693,[],8,12,ReactiveX_RxJava_pull_3693.diff
ReactiveX/RxJava,1.x: Fix Completable using JDK 7 suppressed exceptions feature,"The upgraded gradle switched my IDE to use a JDK 6 library I have installed all along and these popped up immediately.
",2016-02-10 23:15:25,2016-02-11 05:28:35,https://api.github.com/repos/ReactiveX/RxJava/issues/3692,['Bug'],35,36,ReactiveX_RxJava_pull_3692.diff
ReactiveX/RxJava,Update nebula gradle plugin,"Update the gradle-rxjava-project-plugin to the latest version.
Update gradle to version 2.10 as well.
",2016-02-10 20:45:45,2016-02-10 21:44:39,https://api.github.com/repos/ReactiveX/RxJava/issues/3690,['Build'],8,12,ReactiveX_RxJava_pull_3690.diff
ReactiveX/RxJava,1.x: unified onErrorX and onExceptionResumeNext and fixed backpressure,"The operators didn't honor backpressure when they switched over to the other Observable.

This PR also includes the fix #3685.
",2016-02-09 18:25:24,2016-02-09 20:21:40,https://api.github.com/repos/ReactiveX/RxJava/issues/3689,['Bug'],172,345,ReactiveX_RxJava_pull_3689.diff
ReactiveX/RxJava,1.x: Fix zip() - observer array becoming visible too early and causing NPE,"Reported in #3687.

By the way, I see several other small problems with zip: it is implemented as an `Operator` and even though one can know the number of sources upfront, this indirection hides the fact. In addition, it uses SpMc queue but could just use Spsc because there is only one drain thread at a time.
",2016-02-09 14:52:26,2016-02-10 19:17:27,https://api.github.com/repos/ReactiveX/RxJava/issues/3688,['Bug'],18,13,ReactiveX_RxJava_pull_3688.diff
ReactiveX/RxJava,Added retry and retryWhen support for Single,,2016-02-09 14:24:09,2016-02-10 18:35:15,https://api.github.com/repos/ReactiveX/RxJava/issues/3686,['Enhancement'],271,82,ReactiveX_RxJava_pull_3686.diff
ReactiveX/RxJava,1.x: onErrorResumeNext(Func1) should not call plugin handler there,"When the operator switches to the other, that counts as a handled error. 

See also #3347.
",2016-02-09 13:49:18,2016-02-09 18:25:42,https://api.github.com/repos/ReactiveX/RxJava/issues/3685,['Bug'],4,4,ReactiveX_RxJava_pull_3685.diff
ReactiveX/RxJava,1.x: javadoc for Producer,"See #1511. 
",2016-02-09 12:39:32,2016-02-09 22:55:28,https://api.github.com/repos/ReactiveX/RxJava/issues/3684,['Documentation'],11,1,ReactiveX_RxJava_pull_3684.diff
ReactiveX/RxJava,1.x: javadoc for rx.exceptions.Exceptions,"See #1508
",2016-02-09 12:29:23,2016-02-09 18:26:06,https://api.github.com/repos/ReactiveX/RxJava/issues/3683,['Documentation'],4,2,ReactiveX_RxJava_pull_3683.diff
ReactiveX/RxJava,"1.x: fix observeOn resource handling, add delayError capability","This PR fixes the ""messing around"" reported in #3002 and adds an overload to `observeOn` that allows delaying errors without the need for wrapping (see #3542 and maybe there are other reports).

In addition, this PR adds a proper override of the `isEmpty` method to simply compare the two indexes for emptiness directly instead of `size() == 0` to avoid looping, multi-reading and casting.

Benchmark comparison (i7 4790, Windows 7 x64, Java 8u66):

![image](https://cloud.githubusercontent.com/assets/1269832/11442154/3f4f104a-9513-11e5-9b0c-00cef5a6bb10.png)

Note that the benchmark is generally quite noisy, yielding hectic results (i.e., firing up a thread with newThread may take quite some random microseconds). For example, `observeOnImmediate` shouldn't be affected by any of the changes yet the run-to-run variance is +/- 10%. I'm fine with the results of the benchmark.
",2016-02-09 11:54:25,2016-02-10 22:02:06,https://api.github.com/repos/ReactiveX/RxJava/issues/3682,['Enhancement'],240,141,ReactiveX_RxJava_pull_3682.diff
ReactiveX/RxJava,1.x: change publish(Func1) to use a dedicated subject-like dispatcher,"Solves the problems #3673 and #3674 by introducing a new subject-like dispatcher class `OnSubscribePublishMulticast` that does support backpressure, pauses when there are no subscribers and signals the terminal event for late subscribers; all ideal for the multicasting `publish(Func1)` overload.
",2016-02-08 23:53:43,2016-02-11 10:51:47,https://api.github.com/repos/ReactiveX/RxJava/issues/3681,['Enhancement'],773,7,ReactiveX_RxJava_pull_3681.diff
ReactiveX/RxJava,Fix various misspellings in OperatorPublish,"No code change.
",2016-02-08 23:29:57,2016-02-08 23:54:32,https://api.github.com/repos/ReactiveX/RxJava/issues/3680,['Cleanup'],7,7,ReactiveX_RxJava_pull_3680.diff
ReactiveX/RxJava,1.x: fix counted buffer and window backpressure,"This PR fixes the backpressure behavior of the counted `buffer` and `window` operators and consists of several changes.

The main issue lies when `count > skip` in the operators, yielding overlapping buffers/windows. 

For `buffer`, when the upstream completed, the logic emitted all remaining partial buffers even if there was no request for new buffers, which can result in `MissingBackpressureException` somewhere. The proper handling of the final buffers required a new backpressure management algorithm which is now part of the `BackpressureUtils` class and consists of two new methods: `postCompleteDone` called from onComplete to take over the emission of queued values and `postCompleteRequest` which manages requests before and after the completed state.

For `window`, the new window opened was emitted regardless of requests which was common due to request-amplification (i.e., requesting n windows results in requesting `count + skip * (n - 1)` elements at first (then `skip * n` later) which opens `ceil(count / skip)` windows upfront. To avoid the overflow, the individual windows have to go through the usual queue/drain logic as well. I've also updated the Javadoc to reflect the backpressure behavior along with parameter validation.

In addition, the window case didn't manage cancellation properly. When the outer observable is unsubscribed, the inner subscribers may be still going and thus cancelling the upstream would stop/hang the inner windows. Instead, the open window count is tracked (also counting the outer as 1 window) and when all get unsubscribed (i.e., count reaches zero), the upstream is unsubscribed. To accomplish this, the `UnicastSubject` had to be retrofitted with a new optional callback `Action0` which gets called at most once whenever either `onError` or `onCompleted` is called or when the single `Subscriber` unsubscribes.

A secondary issue was with the `TestSubscriber`'s initial request; some upstream operators could get triggered with `Long.MAX_VALUE` despite the initial request amount was set. This PR changes it to be set at construction time instead of in `onStart`.
",2016-02-08 21:50:30,2016-03-18 07:50:29,https://api.github.com/repos/ReactiveX/RxJava/issues/3678,['Bug'],1082,328,ReactiveX_RxJava_pull_3678.diff
ReactiveX/RxJava,1.x: negative argument check for skip's count and merge's maxConcurrent,"As per #3675, we should also check the `count` argument of `skip`. Also added the missing check for `merge`'s `maxConcurrent`.
",2016-02-08 02:50:55,2016-02-08 06:27:59,https://api.github.com/repos/ReactiveX/RxJava/issues/3677,[],33,11,ReactiveX_RxJava_pull_3677.diff
ReactiveX/RxJava,1.x: fix take(-1) not completing,"Originally, only 0 was checked which resulted in `onCompleted()` but negative values weren't. When the downstream requested, c became -1 and was requested from the source. `range` ignores negative requests but other sources may throw IAE in that case.

With the fix, the operator will throw IAE in assembly time.
",2016-02-05 20:19:30,2016-02-06 16:03:04,https://api.github.com/repos/ReactiveX/RxJava/issues/3675,['Bug'],20,0,ReactiveX_RxJava_pull_3675.diff
ReactiveX/RxJava,Add How to Contribute wiki link,"Since it has become standard to have everything about how to contribute on CONTRIBUTING.md file, I think   it would be really helpful and good to have link to How-to-Contribute wiki page.
",2016-02-05 10:51:43,2016-02-06 16:04:15,https://api.github.com/repos/ReactiveX/RxJava/issues/3672,['Documentation'],2,0,ReactiveX_RxJava_pull_3672.diff
ReactiveX/RxJava,2.x: fix SchedulerLifecycle.testStartIdempotence vs cached threads dying,"I forgot that RxCached threads can get evicted during the test. The new logic makes sure no new threads appeared.
",2016-02-05 08:31:16,2016-02-06 16:28:16,https://api.github.com/repos/ReactiveX/RxJava/issues/3671,['Test-Failures'],9,6,ReactiveX_RxJava_pull_3671.diff
ReactiveX/RxJava,1.x: fix Subscribers.create(onNext) javadoc,"fix for javadoc issue #3669
",2016-02-04 14:16:23,2016-02-05 05:29:23,https://api.github.com/repos/ReactiveX/RxJava/issues/3670,['Documentation'],2,2,ReactiveX_RxJava_pull_3670.diff
ReactiveX/RxJava,2.x: full JDK 6 compatible backport + including bugfixes up to today,"Due to the issue with AtomicXFieldUpdaters on certain Android devices, I had to manually replace all of them with regular AtomicX classes.
",2016-02-04 12:56:02,2016-02-05 07:53:38,https://api.github.com/repos/ReactiveX/RxJava/issues/3668,['Enhancement'],30213,10166,ReactiveX_RxJava_pull_3668.diff
ReactiveX/RxJava,Update javadoc for Subscribers.empty(),"fix for https://github.com/ReactiveX/RxJava/issues/3664
",2016-02-03 01:53:22,2016-02-03 17:58:02,https://api.github.com/repos/ReactiveX/RxJava/issues/3665,['Documentation'],3,4,ReactiveX_RxJava_pull_3665.diff
ReactiveX/RxJava,1.x: fix doOnRequest premature requesting.,"When the operator is assembled and it sets the producer on the child, if the child doesn't request until the assembly is complete, `doOnRequest` requested the default Long.MAX_VALUE.
",2016-02-01 23:57:00,2016-02-03 05:26:04,https://api.github.com/repos/ReactiveX/RxJava/issues/3662,['Bug'],58,10,ReactiveX_RxJava_pull_3662.diff
ReactiveX/RxJava,1.x: CombineLatest now supports any number of sources,"This PR is a backport of the 2.x `combineLatest` with `null` support and let's the programmer combine more than 128 sources at once. Note that 2.x supports manual sizing of the prefetch buffer and allows delaying the exceptions to the last moment; I kept these in case such features are required by 1.x some day.

The original had this 128 limit due to using a single and non-parametric RxRingBuffer to store values from sources. In addition, the original algorithm divided downstream requests among the sources with some strange logic in order to keep them running and not overflow the buffer.

This PR uses an unbounded-linked SPSC queue which can now hold as many elements as there are sources times the default ring buffer size (this is not preallocated and grows/shrinks as necessary).

The algorithm stores the current latest array and the source subscriber in the queue in pairs so when that particular row is emitted to downstream, that source subscriber gets the request() replenishment call that generated the row.

In addition, I've added an Iterator overload from #3660 as well.
",2016-02-01 21:35:37,2016-02-03 21:38:07,https://api.github.com/repos/ReactiveX/RxJava/issues/3661,"['Bug', 'Enhancement']",473,286,ReactiveX_RxJava_pull_3661.diff
ReactiveX/RxJava,Add combineLatest overload for Collection,"2.x already uses `Iterable`, but that's a very drastic change compared to just `Collection`.

Motivation here is that I'm using set bindings to create observables in a dependency injector and I want to skip the current `new ArrayList<>(sources)` that I have to do on the set.
",2016-02-01 05:32:09,2016-02-01 21:36:05,https://api.github.com/repos/ReactiveX/RxJava/issues/3660,['Feature-Request'],39,11,ReactiveX_RxJava_pull_3660.diff
ReactiveX/RxJava,Add wrapper task and update to gradle 2.10,"Was using a pretty old version of gradle. Tests all run normally for me locally with this
",2016-02-01 00:11:25,2016-02-01 00:59:03,https://api.github.com/repos/ReactiveX/RxJava/issues/3659,[],7,2,ReactiveX_RxJava_pull_3659.diff
ReactiveX/RxJava,1.x: fix unsubscription and producer issues in sample(other),"This PR fixes 2 bugs with `sample`
- Termination of the main or sampler subscriber unsubscribed the child subscriber which is not allowed.
- The sampler wrapped the child subscriber and thus it allowed setting a producer on the child (thus sampling based on request with some sources).

In addition, #3657 wants to emit the very last item on completion to which I marked the required changes in comments (to be uncommented in a separate PR if needed).
",2016-01-31 11:05:09,2016-02-02 21:00:43,https://api.github.com/repos/ReactiveX/RxJava/issues/3658,['Bug'],172,8,ReactiveX_RxJava_pull_3658.diff
ReactiveX/RxJava,1.x: Add Single.onErrorResumeNext(Single),"Part of #3652, will submit a PR for `onErrorResumeNext(Func1<Throwable, Single>)` later.
",2016-01-29 01:38:28,2016-02-03 05:26:15,https://api.github.com/repos/ReactiveX/RxJava/issues/3655,['Enhancement'],115,3,ReactiveX_RxJava_pull_3655.diff
ReactiveX/RxJava,1.x: fix sample(Observable) not requesting Long.MAX_VALUE,"Reported on the rxjava discussion group.

Sample has to disconnect itself from the Producer chain and request Long.MAX_VALUE instead of whatever the downstream requests.
",2016-01-28 15:39:21,2016-01-31 10:08:40,https://api.github.com/repos/ReactiveX/RxJava/issues/3653,['Bug'],40,9,ReactiveX_RxJava_pull_3653.diff
ReactiveX/RxJava,"1.x: Remove redundant ""final"" modifiers","As promised in #3579.
",2016-01-27 01:03:03,2016-01-31 04:48:39,https://api.github.com/repos/ReactiveX/RxJava/issues/3651,['Cleanup'],155,155,ReactiveX_RxJava_pull_3651.diff
ReactiveX/RxJava,2.x: Add support for concurrently inserting actions while advancing time,"This change is adding a bit of thread safety when some threads are trying to insert some actions while the time is changed in the TestScheduler
",2016-01-26 17:54:51,2016-06-18 18:30:48,https://api.github.com/repos/ReactiveX/RxJava/issues/3648,['Feature-Request'],8,2,ReactiveX_RxJava_pull_3648.diff
ReactiveX/RxJava,Adding support for concurrently inserting actions while advancing time,"This change is adding a bit of thread safety when some threads are trying to insert some actions while the time is changed in the TestScheduler
",2016-01-26 17:25:23,2016-01-26 17:52:57,https://api.github.com/repos/ReactiveX/RxJava/issues/3647,[],40,2,ReactiveX_RxJava_pull_3647.diff
ReactiveX/RxJava,1.x: fix Amb sharing the choice among all subscribers,"The OnSubscribeAmb shared the choice variable among all of its subscribers which prevented reusing the same Observable.
",2016-01-25 22:00:25,2016-01-25 22:43:10,https://api.github.com/repos/ReactiveX/RxJava/issues/3645,['Bug'],24,3,ReactiveX_RxJava_pull_3645.diff
ReactiveX/RxJava,1.x: fix SyncOnSubscribe not signalling onError if the generator crashes,"Discovered in a [stackoverflow](http://stackoverflow.com/questions/35001387/how-to-handle-error-in-generatestate-in-synconsubscribe-rxjava) question.
",2016-01-25 21:19:28,2016-01-25 22:33:00,https://api.github.com/repos/ReactiveX/RxJava/issues/3644,['Bug'],40,2,ReactiveX_RxJava_pull_3644.diff
ReactiveX/RxJava,1.x: Single performance measurements,"Benchmark `Single`'s behavior with `flatMap`, `subscribeOn` and `observeOn`.

Results: (i7 4790, Windows 7 x64, Java 8u72)

```
Benchmark                   Score       Error  Units
direct                9054864,731  189403,130  ops/s
flatmap               2761060,187   40953,148  ops/s
flatmapConst          2763238,776   34372,376  ops/s
observeOn              300489,044   27461,361  ops/s
observeOnExec          333838,535    9098,275  ops/s
observeOnFJ            402261,384    9467,060  ops/s
observeOnSchExec       342714,377    8624,188  ops/s
subscribeOn            311487,902    8986,858  ops/s
subscribeOnExec        257315,361   29967,833  ops/s
subscribeOnFJ          383189,863   12596,397  ops/s
subscribeOnSchExec     290880,185   45773,862  ops/s
```

Here is a side-by-side comparison of throughput on various schedulers:

![image](https://cloud.githubusercontent.com/assets/1269832/12547224/5dc0b5aa-c34f-11e5-889f-f77bca708997.png)
",2016-01-25 09:32:16,2016-01-25 09:41:07,https://api.github.com/repos/ReactiveX/RxJava/issues/3643,['Performance'],263,0,ReactiveX_RxJava_pull_3643.diff
ReactiveX/RxJava,1.x: Optimizate single just,"This PR add similar optimization as ScalarSynchronousObservable to Single.just method.
",2016-01-25 02:43:12,2016-02-03 15:18:07,https://api.github.com/repos/ReactiveX/RxJava/issues/3642,"['Enhancement', 'Performance']",461,13,ReactiveX_RxJava_pull_3642.diff
ReactiveX/RxJava,fix error handling in combineLatest,"`combinator.call()` was not wrapped in an appropriate try catch to prevent the error from being reported from an upstream operator.

This PR includes a unit test that failed on the original code.
",2016-01-24 01:50:26,2016-02-09 12:18:05,https://api.github.com/repos/ReactiveX/RxJava/issues/3641,['Bug'],36,1,ReactiveX_RxJava_pull_3641.diff
ReactiveX/RxJava,fix error handling in onBackpressureDrop,"`onDrop.call()`  was not wrapped in an appropriate try catch to prevent the error from being reported from an upstream operator.

This PR includes a unit test that failed on the original code.
",2016-01-23 23:13:23,2016-01-24 08:43:25,https://api.github.com/repos/ReactiveX/RxJava/issues/3640,['Bug'],38,1,ReactiveX_RxJava_pull_3640.diff
ReactiveX/RxJava,fix error handling in onBackpressureBuffer,"`onOverflow.call()`  was not wrapped in an appropriate try catch to prevent the error from being reported from an upstream operator.

This PR includes a unit test that failed on the original code.
",2016-01-23 10:55:57,2016-01-25 08:50:22,https://api.github.com/repos/ReactiveX/RxJava/issues/3639,['Bug'],43,4,ReactiveX_RxJava_pull_3639.diff
ReactiveX/RxJava,fix error handling in OperatorDistinctUntilChanged,"As per #3637, `keySelector.call()` was not wrapped in an appropriate try catch to prevent the error from being reported from an upstream operator.

This PR includes a unit test that failed on the original code.
",2016-01-23 07:12:52,2016-01-25 08:49:51,https://api.github.com/repos/ReactiveX/RxJava/issues/3638,['Bug'],37,4,ReactiveX_RxJava_pull_3638.diff
ReactiveX/RxJava,handle predicate exceptions properly in skipWhile,"A non-fatal exception thrown by `predicate.call()` in `OperatorSkipWhile` could result in the error being reported by an upstream operator. This PR ensures that the error is reported by the operator in which it occurs.

I've added a unit test for this scenario that failed with the original code, and a couple of other tests.

There are a few more of these floating around that I'll submit PRs for as well.
",2016-01-23 06:49:16,2016-01-24 08:44:41,https://api.github.com/repos/ReactiveX/RxJava/issues/3637,['Bug'],56,1,ReactiveX_RxJava_pull_3637.diff
ReactiveX/RxJava,1.x: zip performance measure,"Performance measurement of `zip` and upgrade to JMH 1.11.3.

Results (Intel Celeron 1005M, Windows 7 x64, Java 8u72):

Overall throughput values:

![image](https://cloud.githubusercontent.com/assets/1269832/12523444/3e1893fc-c157-11e5-81bd-353031db4a91.png)

Comparing fully sync and fully async dual sources:

![image](https://cloud.githubusercontent.com/assets/1269832/12523464/5cc23074-c157-11e5-8231-5954eafd7d0e.png)

Comparing when either the first or the second is an async source:

![image](https://cloud.githubusercontent.com/assets/1269832/12523485/7bdf951e-c157-11e5-9f3c-f2f3b156ba03.png)

So the order of sources matter, having the async first allows it to start early and not after the synchronous source completes its prefetch run.
",2016-01-22 21:29:24,2016-01-25 09:01:20,https://api.github.com/repos/ReactiveX/RxJava/issues/3635,['Performance'],143,0,ReactiveX_RxJava_pull_3635.diff
ReactiveX/RxJava,1.x: redo performance checker,"This PR adds a perf test to measure the redo-based operators: repeat, repeatWhen, retry, retryWhen.

Results (Intel Celeron 1005M, Windows 7 x64, Java 8u72):

```
Benchmark                     (params)        Score  Score error
r.o.RedoPerf.baseline              1,1  9507538,496   384265,883
r.o.RedoPerf.baseline           1,1000   127236,123     6322,513
r.o.RedoPerf.baseline        1,1000000      131,491        7,443
r.o.RedoPerf.baseline           1000,1   126830,429     8161,593
r.o.RedoPerf.baseline        1000,1000      130,795        8,571
r.o.RedoPerf.baseline        1000000,1      130,097        0,936
r.o.RedoPerf.repeatCounted         1,1   473245,445    16574,938
r.o.RedoPerf.repeatCounted      1,1000     2039,161       64,254
r.o.RedoPerf.repeatCounted   1,1000000        2,304        0,376
r.o.RedoPerf.repeatCounted      1000,1    28622,433     2896,427
r.o.RedoPerf.repeatCounted   1000,1000       35,208        2,312
r.o.RedoPerf.repeatCounted   1000000,1       56,978        7,278
r.o.RedoPerf.repeatWhen            1,1   452640,724     5506,024
r.o.RedoPerf.repeatWhen         1,1000     2151,821      352,059
r.o.RedoPerf.repeatWhen      1,1000000        2,159        0,066
r.o.RedoPerf.repeatWhen         1000,1    23919,436      217,644
r.o.RedoPerf.repeatWhen      1000,1000       20,947        1,615
r.o.RedoPerf.repeatWhen      1000000,1       25,316        0,970
r.o.RedoPerf.retryCounted          1,1   176470,291     4570,641
r.o.RedoPerf.retryCounted       1,1000      588,985       38,103
r.o.RedoPerf.retryCounted    1,1000000        0,589        0,037
r.o.RedoPerf.retryCounted       1000,1     7178,699      123,423
r.o.RedoPerf.retryCounted    1000,1000       14,470        0,699
r.o.RedoPerf.retryCounted    1000000,1        7,842        0,252
r.o.RedoPerf.retryWhen             1,1   310407,136     8052,067
r.o.RedoPerf.retryWhen          1,1000      567,338       13,511
r.o.RedoPerf.retryWhen       1,1000000        0,587        0,036
r.o.RedoPerf.retryWhen          1000,1    10388,639      269,817
r.o.RedoPerf.retryWhen       1000,1000       10,657        1,471
r.o.RedoPerf.retryWhen       1000000,1       11,550        0,287
```

The `params` is a composite of number of elements and number of repetitions.
",2016-01-22 18:38:01,2016-01-22 19:05:33,https://api.github.com/repos/ReactiveX/RxJava/issues/3634,['Performance'],116,0,ReactiveX_RxJava_pull_3634.diff
ReactiveX/RxJava,Release 1.1.1 CHANGES.md preparation,"Preparation for release 1.1.1.

There are, however, quite a few PRs open which could be also included with 1.1.1 (ignoring documentation and cleanup):
## Bugfixes
- #3597 fix counted buffer and window operators' backpressure behavior
- #3614 ~~just() now supports backpressure (+ related fixes/changes)~~ merged
- #3620 Fix NPE in CompositeException when nested throws on initCause
## Enhancements
- #3476 overhead reduction for merge and flatMap 
- #3507 combineLatest can now combine arbitrary number of sources
- #3544 fix observeOn resource handling, add delayError capability
- #3579 ~~No more need to convert Singles to Observables for Single.zip()~~ merged
- #3589 concat reduce overhead when streaming a source
- #3627 Added MergeDelay operators for Iterable of Observables
",2016-01-22 09:34:33,2016-02-01 08:59:26,https://api.github.com/repos/ReactiveX/RxJava/issues/3631,['Discussion'],70,0,ReactiveX_RxJava_pull_3631.diff
ReactiveX/RxJava,1.x: ConcatMapEager allow nulls from inner Observables.,"The operator was not allowing `null`s in the inner Observables.

Related: #3629.
",2016-01-21 10:11:27,2016-01-22 06:17:56,https://api.github.com/repos/ReactiveX/RxJava/issues/3630,['Bug'],27,8,ReactiveX_RxJava_pull_3630.diff
ReactiveX/RxJava,1.x: Added MergeDelay operators for Iterable of Observables,"PR for issue #3577
",2016-01-20 16:16:16,2016-02-08 20:35:53,https://api.github.com/repos/ReactiveX/RxJava/issues/3627,['Enhancement'],77,1,ReactiveX_RxJava_pull_3627.diff
ReactiveX/RxJava,use Exceptions.throwOrError to simplify error handling,"This PR simplifies error handling by making use of existing `Exceptions.throwOrError` overloads.

A number of classes are touched by this one PR but I'm assuming review will be easy enough that merge can happen soon.
",2016-01-20 00:21:03,2016-01-22 06:20:59,https://api.github.com/repos/ReactiveX/RxJava/issues/3626,['Cleanup'],13,27,ReactiveX_RxJava_pull_3626.diff
ReactiveX/RxJava,"1.x: implement OperatorDoOnEmpty, with Observable.doOnEmpty() operator","See #3621
",2016-01-19 02:48:50,2016-04-14 19:37:19,https://api.github.com/repos/ReactiveX/RxJava/issues/3624,['Feature-Request'],231,0,ReactiveX_RxJava_pull_3624.diff
ReactiveX/RxJava,1.x: adding source links for @Beta and @Experimental,"Solution for issue #3618.
",2016-01-18 12:05:11,2016-01-27 03:49:11,https://api.github.com/repos/ReactiveX/RxJava/issues/3623,['Documentation'],6,3,ReactiveX_RxJava_pull_3623.diff
ReactiveX/RxJava,1.x: Optimizate single just,"This PR add similar optimization as ScalarSynchronousObservable to Single.just method.
",2016-01-18 03:01:50,2016-01-25 02:38:48,https://api.github.com/repos/ReactiveX/RxJava/issues/3622,['Performance'],171,9,ReactiveX_RxJava_pull_3622.diff
ReactiveX/RxJava,1.x: Fix NPE in CompositeException when nested throws on initCause,"possible solution :)
",2016-01-17 01:15:13,2016-02-06 16:54:18,https://api.github.com/repos/ReactiveX/RxJava/issues/3620,['Bug'],44,1,ReactiveX_RxJava_pull_3620.diff
ReactiveX/RxJava,Solution for 3618,"I've created the solution for issue #3618.
",2016-01-15 10:57:34,2016-01-15 10:59:13,https://api.github.com/repos/ReactiveX/RxJava/issues/3619,[],6990,711,ReactiveX_RxJava_pull_3619.diff
ReactiveX/RxJava,1.x: just() now supports backpressure (+ related fixes/changes),"Updated `just()` to fully support backpressure.

This is a repost of #3496 due to merge and rebase problems.
",2016-01-13 13:01:45,2016-01-26 10:23:11,https://api.github.com/repos/ReactiveX/RxJava/issues/3614,"['Bug', 'Enhancement']",641,197,ReactiveX_RxJava_pull_3614.diff
ReactiveX/RxJava,delaySubscription(Func0) does not use a scheduler,"It subscribes to the upstream `Observable` on the emitting thread of the other `Observable` obtained from the `Func0`.
",2016-01-08 22:39:19,2016-01-08 22:46:30,https://api.github.com/repos/ReactiveX/RxJava/issues/3609,['Documentation'],1,1,ReactiveX_RxJava_pull_3609.diff
ReactiveX/RxJava,1.x: fix counted buffer and window operators' backpressure behavior,"This PR fixes the backpressure behavior of the counted `buffer` and `window` operators and consists of several changes.

The main issue lies when `count > skip` in the operators, yielding overlapping buffers/windows. 

For `buffer`, when the upstream completed, the logic emitted all remaining partial buffers even if there was no request for new buffers, which can result in `MissingBackpressureException` somewhere. The proper handling of the final buffers required a new backpressure management algorithm which is now part of the `BackpressureUtils` class and consists of two new methods: `postCompleteDone` called from onComplete to take over the emission of queued values and `postCompleteRequest` which manages requests before and after the completed state.

For `window`, the new window opened was emitted regardless of requests which was common due to request-amplification (i.e., requesting n windows results in requesting `count + skip * (n - 1)` elements at first (then `skip * n` later) which opens `ceil(count / skip)` windows upfront. To avoid the overflow, the individual windows have to go through the usual queue/drain logic as well. I've also updated the Javadoc to reflect the backpressure behavior along with parameter validation.

In addition, the window case didn't manage cancellation properly. When the outer observable is unsubscribed, the inner subscribers may be still going and thus cancelling the upstream would stop/hang the inner windows. Instead, the open window count is tracked (also counting the outer as 1 window) and when all get unsubscribed (i.e., count reaches zero), the upstream is unsubscribed. To accomplish this, the `UnicastSubject` had to be retrofitted with a new optional callback `Action0` which gets called at most once whenever either `onError` or `onCompleted` is called or when the single `Subscriber` unsubscribes.

A secondary issue was with the `TestSubscriber`'s initial request; some upstream operators could get triggered with `Long.MAX_VALUE` despite the initial request amount was set. This PR changes it to be set at construction time instead of in `onStart`.
",2016-01-04 14:12:32,2016-02-08 21:51:05,https://api.github.com/repos/ReactiveX/RxJava/issues/3597,['Bug'],1085,328,ReactiveX_RxJava_pull_3597.diff
ReactiveX/RxJava,1.x: add never test for  PublishSubjectTest,"This PR complete the never assert in PublishSubjectTest.
",2015-12-30 02:49:37,2016-01-11 20:48:42,https://api.github.com/repos/ReactiveX/RxJava/issues/3592,"['Cleanup', 'Test']",26,2,ReactiveX_RxJava_pull_3592.diff
ReactiveX/RxJava,Update AbstractOnSubscribe.java,"change hasOnNext to !hasOnNext
",2015-12-28 12:47:28,2015-12-28 14:52:09,https://api.github.com/repos/ReactiveX/RxJava/issues/3590,[],1,1,ReactiveX_RxJava_pull_3590.diff
ReactiveX/RxJava,1.x: concat reduce overhead when streaming a source,"This PR reduces the request tracking overhead of `concat` by tracking the produced item count in a plain field and subtracting it from the arbiter and requested values only before the inner source completes. So instead of N decrementAndGet call, we have 1 addAndGet(-N) per source. 

I've added a perf class to measure the difference.

(Intel Celeron 1005M @ 2GHz, Windows 7 x64, Java 8u66)

![image](https://cloud.githubusercontent.com/assets/1269832/12010270/d8af1660-ac9f-11e5-933c-ee96da7deda5.png)

The throughput increased considerably, although I would have expected more, especially in the 1M case where the subscription overhead doesn't matter.

I'll do further investigation on it and post a follow-up PR if this gets merged in the meantime.
",2015-12-27 12:52:29,2016-02-03 22:20:06,https://api.github.com/repos/ReactiveX/RxJava/issues/3589,['Performance'],133,20,ReactiveX_RxJava_pull_3589.diff
ReactiveX/RxJava,Fix the initialization order in GenericScheduledExecutorService,"The static `GenericScheduledExecutorService.None` should be initialized before creating any GenericScheduledExecutorService instance. Although the previous codes happen to work, it's sill worth to fix it.
",2015-12-27 06:43:37,2015-12-27 09:54:57,https://api.github.com/repos/ReactiveX/RxJava/issues/3588,['Cleanup'],7,7,ReactiveX_RxJava_pull_3588.diff
ReactiveX/RxJava,Remove the need for javac to generate synthetic methods.,"Outer classes accessing inner class private fields and methods (and vise versa) causes javac to generate package-scoped trampolines. These bloat the class files, adds overhead to the inliner analysis, and for Android create needless method that eat away at our fixed limit of methods in an application. By simply promoting the private interactions to package scope directly, the synthetic methods do not need generated.

2.5% of RxJava's methods were these needless generated trampolines accounting for 1.2% of jar size and 1.4% of dex size.

```
$ dex-method-count before.dex
5005

$ dex-method-count after.dex
4875
```

```
-rw-r--r--   1 jw  jw   699K Dec 25 03:08 after.dex
-rw-r--r--   1 jw  jw   952K Dec 25 03:08 after.jar
-rw-r--r--   1 jw  jw   709K Dec 25 03:06 before.dex
-rw-r--r--   1 jw  jw   964K Dec 25 03:06 before.jar
```
",2015-12-25 08:29:58,2015-12-27 09:50:49,https://api.github.com/repos/ReactiveX/RxJava/issues/3587,['Cleanup'],157,128,ReactiveX_RxJava_pull_3587.diff
ReactiveX/RxJava,Fixed typo,,2015-12-24 10:40:29,2015-12-26 01:40:18,https://api.github.com/repos/ReactiveX/RxJava/issues/3586,['Cleanup'],2,2,ReactiveX_RxJava_pull_3586.diff
ReactiveX/RxJava,1.x: fix Completable.using not disposing the resource if the factory crashes during the subscription phase.,"This PR fixes the cases when the Completable factory throws an exception
or returns null and the resource is not disposed before reporting error
to the subscriber.
",2015-12-21 18:41:24,2016-01-12 07:57:05,https://api.github.com/repos/ReactiveX/RxJava/issues/3585,['Bug'],157,2,ReactiveX_RxJava_pull_3585.diff
ReactiveX/RxJava,clarify behaviour of groupBy in javadoc,"As discussed in #3411, some clarification of the behaviour of `groupBy` looks necessary re its behaviour when the `GroupedObservable` terminates early (for example has `.first()` applied to it). See also  #3581.

I also took the liberty of recommending `ignoreElements` instead of `take(0)` for the section in the javadoc that recommends how to ignore emissions because the `take(0)` approach would have more overhead (every emission from source would prompt the emission of a new `GroupedObservable`) than the `ignoreElements` approach.

Once this is accepted I'll look to submit a PR with `groupByOnce` (mentioned in #3411).
",2015-12-21 06:06:27,2016-01-11 21:06:28,https://api.github.com/repos/ReactiveX/RxJava/issues/3584,['Documentation'],10,4,ReactiveX_RxJava_pull_3584.diff
ReactiveX/RxJava,1.x: Update ReplaySubjectPerf.java,,2015-12-18 00:40:27,2016-02-08 06:31:23,https://api.github.com/repos/ReactiveX/RxJava/issues/3582,['Cleanup'],3,0,ReactiveX_RxJava_pull_3582.diff
ReactiveX/RxJava,1.x: No more need to convert Singles to Observables for Single.zip(),"PTAL
",2015-12-17 10:56:48,2016-01-24 08:23:47,https://api.github.com/repos/ReactiveX/RxJava/issues/3579,['Enhancement'],296,73,ReactiveX_RxJava_pull_3579.diff
ReactiveX/RxJava,Fix typo in CompositeException documentation,,2015-12-15 08:25:50,2015-12-15 19:08:44,https://api.github.com/repos/ReactiveX/RxJava/issues/3575,['Cleanup'],1,1,ReactiveX_RxJava_pull_3575.diff
ReactiveX/RxJava,Test PR,,2015-12-15 01:36:24,2015-12-15 01:38:43,https://api.github.com/repos/ReactiveX/RxJava/issues/3573,[],13414,4014,ReactiveX_RxJava_pull_3573.diff
ReactiveX/RxJava,Implemented Completable#andThen(Observable),"I expect some discussion around the method name. 
",2015-12-09 20:44:00,2016-01-04 23:07:51,https://api.github.com/repos/ReactiveX/RxJava/issues/3570,"['Discussion', 'Enhancement']",74,0,ReactiveX_RxJava_pull_3570.diff
ReactiveX/RxJava,1.x: fix renamed operator in Single.,"There was a cross dependency between two PRs yielding a broken
compilation in main.
",2015-12-09 11:30:30,2015-12-09 12:06:30,https://api.github.com/repos/ReactiveX/RxJava/issues/3569,['Cleanup'],2,13,ReactiveX_RxJava_pull_3569.diff
ReactiveX/RxJava,Renamed Completable#finallyDo to #doAfterTerminate,"Renames as part of #3434 for the recently added Completable.
",2015-12-09 03:23:04,2015-12-09 10:49:26,https://api.github.com/repos/ReactiveX/RxJava/issues/3568,['Cleanup'],9,9,ReactiveX_RxJava_pull_3568.diff
ReactiveX/RxJava,Implemented Observable#toCompletable,,2015-12-09 03:22:08,2015-12-09 18:59:55,https://api.github.com/repos/ReactiveX/RxJava/issues/3567,['Enhancement'],124,1,ReactiveX_RxJava_pull_3567.diff
ReactiveX/RxJava,Deprecate Observable.finallyDo() and add Observable.doAfterTerminate() instead,"#3434 but for `Observable`.
",2015-12-09 01:46:52,2015-12-09 10:15:20,https://api.github.com/repos/ReactiveX/RxJava/issues/3566,[],32,9,ReactiveX_RxJava_pull_3566.diff
ReactiveX/RxJava,Replace never() calls in BehaviorSubjectTest with verifyNoMoreInteractions,"Advantage is that we verify that there's no interaction at all so also something that we might not expect is not going to happen.
",2015-12-08 16:38:54,2015-12-09 23:20:28,https://api.github.com/repos/ReactiveX/RxJava/issues/3565,['Cleanup'],14,26,ReactiveX_RxJava_pull_3565.diff
ReactiveX/RxJava,Fix typo in documentation,,2015-12-06 17:36:32,2015-12-07 21:24:36,https://api.github.com/repos/ReactiveX/RxJava/issues/3563,['Documentation'],1,1,ReactiveX_RxJava_pull_3563.diff
ReactiveX/RxJava,Add Single.doOnUnsubscribe(),"As promised, adding more operators to `Single`. This one is very useful for releasing resources if task can be cancelled externally via `subscription.unsubscribe()` and subscriber may not receive the result. 
",2015-12-05 19:22:32,2015-12-08 22:03:03,https://api.github.com/repos/ReactiveX/RxJava/issues/3562,['Enhancement'],85,0,ReactiveX_RxJava_pull_3562.diff
ReactiveX/RxJava,Corrected buffer operator onError behaviour documentation,"#3560
",2015-12-05 12:47:15,2015-12-08 08:59:02,https://api.github.com/repos/ReactiveX/RxJava/issues/3561,['Documentation'],44,26,ReactiveX_RxJava_pull_3561.diff
ReactiveX/RxJava,Rewording 1.1.0 release notes in CHANGES.md,,2015-12-04 23:10:10,2015-12-06 08:21:49,https://api.github.com/repos/ReactiveX/RxJava/issues/3559,[],1,1,ReactiveX_RxJava_pull_3559.diff
ReactiveX/RxJava,1.x: fix toMap and toMultimap not handling exceptions of the callbacks,"This PR adds the usual try-catch around callback invocations in `toMap`
and `toMultimap`.

Related #3555.
",2015-12-03 09:36:22,2015-12-08 18:56:19,https://api.github.com/repos/ReactiveX/RxJava/issues/3556,['Bug'],233,19,ReactiveX_RxJava_pull_3556.diff
ReactiveX/RxJava,Update CHANGES.md for v1.1.0,,2015-12-03 02:17:25,2015-12-03 20:42:02,https://api.github.com/repos/ReactiveX/RxJava/issues/3553,['Discussion'],31,0,ReactiveX_RxJava_pull_3553.diff
ReactiveX/RxJava,Update CHANGES.md for v1.0.17,,2015-12-01 22:20:08,2015-12-02 20:24:46,https://api.github.com/repos/ReactiveX/RxJava/issues/3551,['Discussion'],10,0,ReactiveX_RxJava_pull_3551.diff
ReactiveX/RxJava,Public API changes for 1.1.0 release,,2015-12-01 21:43:43,2015-12-03 00:14:15,https://api.github.com/repos/ReactiveX/RxJava/issues/3550,['Enhancement'],508,2474,ReactiveX_RxJava_pull_3550.diff
ReactiveX/RxJava,Remove double whitespace in if conditions,"Just found them while walking through the source code trying to get a better overview of the Rx internals. 
",2015-11-27 23:45:34,2015-12-09 17:46:07,https://api.github.com/repos/ReactiveX/RxJava/issues/3549,['Cleanup'],2,2,ReactiveX_RxJava_pull_3549.diff
ReactiveX/RxJava,"1.x: fix observeOn resource handling, add delayError capability","This PR fixes the ""messing around"" reported in #3002 and adds an overload to `observeOn` that allows delaying errors without the need for wrapping (see #3542 and maybe there are other reports).

In addition, this PR adds a proper override of the `isEmpty` method to simply compare the two indexes for emptiness directly instead of `size() == 0` to avoid looping, multi-reading and casting.

Benchmark comparison (i7 4790, Windows 7 x64, Java 8u66):

![image](https://cloud.githubusercontent.com/assets/1269832/11442154/3f4f104a-9513-11e5-9b0c-00cef5a6bb10.png)

Note that the benchmark is generally quite noisy, yielding hectic results (i.e., firing up a thread with newThread may take quite some random microseconds). For example, `observeOnImmediate` shouldn't be affected by any of the changes yet the run-to-run variance is +/- 10%. I'm fine with the results of the benchmark.
",2015-11-27 13:35:50,2016-02-09 11:52:02,https://api.github.com/repos/ReactiveX/RxJava/issues/3544,['Enhancement'],240,141,ReactiveX_RxJava_pull_3544.diff
ReactiveX/RxJava,Add Single.zip() for Iterable of Singles,,2015-11-24 13:27:44,2015-12-09 19:43:04,https://api.github.com/repos/ReactiveX/RxJava/issues/3539,['Feature-Request'],229,1,ReactiveX_RxJava_pull_3539.diff
ReactiveX/RxJava,1.x: Fix SyncOnSubscribeTest.testConcurrentRequests non-determinism,"The test checks if onUnSubscribe is called but that happens after
onCompleted is sent and as such, may run concurrently with the main
thread where the mock is verified. The change switches to CountDownLatch
to properly await the call to onUnsubscribe.
",2015-11-22 09:23:30,2015-11-25 22:03:57,https://api.github.com/repos/ReactiveX/RxJava/issues/3536,['Test-Failures'],12,3,ReactiveX_RxJava_pull_3536.diff
ReactiveX/RxJava,1.x: Don't swallow fatal errors in OperatorZipIterable,"A follow up PR for #3528
",2015-11-22 03:29:21,2015-11-22 09:03:31,https://api.github.com/repos/ReactiveX/RxJava/issues/3535,['Bug'],1,0,ReactiveX_RxJava_pull_3535.diff
ReactiveX/RxJava,1.x: fix time windows in throttleFirst,"As a result of #3527 discussion I noticed that `throttleFirst` does not comply with behaviour described in javadocs. Time windows used for emissions were supposed to be of constant duration yet could be effectively lengthened because the next time window always started at the time of the emission to downstream plus the window duration.

To demonstrate:

Consider  `source.throttleWithFirst(1000, TimeUnit.MILLISECONDS)` where source emits 

```
Time   Value    
0       ""a""
1200    ""b""
2100    ""c""
```

Desired result is:

`a, b, c`

yet previous version produced

`a, b`

A unit test has been added that failed with the previous version.
",2015-11-17 05:14:00,2016-06-22 13:06:42,https://api.github.com/repos/ReactiveX/RxJava/issues/3529,['Discussion'],55,9,ReactiveX_RxJava_pull_3529.diff
ReactiveX/RxJava,1.x: Avoid to call next when Iterator is drained,"`delay` delays the `onCompleted` event and `unsubscribe` is called when `onCompleted` finishes. So if we put a `o.zipWith(Iterable, func)` before `delay`, such as `o.zipWith(Iterable, func).delay(...)`, `o` may keep emitting items even if `zipWith` emits an `onCompleted` event. This PR just fixed `OperatorZipIterable` to handle this case.

Fixes https://github.com/ReactiveX/RxScala/issues/180
",2015-11-16 05:59:01,2015-11-16 18:32:18,https://api.github.com/repos/ReactiveX/RxJava/issues/3528,['Bug'],31,3,ReactiveX_RxJava_pull_3528.diff
ReactiveX/RxJava,2.x: Reduse verbosity with varargs [WIP],,2015-11-14 18:21:26,2016-06-17 07:07:06,https://api.github.com/repos/ReactiveX/RxJava/issues/3526,['Enhancement'],5,106,ReactiveX_RxJava_pull_3526.diff
ReactiveX/RxJava,fix subscribe() javadoc ,"fix for javadoc issue #3523 
",2015-11-14 04:43:40,2015-11-16 07:55:14,https://api.github.com/repos/ReactiveX/RxJava/issues/3524,['Documentation'],2,1,ReactiveX_RxJava_pull_3524.diff
ReactiveX/RxJava,1.x: Run tests on Android!,"Closes #3503.

In short:
- Created `rxjava` gradle module and moved `src` to `rxjava/src`.
- Created `android-tests` module and configured it to run tests from `rxjava/src/test` on Android.
- Tuned build scripts so we can run builds on Android/JDK concurrently.
- Changed `MemoryMXBean` to `Runtime` in `ExecutorSchedulerTest` because `MemoryMXBean` is not presented on Android.

TODO:
- Fix all failing tests Android (usually timeout problems since Android emulator is :snail:): #3504, cc @akarnokd.
- Decide which Android APIs we want to run tests on, I suggest at least one API with Dalvik VM (with Java 6 and Java 7) and one with ART, for example 18, 19 and 22.

@JakeWharton PTAL
",2015-11-13 04:40:01,2016-06-17 09:18:28,https://api.github.com/repos/ReactiveX/RxJava/issues/3519,['Test'],272,75,ReactiveX_RxJava_pull_3519.diff
ReactiveX/RxJava,Update CHANGES.md for v1.0.16,,2015-11-11 20:36:45,2015-11-11 21:01:51,https://api.github.com/repos/ReactiveX/RxJava/issues/3517,[],11,0,ReactiveX_RxJava_pull_3517.diff
ReactiveX/RxJava,1.x: BlockingUtils test: clear interrupted flag before/after,"For some strange reason, the interrupted flag is sometimes still set when the next JUnit test method runs and `await` will throw immediately.
",2015-11-11 11:55:51,2015-11-20 10:08:32,https://api.github.com/repos/ReactiveX/RxJava/issues/3515,['Test-Failures'],11,5,ReactiveX_RxJava_pull_3515.diff
ReactiveX/RxJava,1.x: SyncOnSubscribeTest.testConcurrentRequests give more time.,"The test failed on Travis and locally if my machine was under heavy load without interacting with the mock. This change gives more time in the inner await and reports the exception instead of itself throwing.
",2015-11-10 07:54:30,2015-11-12 08:52:04,https://api.github.com/repos/ReactiveX/RxJava/issues/3514,['Test-Failures'],37,52,ReactiveX_RxJava_pull_3514.diff
ReactiveX/RxJava,1.x: add shorter RxJavaPlugin class lookup approach.,"This adds a new pattern and lookup method that let's the developer specify the custom plugins with shorter system property keys. Android is quite restrictive and allows only 31 characters.

The new pattern splits the target simple class name and its implementation into two separate system properties:

```
rxjava.plugin.1.class=SimpleClassName
rxjava.plugin.1.impl=path.to.impl.Class
```

The index tag (`1`) can be any string of your chosing:

```
rxjava.plugin.mykey.class=SimpleClassName
rxjava.plugin.mykey.impl=path.to.impl.Class
```

but make sure they are paired, otherwise nothing will happen.

If there are multiple `class` entries with the same `SimpleClassName` one of them will be chosen (depending on the walk order in `java.util.Properties`).

Related issue #2835.
",2015-11-09 22:49:57,2015-11-12 08:52:50,https://api.github.com/repos/ReactiveX/RxJava/issues/3513,['Enhancement'],89,23,ReactiveX_RxJava_pull_3513.diff
ReactiveX/RxJava,1.x: fix SafeSubscriber documentation regarding unsubscribe,"The documentation was wrong in two points: unsubscription doesn't call`onCompleted` and unsubscription doesn't directly prevent delivery of `onXXX` events since the implementation doesn't even check isUnsubscribed: (it is the responsibility of the upstream to do that).

Related issue: #3059.
",2015-11-09 22:00:03,2015-11-10 21:02:42,https://api.github.com/repos/ReactiveX/RxJava/issues/3512,['Documentation'],2,1,ReactiveX_RxJava_pull_3512.diff
ReactiveX/RxJava,1.x: Remove unused and inefficient SubscriptionRandomList.,"Use the standard CompositeSubscription instead.

Related issue: #3105
",2015-11-09 21:45:01,2015-11-10 07:37:00,https://api.github.com/repos/ReactiveX/RxJava/issues/3511,['Cleanup'],0,155,ReactiveX_RxJava_pull_3511.diff
ReactiveX/RxJava,1.x: eager concatMap to choose safe or unsafe queue based on platform.,"I forgot to add the choice because 2.x `SpscArrayQueue` doesn't use Unsafe. I copied the `SpscAtomicArrayQueue` from #3169 and I hope it won't conflict. This is the drawback of long trail of unmerged fixes and enhancements...

Reported in #3508 . 
",2015-11-09 20:58:54,2015-11-10 21:03:09,https://api.github.com/repos/ReactiveX/RxJava/issues/3510,['Bug'],208,2,ReactiveX_RxJava_pull_3510.diff
ReactiveX/RxJava,1.x: split Android detection and version detection,"It seems some Samsung devices running 5.x mess with field names so
reflection can't find them.

If the `PlatformDependent.resolveAndroidApiVersion` logic throws due to
the missing field (but not the class), the original code considered it
to be a non-Android platform and went ahead with `Unsafe` stuff which
causes NPEs at many places.

The change splits the class check and the version check. If the version
check fails, it returns a default version (7) value so the `Unsafe`
paths are not triggered.
",2015-11-09 17:26:16,2015-11-12 08:53:43,https://api.github.com/repos/ReactiveX/RxJava/issues/3509,['Bug'],12,4,ReactiveX_RxJava_pull_3509.diff
ReactiveX/RxJava,1.x: combineLatest can now combine arbitrary number of sources,"This PR is a backport of the 2.x `combineLatest` with `null` support and let's the programmer combine more than 128 sources at once. Note that 2.x supports manual sizing of the prefetch buffer and allows delaying the exceptions to the last moment; I kept these in case such features are required by 1.x some day.

The original had this 128 limit due to using a single and non-parametric RxRingBuffer to store values from sources. In addition, the original algorithm divided downstream requests among the sources with some strange logic in order to keep them running and not overflow the buffer.

This PR uses an unbounded-linked SPSC queue which can now hold as many elements as there are sources times the default ring buffer size (this is not preallocated and grows/shrinks as necessary).

The algorithm stores the current latest array and the source subscriber in the queue in pairs so when that particular row is emitted to downstream, that source subscriber gets the request() replenishment call that generated the row.
",2015-11-09 15:55:09,2016-02-01 21:29:41,https://api.github.com/repos/ReactiveX/RxJava/issues/3507,['Enhancement'],451,289,ReactiveX_RxJava_pull_3507.diff
ReactiveX/RxJava,1.x: enable operator/source fusion by named operator lifter,"This change factors out the body of `lift()` into a named class that gives access to the operator and source parameters. By using this information, other operators can perform what I call **operator macro-fusion**.

One such example with this PR is the repeated use of the operator `mergeWith` which when done in the classical way creates a long linked-list of sources merged in pairs, often leading to stack overflows
and degraded performance. However, if `mergeWith` can see that it is applied to an existing mergeWith, the two operators can use a common list of sources and then turn into a one-level merge() with n + 1
sources (the previous graph will then be GC'd). Don't worry, this doesn't destroy the original assembled sequence. For example, given `c = a.mergeWith(b); d = c.mergeWith(e);` both c and d can be freely subscribed to and still do the same thing.

Note also that this PR conflicts with PR #3477 since the array-based `merge(from(os))` has a different type.

I didn't officially benchmarked this due to the stackoverflow with head. Given the 10002 values merged in the unit test in 34ms (i7 4790, Windows 7 x64, Java 8u66) which yields ~294 kOps/s.
",2015-11-09 14:57:01,2016-02-08 06:31:58,https://api.github.com/repos/ReactiveX/RxJava/issues/3506,['Performance'],195,44,ReactiveX_RxJava_pull_3506.diff
ReactiveX/RxJava,1.x: Test adjustments to reduce problems when tests run on Android,"These changes may help in reducing problems when the tests are run on an Android emulation:
- set an uncaught exception handler because the native error handler crashes the entire test run.
- reduce memory usage by some tests by doing fewer loops or items.
- fix a missing backpressure case as Android starts threads much slower (100ms?).
",2015-11-09 12:38:10,2016-02-22 06:37:03,https://api.github.com/repos/ReactiveX/RxJava/issues/3504,['Test'],86,54,ReactiveX_RxJava_pull_3504.diff
ReactiveX/RxJava,"1.x: Gradle Wrapper 2.8, RxJava project plugin 3.0.0","// Actually, I am slowly preparing RxJava for running tests on Android during CI.

Netflix team: PTAL, hope you're ok with new rxjava-project plugin.
",2015-11-09 02:01:30,2015-12-09 01:22:08,https://api.github.com/repos/ReactiveX/RxJava/issues/3501,['Build'],4,4,ReactiveX_RxJava_pull_3501.diff
ReactiveX/RxJava,Some code clean ups.,"Nothing that could change logic or application flow, just minor refactors to be consistent with good practices and clean code.
To sum up changes:
- Simplified some conditions
- Changed small l to L in long number, as l tends to look like 1 and might confuse
- Removed ""return"" statements where those are not necessary (last instruction in function)
- Inlined returns where there were no need for creating new variable (easier to read)
- Deleted unnecessary colons
",2015-11-07 17:10:54,2015-11-08 02:59:38,https://api.github.com/repos/ReactiveX/RxJava/issues/3500,['Cleanup'],36,57,ReactiveX_RxJava_pull_3500.diff
ReactiveX/RxJava,1.x: operator mapIO which is like map but allows checked exceptions,"It comes up quite frequently that one wants to map values and throw exceptions from within the same function (for example, when dealing with blocking IO that may throw `IOException`). It can be inconvenient to use try-catch and gift-wrap the checked exception into a `RuntimeException`.

This PR adds a `Func1E` functional interface which has a generic exception parameter as well and the operator `mapIO` that accepts it. Changing the existing `map` is out of question because of binary compatibility.
",2015-11-06 08:40:04,2015-12-08 22:11:57,https://api.github.com/repos/ReactiveX/RxJava/issues/3499,"['Discussion', 'Enhancement', 'Feature-Request']",286,0,ReactiveX_RxJava_pull_3499.diff
ReactiveX/RxJava,1.x: Rename cache(int) to cacheWithInitialCapacity(int),"~~The parameter is a capacity hint, but more frequently confused with a
buffer size like replay(int) than it is correctly understood. It also
offers no guarantees, only the weak hope of optimization.~~

The parameter is a capacity hint, but more frequently confused with a buffer size like replay(int) than it is correctly understood. It also offers no guarantees, only the weak hope of optimization.

This change renames the method, deprecating the old name. It also adds javadoc calling out that the parameter is not a bound and referencing replay(int).autoConnect() as a way to achieve that behavior.
",2015-11-05 23:02:57,2015-12-10 18:57:03,https://api.github.com/repos/ReactiveX/RxJava/issues/3498,['Discussion'],16,4,ReactiveX_RxJava_pull_3498.diff
ReactiveX/RxJava,2.x: fix takeLast(time) replay behavior causing discontinuity,"The internal queue has to be trimmed while the source is active and the
backpressured-replay shouldn't drop values in case the requests are
delayed relative to each other.
",2015-11-05 18:25:08,2016-02-04 10:10:20,https://api.github.com/repos/ReactiveX/RxJava/issues/3497,['Bug'],64,21,ReactiveX_RxJava_pull_3497.diff
ReactiveX/RxJava,1.x: make just() support backpressure,"One does not simply add backpressure support to `just()`.
## Fixes

The reason for this is the bugs hidden by the lack of backpressure support of just(): the overwriting of a previous Producer by `timeout`, `zip` and `subscribeOn`. I've fixed up `timeout` with a proper `ProducerArbiter`, had to apply the bugfix from #3493 to `zip` (may conflict) and had to rewrite `subscribeOn` from scratch and have it an `OnSubscribe`. This change required that `Single.subscribeOn` to be rewritten as well.
## Benchmark

Let's see the benchmark comparison (i7 4790, Windows 7 x64, Java 8u66):

![image](https://cloud.githubusercontent.com/assets/1269832/10972989/ec1eb288-83db-11e5-951c-48840b165b7e.png)

There are two ways to implement backpressure: with strong atomics or with plain field accesses. The latter tries to exploit the high chance that there won't be concurrent calls to `request()` ever and thus saves on the atomics. As far as I can tell, there is nothing in RxJava 1.x or 2.x that would violate this assumption. However, I added an escape hatch in case of rogue requesters: set the `rx.just.strong-mode` system parameter to ""true"" and `just` will run with strong atomics.

As seen in the table, the weak version is just slightly better (+3-+10%) in some cases and slightly worse (up to -3%) in other cases. Note, however, the original cases have 2x-5x less overhead. 

Maybe the most revealing are the `simple`, `simpleEscape` and `simpleEscapeAll` comparison between and within version. What's seen there is that with the original version, the JIT converted the test into a pure stack-allocation and thus saving on overhead in the `simple` case. As the other tests add escapes, it forces the JIT to do regular allocations. Interesting that with this PR, the escape doesn't really matter: this is due to how `Subscriber.setProducer` makes the JIT believe the producer escapes.

In the `simpleEscapeAll` (which should be the most restrictive for JIT), the overhead is still 2 - 2.3 times bigger: this is due to the extra allocation of a `Producer` instance when subscribing.

If one remembers my recent [blog post](http://akarnokd.blogspot.hu/2015/10/comparison-of-reactive-streams.html), it can be seen that RxJava 2.x does quite well, about 30 Mops/s in the range-1 test (which is equivalent to `simple`). 

Where does the overhead come from? `SubscriptionList`. In 1.x, the `Subscriber` creates a `SubscriptionList` whether or not it is ever required. (I've tried my best several times to defer the creation of this list to no success: the performance improved for some cases while worsened for others, see #3479.)

The strong/weak optimization is not applied to `scalarScheduleOn`. I haven't benchmarked it but I guess the scheduling overhead overshadows it anyways.
## Conclusion

I believe the correctness of `just` is more important than its performance, but the increased overhead bothers me nonetheless. Given the architecture of 2.x, I'll look into ways to get rid of the mandatory `SubscriptionList` allocation without breaking public API classes such as `Subscriber`.
",2015-11-05 16:08:45,2016-01-13 11:48:54,https://api.github.com/repos/ReactiveX/RxJava/issues/3496,"['Bug', 'Enhancement', 'Performance']",12563,3541,ReactiveX_RxJava_pull_3496.diff
ReactiveX/RxJava,1.x: benchmark just() and its optimizations.,"This add a perf class that benchmarks just() and optimizations it allows. I'll use this as a baseline to compare the upcoming backpressure-aware version against.

Benchmark results of throughput (ops/s) (i7 4790, Windows 7 x64, Java 8u66):

![image](https://cloud.githubusercontent.com/assets/1269832/10963349/0d15c6e8-83a0-11e5-9f28-646b57d08879.png)
",2015-11-05 08:32:59,2015-11-05 08:58:54,https://api.github.com/repos/ReactiveX/RxJava/issues/3495,['Performance'],197,0,ReactiveX_RxJava_pull_3495.diff
ReactiveX/RxJava,1.x: fix for zip(Obs<Obs<T>>) backpressure problem,"Reported in #3492.
",2015-11-04 14:17:23,2015-11-11 20:48:04,https://api.github.com/repos/ReactiveX/RxJava/issues/3493,['Bug'],32,2,ReactiveX_RxJava_pull_3493.diff
ReactiveX/RxJava,1.x: make scan's delayed Producer independent of event serialization,"It turns out serializing `request()` calls with regular `onXXX()` calls can be problematic because a `request()` may trigger an emission of events which then end up being queued (since `emitting == true`). If the request is large and the queue otherwise unbounded, this will likely cause OOME.

In case of `scan`, the fix was to make the missing request accounting and arrival of the `Producer` independent of the event's emitter loop; there is no need for them to be serialized in respect to each other.

In case of the `ProducerObserverArbiter` where the request accounting and producer swapping has to be serialized with the value emission, the solution is to call `request()` outside the emitter-loop.

There shouldn't be any issue with 2.x `scan()` because in 2.x, scan receives the `Subscription` before it allows the downstream to request anything so there is no missing requested to be handled.

This should resolve #3490. As far as I can remember, no other operator should have such problems because all others use `ProducerArbiter` which is independent of `onXXX` emission serializations.
",2015-11-04 09:10:39,2015-12-02 19:36:49,https://api.github.com/repos/ReactiveX/RxJava/issues/3491,['Bug'],156,105,ReactiveX_RxJava_pull_3491.diff
ReactiveX/RxJava,1.x Remove all instances of Atomic*FieldUpdater,"Replace them all with their respective Atomic\* counterparts
For example AtomicLongFieldUpdater -> AtomicLong
Addresses https://github.com/ReactiveX/RxJava/issues/3459
",2015-11-03 07:37:43,2015-11-11 10:09:38,https://api.github.com/repos/ReactiveX/RxJava/issues/3488,"['Bug', 'Performance', 'Question']",223,543,ReactiveX_RxJava_pull_3488.diff
ReactiveX/RxJava,1.x: OnBackpressureBuffer: DROP_LATEST and DROP_OLDEST,"Introduce a new interface BackpressureOverflowStrategy that allows implementing different handlers for an overflow situation.  This patch adds three implementations, reachable via OverflowStrategy:

```
static class OverflowStrategy {
    static final BackpressureOverflowStrategy DEFAULT = Error.INSTANCE;
    static final Error ERROR = Error.INSTANCE;
    static final DropOldest DROP_OLDEST = DropOldest.INSTANCE;
    static final DropLatest DROP_LATEST = DropLatest.INSTANCE;
}
```

The behavior for each is the following:
- ERROR remains the default as the existing implementation.
- DROP_LATEST will drop newly produced items after the buffer fills up.
- DROP_OLDEST will drop the oldest elements in the buffer, making room for
  newer ones.

In all cases, a drop will result in a notification to the producer by invoking the onOverflow callback.

None of the two new behaviours (DROP_*) will unsubscribe from the source nor onError.
",2015-11-02 20:07:28,2016-03-17 17:58:36,https://api.github.com/repos/ReactiveX/RxJava/issues/3487,"['Enhancement', 'Feature-Request']",308,48,ReactiveX_RxJava_pull_3487.diff
ReactiveX/RxJava,1.x: Remove unused imports,,2015-11-02 17:04:10,2015-11-09 07:54:12,https://api.github.com/repos/ReactiveX/RxJava/issues/3486,['Cleanup'],0,2,ReactiveX_RxJava_pull_3486.diff
ReactiveX/RxJava,1.x: fix scan() not accepting a null initial value,"I forgot a NotificationLite conversion in the constructor. Note that
there were no tests verifying null behavior at all.
",2015-11-02 15:41:34,2015-11-03 23:18:24,https://api.github.com/repos/ReactiveX/RxJava/issues/3485,['Bug'],39,1,ReactiveX_RxJava_pull_3485.diff
ReactiveX/RxJava,1.x: update and bugfix to SubscribingPerf,"Note: this doesn't change any main class, just a perf class.
- Two of the tests used the wrong subscriber type.
- The benchmark layout allowed stack allocation instead of heap allocation and thus showing less overhead than expected. By letting consuming the `Subscriber`s via blackhole, this JIT optimization is negated as it should be.
- Added a benchmark which should help verify the overhead of checking `isUnsubscribed` within range in #3479 because I suspect that will get worse there.

Benchmark values: (i7 **4790**, Windows 7 x64, Java 8u66):

![image](https://cloud.githubusercontent.com/assets/1269832/10813246/16cbe7e4-7e1e-11e5-8de6-5bc1ffdb2739.png)
",2015-10-29 08:20:09,2015-10-29 08:31:30,https://api.github.com/repos/ReactiveX/RxJava/issues/3480,"['Bug', 'Performance']",71,12,ReactiveX_RxJava_pull_3480.diff
ReactiveX/RxJava,1.x: reduce Subscriber's creation overhead,"This PR changes the internals of the `Subscriber` class to reduce its creation overhead by deferring the creation of the SubscriptionList until it is actually needed.

Benchmark (i7 4770K, Windows 7 x64, Java 8u66)

![image](https://cloud.githubusercontent.com/assets/1269832/10806351/14e6567e-7dd5-11e5-8c06-3716454ccbc7.png)

For no-backpressure sources, the throughput is now doubled for the safe case and improved by ~20% for the unsafe case. For a backpressuring source, the improvement is between 3-10% but the error ranges overlap.

There is one case where the the throughput halved for some reason. Since JITs are smart, my best guess is that generally the benchmark method gets stack-allocated instead of heap allocated, hence the very large amounts relative to a range(1, 1) benchmark (which tops at 24 MOps/s). 

However, the justStart case is worse than the baseline. My guess is that the `this` looks like it escaped and thus a regular heap allocation is required. I'll test this theory in the morning by blackholing the test `Subscriber`s before subscription thus forcing a heap allocation in each case.

Note that `Subscriber` has now more synchronization which combined with the synchronization in `SubscriptionList` may increase the overhead elsewhere; I plan to run more benchmarks in the morning. The solution would be to inline the logic of `SubscriptionList` into `Subscriber` directly. 

Note also the recursive call to `add` and `unsubscribe` in case the `Subscriber` was created in sharing mode. In RxJava 1.x, operators like to share a single underlying `SubscriptionList` and if the chain is very long, that may prevent some JIT optimizations due to stack dept. The upside is that generally only a few resources are added to a `Subscriber`, especially in async operators, whose overhead may be shadowed by other things and thus not really a problem.
",2015-10-28 23:50:12,2015-10-29 08:42:26,https://api.github.com/repos/ReactiveX/RxJava/issues/3479,"['Enhancement', 'Performance']",135,42,ReactiveX_RxJava_pull_3479.diff
ReactiveX/RxJava,1.x: perf benchmark for the cost of subscribing,"This PR adds a perf test that measures what it takes to subscribe to a
non-backpressured and backpressured source and what is the effect of the
mini-arbitration inside Subscriber.

This should enable investigations into why generally 1.x subscriptions have more overhead than 2.x.

Benchmark (i7 4770K, Windows 7 x64, Java 8u66):

![image](https://cloud.githubusercontent.com/assets/1269832/10804298/023f5772-7dc7-11e5-8cf4-abe03c1ab725.png)

Direct overrides `setProducer` and requests directly. Started requests in the `onStart` method and Usual requests in the constructor.
",2015-10-28 21:41:04,2015-10-28 21:57:16,https://api.github.com/repos/ReactiveX/RxJava/issues/3478,['Performance'],182,0,ReactiveX_RxJava_pull_3478.diff
ReactiveX/RxJava,1.x: add a source OnSubscribe which works from an array directly,"This specialized OnSubscribe performs ~33% better on longer streams.

Benchmark comparison (i7 4770K, Windows 7 x64, Java 8u66):

![image](https://cloud.githubusercontent.com/assets/1269832/10802983/1ef4027a-7dc0-11e5-996a-9e9cf7033ed3.png)

The `slowpath` requests the available amount + 1 to trigger a slow path, `slowpath2` requests in batches of 128 and replenishes only after all were received.
",2015-10-28 21:08:30,2015-12-15 21:11:42,https://api.github.com/repos/ReactiveX/RxJava/issues/3477,"['Enhancement', 'Performance']",343,18,ReactiveX_RxJava_pull_3477.diff
ReactiveX/RxJava,1.x: overhead reduction for merge and flatMap,"Changes to the scalar fast-path was inspired by the Project Reactor's `flatMap` which was in turn inspired by RxJava 2.x's implementation of `flatMap`.

**Naturally, this will conflict with #3169 .**

Benchmark for comparison (i7 4770K, Windows 7 x64, Java 8u66):

![image](https://cloud.githubusercontent.com/assets/1269832/10799061/27b6ff8a-7dab-11e5-8580-6dbbacadf430.png)

Just by applying the scalar re-batching, the operator gained a massive 45% throughput increase, from **48 MOps/s** to **71 MOps/s**.

When the range optimization is also applied, the improvement is even more impressive:  +60% throughput, from **48 MOps/s** to **79 MOps/s**.

The optimization doesn't really affect `rangeFlatMapRange`, it has a larger run-to-run variance due to GC.

I'm experimenting with the 2.x branch as well and by applying these two optimizations, the throughput increasd from **40 MOps/s** to **58 MOps/s**. I'm investigating if switching to synchronized would help with the remaining overhead gap.

Note also that the perf tests measure the operator overhead only.
",2015-10-28 18:46:16,2016-02-21 23:25:45,https://api.github.com/repos/ReactiveX/RxJava/issues/3476,"['Enhancement', 'Performance']",76,56,ReactiveX_RxJava_pull_3476.diff
ReactiveX/RxJava,1.x: benchmark range + flatMap throughput.,"The current baseline on i7 4770K, Windows 7 x64, Java 8u66:

```
Benchmark           (times)   Mode   Samples        Score  Score error    Units
rangeFlatMapJust          1  thrpt         5 24242025,899  2299703,654    ops/s
rangeFlatMapJust         10  thrpt         5  2536987,139   153629,364    ops/s
rangeFlatMapJust       1000  thrpt         5    54154,325     4014,598    ops/s
rangeFlatMapJust    1000000  thrpt         5       48,638        7,591    ops/s
rangeFlatMapRange         1  thrpt         5  9331777,291   531241,251    ops/s
rangeFlatMapRange        10  thrpt         5   388606,708    22875,097    ops/s
rangeFlatMapRange      1000  thrpt         5     4164,424      266,850    ops/s
rangeFlatMapRange   1000000  thrpt         5        4,354        0,575    ops/s
```
",2015-10-28 17:58:48,2015-10-28 18:08:06,https://api.github.com/repos/ReactiveX/RxJava/issues/3475,['Performance'],73,0,ReactiveX_RxJava_pull_3475.diff
ReactiveX/RxJava,Fix indentation,,2015-10-28 01:40:14,2015-11-10 07:36:26,https://api.github.com/repos/ReactiveX/RxJava/issues/3474,['Cleanup'],26,11,ReactiveX_RxJava_pull_3474.diff
ReactiveX/RxJava,1.x: replay request coordination reduce overhead,"Reported in #3469.

This change will make sure whenever a new subscriber arrives, the
request coordination doesn't scan every other subscriber unnecessary.
(They will trigger a manageRequests individually anyway).

Unfortunately, I can't make the subscription registration constant (via a HashSet) because that would slow down the dispatching loop (which is quite expensive to for-each over compared to a plain array).

Note also that this will likely conflict with #3454.

I get the following numbers with the program in #3469.

```
subscribing...
subscribed so far 10000; took 54ms to subscribe last 10000 at rate: 185185 per sec...
subscribed so far 20000; took 110ms to subscribe last 10000 at rate: 90909 per sec...
subscribed so far 30000; took 157ms to subscribe last 10000 at rate: 63694 per sec...
subscribed so far 40000; took 267ms to subscribe last 10000 at rate: 37453 per sec...
subscribed so far 50000; took 211ms to subscribe last 10000 at rate: 47393 per sec...
subscribed so far 60000; took 320ms to subscribe last 10000 at rate: 31250 per sec...
subscribed so far 70000; took 331ms to subscribe last 10000 at rate: 30211 per sec...
subscribed so far 80000; took 369ms to subscribe last 10000 at rate: 27100 per sec...
subscribed so far 90000; took 415ms to subscribe last 10000 at rate: 24096 per sec...
subscribed so far 100000; took 462ms to subscribe last 10000 at rate: 21645 per sec...
subscribed so far 110000; took 516ms to subscribe last 10000 at rate: 19379 per sec...
subscribed so far 120000; took 547ms to subscribe last 10000 at rate: 18281 per sec...
subscribed so far 130000; took 647ms to subscribe last 10000 at rate: 15455 per sec...
subscribed so far 140000; took 720ms to subscribe last 10000 at rate: 13888 per sec...
subscribed so far 150000; took 811ms to subscribe last 10000 at rate: 12330 per sec...
subscribed so far 160000; took 806ms to subscribe last 10000 at rate: 12406 per sec...
subscribed so far 170000; took 873ms to subscribe last 10000 at rate: 11454 per sec...
subscribed so far 180000; took 911ms to subscribe last 10000 at rate: 10976 per sec...
subscribed so far 190000; took 986ms to subscribe last 10000 at rate: 10141 per sec...
subscribed so far 200000; took 1003ms to subscribe last 10000 at rate: 9970 per sec...
subscribed so far 210000; took 1168ms to subscribe last 10000 at rate: 8561 per sec...
subscribed so far 220000; took 1213ms to subscribe last 10000 at rate: 8244 per sec...
subscribed so far 230000; took 1340ms to subscribe last 10000 at rate: 7462 per sec...
subscribed so far 240000; took 1314ms to subscribe last 10000 at rate: 7610 per sec...
subscribed so far 250000; took 1548ms to subscribe last 10000 at rate: 6459 per sec...
subscribed so far 260000; took 1372ms to subscribe last 10000 at rate: 7288 per sec...
subscribed so far 270000; took 1835ms to subscribe last 10000 at rate: 5449 per sec...
subscribed so far 280000; took 2087ms to subscribe last 10000 at rate: 4791 per sec...
subscribed so far 290000; took 1910ms to subscribe last 10000 at rate: 5235 per sec...
subscribed so far 300000; took 1966ms to subscribe last 10000 at rate: 5086 per sec...
unsubscribing...
unsubscribed so far 10000; took 1910ms to unsubscribe last 10000 at rate: 5235 per sec...
unsubscribed so far 20000; took 1782ms to unsubscribe last 10000 at rate: 5611 per sec...
unsubscribed so far 30000; took 1730ms to unsubscribe last 10000 at rate: 5780 per sec...
unsubscribed so far 40000; took 1593ms to unsubscribe last 10000 at rate: 6277 per sec...
unsubscribed so far 50000; took 1514ms to unsubscribe last 10000 at rate: 6605 per sec...
unsubscribed so far 60000; took 1468ms to unsubscribe last 10000 at rate: 6811 per sec...
unsubscribed so far 70000; took 1188ms to unsubscribe last 10000 at rate: 8417 per sec...
unsubscribed so far 80000; took 1234ms to unsubscribe last 10000 at rate: 8103 per sec...
unsubscribed so far 90000; took 1271ms to unsubscribe last 10000 at rate: 7867 per sec...
unsubscribed so far 100000; took 1358ms to unsubscribe last 10000 at rate: 7363 per sec...
unsubscribed so far 110000; took 1103ms to unsubscribe last 10000 at rate: 9066 per sec...
unsubscribed so far 120000; took 1100ms to unsubscribe last 10000 at rate: 9090 per sec...
unsubscribed so far 130000; took 990ms to unsubscribe last 10000 at rate: 10101 per sec...
unsubscribed so far 140000; took 953ms to unsubscribe last 10000 at rate: 10493 per sec...
unsubscribed so far 150000; took 854ms to unsubscribe last 10000 at rate: 11709 per sec...
unsubscribed so far 160000; took 789ms to unsubscribe last 10000 at rate: 12674 per sec...
unsubscribed so far 170000; took 779ms to unsubscribe last 10000 at rate: 12836 per sec...
unsubscribed so far 180000; took 624ms to unsubscribe last 10000 at rate: 16025 per sec...
unsubscribed so far 190000; took 634ms to unsubscribe last 10000 at rate: 15772 per sec...
unsubscribed so far 200000; took 514ms to unsubscribe last 10000 at rate: 19455 per sec...
unsubscribed so far 210000; took 411ms to unsubscribe last 10000 at rate: 24330 per sec...
unsubscribed so far 220000; took 373ms to unsubscribe last 10000 at rate: 26809 per sec...
unsubscribed so far 230000; took 337ms to unsubscribe last 10000 at rate: 29673 per sec...
unsubscribed so far 240000; took 286ms to unsubscribe last 10000 at rate: 34965 per sec...
unsubscribed so far 250000; took 234ms to unsubscribe last 10000 at rate: 42735 per sec...
unsubscribed so far 260000; took 222ms to unsubscribe last 10000 at rate: 45045 per sec...
unsubscribed so far 270000; took 159ms to unsubscribe last 10000 at rate: 62893 per sec...
unsubscribed so far 280000; took 96ms to unsubscribe last 10000 at rate: 104166 per sec...
unsubscribed so far 290000; took 63ms to unsubscribe last 10000 at rate: 158730 per sec...
unsubscribed so far 300000; took 31ms to unsubscribe last 10000 at rate: 322580 per sec...
```
",2015-10-26 21:06:54,2016-06-15 18:17:47,https://api.github.com/repos/ReactiveX/RxJava/issues/3470,['Performance'],435,111,ReactiveX_RxJava_pull_3470.diff
ReactiveX/RxJava,1.x: Fix other places that may swallow OnErrorFailedException,"Reviewed all usages of `OnErrorNotImplementedException` and fixed issues similar to #3455.
",2015-10-24 05:18:58,2015-11-04 06:00:35,https://api.github.com/repos/ReactiveX/RxJava/issues/3468,['Bug'],117,19,ReactiveX_RxJava_pull_3468.diff
ReactiveX/RxJava,1.x: compensation for significant clock drifts in schedulePeriodically,"There is a problem, reported in #3461 and #2943, in which if the system clock drifts, the periodic calculation inside Scheduler.Worker gets off and either taking a longer time for the next invocation of the task or doing ""catching-up"" with all the lost invocations.

The solution checks the wall clock difference between the last run and the current run and if it went back or forward significantly, it rebases the timer period and schedules the next execution relative to now.

If the clock goes back, the original code scheduled the next invocation way into the future. This PR will schedule it after the period.

If the clock goes forward, the original code scheduled executions for all the missed time between the last run and the new time immediately, yielding a bunch of 0 delays. This PR will simply schedule the next invocation after the period.

The algorithm for both cases is the same: make sure the next invocation is scheduled relative to now and recalculate the start timestamp as if the whole sequence run under the new drifted clock all along. The subsequent invocations will be scheduled at a fixed rate again.

I've added the system parameter `rx.scheduler.drift-tolerance` (unit: minutes, default: 15 minutes), which is used to determine if the clock drifted too far between invocations of the periodic task.
",2015-10-22 13:36:45,2015-12-15 00:48:19,https://api.github.com/repos/ReactiveX/RxJava/issues/3467,['Bug'],189,4,ReactiveX_RxJava_pull_3467.diff
ReactiveX/RxJava,2.x: fix Subscribers.create not requesting anything,"I forgot to request Long.MAX_VALUE in 3 of the `Subscribers.create`
overloads.
",2015-10-22 12:14:03,2016-02-04 10:10:30,https://api.github.com/repos/ReactiveX/RxJava/issues/3465,['Bug'],33,3,ReactiveX_RxJava_pull_3465.diff
ReactiveX/RxJava,1.x: A minor doc fix for `interval`,,2015-10-20 13:18:21,2015-10-20 13:39:11,https://api.github.com/repos/ReactiveX/RxJava/issues/3462,['Documentation'],1,1,ReactiveX_RxJava_pull_3462.diff
ReactiveX/RxJava,2.x: platform-aware purge/removeOnCancelPolicy management.,"This PR adds the `SchedulerPoolHelper` class which manages creating
`ScheduledExecutorService`s for the standard schedulers and wires them
up to work properly with JDK 6 `purge` or JDK 7 `removeOnCancelPolicy`,
depending on if the platform supports it or not.

Since the 2.0 is aimed at desktop and will be automatically backported
to JDK 6 level, the desktop (JDK 8) test have to verify both modes.
",2015-10-19 11:41:45,2016-02-04 10:11:28,https://api.github.com/repos/ReactiveX/RxJava/issues/3460,['Enhancement'],477,125,ReactiveX_RxJava_pull_3460.diff
ReactiveX/RxJava,Clarify contracts of CompositeSubscription in its javadoc,"Current state of `CompositeSubscription`'s javadoc — totally misleading :smile: 

Every time we need to store some subscriptions in it then clear them and leave `CompositeSubscription` in an operable state we have to read its sources because its actual behavior is not consistent with the javadoc.

`CompositeSubscription.clear()` leaves `CompositeSubscription` in operable state, when on the other hand `CompositeSubscription.unsubscribe()` sets `isUnsubscribed = true` and `CompositeSubscription` is not able to manage new subscriptions.
",2015-10-17 02:27:15,2015-10-18 07:07:38,https://api.github.com/repos/ReactiveX/RxJava/issues/3458,['Documentation'],9,2,ReactiveX_RxJava_pull_3458.diff
ReactiveX/RxJava,Begin the steps to release 1.0.15,"Can get two more :+1: from the committers.
",2015-10-17 00:51:28,2015-10-30 20:23:05,https://api.github.com/repos/ReactiveX/RxJava/issues/3456,['Discussion'],38,0,ReactiveX_RxJava_pull_3456.diff
ReactiveX/RxJava,OnErrorFailedException fix,"https://github.com/ReactiveX/RxJava/issues/2998
",2015-10-16 21:41:48,2015-10-20 19:53:11,https://api.github.com/repos/ReactiveX/RxJava/issues/3455,"['Bug', 'Enhancement']",71,16,ReactiveX_RxJava_pull_3455.diff
ReactiveX/RxJava,1.x: fix: bounded replay() not requesting enough for latecommers,"Fixes the bug reported in #3452.

The fix involves 3 changes:
- First, each node in the bounded buffer receives an incrementing index whenever they are created. The root node starts with 0, the first value's index will be 1 and so on.
- In the replay logic, the very first time the current node is captured, the node's index is added to the totalRequested amount of the subscriber. Since this is always one less than the max requested that far, there is no point in calling `manageRequests()` at this point.
- Third, the pinning of the current node has to happen before the child requests, otherwise the difference would manifest before the compensation and some elements may get missed.

In addition, there was a missing `r--` in the emission loop and thus the operator could have overflown its child subscriber.
",2015-10-16 20:36:57,2015-12-14 19:10:32,https://api.github.com/repos/ReactiveX/RxJava/issues/3454,['Bug'],142,15,ReactiveX_RxJava_pull_3454.diff
ReactiveX/RxJava,1.x: Change the signature of ignoreElements is also an implicit cast to whatever type you want.,"to remove the need for mergeWithEmpty and concatWithEmpty in #3430.  I'm pretty sure that this doesn't count as a breaking change because of type erasure.
",2015-10-16 18:23:29,2015-12-14 19:03:29,https://api.github.com/repos/ReactiveX/RxJava/issues/3451,['Enhancement'],8,8,ReactiveX_RxJava_pull_3451.diff
ReactiveX/RxJava,2.x: Remove duplication of Optional API behavior.,"get() throws NSE when absent and orElse(T) returns the provided value when absent.
",2015-10-16 01:03:26,2016-01-11 05:54:50,https://api.github.com/repos/ReactiveX/RxJava/issues/3449,['Enhancement'],12,56,ReactiveX_RxJava_pull_3449.diff
ReactiveX/RxJava,Single delay,"Adds the `delay(long delay, TimeUnit unit, Scheduler
scheduler)` and 'delay(long delay, TimeUnit unit)`operators to
`rx.Single`.

Includes (in a separate commit) a refactor of `OperatorDelay`. As far as I can tell, the `source` field isn't used at all - by removing it, I was able to reuse `OperatorDelay` in `rx.Single` to implement the delay operator pretty easily.
",2015-10-15 04:29:24,2015-10-16 23:57:27,https://api.github.com/repos/ReactiveX/RxJava/issues/3448,['Enhancement'],93,6,ReactiveX_RxJava_pull_3448.diff
ReactiveX/RxJava,1.x: DelaySubscription with a plain other Observable.,"Requested in #3445.

This is an efficient implementation as it avoids allocating the lifter object, doesn't require a function wrapper and doesn't use producer arbitration.

(Bonus points to those who can recognize the similarities with #3446).
",2015-10-14 18:58:31,2015-12-09 01:15:29,https://api.github.com/repos/ReactiveX/RxJava/issues/3447,"['Enhancement', 'Feature-Request']",351,0,ReactiveX_RxJava_pull_3447.diff
ReactiveX/RxJava,1.x: Completable class to support valueless event composition + tests,"This is a backport of #3439.
",2015-10-14 11:20:19,2015-12-07 22:59:52,https://api.github.com/repos/ReactiveX/RxJava/issues/3444,['Enhancement'],6795,0,ReactiveX_RxJava_pull_3444.diff
ReactiveX/RxJava,1.x: Observable.ignoreElementsThen,"As discussed in #3113.

I also considered on a consistency basis calling it `ignoreElementsWith` but I don't think it carries the same clarity of meaning like `startWith` or `concatWith`. ""ignore"" and ""then"" seems to be a more natural combination in English to capture the sequential nature.
",2015-10-14 05:42:10,2015-12-11 22:44:23,https://api.github.com/repos/ReactiveX/RxJava/issues/3443,"['Enhancement', 'Feature-Request']",55,0,ReactiveX_RxJava_pull_3443.diff
ReactiveX/RxJava,2.x: Completable class for valueless event composition.,"I saw this mentioned in [this talk](https://www.youtube.com/watch?v=ET_SMMXkE5s) from @benjchristensen 

This PR adds a new class `Completable` which allows composing events
that never want to fire `onNext`, but only `onError` or `onComplete`. It
is built upon the same Reactive-Streams principles as `Single`,
`NbpObservable` and `Observable`.

I've added most methods that made sense and left out the others (such as
`map` and `flatMap`) that would require at least a single value.

Depending on whether this type is actually required, I'll add unit test to this PR or in a new PR in case this gets merged.
",2015-10-12 15:03:11,2016-02-04 10:11:42,https://api.github.com/repos/ReactiveX/RxJava/issues/3439,['Enhancement'],6636,0,ReactiveX_RxJava_pull_3439.diff
ReactiveX/RxJava,Better null tolerance in rx.exceptions.*Exception classes.,"There seems to be a tendency to send `null` values through `onError` which eventually causes repeated failures. This PR converts these `null` values into `NullPointerException`s so the error origin is can be discovered and prevents the XXXExceptions from throwing NPEs in their constructors as well.

I've also added some missing javadoc.
",2015-10-12 06:16:19,2015-10-19 11:59:34,https://api.github.com/repos/ReactiveX/RxJava/issues/3438,['Bug'],161,15,ReactiveX_RxJava_pull_3438.diff
ReactiveX/RxJava,1.x: Add action != null check in OperatorFinally,"Part of #3435.

Personally, I'd also add same test to `Observable.finallyDo()` and `Single.finallyDo()` because there are no guarantees that in future they will use exact same operator as implementation and this contract is more a contract of `Observable.finallyDo()` and `Single.finallyDo()`.
",2015-10-10 17:34:06,2015-11-13 08:28:38,https://api.github.com/repos/ReactiveX/RxJava/issues/3436,['Bug'],15,0,ReactiveX_RxJava_pull_3436.diff
ReactiveX/RxJava,Add Single.finallyDo(),"@akarnokd I've found a problem with `null` action, I'll create separate issue about this soon.
",2015-10-10 16:49:31,2015-12-09 08:33:23,https://api.github.com/repos/ReactiveX/RxJava/issues/3434,['Enhancement'],73,1,ReactiveX_RxJava_pull_3434.diff
ReactiveX/RxJava,Add Single.defer(),,2015-10-10 14:23:05,2015-11-11 16:45:45,https://api.github.com/repos/ReactiveX/RxJava/issues/3433,['Enhancement'],173,0,ReactiveX_RxJava_pull_3433.diff
ReactiveX/RxJava,New operators: `concatEmptyWith` and `mergeEmptyWith`,"As discussed in issue #3037, the primary use of these operators is to be applied to `Observable<Void>` so that they can be merged and concatenated with an Observable of a different type.

Both these operators raise an error if the source Observable emits any item.
",2015-10-09 21:18:14,2015-12-14 22:46:49,https://api.github.com/repos/ReactiveX/RxJava/issues/3430,['Enhancement'],716,0,ReactiveX_RxJava_pull_3430.diff
ReactiveX/RxJava,Removed the alias BlockingObservable#run,,2015-10-09 18:56:11,2015-10-09 20:27:48,https://api.github.com/repos/ReactiveX/RxJava/issues/3429,[],4,12,ReactiveX_RxJava_pull_3429.diff
ReactiveX/RxJava,GroupBy backpressure fix,"This is a backport of the 2.x GroupBy operator which solves #3425.

One unit test in OperatorRetryTest had to be altered a bit. I believe
the original code relied on a GroupBy behavior which caused the bug in
#3425.
",2015-10-09 18:51:46,2015-12-07 19:35:08,https://api.github.com/repos/ReactiveX/RxJava/issues/3428,['Bug'],579,364,ReactiveX_RxJava_pull_3428.diff
ReactiveX/RxJava,2.x: fix GroupBy MissingBackpressureException due to main/group overflow,"The problem with GroupBy is that a request(1) from the main source may
result in a new group, a value for another group or value for the
intended group. The latter two is handled by unicasting but the former
was not properly handled.
",2015-10-09 09:13:18,2016-02-04 10:11:50,https://api.github.com/repos/ReactiveX/RxJava/issues/3426,['Bug'],242,41,ReactiveX_RxJava_pull_3426.diff
ReactiveX/RxJava,Added Runnable interface to BlockingObservable,,2015-10-08 22:52:21,2015-10-09 18:53:36,https://api.github.com/repos/ReactiveX/RxJava/issues/3424,[],1,1,ReactiveX_RxJava_pull_3424.diff
ReactiveX/RxJava,Renaming Observable#x to Observable#extend,,2015-10-08 19:06:37,2015-10-08 20:15:41,https://api.github.com/repos/ReactiveX/RxJava/issues/3423,[],4,4,ReactiveX_RxJava_pull_3423.diff
ReactiveX/RxJava,Update README.md,"Slight change to make the distinction between `@Beta` and `@Experimental` explicit and meaningful.
",2015-10-08 17:21:59,2015-10-08 19:10:49,https://api.github.com/repos/ReactiveX/RxJava/issues/3422,['Documentation'],3,3,ReactiveX_RxJava_pull_3422.diff
ReactiveX/RxJava,Add Single.doOnError(),,2015-10-08 03:17:19,2015-10-08 22:44:28,https://api.github.com/repos/ReactiveX/RxJava/issues/3419,['Enhancement'],106,0,ReactiveX_RxJava_pull_3419.diff
ReactiveX/RxJava,Add Single.fromCallable(),"Second part of #3154.

@akarnokd I'd like to reuse `Observable.fromCallable()` but didn't find apropriate way to do it: `Observable.fromCallable().toSingle()` is not best option, if you have some thoughts on this — please share them.
",2015-10-08 03:02:24,2015-10-09 00:13:53,https://api.github.com/repos/ReactiveX/RxJava/issues/3418,['Enhancement'],78,0,ReactiveX_RxJava_pull_3418.diff
ReactiveX/RxJava,Add Single.doOnSuccess(),"Closes #3385.
",2015-10-08 02:41:02,2015-10-09 01:54:21,https://api.github.com/repos/ReactiveX/RxJava/issues/3417,['Enhancement'],112,0,ReactiveX_RxJava_pull_3417.diff
ReactiveX/RxJava,Add Single.toBlocking(),"Closes #3252.
",2015-10-08 02:15:13,2015-10-08 15:16:48,https://api.github.com/repos/ReactiveX/RxJava/issues/3416,['Enhancement'],298,28,ReactiveX_RxJava_pull_3416.diff
ReactiveX/RxJava,Deprecate the Experimental/Beta method that will be deleted until 1.1.x,"Squashed commits:
[c6e43fc] 1.0.15. Beta/Deprecation of Subject state peeking methods.

This should give users one release to prepare for the class structure
changes.
",2015-10-07 23:35:05,2015-10-07 23:36:17,https://api.github.com/repos/ReactiveX/RxJava/issues/3415,[],74,0,ReactiveX_RxJava_pull_3415.diff
ReactiveX/RxJava,2.x: fix operator Amb eager cancellation and request validation,"Discovered while reviewing the operator for my blog post.
",2015-10-07 08:13:23,2016-02-04 10:11:57,https://api.github.com/repos/ReactiveX/RxJava/issues/3414,['Bug'],65,4,ReactiveX_RxJava_pull_3414.diff
ReactiveX/RxJava,2.x: fix to ReplaySubject not properly accounting for emitted events.,"The subject tries to avoid the request reduction via addAndGet by re-reading the requested amount and continuing the loop as long as possible. The bug was in ignoring the total emission amount and thus a single request(1) from the child ended up replaying all values.
",2015-10-06 11:34:28,2016-02-04 10:12:05,https://api.github.com/repos/ReactiveX/RxJava/issues/3413,['Bug'],95,6,ReactiveX_RxJava_pull_3413.diff
ReactiveX/RxJava,2.x: null safety checks and fixes,"This PR adds over 900 new null checks. Null checks are essential because RS doesn't allow null values and sometimes a missed null check may lead to operator hangs as well.
",2015-10-04 07:04:13,2016-02-04 10:12:12,https://api.github.com/repos/ReactiveX/RxJava/issues/3410,"['Bug', 'Test']",4865,46,ReactiveX_RxJava_pull_3410.diff
ReactiveX/RxJava,DoOnEach: report both original exception and callback exception.,"This came up in a [Stackoverflow](http://stackoverflow.com/questions/32889008/do-operators-instead-of-a-whole-subscriber) answer. If the `doOnError`'s callback or the `doOnEach`'s `onError` method throws, any non-fatal exception replaced the original error which got lost. This PR will wrap them both into a `CompositeException`.

2.x note: since Java 8 supports `addSuppressed` all callbacks in this situation either attach to the original exception or the original exception is attached to the callback's exception.
",2015-10-02 07:08:30,2015-10-07 23:46:39,https://api.github.com/repos/ReactiveX/RxJava/issues/3408,['Bug'],45,17,ReactiveX_RxJava_pull_3408.diff
ReactiveX/RxJava,1.0.15. Beta/Deprecation of Subject state peeking methods.,"This should give users one release to prepare for the class structure
changes.
",2015-10-01 18:40:38,2015-10-07 23:35:55,https://api.github.com/repos/ReactiveX/RxJava/issues/3407,['Discussion'],101,50,ReactiveX_RxJava_pull_3407.diff
ReactiveX/RxJava,1.1.0: promote doOnRequest to be part of the public API,"Based on the majority of votes, doOnRequest can now be part of the
public API.
",2015-10-01 09:26:19,2015-10-07 23:38:16,https://api.github.com/repos/ReactiveX/RxJava/issues/3405,['Discussion'],1,2,ReactiveX_RxJava_pull_3405.diff
ReactiveX/RxJava,1.1.0: promote Subscriptions.unsubscribed to be part of the public API,"Based on unanimous votes, Subscriptions.unsubscribed can now be part of
the public API.
",2015-10-01 09:23:57,2015-12-03 19:38:51,https://api.github.com/repos/ReactiveX/RxJava/issues/3404,['Discussion'],1,3,ReactiveX_RxJava_pull_3404.diff
ReactiveX/RxJava,1.1.0: promote Subscribers.wrap to be part of the public API,"Based on votes, Subscribers.wrap can now be part of the public API.
",2015-10-01 09:21:51,2015-12-03 19:38:51,https://api.github.com/repos/ReactiveX/RxJava/issues/3403,['Discussion'],3,7,ReactiveX_RxJava_pull_3403.diff
ReactiveX/RxJava,1.1.0: Promote 2 RxJavaErrorHandler methods to Beta,"Based on votes, RxJavaErrorHandler.render and
RxJavaErrorHandler.handleOnNextValueRendering can now be promoted to
Beta state.
",2015-10-01 09:19:35,2015-12-03 19:38:51,https://api.github.com/repos/ReactiveX/RxJava/issues/3402,['Discussion'],4,5,ReactiveX_RxJava_pull_3402.diff
ReactiveX/RxJava,1.1.0: promote Single + SingleSubscriber to Beta,"Based on votes, Single, SingleSubscriber and Observable.toSingle can now
be promoted to Beta state.
",2015-10-01 09:16:32,2015-12-03 19:38:51,https://api.github.com/repos/ReactiveX/RxJava/issues/3401,['Discussion'],11,29,ReactiveX_RxJava_pull_3401.diff
ReactiveX/RxJava,1.1.0: Exceptions.throwIfAny promotion to public API,"Based on votes, the method Exceptions.throwIfAny can now be part of the
public API.
",2015-10-01 08:55:19,2015-12-03 19:38:51,https://api.github.com/repos/ReactiveX/RxJava/issues/3400,['Discussion'],1,1,ReactiveX_RxJava_pull_3400.diff
ReactiveX/RxJava,1.1.0: promote switchIfEmpty with Observable to the public API,"Based on unanimous votes, the switchIfEmpty overload with Observable can
now be part of the public API.
",2015-10-01 08:52:14,2015-12-03 19:38:51,https://api.github.com/repos/ReactiveX/RxJava/issues/3399,['Discussion'],1,2,ReactiveX_RxJava_pull_3399.diff
ReactiveX/RxJava,1.1.0: BackpressureDrainManager promotion to public internal API?!,"Based on votes, the BackpressureDrainManager class can drop the
experimental tag, but since it is an internal class, this change doesn't
affect the public API. Not sure why I marked the class as experimental
back then.
",2015-10-01 08:49:39,2015-12-03 19:38:51,https://api.github.com/repos/ReactiveX/RxJava/issues/3398,['Discussion'],3,2,ReactiveX_RxJava_pull_3398.diff
ReactiveX/RxJava,1.1.0: onBackpressureLatest promotion to public API,"Based on votes, onBackpressureLatest can become part of the public API.
",2015-10-01 08:46:07,2015-12-03 19:38:51,https://api.github.com/repos/ReactiveX/RxJava/issues/3397,['Discussion'],1,2,ReactiveX_RxJava_pull_3397.diff
ReactiveX/RxJava,1.1.0: onBackpressureDrop with action promotion to public API,"Based on unanimous votes, the callback version of onBackpressureDrop can
now be part of the public API.
",2015-10-01 08:44:27,2015-12-03 19:38:50,https://api.github.com/repos/ReactiveX/RxJava/issues/3396,['Discussion'],1,2,ReactiveX_RxJava_pull_3396.diff
ReactiveX/RxJava,1.1.0: onBackpressureBuffer overloads promotion to public API,"Based on votes, the onBackpressureBuffer overloads of capacity and
capacity + overflow action can now be part of the public API.
",2015-10-01 08:41:43,2015-12-03 19:38:50,https://api.github.com/repos/ReactiveX/RxJava/issues/3395,['Discussion'],2,4,ReactiveX_RxJava_pull_3395.diff
ReactiveX/RxJava,1.1.0: Promote 2 merge overloads to public,"Based on votes, 2 maxConcurrency overload of merge can now be part of
the public API.
",2015-10-01 08:38:03,2015-12-03 19:38:50,https://api.github.com/repos/ReactiveX/RxJava/issues/3394,['Discussion'],2,4,ReactiveX_RxJava_pull_3394.diff
ReactiveX/RxJava,1.1.0: promote TestSubscriber methods to public,"Based on votes, the experimental TestSubscriber methods can now be part
of the public API.

In addition, I've added the missing javadocs for the create() factory
methods and one of the constructors.
",2015-10-01 08:29:40,2015-12-03 19:38:50,https://api.github.com/repos/ReactiveX/RxJava/issues/3393,['Discussion'],64,29,ReactiveX_RxJava_pull_3393.diff
ReactiveX/RxJava,1.1.0: takeUntil with predicate promote to public,"Based on votes, the predicate version of `takeUntil` should be promoted to be public.
",2015-10-01 08:16:40,2015-12-03 19:38:50,https://api.github.com/repos/ReactiveX/RxJava/issues/3392,['Discussion'],1,4,ReactiveX_RxJava_pull_3392.diff
ReactiveX/RxJava,1.1.0: promote ConnectableObservable.autoConnect to beta,"Based on votes, `autoConnect` can step up one level.
",2015-10-01 08:13:15,2015-12-03 19:38:50,https://api.github.com/repos/ReactiveX/RxJava/issues/3391,['Discussion'],4,4,ReactiveX_RxJava_pull_3391.diff
ReactiveX/RxJava,1.1.0: onBackpressureBlock remove,"It was easy to get `onBackpressureBlock` usage wrong with `subscribeOn`.
",2015-10-01 08:10:02,2015-12-03 19:38:50,https://api.github.com/repos/ReactiveX/RxJava/issues/3390,['Discussion'],0,508,ReactiveX_RxJava_pull_3390.diff
ReactiveX/RxJava,1.1.0: removal of AbstractOnSubscribe,"Based on votes, the `AbstractOnSubscribe` is to be removed.
",2015-10-01 08:03:59,2015-12-03 19:38:50,https://api.github.com/repos/ReactiveX/RxJava/issues/3389,['Discussion'],10,1194,ReactiveX_RxJava_pull_3389.diff
ReactiveX/RxJava,1.1.0: Subject state methods beta/remove,"Based on votes, this PR removes the common Subject state peeking methods from Subject and removes irrelevant methods from each Subject variant and promotes the rest to `@Beta` state.

Due to the removals, I had to rearrange tests as well.
",2015-10-01 07:48:23,2015-12-03 19:38:50,https://api.github.com/repos/ReactiveX/RxJava/issues/3388,['Discussion'],400,699,ReactiveX_RxJava_pull_3388.diff
ReactiveX/RxJava,1.1.0 - Changed javadoc for Observable.doOnRequest(Action1),"This is one of the many 1.1.0 promotion related pull requests. There is a split decision on the operator `Observable.doOnRequest(Action1)`. A majority of core committers have voted to promote this operator from `@Beta` to public. There is currently a minority is support for removing the convenience method on `Observable` or demoting it to `@Experimental`. Instead users would lift the underlying operator `obs.lift(new OperatorDoOnRequest<T>(onRequest))`. In this pull request I have taken the more conservative approach and expect that comments will guide our decisions. 
### Rationale:
- the `doOnRequest` use case is to debug back-pressure use cases and as such should not pollute the public operator namespace. 
- the existence of this operator may mislead and confuse users. it could be misinterpreted and abused to alter or reset over arching state when the back-pressure mechanics should be more or less self contained (with the exception of `AsyncOnSubscribe`).

If my understanding is incorrect and there is a valid use case aside from debugging then please comment. 
",2015-09-29 17:37:24,2015-10-07 23:38:10,https://api.github.com/repos/ReactiveX/RxJava/issues/3386,['Discussion'],14,8,ReactiveX_RxJava_pull_3386.diff
ReactiveX/RxJava,Fix for take() reentrancy bug.,"Fixes the bug reported in  #3346. (I've done this for 1.x as well since the original poster disappeared). 
",2015-09-29 07:54:40,2015-09-30 18:28:58,https://api.github.com/repos/ReactiveX/RxJava/issues/3384,['Bug'],23,2,ReactiveX_RxJava_pull_3384.diff
ReactiveX/RxJava,Fix typo in a comment inside Observable.subscribe,"sigificent -> significant
alreay -> already
",2015-09-28 21:28:13,2015-09-28 23:50:33,https://api.github.com/repos/ReactiveX/RxJava/issues/3383,[],2,1,ReactiveX_RxJava_pull_3383.diff
ReactiveX/RxJava,2.x: fix SpscLinkedArrayQueue leaves 1 slot null just before growing,"Discovered while debugging #3381. Confirmed with JCTools in https://github.com/JCTools/JCTools/pull/80
",2015-09-28 12:58:02,2015-09-30 19:37:55,https://api.github.com/repos/ReactiveX/RxJava/issues/3382,['Bug'],1,1,ReactiveX_RxJava_pull_3382.diff
ReactiveX/RxJava,2.x: UnicastSubject fix for the child becoming visible before onSubscribe is called.,"Discovered while the test `NbpOperatorConcatTest.testIssue2890NoStackoverflow` hung on Travis.

What happened is that the reference to the child became visible before the call to its `onSubscribe` method so a concurrent source emitting at the exact same time could already see the ""unstarted"" child. The PR fixes this in both `NbpUnicastSubject` and `UnicastSubject` by changing the order of calls. The rest of the subjects behave correctly (call `onSubscribe` first, make child visible second).

In addition, `UnicastSubject` now calls `drain()` because when the `onSubscribe` calls `request` and `drain`, the child is not visible and nothing gets replayed. Once both `onSubscribe` call returns and the child is becomes visible, a call to `drain` again will now correctly replay all available contents that were requested.
",2015-09-28 09:47:23,2016-02-04 10:12:18,https://api.github.com/repos/ReactiveX/RxJava/issues/3381,['Bug'],3,2,ReactiveX_RxJava_pull_3381.diff
ReactiveX/RxJava,2.x: CombineLatest removed leftover debug field + better cleanup,"A terminal condition is now clearing the latest array which should help release its contents earlier in case a reference is kept to the class.
",2015-09-27 19:03:50,2016-01-15 21:05:27,https://api.github.com/repos/ReactiveX/RxJava/issues/3380,['Bug'],26,6,ReactiveX_RxJava_pull_3380.diff
ReactiveX/RxJava,2.x: fix take() reentrancy problem.,"Discovered by @mgp in #3346 and using his supplied fix. I've already
applied it to NbpObservable's take this Monday so all that's left was
the unit test.
",2015-09-25 18:13:45,2015-09-28 23:52:36,https://api.github.com/repos/ReactiveX/RxJava/issues/3377,['Bug'],35,2,ReactiveX_RxJava_pull_3377.diff
ReactiveX/RxJava,"2.x: perf comparing Observable, NbpObservable, Stream and ParallelStream","This benchmark compares the overhead of backpressured range, non-backpressured range, streamed range and parallel-streamed range. Run on i7 4770K, Windows 7 x64, Java 1.8u60.

![image](https://cloud.githubusercontent.com/assets/1269832/10107747/75d7c094-63bd-11e5-9e6d-fd3afd50b552.png)
",2015-09-25 17:44:44,2015-10-04 08:33:43,https://api.github.com/repos/ReactiveX/RxJava/issues/3376,['Performance'],99,0,ReactiveX_RxJava_pull_3376.diff
ReactiveX/RxJava,Optimize Exceptions.throwIfFatal(),"`Exceptions.throwIfFatal()` used in almost all RxJava operators.

Basically, in this PR I've just divided `throwable` into 3 groups: `RuntimeException`, `Error` and `Exception` (we don't need to check them).

With this PR `Exceptions.throwIfFatal()` becomes ~7% faster than current implementation in case of non-fatal exceptions (because if it's fatal — app will be crashed :smiley_cat:) on the Oracle JRE 1.8.0_45.

I guess, on Android it will be even more faster! (I am not sure in quality of our JITs/VMs).

I've checked the bytecode after compilation in hope that javac will optimize `Exceptions.throwIfFatal()` into same construction, but it does not perform any optimizations over this method at compile time, so the only hope is JIT and even after JIT, optimized version slightly faster (~7%).

Results of the benchmarks:

```
OPTIMIZED VERSION:

Benchmark                                                               Mode   Samples        Score  Score error    Units
r.e.ExceptionsThrowIfFatalPerf.throwIfFatalNonFatalCheckedException     avgt         5        2.569        0.389    ns/op
r.e.ExceptionsThrowIfFatalPerf.throwIfFatalNonFatalError                avgt         5        2.332        0.030    ns/op
r.e.ExceptionsThrowIfFatalPerf.throwIfFatalNonFatalRuntimeException     avgt         5        2.511        0.037    ns/op

Benchmark                                                               Mode   Samples        Score  Score error    Units
r.e.ExceptionsThrowIfFatalPerf.throwIfFatalNonFatalCheckedException    thrpt         5 395071210.861  1644491.739    ops/s
r.e.ExceptionsThrowIfFatalPerf.throwIfFatalNonFatalError               thrpt         5 429656328.864  3230560.292    ops/s
r.e.ExceptionsThrowIfFatalPerf.throwIfFatalNonFatalRuntimeException    thrpt         5 398472020.961  3961447.943    ops/s

OLD VERSION:

Benchmark                                                               Mode   Samples        Score  Score error    Units
r.e.ExceptionsThrowIfFatalPerf.throwIfFatalNonFatalCheckedException     avgt         5        2.812        0.954    ns/op
r.e.ExceptionsThrowIfFatalPerf.throwIfFatalNonFatalError                avgt         5        2.338        0.019    ns/op
r.e.ExceptionsThrowIfFatalPerf.throwIfFatalNonFatalRuntimeException     avgt         5        2.771        0.064    ns/op

Benchmark                                                               Mode   Samples        Score  Score error    Units
r.e.ExceptionsThrowIfFatalPerf.throwIfFatalNonFatalCheckedException    thrpt         5 370211340.236  9093081.248    ops/s
r.e.ExceptionsThrowIfFatalPerf.throwIfFatalNonFatalError               thrpt         5 427943417.424  6168313.153    ops/s
r.e.ExceptionsThrowIfFatalPerf.throwIfFatalNonFatalRuntimeException    thrpt         5 368255154.316  4520997.005    ops/s
```
",2015-09-25 00:36:22,2015-09-26 22:03:31,https://api.github.com/repos/ReactiveX/RxJava/issues/3374,[],85,19,ReactiveX_RxJava_pull_3374.diff
ReactiveX/RxJava,Observable.empty().collect() should not throw an exception,"`Observable.empty().collect(stateFactory, accumulator)` should return the result of `stateFactory.call()` but throws an exception.

I've added a unit test for this and removed an irrelevant reference to a discussion on `reduce`.
",2015-09-24 06:48:41,2015-09-24 06:51:34,https://api.github.com/repos/ReactiveX/RxJava/issues/3372,[],22,8,ReactiveX_RxJava_pull_3372.diff
ReactiveX/RxJava,2.x: non-backpressure NbpObservable all relevant operators + tests.,"- non-backpressured subjects.
",2015-09-22 20:27:24,2015-09-23 20:46:05,https://api.github.com/repos/ReactiveX/RxJava/issues/3371,['Enhancement'],58220,446,ReactiveX_RxJava_pull_3371.diff
ReactiveX/RxJava,Remove unused field updater from SubjectSubscriptionManager,,2015-09-21 22:40:24,2015-09-23 03:59:32,https://api.github.com/repos/ReactiveX/RxJava/issues/3370,['Enhancement'],0,2,ReactiveX_RxJava_pull_3370.diff
ReactiveX/RxJava,Lint fixes for unnecessary unboxing,"Believe I'm removing some unnecessary unboxing calls, but please correct me if I'm wrong.
",2015-09-21 15:00:55,2015-09-22 05:55:56,https://api.github.com/repos/ReactiveX/RxJava/issues/3369,['Enhancement'],4,4,ReactiveX_RxJava_pull_3369.diff
ReactiveX/RxJava,2.x: Added placeholder operators to NbpObservable + special observables,"Nbp prefixed Observable types added. The core operators throw UnsupportedOperationException for now, overloads delegating to them did not change.
",2015-09-20 09:21:42,2015-09-22 05:51:58,https://api.github.com/repos/ReactiveX/RxJava/issues/3366,['Enhancement'],3283,3,ReactiveX_RxJava_pull_3366.diff
ReactiveX/RxJava,Make field final and remove unnecessary unboxing in OnSubscribeRedo.RetryWithPredicate,,2015-09-20 01:24:31,2015-09-28 23:53:28,https://api.github.com/repos/ReactiveX/RxJava/issues/3365,['Enhancement'],2,2,ReactiveX_RxJava_pull_3365.diff
ReactiveX/RxJava,Possible multithreading bug fix in OnSubscribeAmb,"Looks like non-volatile `chosen` may cause concurrency problems in this operator, @akarnokd PTAL
",2015-09-20 01:12:05,2015-09-20 16:12:12,https://api.github.com/repos/ReactiveX/RxJava/issues/3364,['Question'],1,1,ReactiveX_RxJava_pull_3364.diff
ReactiveX/RxJava,"Remove unused private method from CachedObservable and make ""state"" final","Fewer methods — happier Android Developers :)
",2015-09-20 01:01:47,2015-10-07 23:47:12,https://api.github.com/repos/ReactiveX/RxJava/issues/3363,['Enhancement'],3,10,ReactiveX_RxJava_pull_3363.diff
ReactiveX/RxJava,Fix synchronization on non-final field in BufferUntilSubscriber,"Compiler, VM, JIT and IDE will be happier :)
",2015-09-20 00:26:15,2015-09-29 07:00:20,https://api.github.com/repos/ReactiveX/RxJava/issues/3362,['Enhancement'],1,1,ReactiveX_RxJava_pull_3362.diff
ReactiveX/RxJava,Safer error handling in BlockingOperatorToFuture,"Not very important since `onError` should be called once, but anyway it's `AtomicReference` and we need to store the value returned from `get()` locally.

P.S. I don't use `Future`s, just found this piece of code.
",2015-09-20 00:18:47,2015-10-07 23:48:17,https://api.github.com/repos/ReactiveX/RxJava/issues/3361,['Enhancement'],4,2,ReactiveX_RxJava_pull_3361.diff
ReactiveX/RxJava,2.x: non-backpressure Subscribers,"These classes enable the porting of backpressure-aware operators for non-backpressure Observable.

It would be great if this could be merged sooner.
",2015-09-19 21:57:28,2015-09-22 05:51:52,https://api.github.com/repos/ReactiveX/RxJava/issues/3360,['Enhancement'],2545,0,ReactiveX_RxJava_pull_3360.diff
ReactiveX/RxJava,2.x: non-backpressure Subject implementations,"They can be renamed later as necessary. No unit tests but the regular
Subject tests can be ported easily.
",2015-09-19 20:28:56,2015-09-22 05:51:42,https://api.github.com/repos/ReactiveX/RxJava/issues/3359,['Enhancement'],2729,0,ReactiveX_RxJava_pull_3359.diff
ReactiveX/RxJava,2.x: Single class more operators + test from 1.x,"I've added the methods from the 1.x Single plus a couple more based on Observable operators that makes sense to me in respect to Single. No plus unit tests and no javadoc.
",2015-09-19 16:55:59,2015-09-24 16:38:26,https://api.github.com/repos/ReactiveX/RxJava/issues/3358,['Enhancement'],1919,135,ReactiveX_RxJava_pull_3358.diff
ReactiveX/RxJava,Eager ConcatMap,"Related discussion in #3017.
",2015-09-19 12:44:43,2015-10-08 13:14:16,https://api.github.com/repos/ReactiveX/RxJava/issues/3357,"['Enhancement', 'Feature-Request']",1467,0,ReactiveX_RxJava_pull_3357.diff
ReactiveX/RxJava,Fix to a bunch of bugs and issues with AsyncOnSubscribe,"There were several problems with the operator:
- The first 2 requests were always `Long.MAX_VALUE` no matter what the child requested.
- There was a race-condition and memory leak when tracking the generated `Observable`s.
- Both the individual generated `Observable`s and the main concatenation could overflow the internal buffers and had to be defensively-buffered.
- If a request was responded with a generated `Observable` that delivered less than this requested amount, the child ended up hanging.
- The concatenation didn't know about the number of values it should deliver in aggregate and might have delivered more or less, causing `MissingBackpressureException` or hangs.
- Exception thrown from the `generateState` is now delivered to the child immediately.

As I see, the usage is as follows. Each individual `request()` from the child is supposed to be fulfilled by individual `Observable`s. For example, `request(1)` and `request(5)` will generate two distinct `Observable`s where the first will have 1 value and the second 5.
",2015-09-19 09:51:55,2015-09-29 17:19:45,https://api.github.com/repos/ReactiveX/RxJava/issues/3356,['Bug'],312,99,ReactiveX_RxJava_pull_3356.diff
ReactiveX/RxJava,"2.x: perf comparison of Observable, NbpObservable and Single","I've accidentally pushed this into 2.x (no rules violated though) but I'd like to show the run results on my machine (i7 4790, Windows 7 x64, Java 1.8u60)

![image](https://cloud.githubusercontent.com/assets/1269832/9959437/5768157c-5e14-11e5-8d9f-9b3157070633.png)

The backpressure-overhead on range is quite apparent. Naturally, scalar can't do range so I only compared it agains the `just` of the others. Single has no equivalent operators for the other cases right now.

There is still room for improvement for the range-flatMap-just in NbpObservable and Single.

Again, the lower overhead of NbpObservable shows through in RangeMapRange where there is no fast-path at all and everybody has to subscribe to the inner range.
",2015-09-18 12:53:25,2015-09-18 12:55:42,https://api.github.com/repos/ReactiveX/RxJava/issues/3355,['Performance'],4,4,ReactiveX_RxJava_pull_3355.diff
ReactiveX/RxJava,2.x: perf change wait to spin-loop for short async benchmarks,"I've noticed that the `times = 1` async range sometimes produces double the throughput without any change to the underlying structure and I've figured out it is because how my operation system wakes up the await in the benchmark. I switched the tests to spin-loop and now I get a consistent and higher value than before:

![image](https://cloud.githubusercontent.com/assets/1269832/9958923/0ce916fe-5e0f-11e5-988a-3e8cac1098dc.png)

There are a few light-greens and a few light-reds which I attribute to other fluctuating factors on my computer.

In addition, I've experimented with two optimizations: one for observing a scalar value on a different thread and one where the `OperatorObserveOn` is turned into a `PublisherObserveOn` to save on the allocation of a `PublisherLift`. The scalar optimization ended up being slower by 15% for some reason I don't understand and the `PublishObserveOn` had no impact on the throughput within the error range.
",2015-09-18 12:16:17,2015-09-18 12:23:52,https://api.github.com/repos/ReactiveX/RxJava/issues/3354,['Performance'],47,9,ReactiveX_RxJava_pull_3354.diff
ReactiveX/RxJava,2.x: range perf + added missing header.,"Benchmarks synchronous, asynchronous (where the emission can hop onto the receiver thread) and strictly-pipelined (the emitter and receiver are on different threads). Results on i7 4790, Windows 7 x64, Java 1.8u60:

```
Benchmark                (times)   Mode  Cnt         Score        Error  Units
RangePerf.rangeAsync           1  thrpt    5    135410,552 ?  20521,908  ops/s
RangePerf.rangeAsync        1000  thrpt    5     25634,730 ?    284,526  ops/s
RangePerf.rangeAsync     1000000  thrpt    5        59,073 ?      1,154  ops/s
RangePerf.rangePipeline        1  thrpt    5     98895,846 ?  11398,363  ops/s
RangePerf.rangePipeline     1000  thrpt    5     16233,903 ?    741,712  ops/s
RangePerf.rangePipeline  1000000  thrpt    5        10,621 ?      2,606  ops/s
RangePerf.rangeSync            1  thrpt    5  30367277,992 ? 170100,628  ops/s
RangePerf.rangeSync         1000  thrpt    5    212293,380 ?   3605,320  ops/s
RangePerf.rangeSync      1000000  thrpt    5       248,135 ?      1,775  ops/s
```
",2015-09-18 08:00:02,2015-09-18 08:07:46,https://api.github.com/repos/ReactiveX/RxJava/issues/3353,['Performance'],128,0,ReactiveX_RxJava_pull_3353.diff
ReactiveX/RxJava,2.x: perf checks for flatMap and merge,"Ported the two perf tests to evaluate 2.x throughput.

![image](https://cloud.githubusercontent.com/assets/1269832/9907226/67a454c8-5c8e-11e5-8644-c3196b2e58d8.png)

My primary suspect for the extra overhead are the atomics of queue-drain. The 1.x uses a synchronized-based emitter-loop which is elided by the JIT compiler but atomics can't be elided. As I mentioned before, synchronized works better for light-to-none asynchronous use whereas atomics work better for asynchronous use.

Also quote from #3157

> Exceptions that do not require a :+1: would be:
> 
> javadoc changes
> unit test additions or refactoring
> **perf test additions, fixes or refactoring**
> grammatical and presentation fixes to README, CONTRIBUTING, and other such metadata files
",2015-09-16 14:22:10,2015-09-16 14:34:07,https://api.github.com/repos/ReactiveX/RxJava/issues/3352,['Performance'],302,0,ReactiveX_RxJava_pull_3352.diff
ReactiveX/RxJava,Make BlockingOperatorToIterator exert backpressure.,"The iterator created by `BlockingOperator#getIterator()` doesn't exert backpressure, which causes code like this to never terminate/run out of memory

``` java
Observable.from(new Iterable<Integer>() {

    @Override
    public Iterator<Integer> iterator() {
        return new Iterator<Integer>() {

            @Override
            public boolean hasNext() {
                return true;
            }

            @Override
            public Integer next() {
                return 1;
            }
        };
    }
}).toBlocking().getIterator().next();
```

This PR adds the appropriate `request` calls so that this works. I had to combine the implementations of `Subscriber` and `Iterator` into a single class to get access to `request()`.
",2015-09-16 06:56:58,2015-10-08 13:42:53,https://api.github.com/repos/ReactiveX/RxJava/issues/3351,['Enhancement'],116,50,ReactiveX_RxJava_pull_3351.diff
ReactiveX/RxJava,2.x Design: Creation/Destruction,"How to create and destroy streams.

The wording of this can become much better once agreement occurs in https://github.com/ReactiveX/RxJava/pull/3348/files

The intent of this is:

1) Specify how to create streams (Observable/Flowable) of the various flavors, and account for flow control.
2) Evolve towards what the creation/generation APIs are
3) Specify that it is not the responsibility of the final Subscriber to call unsubscribe/cancel upstream
",2015-09-16 05:18:23,2015-09-17 20:43:01,https://api.github.com/repos/ReactiveX/RxJava/issues/3350,['Discussion'],31,0,ReactiveX_RxJava_pull_3350.diff
ReactiveX/RxJava,2.x Design: Subject,"Clarification of `Subject` that affects implementation. 

Related to discussion in https://github.com/ReactiveX/RxJava/pull/3345.
",2015-09-16 05:03:30,2015-09-21 16:53:32,https://api.github.com/repos/ReactiveX/RxJava/issues/3349,['Discussion'],11,2,ReactiveX_RxJava_pull_3349.diff
ReactiveX/RxJava,2.x Design: Flowable/Observable,"Proposed separation of `Observable` and `Flowable` along with description of each and their characteristics.
",2015-09-16 04:52:57,2015-09-21 16:54:12,https://api.github.com/repos/ReactiveX/RxJava/issues/3348,['Discussion'],33,1,ReactiveX_RxJava_pull_3348.diff
ReactiveX/RxJava,PublishSubject Add Before onSubscribe,"Proposed change to register with state before onSubscribe so that ""doOnSubscribe"" side-effects are safe.

If this is approved as a change, we'd want to do similar for the other Subjects as well I imagine. 

I came across this after debugging race conditions in some code and tracking it down to publishSubject.subscribe not actually subscribing until AFTER onSubscribe is completed. This breaks things if doOnSubscribe side-effects cause data to flow through that subject.

Is there any reason not to make this change?
",2015-09-15 02:40:33,2015-09-16 02:59:15,https://api.github.com/repos/ReactiveX/RxJava/issues/3345,[],71,20,ReactiveX_RxJava_pull_3345.diff
ReactiveX/RxJava,Remove redundant onStart implementation in OperatorGroupBy,"Addresses #3067 - Removes a redundant `onStart` implementation in `OperatorGroupBy`.
",2015-09-12 18:13:12,2015-10-07 23:53:13,https://api.github.com/repos/ReactiveX/RxJava/issues/3342,[],0,3,ReactiveX_RxJava_pull_3342.diff
ReactiveX/RxJava,test/subjects: Use statically imported never() methods,"... and remove the unused Mockito imports
",2015-09-11 12:14:50,2015-09-11 16:58:46,https://api.github.com/repos/ReactiveX/RxJava/issues/3340,[],42,61,ReactiveX_RxJava_pull_3340.diff
ReactiveX/RxJava,2.x: fix delaySubscription with supplied publisher: wrong value to trigger subscription,"The subscription was triggered by the supplied publisher and not one of its value or completion.

Btw, should an `onComplete` from this inner publisher be treated as an indication to not subscribe to the actual source?
",2015-09-11 09:21:21,2015-10-03 13:53:34,https://api.github.com/repos/ReactiveX/RxJava/issues/3339,['Bug'],74,1,ReactiveX_RxJava_pull_3339.diff
ReactiveX/RxJava,2.x: scalar flatMap optimization enabled,"- I wanted to make sure the slow path passes all tests before enabling
  the scalar optimization.
- Fixed headers for internal classes
",2015-09-09 14:03:42,2015-09-09 14:11:27,https://api.github.com/repos/ReactiveX/RxJava/issues/3335,"['Bug', 'Enhancement']",210,241,ReactiveX_RxJava_pull_3335.diff
ReactiveX/RxJava,2.x: disposable unit tests + fix to RefCountDisposable behavior,"- sorted `Observable` and added `@BackpressureSupport` and
  `SchedulerSupport` annotations.
- created `@Beta` and `@Experimental` annotations, nothing is marked
  with them because I intent everything to be standard at this point.
",2015-09-09 13:16:41,2015-09-09 13:24:07,https://api.github.com/repos/ReactiveX/RxJava/issues/3334,"['Bug', 'Enhancement', 'Test']",1947,181,ReactiveX_RxJava_pull_3334.diff
ReactiveX/RxJava,2.x: subscribers/observers tests,"I had to ignore many tests because they either test with null or throw
an exception from a Subscriber method which are not allowed with RS.
- added Observers and Subscribers to create Observers/Subscribers with convenience.
",2015-09-09 11:33:14,2015-09-09 11:40:26,https://api.github.com/repos/ReactiveX/RxJava/issues/3333,"['Bug', 'Test']",3706,1,ReactiveX_RxJava_pull_3333.diff
ReactiveX/RxJava,2.x: subject tests and bugfixes,"- Fixed the `testNestedAsyncConcat` test.
- Fixed memory leak in `NewThreadWorker`.
",2015-09-09 08:08:53,2015-09-09 08:39:54,https://api.github.com/repos/ReactiveX/RxJava/issues/3332,"['Bug', 'Test']",3749,17,ReactiveX_RxJava_pull_3332.diff
ReactiveX/RxJava,2.x: schedulers test of classic schedulers,,2015-09-08 20:27:36,2015-09-08 21:04:26,https://api.github.com/repos/ReactiveX/RxJava/issues/3331,"['Bug', 'Test']",2233,14,ReactiveX_RxJava_pull_3331.diff
ReactiveX/RxJava,2.x: operator test zip and SafeSubscriberTest,,2015-09-08 18:41:02,2015-09-08 18:48:07,https://api.github.com/repos/ReactiveX/RxJava/issues/3330,['Test'],1414,0,ReactiveX_RxJava_pull_3330.diff
ReactiveX/RxJava,2.x: operator test: window variants,"I had to adjust some test slightly due to the a new behavior: if one
cancels a source which is windowed, as long as the windows are active,
the source has to stay active. However, there are more subtle
possibilities that need new tests.
",2015-09-08 17:57:02,2015-09-08 18:04:38,https://api.github.com/repos/ReactiveX/RxJava/issues/3329,"['Bug', 'Test']",1339,36,ReactiveX_RxJava_pull_3329.diff
ReactiveX/RxJava,"2.x: operator tests unsubscribeOn, withLatestFrom, zip (partial)","- fixed cancellation behavior of observeOn, subscribeOn and
  unsubscribeOn (when and what to call cancel on)
- fixed infinite loop in ScheduledRunnable
- fixed zip not quitting eagerly if one of the sources was shorter
- added specific ZipIterable because zip-iterable tests expect it to be
  not prefetching any of the sources (the plain zip does prefetch)
- made the fromIterable more resilient to Iterable/Iterator crashes and
  added null-value checks
",2015-09-08 14:19:13,2015-09-08 14:24:43,https://api.github.com/repos/ReactiveX/RxJava/issues/3328,"['Bug', 'Test']",1189,49,ReactiveX_RxJava_pull_3328.diff
ReactiveX/RxJava,"2.x: operator tests: timestamp, toMap, toMultiMap, toList, toSortedList","- signature fix to toMultimap and removed deprecated markers.
",2015-09-08 11:11:29,2015-09-08 11:27:43,https://api.github.com/repos/ReactiveX/RxJava/issues/3327,"['Bug', 'Test']",907,36,ReactiveX_RxJava_pull_3327.diff
ReactiveX/RxJava,"2.x: operator throttleFirst, timeInterval and timeout + bugfixes",,2015-09-08 10:16:15,2015-09-08 10:22:25,https://api.github.com/repos/ReactiveX/RxJava/issues/3326,"['Bug', 'Test']",1094,91,ReactiveX_RxJava_pull_3326.diff
ReactiveX/RxJava,2.x: operator tests: take family + fixes,"- fixed a deadlock possibility in one of the merge tests
",2015-09-08 09:05:32,2015-09-08 09:14:11,https://api.github.com/repos/ReactiveX/RxJava/issues/3325,"['Bug', 'Test']",1907,11,ReactiveX_RxJava_pull_3325.diff
ReactiveX/RxJava,"2.x: operator test: switchIfEmpty, switchMap + bugfixes",,2015-09-08 07:41:21,2015-09-08 07:47:10,https://api.github.com/repos/ReactiveX/RxJava/issues/3324,"['Bug', 'Test']",1226,73,ReactiveX_RxJava_pull_3324.diff
ReactiveX/RxJava,2.x: operator test: skip variants and bugfix,"Note that since we know have time unit in schedulers, one must be
careful with the time unit of the timed skip operators. The timestamps
will be calculated via this unit and may not return the expected values. 

For example, a skipLast of 1 second will not skip the value 0.5 seconds
before completion because its timestamp is rounded down to the start of
the second. But if one uses 1000 milliseconds, the value will be
skipped.
",2015-09-07 21:00:10,2015-09-07 21:04:28,https://api.github.com/repos/ReactiveX/RxJava/issues/3323,"['Bug', 'Test']",928,11,ReactiveX_RxJava_pull_3323.diff
ReactiveX/RxJava,"2.x: operator test: serialize, single + SerializedSubscriber fix",,2015-09-07 20:16:08,2015-09-07 20:24:14,https://api.github.com/repos/ReactiveX/RxJava/issues/3322,"['Bug', 'Test']",806,0,ReactiveX_RxJava_pull_3322.diff
ReactiveX/RxJava,"2.x: operator tests: sample, scan and sequenceEqual + their bugfixes",,2015-09-07 19:38:06,2015-09-07 19:42:34,https://api.github.com/repos/ReactiveX/RxJava/issues/3321,"['Bug', 'Test']",791,7,ReactiveX_RxJava_pull_3321.diff
ReactiveX/RxJava,"2.x: operator test: retry, retryWhen","- retry with bipredicate
- fixed map not checking the returned value for null
- since RS doesn't allow throwing other than NPE, temporarily subscribe
  and lift will throw NPE with the actual error as cause so we don't miss
  an operator bug due to swallowed exceptions.
",2015-09-07 18:36:56,2015-09-07 18:42:23,https://api.github.com/repos/ReactiveX/RxJava/issues/3320,"['Bug', 'Test']",1449,16,ReactiveX_RxJava_pull_3320.diff
ReactiveX/RxJava,2.x: operator test for replay,"Note that testIssue_2191_SchedulerUnsubscribe had to change the call
count to pass. I don't understand this test and the over-mocking (but
recognize the style).
",2015-09-07 16:38:51,2015-09-07 16:43:59,https://api.github.com/repos/ReactiveX/RxJava/issues/3319,"['Bug', 'Test']",1178,3,ReactiveX_RxJava_pull_3319.diff
ReactiveX/RxJava,"2.x: operator tests: publish, reduce, repeat + fixes","- added toSingle and toNbpObservable to Observable
- fixed bugs in many operators and in the IO scheduler's release logic
",2015-09-07 14:33:17,2015-09-07 14:38:00,https://api.github.com/repos/ReactiveX/RxJava/issues/3318,"['Bug', 'Test']",808,29,ReactiveX_RxJava_pull_3318.diff
ReactiveX/RxJava,"2.x: operator test onError and onException, relevant bugfixes","I had to ignore tests that throw exceptions from a Publisher.subscribe or an Operator.apply due to their non-conformant behavior.
",2015-09-07 13:01:10,2015-09-07 13:05:52,https://api.github.com/repos/ReactiveX/RxJava/issues/3317,"['Bug', 'Test']",1083,17,ReactiveX_RxJava_pull_3317.diff
ReactiveX/RxJava,2.x: operator test onBackpressure(Buffer|Drop|Latest) and their bugfix,,2015-09-07 12:19:02,2015-09-07 12:24:36,https://api.github.com/repos/ReactiveX/RxJava/issues/3316,"['Bug', 'Test']",463,14,ReactiveX_RxJava_pull_3316.diff
ReactiveX/RxJava,2.x: operator test observeOn,"- fix to observeOn to not request if cancelled in onNext delivery
- fix combineLatest error emission if the other sources are late or
  never emit
- fix interval and PublishSubject to send MissingBackpressureException
",2015-09-07 11:31:16,2015-09-07 11:48:22,https://api.github.com/repos/ReactiveX/RxJava/issues/3315,"['Bug', 'Test']",826,6,ReactiveX_RxJava_pull_3315.diff
ReactiveX/RxJava,"2.x: operator test ignoreElements, last, mapNotification",,2015-09-07 09:49:46,2015-09-07 09:59:14,https://api.github.com/repos/ReactiveX/RxJava/issues/3314,['Test'],417,0,ReactiveX_RxJava_pull_3314.diff
ReactiveX/RxJava,2.x: operator test for groupBy; fix to groupBy and type argument swap,"for GroupedObservable
- added BooleanSubscription to detect cancellation without caring about
  requests.

I'm still not 100% convinced the groupBy request coordination works
properly (i.e., no stall due lack of requests from one of the groups).
",2015-09-07 09:24:11,2015-09-07 09:29:16,https://api.github.com/repos/ReactiveX/RxJava/issues/3313,"['Bug', 'Test']",1554,27,ReactiveX_RxJava_pull_3313.diff
ReactiveX/RxJava,"2.x: operator test flatMap, merge, mergeDelayError","- added operator flatMap of notifications, fixed a bug in onBackpressureBuffer

Note also the few ignored tests because they either want to test against a null value or try to throw from RS methods.
",2015-09-07 08:26:49,2015-09-07 08:31:10,https://api.github.com/repos/ReactiveX/RxJava/issues/3312,"['Bug', 'Test']",3149,15,ReactiveX_RxJava_pull_3312.diff
ReactiveX/RxJava,"2.x: operator test elementAt, filter, finally, first","- fixed exceptions throw by elementAt
",2015-09-06 19:12:05,2015-09-06 19:15:53,https://api.github.com/repos/ReactiveX/RxJava/issues/3311,['Test'],535,6,ReactiveX_RxJava_pull_3311.diff
ReactiveX/RxJava,2.x: operator test doOn(Request|Subscribe|Unsubscribe).,,2015-09-06 18:40:54,2015-09-06 18:44:49,https://api.github.com/repos/ReactiveX/RxJava/issues/3310,['Test'],277,0,ReactiveX_RxJava_pull_3310.diff
ReactiveX/RxJava,"2.x: operator test distinct, distinctUntilChanged and doOnEach","Note: several tests have been ignored due to non-conformance with RS

Added missing distinct and distinctUntilChanged overloads, fixed doOnEach not cancelling upstream if the callback crashes on the onNext path.
",2015-09-06 18:19:12,2015-09-06 18:23:41,https://api.github.com/repos/ReactiveX/RxJava/issues/3309,"['Bug', 'Enhancement', 'Test']",489,22,ReactiveX_RxJava_pull_3309.diff
ReactiveX/RxJava,"2.x: operator test delay, dematerialize",,2015-09-06 17:31:45,2015-09-06 17:36:29,https://api.github.com/repos/ReactiveX/RxJava/issues/3308,['Test'],904,0,ReactiveX_RxJava_pull_3308.diff
ReactiveX/RxJava,"2.x: Operator debounce and defaultIfEmpty, fix to debounce behavior","When debounce is completed, the last value encountered is emitted immediately.
",2015-09-06 17:05:06,2015-09-06 17:08:58,https://api.github.com/repos/ReactiveX/RxJava/issues/3307,"['Bug', 'Test']",442,38,ReactiveX_RxJava_pull_3307.diff
ReactiveX/RxJava,2.x: operators cast and concat tests,"The concat reuses the same inner subscriber to save on its allocation
cost which works only if the inner source conforms with the spec and
doesn't emit any event after an onComplete(). There is a test that
explicitly calls onComplete() twice to test the resilience of concat.
The current workaround makes this test pass but any async non-conforming
source may still bug out the operator. 

This is a tradeoff between safety and performance. If we'd expect such
non-conforming behavior, the current optimization has to be turned into
a regular individually allocated inner subscribers.
",2015-09-06 16:26:53,2015-09-06 16:33:02,https://api.github.com/repos/ReactiveX/RxJava/issues/3306,"['Bug', 'Test']",881,7,ReactiveX_RxJava_pull_3306.diff
ReactiveX/RxJava,2.x: classes Single and NbpObservable,"`Single` is a deferred single-value emitting Observable.

`NbpObservable` is the non-backpressure Observable, named this way until
the main Observable gets all its tests ported so a refactor can deal
with all of them.

I've implemented the most basic construction and operator methods on
them.
",2015-09-05 21:59:20,2015-09-06 07:02:50,https://api.github.com/repos/ReactiveX/RxJava/issues/3305,['Enhancement'],1188,0,ReactiveX_RxJava_pull_3305.diff
ReactiveX/RxJava,Enables assertions chaining,"Fluent assertions make the code much more readable.
This change is backward compatible.
",2015-09-05 12:59:43,2015-09-05 14:41:40,https://api.github.com/repos/ReactiveX/RxJava/issues/3304,['Feature-Request'],36,18,ReactiveX_RxJava_pull_3304.diff
ReactiveX/RxJava,2.x: added missing buffer overload (with boundary selector),"- added AsyncSubscription that allows setting the actual subscription
  later and can hold a resource. It has less overhead than
  SubscriptionArbiter due to single use.
",2015-09-05 10:32:31,2015-09-05 10:54:15,https://api.github.com/repos/ReactiveX/RxJava/issues/3303,"['Enhancement', 'Test']",791,13,ReactiveX_RxJava_pull_3303.diff
ReactiveX/RxJava,"2.x: test for buffer, I'm still missing the boundary-supplier version",,2015-09-04 13:05:39,2015-09-04 13:09:17,https://api.github.com/repos/ReactiveX/RxJava/issues/3301,"['Bug', 'Test']",1052,25,ReactiveX_RxJava_pull_3301.diff
ReactiveX/RxJava,"2.x: test for operators all, any, asObservable, fixes to all and any","Bugfix: since they would emit a value on an empty source, they have to hold it until an actual request comes in.
",2015-09-04 11:37:50,2015-09-04 11:41:29,https://api.github.com/repos/ReactiveX/RxJava/issues/3300,"['Bug', 'Test']",559,31,ReactiveX_RxJava_pull_3300.diff
ReactiveX/RxJava,"2.x: test for toFuture and using, changes according to the test","expectations

Some tests are now skipped due to being invalid in RS.
",2015-09-04 10:35:59,2015-09-04 10:39:10,https://api.github.com/repos/ReactiveX/RxJava/issues/3299,['Test'],564,17,ReactiveX_RxJava_pull_3299.diff
ReactiveX/RxJava,"2.x: tests for refCount and timer, fixes to flatMap, publish and range",,2015-09-04 09:32:50,2015-09-04 09:36:56,https://api.github.com/repos/ReactiveX/RxJava/issues/3298,"['Bug', 'Test']",804,17,ReactiveX_RxJava_pull_3298.diff
ReactiveX/RxJava,2.x: unit tests and fixes for fromIterable and range,,2015-09-04 08:08:13,2015-09-04 08:12:22,https://api.github.com/repos/ReactiveX/RxJava/issues/3297,"['Bug', 'Test']",600,8,ReactiveX_RxJava_pull_3297.diff
ReactiveX/RxJava,More tests and bugfixes to operators.,,2015-09-03 22:04:01,2015-09-03 22:06:38,https://api.github.com/repos/ReactiveX/RxJava/issues/3294,"['Bug', 'Test']",893,19,ReactiveX_RxJava_pull_3294.diff
ReactiveX/RxJava,"Test some UnicastSubject, cache, NotificationLite, amb","- bugfix to cache, skipUntil and takeUnit
",2015-09-03 19:56:22,2015-09-03 20:01:55,https://api.github.com/repos/ReactiveX/RxJava/issues/3293,['Test'],701,15,ReactiveX_RxJava_pull_3293.diff
ReactiveX/RxJava,Unit test for Blocking operators.,,2015-09-03 19:13:55,2015-09-03 19:16:35,https://api.github.com/repos/ReactiveX/RxJava/issues/3292,['Test'],710,4,ReactiveX_RxJava_pull_3292.diff
ReactiveX/RxJava,Added more tests and cleaned up SubscriptionList to program to List,"I cleaned up and added more tests to SubscriptionList. 

I also changed the class to implement the List interface instead of hard code LinkedList. 

Changed Data Structure to LinkedList from ArrayList as List is used to iterate over and add exceptions to list. No random access needed and insertions are more efficient in LinkedList.
",2015-09-02 22:47:54,2015-09-04 21:21:31,https://api.github.com/repos/ReactiveX/RxJava/issues/3289,['Enhancement'],175,182,ReactiveX_RxJava_pull_3289.diff
ReactiveX/RxJava,1.x: Implements BlockingSingle,"Adds BlockingSingle (issue #3252), the blocking version of rx.Single.

BlockingSingle has the following methods:
- `from(Single)` -- factory method for creating a `BlockingSingle` from a
  `Single`
- `value()` -- returns the value emitted from the Single
- `toFuture()` -- returns a `java.util.concurrent.Future`

Couldn't actually think of any other useful operations to perform on `BlockingSingle` - in comparison to `BlockingObservable`, there's not much to this class (at the moment).
",2015-09-02 19:26:54,2015-11-11 11:03:39,https://api.github.com/repos/ReactiveX/RxJava/issues/3286,"['Discussion', 'Enhancement']",380,22,ReactiveX_RxJava_pull_3286.diff
ReactiveX/RxJava,Added latch to async SyncOnSubscrbeTest,,2015-09-02 19:16:28,2015-09-04 21:00:56,https://api.github.com/repos/ReactiveX/RxJava/issues/3285,"['Bug', 'Test-Failures']",156,132,ReactiveX_RxJava_pull_3285.diff
ReactiveX/RxJava,"Simpler tests of throttleLast, throttleWithTimeout, zip","Tests expect certain operator parameter orders so I'd expect a few changes in Observable in this regard.

Fixed timing bug with `throttleWithTimeout` but I'm not 100% certain it works as expected beyond this single test.
",2015-09-02 18:57:14,2015-09-02 19:00:42,https://api.github.com/repos/ReactiveX/RxJava/issues/3284,['Test'],300,33,ReactiveX_RxJava_pull_3284.diff
ReactiveX/RxJava,SubscriberTests port from 1.x,"They seem to try testing the request mechanism on thin implementations and are somewhat of no use.
",2015-09-02 18:07:54,2015-09-02 18:10:25,https://api.github.com/repos/ReactiveX/RxJava/issues/3283,['Test'],514,0,ReactiveX_RxJava_pull_3283.diff
ReactiveX/RxJava,"Simpler tests for window reduce, scan, starWith.","I've refectored the mockSubscriber method out into a helper enum since it will be required almost everywhere.
",2015-09-02 17:38:03,2015-09-02 17:40:48,https://api.github.com/repos/ReactiveX/RxJava/issues/3282,['Test'],275,30,ReactiveX_RxJava_pull_3282.diff
ReactiveX/RxJava,ObservableTests and bugfixes.,"Bugfixes in many operators.
",2015-09-02 14:24:52,2015-09-02 14:36:31,https://api.github.com/repos/ReactiveX/RxJava/issues/3280,"['Bug', 'Test']",1134,77,ReactiveX_RxJava_pull_3280.diff
ReactiveX/RxJava,ConversionTest and DoOnTest,"Forgot to call request, refactored some validation code.
",2015-09-02 12:22:25,2015-09-02 12:25:22,https://api.github.com/repos/ReactiveX/RxJava/issues/3279,"['Bug', 'Test']",273,9,ReactiveX_RxJava_pull_3279.diff
ReactiveX/RxJava,"Simplest tests of groupBy, merge and Notification","We need to talk about `Notification`s.
",2015-09-02 11:47:30,2015-09-02 11:51:09,https://api.github.com/repos/ReactiveX/RxJava/issues/3278,['Test'],207,1,ReactiveX_RxJava_pull_3278.diff
ReactiveX/RxJava,ErrorHandlingTests and EventStream,"I've changed them to use `safeSubscribe` because plain RS subscribers
are not expected to throw.
",2015-09-02 11:32:00,2015-09-02 11:35:24,https://api.github.com/repos/ReactiveX/RxJava/issues/3277,['Test'],172,0,ReactiveX_RxJava_pull_3277.diff
ReactiveX/RxJava,Simplest concat test from 1.x,"I've also added convenience overloads to concat 2-9 sources because `concat(Publisher...)` causes overload resolution conflict with `concat(Publisher<Publisher>)`.
",2015-09-02 11:16:59,2015-09-02 11:19:53,https://api.github.com/repos/ReactiveX/RxJava/issues/3276,"['Enhancement', 'Test']",237,8,ReactiveX_RxJava_pull_3276.diff
ReactiveX/RxJava,Simplest combineLatest tests and fix to groupBy.,"Forgot to deliver the value inside the GroupedUnicast drain loop.
",2015-09-02 10:25:52,2015-09-02 10:28:57,https://api.github.com/repos/ReactiveX/RxJava/issues/3275,"['Bug', 'Test']",280,12,ReactiveX_RxJava_pull_3275.diff
ReactiveX/RxJava,Combine latest test2x,,2015-09-02 10:23:10,2015-09-02 10:24:02,https://api.github.com/repos/ReactiveX/RxJava/issues/3274,[],31385,103892,ReactiveX_RxJava_pull_3274.diff
ReactiveX/RxJava,Fix attempt to the firehose test.,"Either the test is non-deterministic or I still have a bug.
",2015-09-02 09:26:01,2015-09-02 09:34:32,https://api.github.com/repos/ReactiveX/RxJava/issues/3273,['Test-Failures'],38,8,ReactiveX_RxJava_pull_3273.diff
ReactiveX/RxJava,Firehose test fix attempt2x,"Either the test is non-deterministic or I have a bug in the operator(s).
",2015-09-02 09:23:40,2015-09-02 09:24:04,https://api.github.com/repos/ReactiveX/RxJava/issues/3272,['Test-Failures'],31154,103938,ReactiveX_RxJava_pull_3272.diff
ReactiveX/RxJava,First unit test and fixes to operators.,"Fixed mistakes in the operators.
",2015-09-02 08:44:52,2015-09-02 09:11:23,https://api.github.com/repos/ReactiveX/RxJava/issues/3271,"['Bug', 'Enhancement']",905,79,ReactiveX_RxJava_pull_3271.diff
ReactiveX/RxJava,"UnicastSubject javadoc, support for onCancelled notification.","The cancellation notification will come in handy with window (and in
groupby). It helps with the case when the main source has been cancelled
but the individual windows/groups are still being consumed. If those get
cancelled by their single Subscribers, this notification will reach the
source and once all windows/groups get cancelled, the main source can be
cancelled.

Fix to generator production accounting.
",2015-09-01 20:28:19,2015-09-01 20:30:54,https://api.github.com/repos/ReactiveX/RxJava/issues/3270,['Enhancement'],118,6,ReactiveX_RxJava_pull_3270.diff
ReactiveX/RxJava,"Standard disposables, changes to resource containers to support them.","- `Disposables` utility class with wrapper methods named `from`.
",2015-09-01 19:50:48,2015-09-01 19:53:57,https://api.github.com/repos/ReactiveX/RxJava/issues/3268,['Enhancement'],494,0,ReactiveX_RxJava_pull_3268.diff
ReactiveX/RxJava,Operator generate: create an observable that generates values by calling,"a function and handling backpressure/resource cleanup automatically.

The logic is based on @stealthcode 's SyncSubscriber proposal from 1.x
but using only the lambda-form.
",2015-09-01 14:31:22,2015-09-01 14:35:27,https://api.github.com/repos/ReactiveX/RxJava/issues/3267,['Enhancement'],224,0,ReactiveX_RxJava_pull_3267.diff
ReactiveX/RxJava,RxJavaPlugins performance enabling fix & lockdown.,"By using null checks and direct returns we can avoid a dynamic dispatch
on a volatile variable which always more expensive.

I've also added the `lockdown()` method to prevent any further changing
of the plugin handlers. There is a `unlock` package-private method to
allow testing the plugin in the locked state and then return to the
unlocked state as other tests may want to install custom plugins.
",2015-09-01 13:27:47,2015-09-01 13:32:35,https://api.github.com/repos/ReactiveX/RxJava/issues/3265,['Enhancement'],128,71,ReactiveX_RxJava_pull_3265.diff
ReactiveX/RxJava,AsyncObserver,"It is meant to be somewhat a replacement for 1.x `rx.Subscriber`, but it
doesn't support `Subscriber` chaining.

I call it an `Observer` because one only needs to implement `onNext`, `onError`
and `onComplete` as with `rx.Observer`
",2015-09-01 13:05:27,2015-09-01 13:09:13,https://api.github.com/repos/ReactiveX/RxJava/issues/3264,['Enhancement'],200,0,ReactiveX_RxJava_pull_3264.diff
ReactiveX/RxJava,Subjects onNext and onError null safety,"Subjects are exposed so they may receive nulls that would mess up the internal state.
",2015-09-01 10:51:05,2015-09-01 10:53:19,https://api.github.com/repos/ReactiveX/RxJava/issues/3263,['Enhancement'],30,0,ReactiveX_RxJava_pull_3263.diff
ReactiveX/RxJava,"Operator window with boundary (exact, selector, exact + supplier).","I'm not 100% certain about the state management: when to let the main
source keep running and when to stop. I.e., the in the selector version,
if the other completes, it means no new window will be opened but the
active should keep receiving values until their closer fires. If all
such closers have fired, the main can be stopped.
",2015-09-01 10:34:00,2015-09-01 10:36:54,https://api.github.com/repos/ReactiveX/RxJava/issues/3262,['Enhancement'],1124,0,ReactiveX_RxJava_pull_3262.diff
ReactiveX/RxJava,Fixes to ReplaySubject and BehaviorSubject.,"ReplaySubject: time and size bound trimming was incorrectly deleting the terminal notification

BehaviorSubject: double emission of the same value. The following loop fails (prints `Bad pattern received: [2, 2]`) with 1.x:

``` java
for (int i = 0; i < 1_000_000; i++) {
    if (i % 1000 == 0) {
        System.out.println(""--> "" + i);
    }
    BehaviorSubject<Object> bs = BehaviorSubject.create(1);

    List<Object> list = new ArrayList<>();
    CyclicBarrier cb = new CyclicBarrier(2);
    CountDownLatch cdl = new CountDownLatch(1);

    ForkJoinPool.commonPool().submit(() -> {
        cb.await();
        bs.onNext(2);
        cdl.countDown();
        return null;
    });

    cb.await();
    bs.subscribe(v -> list.add(v));
    cdl.await();

    if (Arrays.asList(2).equals(list)) {
        continue;
    }
    if (Arrays.asList(1, 2).equals(list)) {
        continue;
    }
    System.out.println(""Bad pattern received: "" + list);
        break;
    }
}
```
",2015-09-01 08:04:13,2015-09-01 08:09:15,https://api.github.com/repos/ReactiveX/RxJava/issues/3261,['Enhancement'],279,117,ReactiveX_RxJava_pull_3261.diff
ReactiveX/RxJava,BehaviorSubject,"The continuous delivery guarantee and the no-duplication requirement makes it necessary to read/write an index and object values together. I've implemented this with another synchronized block. The alternatives are:
- use an object of (index, value) and atomically set the reference (requires allocation on every value delivered.
- this current nested-synchronized block (no deadlock)
- use a reader-writer lock which works better when concurrent subscribers want to do their first emission at the same time.
",2015-08-31 21:34:06,2015-08-31 22:52:06,https://api.github.com/repos/ReactiveX/RxJava/issues/3260,['Enhancement'],474,5,ReactiveX_RxJava_pull_3260.diff
ReactiveX/RxJava,RxJavaPlugins extended with handler registration and reset support,,2015-08-31 20:35:55,2015-08-31 20:38:13,https://api.github.com/repos/ReactiveX/RxJava/issues/3259,['Enhancement'],204,42,ReactiveX_RxJava_pull_3259.diff
ReactiveX/RxJava,ReplaySubject,"Has full backpressure support (replays as many elements as requested).
",2015-08-31 19:50:37,2015-08-31 19:55:36,https://api.github.com/repos/ReactiveX/RxJava/issues/3258,['Enhancement'],834,0,ReactiveX_RxJava_pull_3258.diff
ReactiveX/RxJava,"Operator timeout, onBackpressureBuffer(onOverflow), fixes to parameter","types.
- FullArbiter and FullArbiterSubscriber to work with total-ordered notifications across sources.

I've also sorted `Observable` members.
",2015-08-31 14:56:44,2015-08-31 15:00:29,https://api.github.com/repos/ReactiveX/RxJava/issues/3257,['Enhancement'],2387,1339,ReactiveX_RxJava_pull_3257.diff
ReactiveX/RxJava,"Fixed debounce behavior, added throttleFirst, throttleLast alias","I've implemented the wrong debounce logic in #3254 .
",2015-08-31 11:38:39,2015-08-31 11:47:17,https://api.github.com/repos/ReactiveX/RxJava/issues/3256,['Enhancement'],363,77,ReactiveX_RxJava_pull_3256.diff
ReactiveX/RxJava,"Operator scan, reduce. Fixes to TestSubscriber async behavior.","TestSubscriber now does asynchronous requests and cancellation.
",2015-08-31 10:27:46,2015-08-31 10:30:31,https://api.github.com/repos/ReactiveX/RxJava/issues/3255,['Enhancement'],437,32,ReactiveX_RxJava_pull_3255.diff
ReactiveX/RxJava,"Operator debounce (time, selector), throttleWithTimeout (alias)","(Taking a break from `window()` operators.)
",2015-08-31 08:15:18,2015-08-31 08:19:25,https://api.github.com/repos/ReactiveX/RxJava/issues/3254,['Enhancement'],366,0,ReactiveX_RxJava_pull_3254.diff
ReactiveX/RxJava,"Operator window timespan, timespan + count, timespan + timeskip","The timed buffer and window operators are quite complicated in terms of
concurrency. I'm not sure if all corner cases are covered.
",2015-08-30 22:30:34,2015-08-30 22:37:28,https://api.github.com/repos/ReactiveX/RxJava/issues/3253,['Enhancement'],973,11,ReactiveX_RxJava_pull_3253.diff
ReactiveX/RxJava,"Window with count, count + skip.","Luckily, there is no need to count the emission per subject but just use
arithmetic.
",2015-08-30 17:48:49,2015-08-30 17:53:17,https://api.github.com/repos/ReactiveX/RxJava/issues/3251,['Enhancement'],270,1,ReactiveX_RxJava_pull_3251.diff
ReactiveX/RxJava,"Operator buffer with boundary and open-close, fixes to the timed","variants. 

Added `QueueDrain` and `QueueDrainSubscriber` for common queue-drain
operations. Not applied outside the `buffer()`s as of now.
",2015-08-30 16:34:06,2015-08-30 16:40:15,https://api.github.com/repos/ReactiveX/RxJava/issues/3250,['Enhancement'],1054,133,ReactiveX_RxJava_pull_3250.diff
ReactiveX/RxJava,Update Observable.java,,2015-08-30 15:16:45,2015-08-30 15:17:14,https://api.github.com/repos/ReactiveX/RxJava/issues/3249,[],1,1,ReactiveX_RxJava_pull_3249.diff
ReactiveX/RxJava,"Operators buffer: size, time, size + time","The boundary version will come next.
",2015-08-30 11:33:16,2015-08-30 11:38:24,https://api.github.com/repos/ReactiveX/RxJava/issues/3248,['Enhancement'],990,0,ReactiveX_RxJava_pull_3248.diff
ReactiveX/RxJava,"UnicastSubject, onBackpressureBuffer-like behavior for a single","subscriber only.

Should be the official API replacement of BufferUntilSubscriber.
",2015-08-29 23:17:16,2015-08-29 23:19:37,https://api.github.com/repos/ReactiveX/RxJava/issues/3247,['Enhancement'],310,0,ReactiveX_RxJava_pull_3247.diff
ReactiveX/RxJava,Operator refCount,"Converted nicely.
",2015-08-29 22:04:43,2015-08-29 22:06:51,https://api.github.com/repos/ReactiveX/RxJava/issues/3246,['Enhancement'],200,4,ReactiveX_RxJava_pull_3246.diff
ReactiveX/RxJava,"BlockingObservable, next, latest, mostRecent, first, last, single,","subscribe, stream, forEach, iterator

Now it extends both Publisher and Iterable directly.
",2015-08-29 21:43:32,2015-08-29 21:45:50,https://api.github.com/repos/ReactiveX/RxJava/issues/3245,['Enhancement'],1029,0,ReactiveX_RxJava_pull_3245.diff
ReactiveX/RxJava,"Operators delay, delaySubscription, share.","The `delaySubscription` is implemented via composition.
",2015-08-29 18:59:36,2015-08-29 19:02:07,https://api.github.com/repos/ReactiveX/RxJava/issues/3244,['Enhancement'],175,0,ReactiveX_RxJava_pull_3244.diff
ReactiveX/RxJava,"Operator materialize, dematerialize, minor notification fix.","`Optional.ofNullable` returns an empty instance, not a null-containing one.
",2015-08-29 18:18:54,2015-08-29 18:21:04,https://api.github.com/repos/ReactiveX/RxJava/issues/3243,['Enhancement'],266,25,ReactiveX_RxJava_pull_3243.diff
ReactiveX/RxJava,"Operator using, some internal refactorings.","EmptySubscriber convenience method to reduce boilerplate.
",2015-08-29 17:47:28,2015-08-29 17:49:57,https://api.github.com/repos/ReactiveX/RxJava/issues/3242,['Enhancement'],205,56,ReactiveX_RxJava_pull_3242.diff
ReactiveX/RxJava,Operator combineLatest,"- Some minor internal refactorings in `Observable`.
",2015-08-29 17:08:18,2015-08-29 17:10:49,https://api.github.com/repos/ReactiveX/RxJava/issues/3241,['Enhancement'],533,32,ReactiveX_RxJava_pull_3241.diff
ReactiveX/RxJava,Operator sequenceEqual,"Inlined (no zipping and wrapping like in 1.x)
",2015-08-29 13:52:50,2015-08-29 14:00:45,https://api.github.com/repos/ReactiveX/RxJava/issues/3240,['Enhancement'],299,0,ReactiveX_RxJava_pull_3240.diff
ReactiveX/RxJava,Operator takeWhile,"- a small correction to ConditionalSubscriber: the default onNext removed to avoid bad usage (i.e., not requesting if not accepted).
",2015-08-29 12:35:09,2015-08-29 12:40:39,https://api.github.com/repos/ReactiveX/RxJava/issues/3239,['Enhancement'],104,5,ReactiveX_RxJava_pull_3239.diff
ReactiveX/RxJava,"Operator retryWhen, repeatWhen; Notification","- a fix to OperatorOnErrorNext
",2015-08-29 12:17:55,2015-08-29 12:21:46,https://api.github.com/repos/ReactiveX/RxJava/issues/3238,['Enhancement'],274,7,ReactiveX_RxJava_pull_3238.diff
ReactiveX/RxJava,"Operators onErrorReturn, onErrorResumeNext, onExceptionResumeNext","- onErrorReturnValue
",2015-08-29 10:13:12,2015-08-29 10:18:38,https://api.github.com/repos/ReactiveX/RxJava/issues/3237,['Enhancement'],304,0,ReactiveX_RxJava_pull_3237.diff
ReactiveX/RxJava,"Operator amb, ambWith","Very similar to zip in terms of structure.
",2015-08-29 08:15:08,2015-08-29 08:20:41,https://api.github.com/repos/ReactiveX/RxJava/issues/3235,['Enhancement'],281,0,ReactiveX_RxJava_pull_3235.diff
ReactiveX/RxJava,"Operator switchMap, switchOnNext, added missing merge and concat","overloads, some refactorings
",2015-08-29 00:26:42,2015-08-29 00:28:57,https://api.github.com/repos/ReactiveX/RxJava/issues/3234,['Enhancement'],432,51,ReactiveX_RxJava_pull_3234.diff
ReactiveX/RxJava,"Operators first, last, multi-offer for SpscLinkedArrayQueue","The multi-offer helps with the timed skipLast. By offering two at once, the drain won't loop until the second value arrives.
",2015-08-28 20:40:01,2015-08-28 20:42:48,https://api.github.com/repos/ReactiveX/RxJava/issues/3232,['Enhancement'],54,5,ReactiveX_RxJava_pull_3232.diff
ReactiveX/RxJava,"Operator takeLast time + size, skipLast time","- bufferSize +delayError options, as usual by now
",2015-08-28 20:03:30,2015-08-28 20:06:59,https://api.github.com/repos/ReactiveX/RxJava/issues/3231,['Enhancement'],573,0,ReactiveX_RxJava_pull_3231.diff
ReactiveX/RxJava,"Operato switchIfEmpty, defaultIfEmpty",,2015-08-28 18:27:22,2015-08-28 18:29:55,https://api.github.com/repos/ReactiveX/RxJava/issues/3230,['Enhancement'],85,0,ReactiveX_RxJava_pull_3230.diff
ReactiveX/RxJava,Operator sample with time or with another publisher,"I'd like to state that I try to use `Publisher` as much as possible: this adds the benefit that RxJava can use someone else's publisher without the explicit need to wrap it into an `Observable` all the time.
",2015-08-28 17:56:26,2015-08-28 17:59:28,https://api.github.com/repos/ReactiveX/RxJava/issues/3229,['Enhancement'],366,0,ReactiveX_RxJava_pull_3229.diff
ReactiveX/RxJava,ConditionalSubscriber to help fusing filter-like operators into,"emission/drain loops.

This may help with operators that call request(1) to replenish a dropped value (filter for example).

I've only implemented this with the array-source and with a lot of code duplication. I'll think about how to reduce this duplication via inheritance or with lambdas (which might negate the benefit).
",2015-08-28 16:32:27,2015-08-28 16:46:32,https://api.github.com/repos/ReactiveX/RxJava/issues/3228,['Enhancement'],134,5,ReactiveX_RxJava_pull_3228.diff
ReactiveX/RxJava,collect: javac is unable to select the right overload for some reason,"javac is unable to select the right overload for some reason
",2015-08-28 14:26:02,2015-08-28 14:28:49,https://api.github.com/repos/ReactiveX/RxJava/issues/3227,[],1,1,ReactiveX_RxJava_pull_3227.diff
ReactiveX/RxJava,"Operator collect, toMap and toMultimap based on it.","I know `toList` can be also implemented this way but its frequent use makes it eligible for a custom operator.
",2015-08-28 14:08:21,2015-08-28 14:08:25,https://api.github.com/repos/ReactiveX/RxJava/issues/3226,['Enhancement'],385,191,ReactiveX_RxJava_pull_3226.diff
ReactiveX/RxJava,Operations doOnX.,"The various doOnXXX operator overloads + range(scheduler) + repeat(scheduler).
",2015-08-28 13:37:58,2015-08-28 13:42:48,https://api.github.com/repos/ReactiveX/RxJava/issues/3225,['Enhancement'],184,0,ReactiveX_RxJava_pull_3225.diff
ReactiveX/RxJava,"Operator distinct, timeInterval, common Timed container.","Instead of having `Timestamped` and `TimeInterval` with the same structure, let's have just a single one: `Timed`.

`distinctUntilChanged` is implemented via special `distinct`.
",2015-08-28 13:08:05,2015-08-28 13:11:20,https://api.github.com/repos/ReactiveX/RxJava/issues/3224,['Enhancement'],354,27,ReactiveX_RxJava_pull_3224.diff
ReactiveX/RxJava,"Fixes to classes, convenience operators mostly.","Also corrected the naming of one-shot timer and fixed-period interval
",2015-08-28 11:39:17,2015-08-28 11:43:24,https://api.github.com/repos/ReactiveX/RxJava/issues/3223,"['Bug', 'Enhancement']",277,23,ReactiveX_RxJava_pull_3223.diff
ReactiveX/RxJava,"Operator WithLatestFrom, PublishLift to help with operator fusing,","SubscriptionHelper for common validation logic.

The SubscriptionHelper's methods are not yet applied to former operators.
",2015-08-28 09:52:01,2015-08-28 09:55:20,https://api.github.com/repos/ReactiveX/RxJava/issues/3222,['Enhancement'],366,16,ReactiveX_RxJava_pull_3222.diff
ReactiveX/RxJava,"Strenghtening flatMap against misbehaving sources, TestSubscriber +","methods.
",2015-08-28 07:45:30,2015-08-28 07:54:40,https://api.github.com/repos/ReactiveX/RxJava/issues/3220,['Enhancement'],76,1,ReactiveX_RxJava_pull_3220.diff
ReactiveX/RxJava,Operator zip plus Function3..Function9.,"FunctionX extends Function<Object[], R> and the default method for it unpacks the array.
",2015-08-27 21:13:27,2015-08-27 21:13:31,https://api.github.com/repos/ReactiveX/RxJava/issues/3215,['Enhancement'],684,0,ReactiveX_RxJava_pull_3215.diff
ReactiveX/RxJava,Fix to Notification equals method.,"The Notification method was missing a check to hasValue and hasThrowable. This allowed for a null value onNext Notification to equal an Object notification. A similar bug for onError Notification events also existed.
",2015-08-27 21:09:21,2015-08-28 17:30:48,https://api.github.com/repos/ReactiveX/RxJava/issues/3214,['Bug'],69,0,ReactiveX_RxJava_pull_3214.diff
ReactiveX/RxJava,Operator groupBy,"This default implementation supports backpressure but doesn't coordinate the group requests with the main requests in any way. 

This means, for example, that given a million element source and a constant true key selector will queue up all million elements until a single subscriber consumes them.

The 1.x version had some coordination and all sorts of group management logic which I don't understand. I'll revisit this operator later.
",2015-08-27 19:06:32,2015-08-27 19:08:46,https://api.github.com/repos/ReactiveX/RxJava/issues/3212,['Enhancement'],436,1,ReactiveX_RxJava_pull_3212.diff
ReactiveX/RxJava,Operators onBackpressure(Drop|Buffer|Latest),"There won't be `onBackpressureBlock` although it can work with `subscribeOn(scheduler, false)` since that won't schedule the request behind the blocked emission.

Operator `onBackpressureBuffer` has now a `delayError` option; I'd like to give the developer the option on this one. Naturally, the default is false.
",2015-08-27 14:39:06,2015-08-27 14:41:30,https://api.github.com/repos/ReactiveX/RxJava/issues/3209,['Enhancement'],556,0,ReactiveX_RxJava_pull_3209.diff
ReactiveX/RxJava,Operators interval and intervalRange,"`intervalRange` helps when one needs a fixed amount of timed values and wants to avoid map+take overhead.
",2015-08-27 13:32:15,2015-08-27 13:35:17,https://api.github.com/repos/ReactiveX/RxJava/issues/3208,['Enhancement'],470,0,ReactiveX_RxJava_pull_3208.diff
ReactiveX/RxJava,"Some Repeat + Retry methods, fix to SubscriptionArbiter.","I'll post the `retryWhen` and `repeatWhen` separately.
",2015-08-27 12:33:32,2015-08-27 12:48:22,https://api.github.com/repos/ReactiveX/RxJava/issues/3207,['Enhancement'],365,1,ReactiveX_RxJava_pull_3207.diff
ReactiveX/RxJava,TestSubscriber implemented,"- internal `EmptySubscriber`
",2015-08-27 11:20:47,2015-08-27 11:23:28,https://api.github.com/repos/ReactiveX/RxJava/issues/3206,['Enhancement'],622,0,ReactiveX_RxJava_pull_3206.diff
ReactiveX/RxJava,Lambda-based subscribe and lifecycle tracking methods,"- forEachWhile that allows stopping the stream from within the onNext callback by returning false.

The lambda subscribe()s return a Disposable so they can be asynchronously cancelled.
",2015-08-27 09:11:34,2015-08-27 09:19:02,https://api.github.com/repos/ReactiveX/RxJava/issues/3205,['Enhancement'],297,0,ReactiveX_RxJava_pull_3205.diff
ReactiveX/RxJava,Operator concatMap and related convenience methods,"This includes
- concatMap
- concat
- startWith
- endWith
- concatWith
- mergeWith (via merge)
",2015-08-27 08:23:17,2015-08-27 08:26:20,https://api.github.com/repos/ReactiveX/RxJava/issues/3204,['Enhancement'],435,0,ReactiveX_RxJava_pull_3204.diff
ReactiveX/RxJava,Implemented the AsyncOnSubscribe,"This includes the first functioning unit tests. This still has a few iterations to go but opening PR for review.
",2015-08-27 00:49:32,2015-09-11 19:26:13,https://api.github.com/repos/ReactiveX/RxJava/issues/3203,['Enhancement'],918,0,ReactiveX_RxJava_pull_3203.diff
ReactiveX/RxJava,"Operators observeOn, subscribeOn and unsubscribeOn","Few considerations:
- Added an option to specify if `subscribeOn` should also request on the same worker or not. If not, the consumer thread may freely grab the producer and thus reduce the inter-thread communication.
- The scheduling of the subscription in `subscribeOn` now can't be cancelled because in RS, the indication of 'subscription' is to call `onSubscribe` on the proper thread. Since the `Subscriber` can't call cancel until it receives the subscription through `onSubscribe` the time it receives the subscription there is no point in cancelling the operation.
- Added two parametrization option to `observeOn`: the ability to delay the error after all the `onNext` events and the ability to specify the buffer size. Since many get surprised by the 1.x behavior, this should help the situation and also makes it possible to avoid wrapping/materializing the sequence. The second ability should help with fine tuning a particular sequence independent to the other sequences.
- I've padded away (since the `@Contended` annotation is not standard) the request and wip counters in `observeOn`. If unpadded, they bash each other constantly and I've experienced 15-20% throughput loss.
",2015-08-26 21:54:57,2015-08-26 21:57:31,https://api.github.com/repos/ReactiveX/RxJava/issues/3202,['Enhancement'],484,7,ReactiveX_RxJava_pull_3202.diff
ReactiveX/RxJava,All standard schedulers ported and cleaned up.,"- updated RxJavaPlugins and added decorator calls to the Schedulers.
",2015-08-26 19:32:58,2015-08-26 19:38:17,https://api.github.com/repos/ReactiveX/RxJava/issues/3200,['Enhancement'],1058,29,ReactiveX_RxJava_pull_3200.diff
ReactiveX/RxJava,"Operators all, any, count, elementAt, single","- isEmpty == any(v -> true)
",2015-08-26 17:23:43,2015-08-26 17:26:37,https://api.github.com/repos/ReactiveX/RxJava/issues/3199,['Enhancement'],578,0,ReactiveX_RxJava_pull_3199.diff
ReactiveX/RxJava,"Operators publish, replay and cache.","I'm not 100% certain about the the timing of the onSubscribe() calls inside the operators; I'll have a second run over them once the tests are also added.
",2015-08-26 14:33:55,2015-08-26 14:56:41,https://api.github.com/repos/ReactiveX/RxJava/issues/3198,['Enhancement'],2837,2,ReactiveX_RxJava_pull_3198.diff
ReactiveX/RxJava,Operator toList and toSortedList,"`toSortedList` is implemented with `toList().map()`.
",2015-08-26 12:30:55,2015-08-26 12:33:14,https://api.github.com/repos/ReactiveX/RxJava/issues/3197,['Enhancement'],195,1,ReactiveX_RxJava_pull_3197.diff
ReactiveX/RxJava,The skips and filter operators added to Observable,"Forgot to add them in the previous PR.
",2015-08-26 11:50:38,2015-08-26 11:54:24,https://api.github.com/repos/ReactiveX/RxJava/issues/3196,['Enhancement'],43,8,ReactiveX_RxJava_pull_3196.diff
ReactiveX/RxJava,"Operators of skip (untimed), filter; fix to takeUntil","In `takeUntil`, the other source may emit an `onError` before the main source sets a subscription. The fix makes sure if other is first, it sets an empty subscription before emitting the error (this is an RS specific thing, doesn't affect 1.x).
",2015-08-26 11:39:19,2015-08-26 11:41:34,https://api.github.com/repos/ReactiveX/RxJava/issues/3195,['Enhancement'],490,8,ReactiveX_RxJava_pull_3195.diff
ReactiveX/RxJava,"Operators of take (untimed), plugin error reporting fix for other","operators
",2015-08-26 11:16:01,2015-08-26 11:18:18,https://api.github.com/repos/ReactiveX/RxJava/issues/3194,['Enhancement'],708,11,ReactiveX_RxJava_pull_3194.diff
ReactiveX/RxJava,ConnectableObservable and autoConnect,"`refCount` will come later, although its behavior is sometimes surprising to developers: it disconnects and reconnects in certain use pattern. The alternative is to use `autoConnect(n, connectionConsumer)` which lets the developer explicitly disconnect.
",2015-08-26 10:40:31,2015-08-26 10:44:04,https://api.github.com/repos/ReactiveX/RxJava/issues/3193,['Enhancement'],182,0,ReactiveX_RxJava_pull_3193.diff
ReactiveX/RxJava,Connectable observable2x,,2015-08-26 10:32:50,2015-08-26 10:33:20,https://api.github.com/repos/ReactiveX/RxJava/issues/3192,[],6994,106878,ReactiveX_RxJava_pull_3192.diff
ReactiveX/RxJava,Operators map and flatMap,"With all `flatMap`, `merge` and `mergeDelayError` overloads.
",2015-08-26 10:14:43,2015-08-26 10:17:25,https://api.github.com/repos/ReactiveX/RxJava/issues/3191,['Enhancement'],793,2,ReactiveX_RxJava_pull_3191.diff
ReactiveX/RxJava,Basic Subscribers and plugin class,"- SafeSubscriber
- SerializedSubscriber
- RxJavaPlugins (partial)
",2015-08-26 09:25:24,2015-08-26 09:41:31,https://api.github.com/repos/ReactiveX/RxJava/issues/3190,['Enhancement'],463,26,ReactiveX_RxJava_pull_3190.diff
ReactiveX/RxJava,Added a bunch of basic event sources and helper Subscription,"implementations.
",2015-08-26 07:46:48,2015-08-26 07:52:17,https://api.github.com/repos/ReactiveX/RxJava/issues/3189,['Enhancement'],1066,0,ReactiveX_RxJava_pull_3189.diff
ReactiveX/RxJava,"Schedulers (a few) + API, slight modifications to other classes,","incomplete.

This PR has a few TODO questions that require decisions.
",2015-08-25 22:25:17,2015-08-26 06:58:42,https://api.github.com/repos/ReactiveX/RxJava/issues/3188,['Enhancement'],890,2,ReactiveX_RxJava_pull_3188.diff
ReactiveX/RxJava,Disposable interface and a bunch of general resource containers.,"Mostly internal addition plus the public `Disposable` interface.

Naming of packages and classes can be changed at any time if one wishes...
",2015-08-25 14:56:47,2015-08-25 14:59:30,https://api.github.com/repos/ReactiveX/RxJava/issues/3186,['Enhancement'],793,8,ReactiveX_RxJava_pull_3186.diff
ReactiveX/RxJava,"PublishSubject, AsyncSubject and a few helper classes","We can use `Publisher` directly and no need for `OnSubscribe`. `Operator` is still quite a convenience.
",2015-08-25 13:10:32,2015-08-25 13:47:30,https://api.github.com/repos/ReactiveX/RxJava/issues/3185,['Enhancement'],2019,6,ReactiveX_RxJava_pull_3185.diff
ReactiveX/RxJava,Refactored exception reporting of most operators.,"Added two convenient methods to `Exceptions` which either throws a fatal exception or reports it with our without the causing value to an Observer.
",2015-08-24 22:11:51,2015-08-28 18:43:38,https://api.github.com/repos/ReactiveX/RxJava/issues/3183,"['Bug', 'Enhancement']",167,141,ReactiveX_RxJava_pull_3183.diff
ReactiveX/RxJava,MapNotification producer NPE fix,"Fixed the NPE reported in #3180.
",2015-08-24 17:20:19,2015-08-24 21:19:08,https://api.github.com/repos/ReactiveX/RxJava/issues/3181,['Bug'],109,42,ReactiveX_RxJava_pull_3181.diff
ReactiveX/RxJava,BackpressureUtils capped add/multiply methods + tests,"Common methods to add and multiply longs and cap the result at Long.MAX_VALUE in case of an overflow.
",2015-08-22 10:36:48,2015-08-24 21:17:53,https://api.github.com/repos/ReactiveX/RxJava/issues/3177,['Enhancement'],72,10,ReactiveX_RxJava_pull_3177.diff
ReactiveX/RxJava,Some safe queue implementations,"Spsc:
- power-of-2 array
- exact capacity array
- linked array

Mpsc:
- linked
",2015-08-21 20:25:11,2015-08-21 20:36:42,https://api.github.com/repos/ReactiveX/RxJava/issues/3175,['Enhancement'],1054,0,ReactiveX_RxJava_pull_3175.diff
ReactiveX/RxJava,Blocking subscribe methods for convenience,"Mirroring some `Observable.subscribe` methods on `BlockingObservable`.

Related discussion: #3063.
",2015-08-21 16:32:31,2015-10-08 16:45:44,https://api.github.com/repos/ReactiveX/RxJava/issues/3174,['Enhancement'],386,34,ReactiveX_RxJava_pull_3174.diff
ReactiveX/RxJava,"RS dependency, some basic Observable/Observer methods.","- Added compile dependency for reactive-streams.
- Added some basic methods to Observable.

As long as the project defaults to 1.x, the create PR webpage will take a long time to render because it tries to compare a small branch 2.x against the huge 1.x branch with lots of 'deleted' content. A separate project would be much simpler to operate.
",2015-08-21 13:51:50,2015-08-25 07:00:11,https://api.github.com/repos/ReactiveX/RxJava/issues/3172,['Enhancement'],125,1,ReactiveX_RxJava_pull_3172.diff
ReactiveX/RxJava,Scan backpressure and first emission fix,"Fixes #3168

If there is no initial value, there is no need to manipulate the request amounts.

If there is an initial value, we must do a full emitter-loop with value queueing because now the downstream request can race with the first onNext or the setting of the upstream producer. The downside is the increased overhead which should be reduced when the spsc unbounded queues get merged.
",2015-08-21 12:13:33,2015-08-28 17:27:44,https://api.github.com/repos/ReactiveX/RxJava/issues/3171,['Bug'],321,88,ReactiveX_RxJava_pull_3171.diff
ReactiveX/RxJava,Merge can now operate in horizontally unbounded mode.,"Resolves #3156 

Note that since the default merge operation is unbounded, this change could lead to an excessive memory usage when flatMapping fast sources. Note that the pre 1.0.13 version did this albeit on a slighty slower path.

The change also affects the scalar optimization as well. Pre 1.0.13 implicitly limited the concurrency level to RxRingBuffer.SIZE when scalars were received. This version now fills the queue up to the concurrency level.

For 2.0, I suggest having a bounded behavior by default and require the developer to specify Integer.MAX_VALUE to go for the unbounded behavior so he/she knows about the consequences.
",2015-08-20 20:10:24,2015-11-10 21:39:27,https://api.github.com/repos/ReactiveX/RxJava/issues/3169,"['Bug', 'Enhancement']",923,24,ReactiveX_RxJava_pull_3169.diff
ReactiveX/RxJava,Fixed negative request due to unsubscription of a large requester,"Reported in #3166 

What happened is that if there are multiple subscribers, one with larger requests than the others and it unsubscribed early, the new max request of the others then became smaller than before which yielded a negative difference and thus a negative request.
",2015-08-20 17:26:27,2015-08-24 21:18:56,https://api.github.com/repos/ReactiveX/RxJava/issues/3167,['Bug'],26,1,ReactiveX_RxJava_pull_3167.diff
ReactiveX/RxJava,Making a cross between defer() and just() ,"that takes advantage of existing scalar synchronous optimizations.
",2015-08-18 19:55:57,2015-08-25 23:27:47,https://api.github.com/repos/ReactiveX/RxJava/issues/3163,[],123,39,ReactiveX_RxJava_pull_3163.diff
ReactiveX/RxJava,Remove redundant variables,"Remove redundant variables from the following classes:
- OperatorTimeoutBase
- EventLoopsScheduler
",2015-08-14 21:47:09,2015-08-18 19:08:13,https://api.github.com/repos/ReactiveX/RxJava/issues/3160,[],3,9,ReactiveX_RxJava_pull_3160.diff
ReactiveX/RxJava,SafeSubscriber - report onCompleted unsubscribe error to RxJavaPlugin ,"Discussed in #2464, when an observable emits `onCompleted` but `unsubscribe` in `SafeSubscriber` throws then the error should be reported to the `RxJavaPlugin` error handler and if that fails a stack trace is written to `System.err`.
",2015-08-14 11:12:54,2015-08-24 21:17:29,https://api.github.com/repos/ReactiveX/RxJava/issues/3155,"['Bug', 'Enhancement']",223,66,ReactiveX_RxJava_pull_3155.diff
ReactiveX/RxJava,Add Observable.fromCallable() as a companion for Observable.defer(),"Yep, this is a new operator.

Motivation? `Observable.defer()` requires function that returns `Observable<T>` when usually we don't want to create `Observable<T>` manually, we just want to defer execution of some function.

Like this:

``` java
Observable
  .fromCallable(() -> someFunc())
  .subscribeOn(...)
  ...
```

Instead of this:

``` java
Observable
  .defer(() -> Observable.just(someFunc()))
  .subscribeOn(...)
  ...
```

And more important case with deferring code that throws checked exceptions:

``` java
Observable
  .fromCallable(() -> {
    Value value = ...;
    // some code
    return value;
  })
 .subscribeOn(...)
 ...
```

Instead of this:

``` java
Observable
  .defer(() -> {
    try {
      Value value = ...;
       // some code that throws checked exceptions
      return Observable.just(value);
    } catch (Exception e) {
      return Observable.error(e);
    }
  })
 .subscribeOn(...)
 ...
```

I'd use name `defer` but both methods will have same type erasure (`Func0<Observable>` and `Func0<T>`), so I had to use a different name.

Questions:
1. Useful or not? For me — deferring some function call is a common task.
2. Naming.

If the decision about this operator will be positive — I'll add javadoc to this PR and then create separate PR for `Single.fromCallable()`.
",2015-08-14 01:03:47,2015-09-04 21:19:11,https://api.github.com/repos/ReactiveX/RxJava/issues/3154,['Enhancement'],201,0,ReactiveX_RxJava_pull_3154.diff
ReactiveX/RxJava,Add semantic-named override for unsubscribe-action subscription.,"Closes #2967.
",2015-08-13 01:16:45,2015-10-08 16:44:51,https://api.github.com/repos/ReactiveX/RxJava/issues/3151,['Discussion'],54,46,ReactiveX_RxJava_pull_3151.diff
ReactiveX/RxJava,Window operators now support backpressure in the inner observable.,"Repost of #3050.
",2015-08-12 22:47:48,2015-11-23 23:17:18,https://api.github.com/repos/ReactiveX/RxJava/issues/3150,['Enhancement'],1117,22,ReactiveX_RxJava_pull_3150.diff
ReactiveX/RxJava,Scheduler shutdown capability,"Repost of #3022.
",2015-08-12 21:20:48,2015-10-01 18:49:09,https://api.github.com/repos/ReactiveX/RxJava/issues/3149,['Enhancement'],457,94,ReactiveX_RxJava_pull_3149.diff
ReactiveX/RxJava,Remove unnecessary static modifier,"P.S. 
@benjchristensen @akarnokd sorry for large amount of simple pull requests, I'm doing full code review of RxJava sources http://artemzin.com/blog/rxjava-code-review-part-1/ and I'll create PRs and issues during this review.

I'll try to group changes by themes so it will be easy to review them. Looks like this adventure is going to be part of #3145!
",2015-08-10 23:47:52,2015-08-12 19:36:29,https://api.github.com/repos/ReactiveX/RxJava/issues/3147,['Enhancement'],3,3,ReactiveX_RxJava_pull_3147.diff
ReactiveX/RxJava,Remove redundant cast in Exceptions,,2015-08-10 16:53:57,2015-08-12 19:35:27,https://api.github.com/repos/ReactiveX/RxJava/issues/3144,['Enhancement'],1,1,ReactiveX_RxJava_pull_3144.diff
ReactiveX/RxJava,Fix for BackpressureUtils method javadoc,,2015-08-10 16:19:10,2015-08-12 12:02:59,https://api.github.com/repos/ReactiveX/RxJava/issues/3143,[],1,3,ReactiveX_RxJava_pull_3143.diff
ReactiveX/RxJava,Remove redundant final modifier from static method in Actions,,2015-08-10 16:10:08,2015-08-12 21:46:43,https://api.github.com/repos/ReactiveX/RxJava/issues/3142,['Enhancement'],1,1,ReactiveX_RxJava_pull_3142.diff
ReactiveX/RxJava,Improved Scheduler.Worker memory leak detection,"The former Executor-based check instantiated the wrong worker. In addition, I've refactored the common parts, added check for periodic task retention (after the first round) and added the checks to computation scheduler test as well.
",2015-08-09 09:28:04,2015-08-09 09:43:01,https://api.github.com/repos/ReactiveX/RxJava/issues/3141,['Enhancement'],110,59,ReactiveX_RxJava_pull_3141.diff
ReactiveX/RxJava,Range overhead reduction.,"Applied some refactorings and local variable usage to reduce the overhead.

Few observations:
- Having too many local variables may cause register spill, even on x64 which makes some `size` benchmark faster while other slower.
- The observeOn benchmarks are quite hectic because of receiving thread migration caused by the round-robin worker assignment. It affects the benchmarks with 1 or 1000 elements in the stream.
- Note that the previous `OperatorRangePerf` `size = 1` measured the speed of `just` due to the optimization of `range()`. The updated perf now instantiates the `OnSubscribeRange`.
- Note that the `observeOn` benchmark with `size = 1` run the `just()` as well.

Benchmark comparison (i7 4770K, Windows 7 x64, Java 8u51)
![image](https://cloud.githubusercontent.com/assets/1269832/9153053/5f501902-3e42-11e5-85ea-8ff1f6725c08.png)
",2015-08-09 01:10:48,2015-08-12 20:14:31,https://api.github.com/repos/ReactiveX/RxJava/issues/3138,['Enhancement'],92,56,ReactiveX_RxJava_pull_3138.diff
ReactiveX/RxJava,FromIterable overhead reduction.,"Some restructuring reduces the overhead of operators:
- extending `AtomicLong` gives access to atomic intrinsics for the request accounting
- loading the final fields into local variables prevents them from being reloaded from cache due to the atomics around them
- request() is hot but generally too large due to the fastpath/slowpath fit and JIT may not want to pick it up early. By refactoring the two paths into two separate methods, it becomes inline friendly for the either of the paths.

Benchmark results on my i7 4770K, Windows 7 x64, Java 8u51:

![image](https://cloud.githubusercontent.com/assets/1269832/9147979/50438994-3d70-11e5-8e17-1af9b23c8506.png)

The benchmark from #3118 gives this result:

![image](https://cloud.githubusercontent.com/assets/1269832/9148013/f49effa0-3d70-11e5-9d66-346bfaba6daa.png)
",2015-08-07 23:58:52,2015-08-12 20:11:15,https://api.github.com/repos/ReactiveX/RxJava/issues/3137,['Enhancement'],142,48,ReactiveX_RxJava_pull_3137.diff
ReactiveX/RxJava,Renaming rx.Subscriber#request(long) to requestFromProducer(long),"Right now its not possible to both extend `rx.Subscriber` and implement `rx.Producer`. See test below.

``` java
public class Foo<T> extends Subscriber<T> implements Producer {

    @Override
    public void onCompleted() {
    }

    @Override
    public void onError(Throwable e) {
    }

    @Override
    public void onNext(T t) {
    }

    @Override
    public void request(long n) {
    }
}
```

Currently this blows up because `protected rx.Subscriber#request(long)` collides with `public rx.Producer#request(long)`. 
",2015-08-06 20:53:47,2015-08-12 22:25:25,https://api.github.com/repos/ReactiveX/RxJava/issues/3135,"['Discussion', 'Enhancement']",174,174,ReactiveX_RxJava_pull_3135.diff
ReactiveX/RxJava,"Switch to PrivateConstructorChecker for ""testNotInstantiable"" tests","@akarnokd as I promised in #3112 I am adding nice class that allows to assert that:
- Class has **only one constructor without args and that it's private**.
- Constructor throws exception (optional) with some type and/or message.

Here is the repository: https://github.com/pushtorefresh/java-private-constructor-checker

Hope you'll find it nice & useful!

Previous solution didn't check that constructor is private, that class has only one constructor and it required a lot of boilerplate code!
",2015-08-04 23:04:06,2015-12-04 22:41:02,https://api.github.com/repos/ReactiveX/RxJava/issues/3130,['Enhancement'],422,61,ReactiveX_RxJava_pull_3130.diff
ReactiveX/RxJava,Fix retry with predicate ignoring backpressure.,"Apparently, we forgot about this operator. The backpressure handling is a trivial case with `ProducerArbiter`. I've also fixed some apparent code indentation error.

Originally reported in #3128 with a test case which I didn't include due to its lengthy nature; however, I did run the test manually and both passed after the fix.
",2015-08-03 19:29:48,2015-08-06 08:24:54,https://api.github.com/repos/ReactiveX/RxJava/issues/3129,['Bug'],105,54,ReactiveX_RxJava_pull_3129.diff
ReactiveX/RxJava,Allow to use null as error for TestSubscriber.assertError(),"Resolves #3125 via test, makes `TestSubscriber.assertError()` little bit faster via caching first error, and allows to use `TestSubscriber.assertError(null)`.
",2015-07-31 17:40:34,2015-08-12 22:19:28,https://api.github.com/repos/ReactiveX/RxJava/issues/3126,['Bug'],36,10,ReactiveX_RxJava_pull_3126.diff
ReactiveX/RxJava,Remove redundant type parameter in EmptyAction,"There is one too many.
",2015-07-29 23:31:49,2015-08-12 19:38:31,https://api.github.com/repos/ReactiveX/RxJava/issues/3123,['Enhancement'],2,2,ReactiveX_RxJava_pull_3123.diff
ReactiveX/RxJava,"Improve performance of NewThreadWorker, disable search for setRemoveOnCancelPolicy() on Android API < 21","Resolves #3119.

This PR adds methods for detecting Android API Version and disables `NewThreadWorker.tryEnableCancelPolicy()` on Android API < 21 which has significant performance cost on Android.

PR also improves performance of `NewThreadWorker.tryEnableCancelPolicy()` via caching Reflection.
",2015-07-29 18:16:10,2015-08-01 10:58:18,https://api.github.com/repos/ReactiveX/RxJava/issues/3121,['Enhancement'],186,29,ReactiveX_RxJava_pull_3121.diff
ReactiveX/RxJava,No InterruptedException with synchronous BlockingObservable,"I'm using Observable for backport of Java 8's java.util.stream (i.e. [no more loops](http://www.deadcoderising.com/java-8-no-more-loops/)) for Android project.

``` java
List<Foo> list2 = Observable.from(list)
        .map(...)
        .filter(...)
        .toList().toBlocking().single()
```

But it sometimes emits InterruptedException at BlockingObservable.
https://github.com/ReactiveX/RxJava/issues/1804#issuecomment-61396523

As the BlocingObservable is placed in map() of another observable with `subscribeOn(Schedulers.io())`, and it is unsubscribed from main thread, perhaps Future.cancel(true) is called on unsubscribing. (#1914)

This PR allows BlockingObsevable not to be interrupted when source observable emits synchronously, by checking current latch or queue state before awaiting for them.
",2015-07-29 17:31:18,2015-07-30 07:17:02,https://api.github.com/repos/ReactiveX/RxJava/issues/3120,['Enhancement'],215,104,ReactiveX_RxJava_pull_3120.diff
ReactiveX/RxJava,Implementing the SyncOnSubscribe,"This is useful for creating an observable that reads from a data source in a synchronous manner. This is a rewrite of the `AbstractOnSubscribe` experimental class based on the ideas in #3003.
",2015-07-29 01:00:37,2015-09-01 19:13:16,https://api.github.com/repos/ReactiveX/RxJava/issues/3118,['Enhancement'],1649,42,ReactiveX_RxJava_pull_3118.diff
ReactiveX/RxJava,Operator replay() now supports backpressure (again),"And applied the hardenings as well.
",2015-07-27 06:43:06,2015-07-27 06:49:39,https://api.github.com/repos/ReactiveX/RxJava/issues/3117,['Enhancement'],1620,261,ReactiveX_RxJava_pull_3117.diff
ReactiveX/RxJava,cache() now supports backpressure (again),"Implemented backpressure for cache() again and applied the hardenings as well.
",2015-07-27 06:30:35,2015-07-27 06:49:27,https://api.github.com/repos/ReactiveX/RxJava/issues/3116,['Enhancement'],930,242,ReactiveX_RxJava_pull_3116.diff
ReactiveX/RxJava,Observers package test coverage and fixes.,"This includes a rewrite of `SerializedObserver` to have a more cleaner exception semantics.

The `TestSubscriberTest` can be improved further but I've run out of time for today.
",2015-07-24 13:00:36,2015-08-12 19:48:53,https://api.github.com/repos/ReactiveX/RxJava/issues/3112,"['Bug', 'Enhancement']",1475,169,ReactiveX_RxJava_pull_3112.diff
ReactiveX/RxJava,remove OnSubscribeMulticastSelector and SubscriptionRandomList,"remove `OnSubscribeMulticastSelector` and `SubscriptionRandomList` because unused
",2015-07-24 10:57:26,2015-07-24 11:33:49,https://api.github.com/repos/ReactiveX/RxJava/issues/3111,[],0,232,ReactiveX_RxJava_pull_3111.diff
ReactiveX/RxJava,Test coverage of rx.functions utility methods.,"Since these are public API methods, their expected behavior needs to be verified.
",2015-07-24 10:33:56,2015-07-24 10:39:31,https://api.github.com/repos/ReactiveX/RxJava/issues/3110,['Enhancement'],558,0,ReactiveX_RxJava_pull_3110.diff
ReactiveX/RxJava,Unit tests and cleanup of JCTools' queues.,"Increased test coverage of JCTools' queues and unsafe activities. Fixed inconsistencies in the queues.
",2015-07-24 09:14:26,2015-07-24 09:38:54,https://api.github.com/repos/ReactiveX/RxJava/issues/3109,['Enhancement'],428,62,ReactiveX_RxJava_pull_3109.diff
ReactiveX/RxJava,remove OperatorOnErrorFlatMap because unused,"as per issue #3106, this PR removes `OperatorOnErrorFlatMap` because it is unused.
",2015-07-24 08:08:05,2015-07-24 08:20:11,https://api.github.com/repos/ReactiveX/RxJava/issues/3108,[],0,84,ReactiveX_RxJava_pull_3108.diff
ReactiveX/RxJava,Fix SynchronizedQueue.equals,"Courtesy of findBugs, `SynchronizedQueue.equals()` is improperly implemented. I used Eclipse to generate a new `equals()` method based on the `list` field.

The existing code would even have failed to return true when testing queue equality with itself.

I don't think this is causing problems anywhere but this PR will ensure that it doesn't cause a problem in the future.
",2015-07-24 05:20:10,2015-08-12 19:37:47,https://api.github.com/repos/ReactiveX/RxJava/issues/3104,['Bug'],31,4,ReactiveX_RxJava_pull_3104.diff
ReactiveX/RxJava,materialize() - add backpressure support,"As mentioned in #3098 the existing version of  `materialize` could deliver one more event than requested being the termination event (completion or error).

This PR ensures that a termination event is buffered till requested.
",2015-07-24 03:56:10,2015-08-06 08:26:09,https://api.github.com/repos/ReactiveX/RxJava/issues/3103,['Bug'],227,20,ReactiveX_RxJava_pull_3103.diff
ReactiveX/RxJava,Fix take swallowing exception if thrown by exactly the nth onNext call to it.,"Fixes the case uncovered by #3095.
",2015-07-23 13:54:29,2015-07-24 09:39:39,https://api.github.com/repos/ReactiveX/RxJava/issues/3101,['Bug'],43,32,ReactiveX_RxJava_pull_3101.diff
ReactiveX/RxJava,Fix request != 0 checking in the scalar paths of merge(),"Requested amount could reach zero between the first check and entering the synchronized block where it has to be re-read in order to verify the scalar emission can really happen at that point; the new `testMergeAsyncThenObserveOnLoop` test failed with `MissingBackpressureException` after ~20 rounds on my i7 4770K.

This might or might not relate to the canary failure; if combined with retry(), it could have failed over and over, but I'm not sure where the worker retention might have happened.
",2015-07-20 21:11:40,2015-07-20 21:21:16,https://api.github.com/repos/ReactiveX/RxJava/issues/3093,['Bug'],28,2,ReactiveX_RxJava_pull_3093.diff
ReactiveX/RxJava,Single.toObservable,"Adding `Single.toObservable` as companion to `Observable.toSingle`.
",2015-07-20 17:09:48,2015-07-20 17:15:16,https://api.github.com/repos/ReactiveX/RxJava/issues/3092,[],48,28,ReactiveX_RxJava_pull_3092.diff
ReactiveX/RxJava,Fix autoConnect calling onStart twice.,"Forgot to add the wrapping.
",2015-07-20 17:05:02,2015-07-20 17:15:07,https://api.github.com/repos/ReactiveX/RxJava/issues/3091,[],4,2,ReactiveX_RxJava_pull_3091.diff
ReactiveX/RxJava,add code quality plugins to build.gradle,"This PR adds plugins for 
- findbugs
- jacoco (code coverage)

The plugins do not run by default and are run as below:

`./gradlew findbugsMain` then open `build/reports/findbugs/main.html`.

`./gradlew test jacocoTestReport` then open `build/reports/jacoco/index.html`

Coverage can be run on a single test like so:

`./gradlew -Dtest.single=OperatorRetry test jacocoTestReport`

All these instructions are in comments in `build.gradle`.
",2015-07-18 21:59:42,2015-10-09 19:13:48,https://api.github.com/repos/ReactiveX/RxJava/issues/3089,['Enhancement'],47,2,ReactiveX_RxJava_pull_3089.diff
ReactiveX/RxJava,Hardened both cache() and replay() against child-thrown exceptions.,"- Made cache() more eager to check for unsubscription in its replay loop
- Fixed autoConnect() triggering a second call to onStart
- Added cache() tests to see replay().autoConnect() works equivalently.
- Changed the way cache() connects to the source, removed unnnecessary synchronization of incoming events.
",2015-07-17 17:45:17,2015-07-23 13:07:01,https://api.github.com/repos/ReactiveX/RxJava/issues/3088,[],383,44,ReactiveX_RxJava_pull_3088.diff
ReactiveX/RxJava,improve ExecutorSchedulerTest.testOnBackpressureDrop,"This test fails for me occasionally on my slow laptop when full test suite run because work is scheduled for only 1ms in the future. I've decreased the probability of this one failing by changing the schedule to 50ms in the future.
",2015-07-16 23:54:41,2015-07-23 13:07:48,https://api.github.com/repos/ReactiveX/RxJava/issues/3086,['Test-Failures'],2,2,ReactiveX_RxJava_pull_3086.diff
ReactiveX/RxJava,break tests as approach timeout so that don't fail on slow machines,"These tests were giving me regular failures on my slow laptop:
- `OperatorMergeMaxConcurrentTest.testSimpleOneLessAsync`
- `BackpressureTests.testOnBackpressureDrop`

They both loop repeatedly looking for failure or lockup. If the machine running the tests isn't fast enough then the tests timeout before reaching the desired number of loops. This PR adds a break to the tests when the loop has run for 9 seconds (timeout is 10 seconds).
",2015-07-16 23:44:52,2015-07-23 13:08:44,https://api.github.com/repos/ReactiveX/RxJava/issues/3085,['Test-Failures'],10,0,ReactiveX_RxJava_pull_3085.diff
ReactiveX/RxJava,Observable.x(ConversionFunc) to allow extensions to Observables,,2015-07-16 06:03:11,2015-08-07 19:58:56,https://api.github.com/repos/ReactiveX/RxJava/issues/3082,"['Discussion', 'Enhancement']",276,8,ReactiveX_RxJava_pull_3082.diff
ReactiveX/RxJava,Revert of cache/replay,"#3076. I did revert commit of the PR that added back pressure support to the cache operator and ran a canary.  Our production systems seem stable now even with the new merge.
",2015-07-16 05:50:34,2015-07-20 16:57:13,https://api.github.com/repos/ReactiveX/RxJava/issues/3081,[],441,2225,ReactiveX_RxJava_pull_3081.diff
ReactiveX/RxJava,fix forEach javadoc,"`Observable.forEach` javadoc suffered from a bit of copy-and-paste and neglected to mention the possible throw of `OnErrorNotImplementedException`.

Also added a couple of unit tests.
",2015-07-15 03:31:40,2015-07-23 13:11:02,https://api.github.com/repos/ReactiveX/RxJava/issues/3079,['Documentation'],28,6,ReactiveX_RxJava_pull_3079.diff
ReactiveX/RxJava,switchOnNext() - fix lost requests race condition ,"As per #3073 a race condition in `OperatorSwitch` means that requests can be lost. This PR uses `ProducerArbiter` to ensure all unfulfilled requests are carried through to the next `Observable`.

I also changed `InnerSubscriber` to be a static class as opposed to an inner class just to decouple it from surrounding state. 
",2015-07-14 23:54:42,2015-08-12 20:01:18,https://api.github.com/repos/ReactiveX/RxJava/issues/3078,['Bug'],63,107,ReactiveX_RxJava_pull_3078.diff
ReactiveX/RxJava,"Add ""since"" annotations to javadocs for new Experimental/Beta methods",,2015-07-14 20:28:36,2015-07-23 13:12:19,https://api.github.com/repos/ReactiveX/RxJava/issues/3077,['Documentation'],8,2,ReactiveX_RxJava_pull_3077.diff
ReactiveX/RxJava,"Improve toSingle() javadoc (diagram, see also, since-annotation)",,2015-07-09 15:14:37,2015-07-13 21:03:41,https://api.github.com/repos/ReactiveX/RxJava/issues/3069,[],3,0,ReactiveX_RxJava_pull_3069.diff
ReactiveX/RxJava,add Subscribers.wrap,"Add utility method to `Subscribers` to perform this common use case:

Naming briefly discussed in #3057.

``` java
new Subscriber<T>(subscriber) {

    @Override
    public void onCompleted() {
        subscriber.onCompleted();
    }

    @Override
    public void onError(Throwable e) {
        subscriber.onError(e);
    }

    @Override
    public void onNext(T t) {
        subscriber.onNext(t);
    }

};
```
",2015-07-05 22:56:29,2015-07-14 16:17:59,https://api.github.com/repos/ReactiveX/RxJava/issues/3065,[],50,87,ReactiveX_RxJava_pull_3065.diff
ReactiveX/RxJava,New operators: `concatEmptyWith` and `mergeEmptyWith`.,"As discussed in issue #3037, the primary use of these operators is to be applied to `Observable<Void>` so that they can be merged and concatenated with an Observable of a different type.

Both these operators raise an error if the source Observable emits any item.
",2015-07-02 01:28:32,2015-10-09 20:53:55,https://api.github.com/repos/ReactiveX/RxJava/issues/3060,['Enhancement'],716,0,ReactiveX_RxJava_pull_3060.diff
ReactiveX/RxJava,add and improve javadoc in Subscriber,"This PR 
- adds missing javadoc to the `Subscriber(Subscriber)` constructor
- improves (hopefully!) the javadoc for the constructor `Subscriber(Subscriber,boolean)`
- adds missing javadoc for `setProducer`
",2015-07-01 04:44:56,2015-07-14 16:23:43,https://api.github.com/repos/ReactiveX/RxJava/issues/3058,[],30,6,ReactiveX_RxJava_pull_3058.diff
ReactiveX/RxJava,New experimental operator to switch the types on the completion of empty Observables.,"For the issue #3037 a new operator that let consumer of an empty Observable tie additional work to follow after the completion.
",2015-06-30 19:59:05,2015-07-14 16:24:40,https://api.github.com/repos/ReactiveX/RxJava/issues/3056,[],424,0,ReactiveX_RxJava_pull_3056.diff
ReactiveX/RxJava,toSingle() should use unsafeSubscribe,"As per my comment in #3049, `Observable.toSingle` should use `unsafeSubscribe` internally.

This PR includes a unit test that failed on previous code.
",2015-06-30 01:35:58,2015-07-14 16:25:00,https://api.github.com/repos/ReactiveX/RxJava/issues/3055,[],24,4,ReactiveX_RxJava_pull_3055.diff
ReactiveX/RxJava,Reduce test failure likelihood of testMultiThreadedWithNPEinMiddle,"Factored out the NPE before the thread creation as it can take several milliseconds and other values can just slip through.
",2015-06-24 11:34:20,2015-06-24 11:45:26,https://api.github.com/repos/ReactiveX/RxJava/issues/3052,['Test-Failures'],2,1,ReactiveX_RxJava_pull_3052.diff
ReactiveX/RxJava,Backpressure support for most BufferUntilSubscriber use places.,"I've added backpressure support to `BufferUntilSubscriber`, however, the internal workings of `groupBy` were in conflict with my 'clean' approach. Therefore, I kept the original `BufferUntilSubscriber` use in `groupBy` and added `BufferUntilSubscriberV2` and made the various `window()` operators use it instead.

I've also added a two unbounded Spsc queue implementations from JCTools which can reduce the allocation-rate of these linked-node queues.

The problem with `groupBy` seems to be that it sets a producer on the `Subscriber` before it is actually subscribed to the `BufferUntilSubscriber`. The V2 however sets its on producer to support proper replay and kicks out the original coordinator producer. I don't know how to make the two work together yet. Maybe the `groupBy` has to be rewritten from scratch and inline the group backpressure support, request coordination and queueing more directly. An alternative might be to expose the single child request amount in `BufferUntilSubscriber` through a callback to the group somehow.
",2015-06-24 10:00:24,2015-08-12 22:48:05,https://api.github.com/repos/ReactiveX/RxJava/issues/3050,['Enhancement'],1164,35,ReactiveX_RxJava_pull_3050.diff
ReactiveX/RxJava,single: add toSingle method to Observable,"- closes ReactiveX/RxJava#3038
- this method allows an observable which is guaranteed to return exactly one
  item to be converted to a Single
- NOTE: the semantics of this function are very similar to that of single
- i.e. errors are passed through, more than one item results in an
  IllegalArgumentException, completion without emission results in a
  NoSuchElementException and exactly one item is passed through the onSuccess
  method of SingleSubscriber
",2015-06-23 23:38:55,2015-06-24 19:52:28,https://api.github.com/repos/ReactiveX/RxJava/issues/3049,['Enhancement'],184,2,ReactiveX_RxJava_pull_3049.diff
ReactiveX/RxJava,CompositeException extra NPE protection,"`CompositeException` won't crash if it received null by some means. A `null` collection or `null` collection item is replaced by a `NullPointerException` instance.

See also: #3046.
",2015-06-23 21:08:31,2015-07-14 16:29:18,https://api.github.com/repos/ReactiveX/RxJava/issues/3048,"['Bug', 'Enhancement']",25,5,ReactiveX_RxJava_pull_3048.diff
ReactiveX/RxJava,Operator replay() now supports backpressure,"I've added backpressure support to the replay() operator(s).

Related issue: #1487
",2015-06-23 15:35:43,2015-07-14 16:35:53,https://api.github.com/repos/ReactiveX/RxJava/issues/3047,['Enhancement'],1352,195,ReactiveX_RxJava_pull_3047.diff
ReactiveX/RxJava,ElementAt request management enhanced,"Based on #3014 

The operator can request up to Long.MAX_VALUE because it will only ever return a single value. If there are fewer elements, the onCompleted() will be triggered anyway. If there are more elements, the unsubscribe() will stop the sequence at the index.
",2015-06-23 07:24:36,2015-07-14 16:38:21,https://api.github.com/repos/ReactiveX/RxJava/issues/3045,['Enhancement'],46,13,ReactiveX_RxJava_pull_3045.diff
ReactiveX/RxJava,TestSubscriber javadoc cleanup,"- standardize on `Asserts that` and `Returns`
- fix tenses and wordings
",2015-06-23 06:41:20,2015-06-23 07:01:07,https://api.github.com/repos/ReactiveX/RxJava/issues/3043,[],17,17,ReactiveX_RxJava_pull_3043.diff
ReactiveX/RxJava,add backpressure support for defaultIfEmpty() ,"When looking at implementing backpressure support for `defaultIfEmpty` the obvious strategy is to reuse `switchIfEmpty` and get rid of `OperatorDefaultIfEmpty`. That's what this PR does.

There is a little bit of overhead with using `Observable.from(Arrays.asList(defaultValue))` as the alternate observable. Might be nice to have a version of `Observable.just(item)` that supports backpressure to use in its place (you've mentioned this before @akarnokd). 
",2015-06-23 06:27:32,2015-06-23 07:03:39,https://api.github.com/repos/ReactiveX/RxJava/issues/3042,['Enhancement'],34,66,ReactiveX_RxJava_pull_3042.diff
ReactiveX/RxJava,Window with Observable: fixed unsubscription and behavior,"Fixed unsubscription propagation of two Window variants (boundary, start-end).

In addition, there was a discrepancy reported on [StackOverflow](http://stackoverflow.com/questions/30963993/rxjava-window-buffer-overload-questions-incompatibility-with-rx-net) regarding the factory-boundary version. In Rx.NET, the factory is called whenever the previous boundary observable has produced a value. I.e., instead of a series of `onNexts` from the same `Observable`, it uses a series of `Observable`s with a single `onNext` emission as a boundary indicator.
",2015-06-22 08:19:14,2015-07-14 16:39:32,https://api.github.com/repos/ReactiveX/RxJava/issues/3039,['Bug'],624,89,ReactiveX_RxJava_pull_3039.diff
ReactiveX/RxJava,Instantiate EMPTY lazily,"The singleton `EMPTY` returned by `Observable.empty()` can be instantiated lazily because it is not always required.
",2015-06-19 00:27:57,2015-06-19 06:28:46,https://api.github.com/repos/ReactiveX/RxJava/issues/3034,['Enhancement'],10,8,ReactiveX_RxJava_pull_3034.diff
ReactiveX/RxJava,"takeLast() javadoc fixes, standardize parameter names (count instead of num)","This PR includes these changes:
- standardized parameter names for `take`, `takeLast`, `skip`, `limit` to use `count` instead of `num`
- enhanced the javadoc for `takeLast` so it is clear for all overrides that if the observable contains less than `count` items then all will be emitted.
- improved the exception message thrown by `OperatorTakeLast` when `count` <0

Addresses #3027
",2015-06-18 23:56:22,2015-06-22 09:04:07,https://api.github.com/repos/ReactiveX/RxJava/issues/3033,['Documentation'],31,29,ReactiveX_RxJava_pull_3033.diff
ReactiveX/RxJava,range() and from() run in fast-path in case request is at least the,"known available amount.

This optimization switches to the fast-path if one requests at least the amount the producer can provide instead of just when requesting MAX_VALUE.

```
1.x
Benchmark                       (size)         Score  Score error
rangeWithBackpressureRequest         1  82865476,500  3050323,928
rangeWithBackpressureRequest      1000    279002,692    11523,399
rangeWithBackpressureRequest   1000000       172,744       17,732
rangeWithoutBackpressure             1  84039644,379  4026176,141
rangeWithoutBackpressure          1000    285125,368     6292,095
rangeWithoutBackpressure       1000000       261,569       28,274

This PR
Benchmark                       (size)         Score  Score error
rangeWithBackpressureRequest         1  86083847,250  3562236,352
rangeWithBackpressureRequest      1000    289972,949    16689,560
rangeWithBackpressureRequest   1000000       278,011       46,335
rangeWithoutBackpressure             1  89601089,634  2260936,315
rangeWithoutBackpressure          1000    294289,152     8461,897
rangeWithoutBackpressure       1000000       272,347       22,644
```

I'm not sure if there is an existing benchmark for `from()` or not.
",2015-06-18 21:13:29,2015-08-06 08:28:11,https://api.github.com/repos/ReactiveX/RxJava/issues/3032,['Enhancement'],38,28,ReactiveX_RxJava_pull_3032.diff
ReactiveX/RxJava,Fix OperatorFlatMapPerf.flatMapIntPassthruAsync Perf Test,"This test was reported broken in https://github.com/ReactiveX/RxJava/pull/2928#issuecomment-113229698

Fixing by adding the use of LatchedObserver.

Previously broken test results:

```
r.o.OperatorFlatMapPerf.flatMapIntPassthruAsync         1  thrpt         5   363615.622   115041.519    ops/s
r.o.OperatorFlatMapPerf.flatMapIntPassthruAsync      1000  thrpt         5      350.204      125.773    ops/s
r.o.OperatorFlatMapPerf.flatMapIntPassthruAsync   1000000  thrpt         5        0.319        0.184    ops/s
```

Fixed results:

```
r.o.OperatorFlatMapPerf.flatMapIntPassthruAsync         1  thrpt         5   102109.681     8709.920    ops/s
r.o.OperatorFlatMapPerf.flatMapIntPassthruAsync      1000  thrpt         5      403.071      130.651    ops/s
r.o.OperatorFlatMapPerf.flatMapIntPassthruAsync   1000000  thrpt         5        0.355        0.070    ops/s
```
",2015-06-18 18:40:35,2015-06-18 18:48:55,https://api.github.com/repos/ReactiveX/RxJava/issues/3031,[],4,1,ReactiveX_RxJava_pull_3031.diff
ReactiveX/RxJava,Operator requestBatching to change the in-flight event amounts,"I'm proposing an operator that can change (lower) the in-flight request amount for both an unlimited downstream and for a backpressuring downstream.

I'm not certain about its use cases besides forcing a slow-path emission in a stream where the Subscriber requests Long.MAX_VALUE, for example with the rewritten merge of #2928 where one merges long streams asynchronously, the internal serialization buffer can get quite large. The use of this operator would switch it back to a slower-path merging where bounded buffers are employed.
",2015-06-18 12:35:22,2015-07-14 17:05:44,https://api.github.com/repos/ReactiveX/RxJava/issues/3030,['Enhancement'],461,0,ReactiveX_RxJava_pull_3030.diff
ReactiveX/RxJava,Replaced tabs with spaces for good.,"Somehow, every second rebase I do I get this tab-space conversion which pollutes my PRs. 
",2015-06-18 09:32:50,2015-06-18 09:40:18,https://api.github.com/repos/ReactiveX/RxJava/issues/3029,[],63,63,ReactiveX_RxJava_pull_3029.diff
ReactiveX/RxJava,Delay: error cut ahead was not properly serialized,"Originally, the error through `delay` was emitted directly to the child without serializing in respect of an in-flight `onNext()`. This change schedules the error on the worker with no delay which ensures proper serialization. (The alternative would be to wrap the child into a `SerializedSubscriber`, however, that wouldn't immediately cancel any in-flight onNext schedules.)
",2015-06-18 09:12:26,2015-06-22 09:05:03,https://api.github.com/repos/ReactiveX/RxJava/issues/3028,['Bug'],44,5,ReactiveX_RxJava_pull_3028.diff
ReactiveX/RxJava,ConnectableObservable autoConnect operator,"There is a need for auto-connection capability for an arbitrary ConnectableObservable similar to how it is possible now to use cache() as an auto-connected unbounded replay.

The new `autoConnect()` method let's specify the number of `Subscriber`s required for the real connection to happen and also offers the ability to receive the connection `Subscription`.

I've also updated the parameter name of `cache(int)` to reflect it is a capacity hint and not a bound.
",2015-06-17 12:55:07,2015-07-14 16:50:06,https://api.github.com/repos/ReactiveX/RxJava/issues/3023,['Enhancement'],289,8,ReactiveX_RxJava_pull_3023.diff
ReactiveX/RxJava,Scheduler shutdown capability,"This comes back from time to time (#1730): some containers, when removing RxJava enabled applications expect it to shut down all its threads but by default, computation threads can't be shut down manually and io threads take 1 minute to shut down on their own. 

This PR adds the capability to make them shut down their worker threads more eagerly. Since such shutdown would be terminal and thus break any subsequent test, a restart capability is required.

Therefore, I've introduced the optional `SchedulerLifecycle` interface which if implemented by a Scheduler, makes it eligible for the `Schedulers` factory to trigger a shutdown or restart for all kinds of schedulers.

Naturally, this implies some extra cost:
- The underlying pool of the computation scheduler is no longer constant and involves a volatile get every time a worker is requested. I haven't benchmarked this but it just adds a cheap load on x86 and shouldn't be a performance hit.
- Since we need to track all ThreadWorkers of the io scheduler, this involves a `CompositeSubscription` and the cost of starting new workers is increased by the synchronization and HashSet.add() operations. However, since starting a new thread in itself is somewhat expensive, again this shouldn't be a performance hit although it's hard to benchmark it.

In addition, to support proper task rejection after the scheduler has shut down, both scheduler types require a constant shutdown worker. These workers are created at class load time and will spin up a thread for a short duration before they shut it down. They don't affect, performance wise, the normal operations but the app startup time might get increased. The tradeoff here is to save on a mandatory class cast whenever a worker is requested.
",2015-06-17 09:16:02,2015-08-12 21:04:18,https://api.github.com/repos/ReactiveX/RxJava/issues/3022,['Enhancement'],490,83,ReactiveX_RxJava_pull_3022.diff
ReactiveX/RxJava,Javadoc improvements for new Single class,,2015-06-11 22:36:45,2015-06-12 16:33:44,https://api.github.com/repos/ReactiveX/RxJava/issues/3019,[],367,440,ReactiveX_RxJava_pull_3019.diff
ReactiveX/RxJava,TestSubscriber - fix awaitTerminalEventAndUnsubscribeOnTimeout,"The method `TestSubscriber.awaitTerminalEventAndUnsubscribeOnTimeout` did not unsubscribe on timeout. This PR fixes it.
",2015-06-11 01:22:48,2015-06-17 11:57:30,https://api.github.com/repos/ReactiveX/RxJava/issues/3018,[],40,4,ReactiveX_RxJava_pull_3018.diff
ReactiveX/RxJava,rx.Single,"Adds `rx.Single` as an ""Observable Future"" for representing work with a single return value.

See https://github.com/ReactiveX/RxJava/issues/1594 rx.Future/Task/Async/Single

This provides a type similar to `Future` in that it represents a scalar unit of work, but it is lazy like an `Observable` and many `Single`s can be combined into an `Observable` stream. Note how `Single.zip` returns `Single<R>` whereas `Single.merge` returns `Observable<R>`.

Examples of using this class:

``` java
import rx.Observable;
import rx.Single;

public class TaskExamples {

    public static void main(String... args) {
        // scalar synchronous value
        Single<String> t1 = Single.create(t -> {
            t.onSuccess(""Hello World!"");
        });

        // scalar synchronous value using helper method
        Single<Integer> t2 = Single.just(1);

        // synchronous error
        Single<String> error = Single.create(t -> {
            t.onError(new RuntimeException(""failed!""));
        });

        // executing
        t1.subscribe(System.out::println);
        t2.subscribe(System.out::println);
        error.subscribe(System.out::println, e -> System.out.println(e.getMessage()));

        // scalar Singles for request/response like a Future
        getData(1).subscribe(System.out::println);

        // combining Tasks into another Task
        Single<String> zipped = Single.zip(t1, t2, (a, b) -> a + "" -- "" + b);

        // combining Singles into an Observable stream
        Observable<String> merged = Single.merge(t1, t2.map(String::valueOf), getData(3));
        Observable<String> mergeWith = t1.mergeWith(t2.map(String::valueOf));

        zipped.subscribe(v -> System.out.println(""zipped => "" + v));
        merged.subscribe(v -> System.out.println(""merged => "" + v));
        mergeWith.subscribe(v -> System.out.println(""mergeWith => "" + v));
    }

    /**
     * Example of an async scalar execution using Single.create
     * <p>
     * This shows the lazy, idiomatic approach for Rx exactly like an Observable except scalar.
     *
     * @param arg
     * @return
     */
    public static Single<String> getData(int arg) {
        return Single.create(s -> {
            new Thread(() -> {
                try {
                    Thread.sleep(500);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                // deliver value
                    s.onSuccess(""Data="" + arg);
                }).start();
        });
    }

}
```
",2015-06-09 20:54:11,2015-06-10 19:35:43,https://api.github.com/repos/ReactiveX/RxJava/issues/3012,['Enhancement'],2495,1,ReactiveX_RxJava_pull_3012.diff
ReactiveX/RxJava,Fix TestSubscriber awaitTerminalEvent methods,"Returning if timeout occurred from `TestSubscriber.awaitTerminalEvent` is a feature I wanted and put in this PR. It was a void method and now returns a boolean so this should be a non-breaking change. 

In the process I noticed that `TestSubscriber.awaitTerminalEventAndUnsubscribeOnTimeout` was broken in that it assumed that an exception was thrown on timeout.  Fixed this making use of the boolean return of `TestSubscriber.awaitTerminalEvent`.

Added two unit tests.
",2015-06-09 06:21:46,2015-06-09 21:14:05,https://api.github.com/repos/ReactiveX/RxJava/issues/3011,[],39,8,ReactiveX_RxJava_pull_3011.diff
ReactiveX/RxJava,Operator flat map rewrite,"An alternative to #2928 by using flatMap(o -> o) == merge() identity.

Benchmark:

![image](https://cloud.githubusercontent.com/assets/1269832/8029913/845868ae-0dc2-11e5-881e-54cb5e57b39d.png)

It is slightly better than #2928 for flatMap() benchmarks and slightly worse than merge()
",2015-06-08 07:42:33,2015-06-17 12:08:23,https://api.github.com/repos/ReactiveX/RxJava/issues/3010,['Enhancement'],1399,1112,ReactiveX_RxJava_pull_3010.diff
ReactiveX/RxJava,Observable.from(iterable) - ensure it.hasNext() is not called unnecessarily #3006,"This PR is a fix for #3006.

Ensured `it.hasNext()` not called more often than required especially when unsubscription happens before completion.

Added two unit tests (one for fast path and the other for backpressure) that failed on previous codebase.
",2015-06-08 06:34:42,2015-06-09 07:38:35,https://api.github.com/repos/ReactiveX/RxJava/issues/3009,['Enhancement'],120,17,ReactiveX_RxJava_pull_3009.diff
ReactiveX/RxJava,use Subscribers.from(),"minor simplification in `OperatorDelayWithSelector` and `OperatorMulticast`
",2015-06-02 11:29:25,2015-06-03 06:24:49,https://api.github.com/repos/ReactiveX/RxJava/issues/3001,['Enhancement'],4,34,ReactiveX_RxJava_pull_3001.diff
ReactiveX/RxJava,"Replace the Java 7 AssertionError(message, cause) with initCause","`AssertionError(message, cause)` is a Java 7 API. This PR uses RuntimeException to replace it, just like `assertNoErrors`.
",2015-06-02 09:15:48,2015-06-02 20:01:23,https://api.github.com/repos/ReactiveX/RxJava/issues/3000,[],19,7,ReactiveX_RxJava_pull_3000.diff
ReactiveX/RxJava,Fix a wrong assertion in assertError,,2015-06-02 08:42:43,2015-06-02 09:04:20,https://api.github.com/repos/ReactiveX/RxJava/issues/2999,[],8,1,ReactiveX_RxJava_pull_2999.diff
ReactiveX/RxJava,Fix retry() race conditions,"This is the continuation of #2930 with a rebased PR.

There are sporadic testing failures with this PR so not ready for merge. I'll note some failures with this one soon.
",2015-06-01 03:21:23,2015-06-17 12:14:39,https://api.github.com/repos/ReactiveX/RxJava/issues/2997,['Bug'],202,118,ReactiveX_RxJava_pull_2997.diff
ReactiveX/RxJava,switchIfEmpty - fix backpressure bug and lost requests,"`OperatorSwitchIfEmpty` suffered from these conditions:
- Backpressure was not enabled for the source observable (as opposed to the altenate) because `setProducer` called `super.setProducer` instead of `child.setProducer`
- Requests could be lost

Bot the of the above problems are solved by using `ProducerArbiter` from @akarnokd.

Included two unit tests that failed on previous code.
",2015-05-31 11:05:42,2015-06-01 10:19:39,https://api.github.com/repos/ReactiveX/RxJava/issues/2996,['Bug'],101,53,ReactiveX_RxJava_pull_2996.diff
ReactiveX/RxJava,switchOnNext - ensure initial requests additive and fix request overflow,"`OperatorSwitch` didn't record the total of requests before first inner subscription occurring and had problems with request overflow. 

Includes 4 unit tests that failed on the original code.
",2015-05-31 07:24:15,2015-06-17 12:11:16,https://api.github.com/repos/ReactiveX/RxJava/issues/2995,['Bug'],117,8,ReactiveX_RxJava_pull_2995.diff
ReactiveX/RxJava,takeWhile(predicate) - include last value in error cause,"As per title, unit test included.
",2015-05-30 07:57:39,2015-05-30 08:25:40,https://api.github.com/repos/ReactiveX/RxJava/issues/2993,['Enhancement'],25,4,ReactiveX_RxJava_pull_2993.diff
ReactiveX/RxJava,Fix value rendering in error last cause for primitive types,"When an error occurs some `Operator`s (like `map`) include the value in the exception cause to help debugging. The intent is that for the 9 primitive types (int/Integer, double/Double, byte/Byte, char/Character etc) we render the value using `value.toString` but the test for being a primitive does not work because `.isPrimitive` always returns false (primitives have always been autoboxed by the time they get here).

The fix is to create a lazy loaded singleton set of the primitive classes (Integer.class, Double.class, etc) and check for membership in that set.

Unit tests included for each primitive type.
",2015-05-30 03:15:49,2015-05-30 07:49:05,https://api.github.com/repos/ReactiveX/RxJava/issues/2992,['Bug'],75,2,ReactiveX_RxJava_pull_2992.diff
ReactiveX/RxJava,takeUntil(predicate) - include last value in error cause,"As per title, unit test included.
",2015-05-30 02:33:00,2015-05-30 07:45:48,https://api.github.com/repos/ReactiveX/RxJava/issues/2991,['Enhancement'],25,4,ReactiveX_RxJava_pull_2991.diff
ReactiveX/RxJava,Improve Subscriber readability,"The `Subscriber` class is something I encounter frequently when debug stepping through code and is hard to read. This PR improves the names of variables and makes the `request` method more readable in particular by moving some code off into another method. 

I've also put in a `return` straight after the `addToRequested(n)` call so that we don't need to make an unnecessary test of `producerToRequestFrom != null`. Very minor saving I'm sure but why not.

Javadoc is still missing and I thought to leave that for another PR (because it will require a bit more thought).
",2015-05-30 01:41:32,2015-06-09 21:28:53,https://api.github.com/repos/ReactiveX/RxJava/issues/2990,[],53,43,ReactiveX_RxJava_pull_2990.diff
ReactiveX/RxJava,prevent take() from requesting more than needed,"The `request` method used logic that could overrequest upstream if multiple small requests were made before the next item arrived.

Added a unit test that failed on previous code.
",2015-05-28 23:27:35,2015-05-29 08:05:53,https://api.github.com/repos/ReactiveX/RxJava/issues/2989,['Bug'],44,7,ReactiveX_RxJava_pull_2989.diff
ReactiveX/RxJava,Operator exists() - implement backpressure and include last value in exception cause,"Implemented backpressure using `SingleDelayedProducer`  and while I was there ensured that the last value is in the exception cause when the predicate throws an exception.
",2015-05-28 21:59:46,2015-05-29 06:22:14,https://api.github.com/repos/ReactiveX/RxJava/issues/2988,['Enhancement'],69,10,ReactiveX_RxJava_pull_2988.diff
ReactiveX/RxJava,fix skip() race condition and request overflow,"`OperatorSkip` suffered from this race condition:

Suppose we wanted to skip 5 elements, then
- two concurrent requests of say 1 between onStart request of 0 and first emission would request 1+ (5-0) and 1 + (5-0) elements = 12 elements. To deliver the two requested we only need 7 from upstream so we have overrequested.

It also lacked protection from request overflow.

Two unit tests have been added that failed on previous code and now pass.
",2015-05-28 10:04:02,2015-05-28 12:17:49,https://api.github.com/repos/ReactiveX/RxJava/issues/2987,['Bug'],43,14,ReactiveX_RxJava_pull_2987.diff
ReactiveX/RxJava,OperatorAll  - implement backpressure and include last value in exception cause,"Implemented backpressure using `SingleDelayedProducer` (thanks @akarnokd) and while I was there ensured that the last value is in the exception cause when the predicate throws an exception.
",2015-05-27 18:43:02,2015-05-28 10:28:35,https://api.github.com/repos/ReactiveX/RxJava/issues/2986,['Enhancement'],68,9,ReactiveX_RxJava_pull_2986.diff
ReactiveX/RxJava,improve OperatorSerializeTest.testMultiThreadedWithNPEinMiddle ,"to address #2870, have made it much more improbable that the error emission is the last thread to complete by only failing the test if the error emission is the last for `n` repeats. I chose `n` = 3 to keep the runtime low (average <2s).
",2015-05-27 11:55:04,2015-05-27 14:12:28,https://api.github.com/repos/ReactiveX/RxJava/issues/2985,['Test-Failures'],36,27,ReactiveX_RxJava_pull_2985.diff
ReactiveX/RxJava,Fixed multiple calls to onStart.,"Started investigating multiple calls to onStart based on #2979 and found a bunch, but since onStart can be overridden, I might have missed cases. In addition, I've found a single place where a producer is set twice on a subscriber but again, many other places may exist.
",2015-05-26 07:18:17,2015-06-17 11:56:38,https://api.github.com/repos/ReactiveX/RxJava/issues/2983,['Bug'],145,38,ReactiveX_RxJava_pull_2983.diff
ReactiveX/RxJava,TestSubscriber - add factory methods,"Since we use this so much I've added factory methods so we can infer types. 

Instead of 

``` java
TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
```

We can write

``` java
TestSubscriber<Integer> ts = TestSubscriber.create();
```

I changed the tests in `OnSubscribeRangeTest` to demo the usage.
",2015-05-26 04:39:07,2015-06-17 12:02:00,https://api.github.com/repos/ReactiveX/RxJava/issues/2982,['Enhancement'],30,5,ReactiveX_RxJava_pull_2982.diff
ReactiveX/RxJava,Add example of dependency for Gradle,,2015-05-23 19:40:01,2015-06-17 12:09:26,https://api.github.com/repos/ReactiveX/RxJava/issues/2981,['Documentation'],4,0,ReactiveX_RxJava_pull_2981.diff
ReactiveX/RxJava,Changes to support execution hooks,"wrap the onSubscribe/Operator as soon as possible in lift.
wrap the onSubscribe in the constructor to get subclasses.
add code to the scalar synchronous observable to detect exec hook usage.
",2015-05-22 06:08:05,2015-07-14 18:52:46,https://api.github.com/repos/ReactiveX/RxJava/issues/2978,['Enhancement'],258,119,ReactiveX_RxJava_pull_2978.diff
ReactiveX/RxJava,Deprecate and rename two timer overloads to interval,"The existing six methods below didn't make sense and caused some confusion.

```
timer(delay, timeUnit[, scheduler]);  --> emits 0 after delay and completes
timer(delay, period, timeUnit[, scheduler]); --> emits 0 after delay and then i++ after every period forever
interval(period, timeUnit[, schduler); --> emits i++ after every period forever
```

I felt that the middle method acted more like the third method `interval` than first method `timer`.  This PR is to make this change.

```
 timer(delay, timeUnit[, scheduler]);  --> emits 0 after delay and completes
+@Deprecated
 timer(delay, period, timeUnit[, scheduler]); --> emits 0 after delay and then i++ after every period forever
+interval(delay, period, timeUnit[, scheduler]); --> emits 0 after delay and then i++ after every period forever
 interval(period, timeUnit[, schduler); --> emits i++ after every period forever
```

PS: yes, I understand that we can't delete the deprecated timer method.
@davgross and if this PR is merged will have to change the images.
",2015-05-20 17:25:56,2015-06-17 12:00:16,https://api.github.com/repos/ReactiveX/RxJava/issues/2975,['Documentation'],87,25,ReactiveX_RxJava_pull_2975.diff
ReactiveX/RxJava,observeOn: option to batch-request instead of at end of a drain-run.,"I measured +10% improvement in some cases, but -20% in others:

![image](https://cloud.githubusercontent.com/assets/1269832/7726981/2dcd0cee-ff06-11e4-8bef-5bfb36c4a824.png)

Here is the scan of various batching sizes and number of source elements:

![image](https://cloud.githubusercontent.com/assets/1269832/7726990/40d3ecae-ff06-11e4-8d70-b0db51cda8a8.png)

The benchmarks fluctuate quite a bit on their own, probably due to frequent biased-lock revocation.
",2015-05-20 13:40:09,2015-07-14 19:03:54,https://api.github.com/repos/ReactiveX/RxJava/issues/2973,['Enhancement'],86,13,ReactiveX_RxJava_pull_2973.diff
ReactiveX/RxJava,"Fixed window(time) to work properly with unsubscription, added","backpressure support to window(size, skip).

See #1880.
",2015-05-20 11:29:41,2015-06-17 11:57:42,https://api.github.com/repos/ReactiveX/RxJava/issues/2972,"['Bug', 'Enhancement']",209,64,ReactiveX_RxJava_pull_2972.diff
ReactiveX/RxJava,Added experimental to() method for fluent type conversions.,"See #2793.
",2015-05-20 08:55:07,2015-08-12 20:10:28,https://api.github.com/repos/ReactiveX/RxJava/issues/2971,['Enhancement'],20,0,ReactiveX_RxJava_pull_2971.diff
ReactiveX/RxJava,Deprecated onBackpressureBlock,"See #2799 for reasons to deprecate.
",2015-05-20 08:42:24,2015-06-17 11:58:21,https://api.github.com/repos/ReactiveX/RxJava/issues/2970,['Documentation'],19,1,ReactiveX_RxJava_pull_2970.diff
ReactiveX/RxJava,Operator cache() now supports backpressure,"I've removed the controversial features and made the backing CachedObservable internal.

Related issue #1483.
",2015-05-20 06:59:56,2015-06-17 12:12:57,https://api.github.com/repos/ReactiveX/RxJava/issues/2969,['Enhancement'],871,242,ReactiveX_RxJava_pull_2969.diff
ReactiveX/RxJava,Operator cache() now supports backpressure,"I've removed the controversial features and made the backing CachedObservable internal.
",2015-05-20 06:54:17,2015-05-20 06:59:06,https://api.github.com/repos/ReactiveX/RxJava/issues/2968,['Enhancement'],912,242,ReactiveX_RxJava_pull_2968.diff
ReactiveX/RxJava,The usual anally-retentive javadoc edits.,,2015-05-19 17:36:50,2015-05-20 06:55:01,https://api.github.com/repos/ReactiveX/RxJava/issues/2966,[],46,6,ReactiveX_RxJava_pull_2966.diff
ReactiveX/RxJava,Set of standard producers and updated queue implementations with some,"platform-safe variants.
",2015-05-19 10:00:33,2015-05-19 18:52:14,https://api.github.com/repos/ReactiveX/RxJava/issues/2963,[],2153,94,ReactiveX_RxJava_pull_2963.diff
ReactiveX/RxJava,fix Amb backpressure bug,"The Amb operator has a backpressure bug:
- if `m` requests were made before the first emission then `m` subscriptions were started on each source observable. We only want once subscription on each.

This PR adds fix code to  `OnSubscribeAmb` and two unit tests.
",2015-05-19 05:48:55,2015-05-26 07:30:09,https://api.github.com/repos/ReactiveX/RxJava/issues/2961,['Bug'],143,29,ReactiveX_RxJava_pull_2961.diff
ReactiveX/RxJava,fix OperatorConcat race condition where request lost,"If a request arrives while `ConcatInnerSubscriber` is being constructed ([L199-201](https://github.com/ReactiveX/RxJava/blob/bad4d40a7b59cb443c3cb19d00ab80000e017a5f/src/main/java/rx/internal/operators/OperatorConcat.java#L199-L201)) then that additional request does not induce a request from the subscriber and could stall the stream. The fix is not to pass `requested` value in the constructor but to call `ConcatInnerSubscriber.requestMore` with `requested` only once `currentSubscriber` is set.
",2015-05-19 00:34:58,2015-05-27 11:41:02,https://api.github.com/repos/ReactiveX/RxJava/issues/2960,['Bug'],61,32,ReactiveX_RxJava_pull_2960.diff
ReactiveX/RxJava,OperatorObserveOn should not request more after child is unsubscribed,"In existing code if unsubscription happens immediately after a `child.onNext` call from `pollQueue` then the number of emissions made in the loop will be requested of upstream despite `child` being unsubscribed.

This PR adds a local variable `isUnsubscribed` and when set to true no further requests will be made.

This PR includes a unit test that failed on the existing codebase.
",2015-05-16 10:47:11,2015-05-16 11:45:47,https://api.github.com/repos/ReactiveX/RxJava/issues/2956,[],43,1,ReactiveX_RxJava_pull_2956.diff
ReactiveX/RxJava,OperatorObserveOn - reduce object allocations ,"Instead of using a queue of `Notification<T>` we can use a queue of `T` and when `t` is null place a singleton `NULL_SENTINEL` object on the queue (which we get away with because of type erasure).

This means we don't need to wrap every `onNext` arrival as a `Notification` and thus reduce object allocations.
",2015-05-15 07:19:27,2015-05-15 07:58:22,https://api.github.com/repos/ReactiveX/RxJava/issues/2953,[],19,8,ReactiveX_RxJava_pull_2953.diff
ReactiveX/RxJava,OperatorConcat - prevent request overflow and fix race condition,"Used `BackpressureUtils` to prevent request overflow and added an `n > 0` check for requests to ensure that `subscribeNext` is not called concurrently (race condition).

No unit tests written. Let me know if you think worth the effort.
",2015-05-15 01:56:06,2015-05-15 08:12:57,https://api.github.com/repos/ReactiveX/RxJava/issues/2951,[],30,1,ReactiveX_RxJava_pull_2951.diff
ReactiveX/RxJava,OperatorGroupBy - check for request overflow and don't decrement when at Long.MAX_VALUE,"Added request overflow check to `OperatorGroupBy` (using `BackpressureUtils`) and prevented `requested` counters from being decremented if they were at `Long.MAX_VALUE`.

Includes unit test that failed on current codebase.
",2015-05-15 01:00:49,2015-05-15 06:38:39,https://api.github.com/repos/ReactiveX/RxJava/issues/2950,[],60,3,ReactiveX_RxJava_pull_2950.diff
ReactiveX/RxJava,Remove findbugs+jacoco from build.gradle,"Apologies for the PR that added these to build.gradle. My claim that they were not run by default was wrong (`./gradlew build` runs them). Let's remove till I figure out how to do this properly.
",2015-05-14 12:24:28,2015-05-14 12:38:44,https://api.github.com/repos/ReactiveX/RxJava/issues/2949,[],0,44,ReactiveX_RxJava_pull_2949.diff
ReactiveX/RxJava,More assertions for TestSubscriber,"Additional asserts for TestSubscriber and the option to specify the initial request via a constructor.
",2015-05-14 06:32:59,2015-05-19 16:25:33,https://api.github.com/repos/ReactiveX/RxJava/issues/2948,['Enhancement'],180,22,ReactiveX_RxJava_pull_2948.diff
ReactiveX/RxJava,Pull 1,,2015-05-12 17:53:42,2015-05-12 17:54:20,https://api.github.com/repos/ReactiveX/RxJava/issues/2942,[],7,5,ReactiveX_RxJava_pull_2942.diff
ReactiveX/RxJava,Remove unnecessary localHasValue check,"Due to !hasValue check (line 120), localHasValue field is always true
",2015-05-09 12:00:30,2015-05-09 14:42:08,https://api.github.com/repos/ReactiveX/RxJava/issues/2940,[],5,9,ReactiveX_RxJava_pull_2940.diff
ReactiveX/RxJava,publish: Fix another race between terminalEvent and the queue being empty.,"Yet another fix to the race condition in publish().
",2015-05-08 11:23:40,2015-05-08 21:14:30,https://api.github.com/repos/ReactiveX/RxJava/issues/2939,['Bug'],2,1,ReactiveX_RxJava_pull_2939.diff
ReactiveX/RxJava,Fixed Observable.combineLatest overflow bug on Android,"RxRingBuffer size is not a constant and on Android is
less then 128 (16). So it causing silent issues when
there were given 16 < Observers < 128.
",2015-05-07 10:41:35,2015-05-07 11:23:03,https://api.github.com/repos/ReactiveX/RxJava/issues/2938,[],4,4,ReactiveX_RxJava_pull_2938.diff
ReactiveX/RxJava,"Add code quality plugins to build.gradle (jacoco, findbugs)","This is one thing I've missed for a while so I figured out how to get gradle to provide them. This PR enables production of Jacoco coverage reports and Findbugs reports as html in the build directory. It doesn't happen by default, the plugins are run like this (instructions in comments in `build.gradle`):

To run Findbugs:
`./gradlew check`

To run Jacoco test coverage:
`./gradlew test jacocoTestReport`

To run Jacoco on a single test:
`./gradlew -Dtest.single=OperatorRetry test jacocoTestReport`

Then open up the reports in `build/reports`.
",2015-05-07 06:23:07,2015-05-13 17:07:47,https://api.github.com/repos/ReactiveX/RxJava/issues/2937,[],44,0,ReactiveX_RxJava_pull_2937.diff
ReactiveX/RxJava,Fix TestSubject bug,"## Info

Problem is in TestSubject.onNext()
when is called on current time that is not 0 it will be delayed by current time.
calling TestSubject.onNext() should execute immediately.
## Tests
- TestSubjectTest.testObserverPropagateValueAfterTriggeringActions - represent already working behavior
- TestSubjectTest.testObserverPropagateValueInFutureTimeAfterTriggeringActions - represent a bug that is fixed by this commit
",2015-05-06 12:07:22,2015-05-07 06:53:48,https://api.github.com/repos/ReactiveX/RxJava/issues/2936,['Bug'],144,17,ReactiveX_RxJava_pull_2936.diff
ReactiveX/RxJava,CachedObservable that supports backpressure and disconnection.,"I've written a `cache()` alternative that supports backpressure on its client side and can be disconnected from the upstream.

I've omitted the Experimental annotation for now because I'd like to have some feedback:
- Should this replace `cache()` completely? Note that this implies changing the return type of `cache()`.
- Are the method names satisfactory?
- Should I add state-peeking methods similar to ReplaySubject?
",2015-05-06 11:13:14,2015-05-20 06:50:43,https://api.github.com/repos/ReactiveX/RxJava/issues/2935,['Enhancement'],1024,0,ReactiveX_RxJava_pull_2935.diff
ReactiveX/RxJava,Fix termination race condition in OperatorPublish.dispatch,"Fixes the cause of #2933.
",2015-05-06 06:27:10,2015-05-06 06:35:22,https://api.github.com/repos/ReactiveX/RxJava/issues/2934,['Bug'],13,3,ReactiveX_RxJava_pull_2934.diff
ReactiveX/RxJava,OnSubscribeRedo - fix race conditions,"While searching for the cause of #2863 I bumped into this race condition (which doesn't fix #2863):

If a request is made between L238 and L239 then `consumerCapacity` may become `Long.MAX_VALUE` on arriving at L239 in which case we don't wish to decrement it. To fix, used `compareAndSet`.

What is interesting about this fix is that in the test loop of 5000 in `OperatorRetryTest` I see many more occurrences of the failure on average (3 -> 50) presumably because the extra time to perform the  `compareAndSet` action has expanded the window for the race condition causing the failures.
",2015-05-05 11:12:35,2015-06-01 03:22:00,https://api.github.com/repos/ReactiveX/RxJava/issues/2930,['Bug'],350,169,ReactiveX_RxJava_pull_2930.diff
ReactiveX/RxJava,OperatorObserveOn onComplete can be emitted despite onError being called,"This is a fix for a race condition in `OperatorObserveOn` where if thread A gets to L164 and thread B starts the pollQueue loop then it will act as if the stream had completed normally instead of with an error. 

The effect is that a stream could appear to complete normally when in fact an error had occurred.

Using two boolean volatiles `completed` and `failed` that as a pair were not atomically updated/read exposed us to this race condition. 

The fix is to use a single volatile integer `status` to represent the  states ACTIVE, COMPLETED, ERRORED to replace `completed` and `failed`.
",2015-05-01 00:26:33,2015-05-13 17:22:33,https://api.github.com/repos/ReactiveX/RxJava/issues/2929,"['Bug', 'Enhancement']",59,51,ReactiveX_RxJava_pull_2929.diff
ReactiveX/RxJava,Merge and MergeMaxConcurrent unified and rewritten,"I've rewritten `merge` and `mergeMaxConcurrent` together from scratch.
- Added experimental `maxConcurrent` overloads to the array-merge and the mergeDelayError
- Fixed `OperatorMapNotification` beause it disregarded backpressure on its terminal emissions.
- While debugging some merge test failures, I've encountered a bug in OperatorPublish with the same underlying logical error (see comment) and fixed it here.
- Accidentally introduced a few tabs, therefore, I went in and replaced all tabs with spaces.
- I've changed `OperatorMergeTest.shouldNotCompleteIfThereArePendingScalarSynchronousEmissionsWhenTheLastInnerSubscriberCompletes` because it is legal to get onCompleted without any request.
",2015-04-30 20:02:47,2015-07-14 18:50:59,https://api.github.com/repos/ReactiveX/RxJava/issues/2928,"['Bug', 'Enhancement']",1211,1040,ReactiveX_RxJava_pull_2928.diff
ReactiveX/RxJava,SubscriptionIndexedRingBuffer - remove redundant check,"Very minor cleanup. A Subscription was being checked twice for a null value before unsubscribe.
",2015-04-30 06:17:28,2015-04-30 23:16:47,https://api.github.com/repos/ReactiveX/RxJava/issues/2927,[],2,4,ReactiveX_RxJava_pull_2927.diff
ReactiveX/RxJava,OnBackpressureLatest: Non-blocking version of the toBlocking().latest() operator.,"This is essentially the pair of the `OnBackpressureDrop`. While `OnBackpressureDrop` emits the first value requested and then drops the rest, `OnBackpressureLatest` drops values but the latest and emits that when requested. One can also think of this operator as a sample with backpressure.

One mentionable property is that since it holds onto the very last value, downstream has to request at least one to receive `onCompleted()`.
",2015-04-29 14:37:36,2015-05-13 21:24:05,https://api.github.com/repos/ReactiveX/RxJava/issues/2923,['Enhancement'],393,0,ReactiveX_RxJava_pull_2923.diff
ReactiveX/RxJava,OperatorObserveOn - handle request overflow correctly,"Use `BackpressureUtils.getAndAddRequest` in the `Producer` in `OperatorObserveOn`.

Includes unit test that failed on codebase before this change.
",2015-04-29 03:38:03,2015-04-29 07:57:34,https://api.github.com/repos/ReactiveX/RxJava/issues/2921,['Bug'],62,7,ReactiveX_RxJava_pull_2921.diff
ReactiveX/RxJava,Observable.ignoreElements - optimize ,"As suggested by @akarnokd, instead of `filter(alwaysFalse)` use a custom operator and a singleton instance of it.

Also snuck in the removal of an unused import from `OperatorTakeLastOneTest.java`.
",2015-04-25 11:13:47,2015-04-27 06:18:38,https://api.github.com/repos/ReactiveX/RxJava/issues/2915,['Enhancement'],191,2,ReactiveX_RxJava_pull_2915.diff
ReactiveX/RxJava,Optimization - use OperatorTakeLastOne for takeLast(1),"This is an optimization for `takeLast` when called with parameter 1. Using `OperatorTakeLast` carries unnecessary overhead for the `takeLast(1)` case and a decent throughput improvement (x2) for streams of 100 elements or more is seen in the benchmarks below.

`takeLast(1)` is used by the following operators which will also demonstrate a throughput improvement:
- `last`, `lastOrDefault`
- `reduce`
- `collect`
- `count`, `countLong`

Benchmarks comparing using the new `OperatorTakeLastOne` and `OperatorTakeLast`:

```
Benchmark                                                        Mode   Samples        Score  Score error    Units
r.o.OperatorTakeLastOnePerf.takeLastOneUsingTakeLastOne_Few     thrpt         5  2235516.141   129091.019    ops/s
r.o.OperatorTakeLastOnePerf.takeLastOneUsingTakeLastOne_Many    thrpt         5      103.980        9.233    ops/s
r.o.OperatorTakeLastOnePerf.takeLastOneUsingTakeLastOne_Some    thrpt         5   984689.481    48560.897    ops/s
r.o.OperatorTakeLastOnePerf.takeLastOneUsingTakeLast_Few        thrpt         5  2187421.223    93550.379    ops/s
r.o.OperatorTakeLastOnePerf.takeLastOneUsingTakeLast_Many       thrpt         5       54.575        2.054    ops/s
r.o.OperatorTakeLastOnePerf.takeLastOneUsingTakeLast_Some       thrpt         5   466892.497     9267.405    ops/s

```
",2015-04-24 11:12:22,2015-04-25 08:04:06,https://api.github.com/repos/ReactiveX/RxJava/issues/2914,['Enhancement'],346,1,ReactiveX_RxJava_pull_2914.diff
ReactiveX/RxJava,Fix the performance degradation due to different schedule execution and,"SubscriptionList.add() and thread unparking.

This PR partially reverts some changes from earlier scheduler optimizations and fixes a case where if multiple concurrent schedule() calls happen, the order in the SubscriptionList might be different from the actual execution order which degrades performance on task termination due to remove() being O(n).

This might be the source of degradation in #2857 as well.

I'll post the `ComputationSchedulerPerf` results later.
",2015-04-23 15:53:55,2015-04-30 05:26:35,https://api.github.com/repos/ReactiveX/RxJava/issues/2912,['Bug'],7,31,ReactiveX_RxJava_pull_2912.diff
ReactiveX/RxJava,OperatorPublish benchmark,"Benchmarks the behavior of `publish()` in face of number of child subscribers, batching effect in request(), length of the source and whether or not each child observes values on a separate thread.

 [Benchmark results](https://gist.github.com/akarnokd/cccc31312125d8636d3d)

Remarks:
- With no subscribers, the operator seems to fill its queue and then do nothing unless someone subscribes. There is no test to check for this behavior so it might be a bug or a feature.
- In async mode, the benchmark threw `MissingBackpressureException` a lot of times which can happen with a single subscriber as well, so it might be some concurrency bug in the operator.
",2015-04-23 13:52:40,2015-04-23 14:01:47,https://api.github.com/repos/ReactiveX/RxJava/issues/2911,['Enhancement'],159,0,ReactiveX_RxJava_pull_2911.diff
ReactiveX/RxJava,Fix the drainer to check if the queue is empty before quitting.,"Reported in #2908. The bug is on line [113](https://github.com/ReactiveX/RxJava/blob/5ac4448873c09cd806ae73a37727a299cbaee2ba/src/test/java/rx/internal/util/RxRingBufferWithoutUnsafeTest.java#L113). If the drainer is delayed after a poll returning null and the emitter producing & terminating before the getCount(), the queue is non empty but the drainer quits and hence the value difference. It comes up almost always if you put a sleep before L113.
",2015-04-23 09:05:55,2015-04-23 09:15:01,https://api.github.com/repos/ReactiveX/RxJava/issues/2909,['Test-Failures'],28,12,ReactiveX_RxJava_pull_2909.diff
ReactiveX/RxJava,Fixed schedule race and task retention with ExecutorScheduler.,"Fixes a race condition with the timed schedule (first potentially overwriting the result of the untimed schedule in mas) and a scheduled task retention problem due to not tracking those.
",2015-04-23 07:29:50,2015-05-13 17:56:16,https://api.github.com/repos/ReactiveX/RxJava/issues/2907,['Bug'],223,75,ReactiveX_RxJava_pull_2907.diff
ReactiveX/RxJava,Use singleton Operators where we can,"To reduce GC pressure use singleton `Operator`s for `Observable.single`, `distinct`, `distinctUntilChanged`,  `onBackpressureBuffer`,  `isEmpty`.
",2015-04-22 10:57:18,2015-04-23 08:15:01,https://api.github.com/repos/ReactiveX/RxJava/issues/2905,['Enhancement'],87,9,ReactiveX_RxJava_pull_2905.diff
ReactiveX/RxJava,TakeLast - add request overflow check,"Added request overflow check to `TakeLastQueueProducer` and associated unit test (that failed on existing code base).
",2015-04-22 03:22:12,2015-04-22 06:30:06,https://api.github.com/repos/ReactiveX/RxJava/issues/2904,['Bug'],31,1,ReactiveX_RxJava_pull_2904.diff
ReactiveX/RxJava,OperatorPublish - use BackpressureUtils,"Logic is fine, can replace a block of code with a call to `BackpressureUtils.getAndAddRequest`.
",2015-04-21 23:05:24,2015-04-22 08:07:52,https://api.github.com/repos/ReactiveX/RxJava/issues/2903,[],1,13,ReactiveX_RxJava_pull_2903.diff
ReactiveX/RxJava,Prevent ExceptionsTest from hanging when testing stack overflow,"On my i5 laptop `ExceptionsTest.testStackOverflowIsThrow` hangs. This PR changes the test so that it confirms that significant stack depth occurs and in another test ensures that the fatal `StackOverflowError` is thrown by `subscribe` when it occurs in `onNext`.

I also removed some unused code from the original test and some extra subscriptions that didn't seem to serve a particular function.
",2015-04-21 11:24:43,2015-04-21 11:34:44,https://api.github.com/repos/ReactiveX/RxJava/issues/2902,[],25,29,ReactiveX_RxJava_pull_2902.diff
ReactiveX/RxJava,Operators toList and toSortedList now support backpressure,"Added support for backpressure in `toList` and `toSortedList`: they emit their buffered content only when downstream actually requested it.

Few other notes:
- Added overload to `toSortedList` taking a `initialCapacity` argument which should help reduce the number of times the buffer needs to be resized.
- The Func2 parameter of `toSortedList` is now wrapped once per operator instead of once per subscriber.
- Using non-final list buffers which are set to null on completion to not hold onto the buffer.
- `toSortedList`now returns a modifiable `ArrayList`: since it is a handoff procedure, there is no value in forcing a non-modification constraint on the emitted list (similar to `toList` even before this PR).
",2015-04-21 11:10:27,2015-04-29 05:42:37,https://api.github.com/repos/ReactiveX/RxJava/issues/2901,['Enhancement'],390,77,ReactiveX_RxJava_pull_2901.diff
ReactiveX/RxJava,Observable.from(empty) to emit onComplete even when 0 requested,"As per discussion in #2884, `Observable.from(iterable)` is preferred to emit `onCompleted` when `iterable` is empty even when nothing has been requested.

This PR adds a check on `iterator.hasNext` before the `Producer` is assigned and emits `onCompleted` immediately if `hasNext` returns false.

Includes unit test that failed on existing code base.
",2015-04-21 00:09:31,2015-04-21 06:39:55,https://api.github.com/repos/ReactiveX/RxJava/issues/2899,[],33,3,ReactiveX_RxJava_pull_2899.diff
ReactiveX/RxJava,Observable.range - add unit test for eager completion on empty,"As per discussion in #2884, it turns out that `range` does emit `onComplete` even when zero is requested because `Observable.range` does not use `OperatorRange` when the count is zero but rather returns an `Observable.empty()`. This PR adds a unit test confirming this fact.
",2015-04-20 23:49:15,2015-04-21 06:34:43,https://api.github.com/repos/ReactiveX/RxJava/issues/2898,[],30,1,ReactiveX_RxJava_pull_2898.diff
ReactiveX/RxJava,Fix for overlapping windows. ,"Source was emitting t multiple times while holding queue.

Fixes #2896
",2015-04-20 23:36:07,2015-04-21 15:58:22,https://api.github.com/repos/ReactiveX/RxJava/issues/2897,['Bug'],39,1,ReactiveX_RxJava_pull_2897.diff
ReactiveX/RxJava,Fix Observable.from(Iterable) race condition,"In `IterableProducer` if the first two requests come concurrently and are both for `Long.MAX_VALUE` then there is a possible race condition where the fast path is started twice thus emitting some or all elements twice.

This PR fixes the race by only allowing the fast path if the current request count is 0 (using `compareAndSet`).
",2015-04-20 08:14:31,2015-04-20 08:24:02,https://api.github.com/repos/ReactiveX/RxJava/issues/2895,[],3,4,ReactiveX_RxJava_pull_2895.diff
ReactiveX/RxJava,Concat: fixed reentrancy problem in completeInner,"Fixes issue #2890.
",2015-04-20 07:42:56,2015-04-21 07:16:54,https://api.github.com/repos/ReactiveX/RxJava/issues/2894,['Bug'],58,10,ReactiveX_RxJava_pull_2894.diff
ReactiveX/RxJava,Fix Observable.range race condition,"In `RangeProducer` if the first two requests come concurrently and are both for `Long.MAX_VALUE` then there is a possible race condition where the fast path is started twice thus emitting some or all elements twice.

This PR fixes the race by only allowing the fast path if the current request count is 0 (using `compareAndSet`).
",2015-04-19 12:11:04,2015-04-20 05:21:20,https://api.github.com/repos/ReactiveX/RxJava/issues/2892,['Bug'],2,3,ReactiveX_RxJava_pull_2892.diff
ReactiveX/RxJava,OnSubscribeRange Producer field should be volatile,"The `RangeProducer.request` method may be called from different threads so the mutable field `index` that is read and written by this method should be volatile. 
",2015-04-17 12:50:18,2015-04-17 13:04:15,https://api.github.com/repos/ReactiveX/RxJava/issues/2886,[],1,1,ReactiveX_RxJava_pull_2886.diff
ReactiveX/RxJava,Proposal: standardized Subject state-peeking methods.,"This PR modifies the `Subject` class to host the union of the state-peeking methods of the various `Subject` implementations and fixes the inconsistent behavior of `ReplaySubject.getValues(T[])`.

The changes enable the `SerializedSubject` to relay such state-peeking method calls into the wrapped subject and allows future `Subject` wrappers to do the same (#2458).
",2015-04-16 18:44:33,2015-04-29 05:36:14,https://api.github.com/repos/ReactiveX/RxJava/issues/2883,['Enhancement'],645,9,ReactiveX_RxJava_pull_2883.diff
ReactiveX/RxJava,OperatorScan - don't call onNext after onError is called,"title says it all
",2015-04-16 03:18:15,2015-04-16 06:25:00,https://api.github.com/repos/ReactiveX/RxJava/issues/2882,[],3,0,ReactiveX_RxJava_pull_2882.diff
ReactiveX/RxJava,VarArg parameters for the assertReceivedOnNext(T... items),"Syntactic simplification for the `assertReceivedOnNext(List<T> items)`.
Instead of 

```
testSubscriber.assertReceivedOnNext(Arrays.asList(1, 2, 3))
```

(almost all existing calls use Arrays.asList())
 proposed vararg method 

```
testSubscriber.assertReceivedOnNext(1, 2, 3)
```

 looks simplier and nicer.
",2015-04-15 12:11:50,2015-05-19 16:32:48,https://api.github.com/repos/ReactiveX/RxJava/issues/2881,['Enhancement'],122,98,ReactiveX_RxJava_pull_2881.diff
ReactiveX/RxJava,Use singleton reduction functions in count and countLong,"Every call to Observable.count() and countLong() instantiated a new Func2 which I have now made a singleton in the interests of minimizing GC pressure. 

Can anyone in the know confirm for me that there is GC benefit from this one because I assume a sophisticated enough compiler could replace the new Func2 call with a singleton during its optimizations.

If this one is worthwhile then there are heaps more of these in `Observable.java` and possibly elsewhere.
",2015-04-15 07:18:32,2015-04-21 11:12:23,https://api.github.com/repos/ReactiveX/RxJava/issues/2880,['Enhancement'],17,9,ReactiveX_RxJava_pull_2880.diff
ReactiveX/RxJava,flatMap: fixed scalar-merging.,"FlatMapping over a sequence of scalar observable values while observing them from a different thread did not work: items in the scalar queue where ignored by some terminal checks.
",2015-04-14 21:16:21,2015-04-30 08:01:46,https://api.github.com/repos/ReactiveX/RxJava/issues/2878,['Bug'],122,57,ReactiveX_RxJava_pull_2878.diff
ReactiveX/RxJava,Fix: NPE in requestFromChild method.,"Fixes NPE reported in #2874.
",2015-04-14 09:26:25,2015-04-14 10:26:57,https://api.github.com/repos/ReactiveX/RxJava/issues/2875,['Bug'],4,3,ReactiveX_RxJava_pull_2875.diff
ReactiveX/RxJava,Use the correct accounts for sonatype sync,,2015-04-10 16:52:07,2015-05-13 18:04:23,https://api.github.com/repos/ReactiveX/RxJava/issues/2872,['Build'],5,9,ReactiveX_RxJava_pull_2872.diff
ReactiveX/RxJava,Use explicit versioning for gradle-rxjava-project-plugin,"When a release is created the tagged version should build deterministically at any time. The wildcard dependency on `gradle-rxjava-project-plugin` in `build.gradle` means this will not be the case. This PR sets the version at 2.2.3 (the latest on Maven Central). 
",2015-04-10 04:20:25,2015-05-13 18:06:52,https://api.github.com/repos/ReactiveX/RxJava/issues/2871,['Build'],1,1,ReactiveX_RxJava_pull_2871.diff
ReactiveX/RxJava,Fixed reentrancy issue with the error producer.,"Should fix the test recent test failures.
",2015-04-09 12:10:38,2015-04-09 12:16:02,https://api.github.com/repos/ReactiveX/RxJava/issues/2868,[],63,13,ReactiveX_RxJava_pull_2868.diff
ReactiveX/RxJava,More warnings cleanup,"- removed unused constructors that were the subject of varargs warnings
- removed unused import

I think that cleans up all java source warnings (not including javadoc issues).
",2015-04-09 07:18:26,2015-04-09 12:22:07,https://api.github.com/repos/ReactiveX/RxJava/issues/2867,[],1,13,ReactiveX_RxJava_pull_2867.diff
ReactiveX/RxJava,"Use simpler naming in Action1, Func1 to assist IDEs","Use simpler naming in `Action1`, `Func1` because is used as a default for IDEs when generating implementing methods. For instance,  in Eclipse when auto-generating the implementing methods for an `Action1` I get by default:

``` java
new Action1<Integer>() {

    @Override
    public void call(Integer t1) {
         //TODO auto-generated
    }
}
```

I can't count the number of times I've removed the trailing 1 from the parameter before continuing and I'd appreciate not having to do it! (unfortunately I can't use Java 8 lambdas in all my code).

I'd also be open to a name other than `t` like `value` but would be happy just to see the 1 go.
",2015-04-09 05:15:06,2015-04-09 13:33:10,https://api.github.com/repos/ReactiveX/RxJava/issues/2866,['Enhancement'],4,4,ReactiveX_RxJava_pull_2866.diff
ReactiveX/RxJava,IndexedRingBuffer.getInstance can infer type,"Added type to IndexedRingBuffer.POOL (to get rid of raw types warning) and changed signature of `IndexedRingBuffer.getInstance` so that it infers type. Means that 13 `unchecked` warnings in the code base can be removed.
",2015-04-08 23:32:44,2015-04-09 06:22:01,https://api.github.com/repos/ReactiveX/RxJava/issues/2864,['Enhancement'],7,19,ReactiveX_RxJava_pull_2864.diff
ReactiveX/RxJava,Cleanup warnings in test source,"Made changes to test source to avoid or suppress these warnings:
- raw types 
- unused imports
- unused variables
",2015-04-08 00:15:24,2015-04-09 06:27:42,https://api.github.com/repos/ReactiveX/RxJava/issues/2862,[],47,41,ReactiveX_RxJava_pull_2862.diff
ReactiveX/RxJava,Ensure OperatorZipTest.testZipRace does not fail on slower machines,"The test `OperatorZipTest.testZipRace` fails every time on my pretty fast desktop due to not achieving the desired number of iterations within the timeout. It also fails every time on my slow laptop. This PR adds a time limit for the iterations of one second less than the test timeout so that the test will fail if a zip hangs but not if the machine is slow.
",2015-04-07 23:43:42,2015-04-08 06:39:46,https://api.github.com/repos/ReactiveX/RxJava/issues/2861,['Test-Failures'],7,1,ReactiveX_RxJava_pull_2861.diff
ReactiveX/RxJava,OperatorSingle should request exactly what it needs,"I noticed that `observable.single().subscribe()` requested `Long.MAX_VALUE` from `observable` which is more than it needs to come up with one item or an error. This PR sets a `Producer` for `OperatorSingle` so that it requests no more or less than it needs.
",2015-04-07 07:23:30,2015-04-07 17:15:15,https://api.github.com/repos/ReactiveX/RxJava/issues/2860,['Enhancement'],235,36,ReactiveX_RxJava_pull_2860.diff
ReactiveX/RxJava,OperatorDoOnRequest should unsubscribe from upstream,"When `Observable.doOnRequest` is used it does not pass unsubscription upstream. This PR fixes that and also adds a unit test of the base functionality for `doOnRequest` (no unit tests were present for this operator at all).
",2015-04-07 05:31:08,2015-04-07 09:35:03,https://api.github.com/repos/ReactiveX/RxJava/issues/2859,['Bug'],81,1,ReactiveX_RxJava_pull_2859.diff
ReactiveX/RxJava,toBlocking.single should not request more than needed,"When `observable.toBlocking().single()` was called the number requested from `observable` was `Long.MAX_VALUE` due to `OperatorSingle` not overriding the request number.
",2015-04-06 03:24:27,2015-04-06 08:23:34,https://api.github.com/repos/ReactiveX/RxJava/issues/2855,[],49,0,ReactiveX_RxJava_pull_2855.diff
ReactiveX/RxJava,Fixes wrong request accounting in AbstractOnSubscribe,"Fixes #2853.
",2015-04-03 06:24:04,2015-04-07 17:14:21,https://api.github.com/repos/ReactiveX/RxJava/issues/2854,['Bug'],59,16,ReactiveX_RxJava_pull_2854.diff
ReactiveX/RxJava,Change retryWhen to eagerly ignore an error'd source's subsequent events,"Fixes both issue #2826 and [this StackOverflow](http://stackoverflow.com/questions/29324886/retrywhen-operator-never-retries) problem.
",2015-04-02 06:53:35,2015-04-02 18:41:39,https://api.github.com/repos/ReactiveX/RxJava/issues/2852,['Bug'],79,27,ReactiveX_RxJava_pull_2852.diff
ReactiveX/RxJava,Add 'request(Long.MAX_VALUE)' in 'onStart' to fix the backpressure issue of debounce,"Fixed #2850.

The issue is because OperatorDebounceWithTime will swallow values but not request more items. Just add `request(Long.MAX_VALUE)` since it doesn't support backpressure.
",2015-04-01 09:55:14,2015-04-02 16:24:48,https://api.github.com/repos/ReactiveX/RxJava/issues/2851,['Bug'],24,0,ReactiveX_RxJava_pull_2851.diff
ReactiveX/RxJava,"Revert ""Corrected all Java interfaces declarations""","Reverts ReactiveX/RxJava#2807

Revert because they are breaking changes. RxScala needs the `public` modifier so that it can wrap them into Scala classes.
",2015-03-30 15:20:40,2015-03-30 15:22:21,https://api.github.com/repos/ReactiveX/RxJava/issues/2849,[],26,26,ReactiveX_RxJava_pull_2849.diff
ReactiveX/RxJava,More execution hook support,"I've made a couple of changes to the where the execution hooks are used.
- Moved the `onCreate()` from the create method to the constructor to capture things going on with other subclasses of `Observable` like `GroupedObservable` and `ScalarSynchronousObservable`.
- Moved the `onLift()` hook outside of the closure so as to capture information about where/when the operators lifted rather than when/where they were subscribed.

I also made a change to the `ScalarSynchronousObservable.get()` have a slow path to allow hooks know when the data is pulled as if it was subscribed to normally.
",2015-03-27 17:45:39,2015-05-20 16:45:47,https://api.github.com/repos/ReactiveX/RxJava/issues/2847,['Enhancement'],105,21,ReactiveX_RxJava_pull_2847.diff
ReactiveX/RxJava,Fix for repeat: wrong target of request,"Fixes #2844.
",2015-03-24 15:43:30,2015-03-25 15:55:11,https://api.github.com/repos/ReactiveX/RxJava/issues/2845,['Bug'],28,1,ReactiveX_RxJava_pull_2845.diff
ReactiveX/RxJava,Fix typo in OnSubscribe interface's Javadoc,,2015-03-19 07:32:32,2015-03-19 07:37:58,https://api.github.com/repos/ReactiveX/RxJava/issues/2838,[],1,1,ReactiveX_RxJava_pull_2838.diff
ReactiveX/RxJava,Fixed a non-deterministic test and a few scheduler leaks.,,2015-03-18 17:29:13,2015-03-18 17:36:07,https://api.github.com/repos/ReactiveX/RxJava/issues/2837,[],159,144,ReactiveX_RxJava_pull_2837.diff
ReactiveX/RxJava,Figuring out why the build fails,"Not for merge. Trying to find what's causing SIGKILL.
",2015-03-18 10:42:20,2015-03-18 17:23:17,https://api.github.com/repos/ReactiveX/RxJava/issues/2834,['Build'],508,606,ReactiveX_RxJava_pull_2834.diff
ReactiveX/RxJava,testOnBackpressureDropWithAction restored original test count,"Not for merge. Diagnosing travis build failure.
",2015-03-17 17:27:31,2015-03-17 17:37:24,https://api.github.com/repos/ReactiveX/RxJava/issues/2831,[],1,1,ReactiveX_RxJava_pull_2831.diff
ReactiveX/RxJava,Disable MySQL and PostgreSQL on travis,"Not for merge. Diagnosing build failures.
",2015-03-17 17:09:51,2015-03-17 17:21:33,https://api.github.com/repos/ReactiveX/RxJava/issues/2830,[],10,1,ReactiveX_RxJava_pull_2830.diff
ReactiveX/RxJava,The retry with predicate wasn't behaving correctly when it used unsafeSubscribe,"For #2826
The `ScalarSynchronousObservable` and `OperatorRetryWithPredicate` both assume that everyone else obey the rules so they don't have to.  Bad things happen when they are used together.
",2015-03-15 21:19:49,2015-04-02 06:54:22,https://api.github.com/repos/ReactiveX/RxJava/issues/2827,['Bug'],24,1,ReactiveX_RxJava_pull_2827.diff
ReactiveX/RxJava,Fixed javadoc for Observable.repeat() method,"Removed wrong link inside of JavaDoc for Observable.repeat() method
",2015-03-15 18:53:04,2015-03-18 20:01:11,https://api.github.com/repos/ReactiveX/RxJava/issues/2825,['Documentation'],1,1,ReactiveX_RxJava_pull_2825.diff
ReactiveX/RxJava,Enable maven central sync via bintray,,2015-03-13 22:24:01,2015-03-17 16:20:14,https://api.github.com/repos/ReactiveX/RxJava/issues/2823,[],4,2,ReactiveX_RxJava_pull_2823.diff
ReactiveX/RxJava,match operator,"Added an match operator that constructs chain of predicates mapped to a function. The predicate will be applied to what an Observable emits, and if the predicate returns true the function mapped to the predicate will be applied.

The match operator creates a MatchBuilder which can either chain subsequent matches or return the Observable back when the defaultMatch method is called. This ensures there is a default match provided.
",2015-03-12 22:14:04,2015-03-13 19:17:12,https://api.github.com/repos/ReactiveX/RxJava/issues/2821,[],518,0,ReactiveX_RxJava_pull_2821.diff
ReactiveX/RxJava,Backpressure for window(size),"Changes to the `window(size)` operator to respect the backpressure on its _outer_ Observable: asking for 1 window will request `size` values from upstream. 

Backpressure is ignored on the inner Observable for now, partially because the `BufferUntilSubscriber` doesn't support it, partially because coordinating the inner requests with the outer requests needs more thoughts. The problem is that the outer has to request at least 1 element from upstream in order to open the window, but the inner subscriber may not want that single element just yet or would request more than the remaining window size and it would trigger new windows whose value it can't receive but would overflow the next window's observers.

`window(size, skip)` is not changed as I need to think about it more.
",2015-03-12 13:37:59,2015-04-30 05:23:57,https://api.github.com/repos/ReactiveX/RxJava/issues/2820,['Enhancement'],79,25,ReactiveX_RxJava_pull_2820.diff
ReactiveX/RxJava,Small fix for the getValue javadoc in AsyncSubject and BehaviorSubject,,2015-03-12 09:29:26,2015-03-12 09:41:37,https://api.github.com/repos/ReactiveX/RxJava/issues/2818,[],2,2,ReactiveX_RxJava_pull_2818.diff
ReactiveX/RxJava,Fix for non-deterministic: testOnBackpressureDropWithAction,"It is possible the synchronized block inside RxRingBuffer blocks out the firehose thread long enough that there will be enough requests cumulating up and no values have to be dropped. The change increases the taken value count and should decrease the likelihood of such no-drop situation.
",2015-03-11 15:08:00,2015-03-11 15:47:08,https://api.github.com/repos/ReactiveX/RxJava/issues/2817,['Test-Failures'],1,1,ReactiveX_RxJava_pull_2817.diff
ReactiveX/RxJava,"Merged merge, mergeDelayError and mergeMaxConcurrent into a single merge","Added overload to `mergeDelayError` to take a `maxConcurrent` parameter as well.

`OperatorMapNotification` had to be fixed because it disregarded backpressure on its `onError` and `onCompleted` paths: these produce value that may lack of an associated request and have to be buffered. The downside is the extra overhead due to serialization via `drain()` instead of write-through, but it is required for correctness.
",2015-03-11 09:45:43,2015-04-14 21:32:42,https://api.github.com/repos/ReactiveX/RxJava/issues/2816,['Enhancement'],263,397,ReactiveX_RxJava_pull_2816.diff
ReactiveX/RxJava,Operator Publish full rewrite,"Complete rewrite of `publish()` and fixed bugs of #2810 and #2803.
",2015-03-10 11:58:29,2015-04-30 05:04:30,https://api.github.com/repos/ReactiveX/RxJava/issues/2814,['Enhancement'],827,326,ReactiveX_RxJava_pull_2814.diff
ReactiveX/RxJava,Proposed AbstractProducer to replace AbstractOnSubscribe,"Proposed replacement for `AbstractProducer` which gives access to the requested amount allowing batch or fast-path value emission.

I've skipped the detailed javadoc until the feedback about using this instead of `AbstractOnSubscribe`.
",2015-03-09 10:04:21,2015-08-12 20:03:37,https://api.github.com/repos/ReactiveX/RxJava/issues/2813,['Enhancement'],554,0,ReactiveX_RxJava_pull_2813.diff
ReactiveX/RxJava,Fixed takeUntil not unsubscribing from either of the observables in case,"of a terminal condition.

This issue came up in [a group discussion](https://groups.google.com/forum/#!topic/rxjava/sF2hy5sV5ck) (but is unrelated to the actual problem there). The problem was that takeUntil was unsafeSubscribed to, there was no one to terminate either the main or the other observable on a terminal condition, leaving the connection to upstream active indefinitely.
",2015-03-05 21:21:37,2015-03-06 20:51:11,https://api.github.com/repos/ReactiveX/RxJava/issues/2809,['Bug'],144,12,ReactiveX_RxJava_pull_2809.diff
ReactiveX/RxJava,Corrected all Java interfaces declarations,"Just little Java syntax fix for interfaces

I checked all interfaces in RxJava.

@benjchristensen I can add and configure `Checkstyle` gradle plugin for RxJava if you don't mind, mm? 
",2015-03-05 16:24:14,2015-03-17 16:22:06,https://api.github.com/repos/ReactiveX/RxJava/issues/2807,['Enhancement'],26,26,ReactiveX_RxJava_pull_2807.diff
ReactiveX/RxJava,"Operator buffer(time) and buffer(time, size) now support backpressure.","Added backpressure support to `buffer(time)` and `buffer(time, size)` non-overlapping variants as requested in #2797.

A request of `n | n < Long.MAX_VALUE` is converted to a request of `n * size` for the upstream. Every time the buffer's size reaches the specified amount, the timer is ""paused"". The remaining time for it to fire is calculated and stored so the next time the timer is started again with this remaining time, either by a downstream request 0 -> !0 transition or by the `onNext` itself because downstream request is not null.

Note that this start-stop behavior is of millisecond accuracy regardless of the original time unit specified because our scheduler's now() return the time in millisecond resolution.

I've also added some new assert methods and constructors to `TestSubscriber` to make state checks more convenient and support a common zero request at subscription directly (so no need to extend the class just for this anymore).
",2015-03-05 15:41:28,2015-05-14 06:31:38,https://api.github.com/repos/ReactiveX/RxJava/issues/2806,['Enhancement'],695,49,ReactiveX_RxJava_pull_2806.diff
ReactiveX/RxJava,ObserveOn throughput enhancements,"Squashed commits of #2773.

---

Further optimizations to `observeOn`.
- Using SpscArrayQueue directly in observeOn instead of `RingBuffer` to avoid the synchronization block
- Split tracking structure to serial (SubscriptionList) and timed (CompositeSubscription) in `EventLoopsScheduler` which improves the sequential scheduling performance because a completing task's subscription will be most likely the first item in the underlying LinkedList.

Benchmark: (i7 920, Window 7 x64, Java 1.8u31, 5x1s warmup, 5x5s iteration)

```
Benchmark      (size)         1.x    1.x error      this PR   this error
observeOn           1  162326,012     2458,085   166536,559     3154,174
observeOn          10  132471,205     1857,434   142517,407     3734,424 ++
observeOn         100   43282,527     2145,910   112238,179     2270,103 ++
observeOn        1000   11779,482      173,370    25726,564      309,193 ++
observeOn        2000    6756,211       89,196    12123,276      276,470 ++
observeOn        3000    4736,893      253,796     9342,673      263,667 ++
observeOn        4000    3661,874       51,359     7346,015      123,049 ++
observeOn       10000    1519,282      108,503     1546,547       21,885
observeOn      100000     151,193        2,569      156,160        1,974
observeOn     1000000      15,373        1,310       15,660        0,153
subscribeOn         1  161290,037     2867,882   164952,259      797,408
subscribeOn        10  151842,821     2448,734   147906,491     4373,682
subscribeOn       100  136418,065     1773,558   136889,052     2362,203
subscribeOn      1000   58389,066     4559,030    59482,225     1372,692
subscribeOn      2000   34089,152     9318,205    36581,203     1264,100
subscribeOn      3000   26712,331     1265,442    26519,320     1319,293
subscribeOn      4000   20118,326     2018,439    20163,395      839,709
subscribeOn     10000    8914,213      677,164     9059,934      200,158
subscribeOn    100000     958,038       43,349      965,663       60,708
subscribeOn   1000000      91,849        2,148       92,706        1,202
```

Notes:
- At `size = 1`, the throughput varies in a +/- 3000 range on each run, and since the changes don't touch the scalar optimization, there is no real improvement there.
- At `size = 10.000` my system reached either the cache capacity or the OS scheduler's time resolution so there no improvement there on.
- At `size = 100.000` and `size = 1.000.000` the throughput doubles if I introduce some extra delay (i.e., via sleep(1) or some extra work).
- The benchmark generates a lot of garbage due to boxing: switching to a constant emitter increases the throughput `subscribeOn(1.000.000)` from 91 to 136. 

Since it conflicts with #2772 anyway, this is PR is to let others verify the optimizations actually work on other OSes, because on my Windows, I sometimes get significant variance in the throughput during iterations. Increased iteration time may be required as well.
",2015-03-05 11:23:12,2015-03-06 20:45:29,https://api.github.com/repos/ReactiveX/RxJava/issues/2804,['Enhancement'],217,80,ReactiveX_RxJava_pull_2804.diff
ReactiveX/RxJava,Fix the bug that 'publish' will cache items when no subscriber,"Fixed #2775 and #2596
",2015-03-02 06:53:37,2015-03-04 21:54:42,https://api.github.com/repos/ReactiveX/RxJava/issues/2788,['Bug'],39,6,ReactiveX_RxJava_pull_2788.diff
ReactiveX/RxJava,OperatorMulticast.connect(connection) should not return null,"See discussion in  #2774 

Changes include 
- fix for #2774 just for `OperatorMulticast` (will do `OperatorPublish` in another PR once have sorted this one out)
- made fields private that had default visibility
- renamed `OnSubscribeMulticastTest` to `OperatorMulticastTest`
- addressed a possible race condition that could provoke an IAE when `Observable.subscribe(sub)` is called with sub=null (unsubscription occurs between L144 and L145 on old code).
",2015-02-28 12:16:22,2015-03-02 07:41:24,https://api.github.com/repos/ReactiveX/RxJava/issues/2779,['Bug'],45,35,ReactiveX_RxJava_pull_2779.diff
ReactiveX/RxJava,fix several typos,,2015-02-26 18:24:14,2015-03-03 12:02:41,https://api.github.com/repos/ReactiveX/RxJava/issues/2777,[],2,2,ReactiveX_RxJava_pull_2777.diff
ReactiveX/RxJava,issue-2764: add new operator onBackpressureDrop(Action1 onDrop),,2015-02-26 18:11:08,2015-03-04 21:55:55,https://api.github.com/repos/ReactiveX/RxJava/issues/2776,['Enhancement'],118,6,ReactiveX_RxJava_pull_2776.diff
ReactiveX/RxJava,ObserveOn performance improvements,"Further optimizations to `observeOn`.
- Using SpscArrayQueue directly in observeOn instead of `RingBuffer` to avoid the synchronization block
- Split tracking structure to serial (SubscriptionList) and timed (CompositeSubscription) in `EventLoopsScheduler` which improves the sequential scheduling performance because a completing task's subscription will be most likely the first item in the underlying LinkedList.

Benchmark: (i7 920, Window 7 x64, Java 1.8u31, 5x1s warmup, 5x5s iteration)

```
Benchmark      (size)         1.x    1.x error      this PR   this error
observeOn           1  162326,012     2458,085   166536,559     3154,174
observeOn          10  132471,205     1857,434   142517,407     3734,424 ++
observeOn         100   43282,527     2145,910   112238,179     2270,103 ++
observeOn        1000   11779,482      173,370    25726,564      309,193 ++
observeOn        2000    6756,211       89,196    12123,276      276,470 ++
observeOn        3000    4736,893      253,796     9342,673      263,667 ++
observeOn        4000    3661,874       51,359     7346,015      123,049 ++
observeOn       10000    1519,282      108,503     1546,547       21,885
observeOn      100000     151,193        2,569      156,160        1,974
observeOn     1000000      15,373        1,310       15,660        0,153
subscribeOn         1  161290,037     2867,882   164952,259      797,408
subscribeOn        10  151842,821     2448,734   147906,491     4373,682
subscribeOn       100  136418,065     1773,558   136889,052     2362,203
subscribeOn      1000   58389,066     4559,030    59482,225     1372,692
subscribeOn      2000   34089,152     9318,205    36581,203     1264,100
subscribeOn      3000   26712,331     1265,442    26519,320     1319,293
subscribeOn      4000   20118,326     2018,439    20163,395      839,709
subscribeOn     10000    8914,213      677,164     9059,934      200,158
subscribeOn    100000     958,038       43,349      965,663       60,708
subscribeOn   1000000      91,849        2,148       92,706        1,202
```

Notes:
- At `size = 1`, the throughput varies in a +/- 3000 range on each run, and since the changes don't touch the scalar optimization, there is no real improvement there.
- At `size = 10.000` my system reached either the cache capacity or the OS scheduler's time resolution so there no improvement there on.
- At `size = 100.000` and `size = 1.000.000` the throughput doubles if I introduce some extra delay (i.e., via sleep(1) or some extra work).
- The benchmark generates a lot of garbage due to boxing: switching to a constant emitter increases the throughput `subscribeOn(1.000.000)` from 91 to 136. 

Since it conflicts with #2772 anyway, this is PR is to let others verify the optimizations actually work on other OSes, because on my Windows, I sometimes get significant variance in the throughput during iterations. Increased iteration time may be required as well.
",2015-02-25 13:44:43,2015-03-05 11:18:09,https://api.github.com/repos/ReactiveX/RxJava/issues/2773,['Enhancement'],0,0,ReactiveX_RxJava_pull_2773.diff
ReactiveX/RxJava,Helper methods to schedule tasks (non-)interruptibly on an,"ExecutorService. Replaces #2761.

By default, io() and newThread() schedules interruptible tasks, computation() schedules non-interruptible tasks.
",2015-02-25 08:24:17,2015-05-06 06:45:10,https://api.github.com/repos/ReactiveX/RxJava/issues/2772,['Enhancement'],437,31,ReactiveX_RxJava_pull_2772.diff
ReactiveX/RxJava,OnSubscribeRange request overflow check,"One more:

Use `BackpressureUtils.getAndAddRequest(requested, n)` instead of `requested.getAndAdd(n)` so that an overflow check takes place. Includes a unit test that failed on original code (but passes with this PR).
",2015-02-24 11:00:06,2015-02-24 11:16:37,https://api.github.com/repos/ReactiveX/RxJava/issues/2771,[],31,1,ReactiveX_RxJava_pull_2771.diff
ReactiveX/RxJava,OperatorOnBackpressureDrop request overflow check,"Use `BackpressureUtils.getAndAddRequest(requested, n)` instead of `requested.getAndAdd(n)` so that an overflow check takes place. Includes a unit test that failed on original code (but passes with this PR).
",2015-02-24 00:23:53,2015-02-24 07:16:59,https://api.github.com/repos/ReactiveX/RxJava/issues/2770,['Bug'],51,3,ReactiveX_RxJava_pull_2770.diff
ReactiveX/RxJava,OperatorCombineLatest request overflow check,"Use `BackpressureUtils.getAndAddRequest(requested, n)` instead of  `requested.getAndAdd(n)` so that an overflow check takes place. 
",2015-02-23 22:12:20,2015-02-23 23:56:26,https://api.github.com/repos/ReactiveX/RxJava/issues/2769,[],36,1,ReactiveX_RxJava_pull_2769.diff
ReactiveX/RxJava,Optimized scalar observeOn/subscribeOn,"Redone #2603.

Run on i7 920, 2.6GHz, Windows 7 x64, JDK 1.8u31

```
Benchmark      (size)       this   Score error       1.x   Score error
observeOn           1  160377,408     3091,205  140913,081     7097,415
observeOn          10  132990,049     1477,661  125288,149    14304,259
observeOn         100   43701,203     2342,570   43840,921      944,682
observeOn        1000   11603,952     2377,205   11400,340     1400,628
observeOn        2000    6769,716      220,476    6853,283       71,276
observeOn        3000    4753,876      326,497    4741,108      120,612
observeOn        4000    3616,782      212,285    3632,433      433,754
observeOn       10000    1544,141       28,796    1548,504       61,419
observeOn      100000     149,573       14,974     150,924        8,331
observeOn     1000000      14,909        2,079      13,658        7,702
subscribeOn         1  160639,801    16463,799  156911,862     2463,637
subscribeOn        10  148883,172     6885,684  151514,397     9425,348
subscribeOn       100  133756,358     3329,421  133327,933     3479,124
subscribeOn      1000   56411,785    22525,962   52902,999    19948,305
subscribeOn      2000   35471,110    12240,514   34272,374    16515,454
subscribeOn      3000   25868,564     2755,244   26291,293     2435,165
subscribeOn      4000   20453,512     2996,777   19598,400     4643,195
subscribeOn     10000    8817,797      465,195    5389,428      272,784
subscribeOn    100000     958,665       22,157     900,036      320,547
subscribeOn   1000000      91,606        2,462      91,396        3,407
```

Note that since the tests create a lot of garbage, some perf numbers have quite some error margin: some appear to be faster with this PR while others appear to be slower, even if they are not affected by the changes.
",2015-02-23 08:42:19,2015-02-24 17:51:55,https://api.github.com/repos/ReactiveX/RxJava/issues/2767,['Enhancement'],90,7,ReactiveX_RxJava_pull_2767.diff
ReactiveX/RxJava,Avoid merge operator from over requesting upstream producer.,"The merge operator requests from upstream disregarding the amount
of requested items from downstream. This causes an issue where
it creates a produce/consume cycle that is infinite and puts
pressure on producer.
",2015-02-21 19:55:07,2015-05-06 06:38:17,https://api.github.com/repos/ReactiveX/RxJava/issues/2765,[],67,5,ReactiveX_RxJava_pull_2765.diff
ReactiveX/RxJava,Added Subscriber#isSubscribed(),"How many times have you **read or write** code like this:

``` java
return Observable.create(new Observable.OnSubscribe()<SomeType> {
    @Override public SomeType call(Subscriber<? super SomeType> subscriber) {
        // ...

        if (!subscriber.isUnsubscribed) { // <-- here is the problem
            subscriber.onNext(next);
        }

        // ...
    } 
});
```

I think it's way more clear to write it like this:

``` java
if (subscriber.isSubscribed()) { // <-- 50% more readable
    subscriber.onNext(next);
}
```

My brain does not work as CPU, I don't like to do negation operations, especially when I am reading/writing code, I think, nobody likes it.

This change does not affect any `Subscriber` implementation and 100% backward compatible.

`Better tools -> better products`
",2015-02-20 10:36:12,2015-02-21 04:45:08,https://api.github.com/repos/ReactiveX/RxJava/issues/2763,[],58,0,ReactiveX_RxJava_pull_2763.diff
ReactiveX/RxJava,Optimized isUnsubscribed check,"Extracted isUnsubscribed optimization from #2603.

```
Benchmark                                   (size)   Mode   Samples          1.x        2603    
r.s.ComputationSchedulerPerf.observeOn           1  thrpt         5   104110.926  104707.286
r.s.ComputationSchedulerPerf.observeOn          10  thrpt         5   100723.402  105825.148
r.s.ComputationSchedulerPerf.observeOn         100  thrpt         5    24609.763   65571.461
r.s.ComputationSchedulerPerf.observeOn        1000  thrpt         5     3212.434   13020.027
r.s.ComputationSchedulerPerf.observeOn       10000  thrpt         5      955.002    1555.493  
r.s.ComputationSchedulerPerf.observeOn      100000  thrpt         5       96.628     160.218  
r.s.ComputationSchedulerPerf.observeOn     1000000  thrpt         5        9.508      16.559  
r.s.ComputationSchedulerPerf.subscribeOn         1  thrpt         5   114212.000  114485.516  
r.s.ComputationSchedulerPerf.subscribeOn        10  thrpt         5   112376.809  112270.024  
r.s.ComputationSchedulerPerf.subscribeOn       100  thrpt         5    88433.002  104240.739  
r.s.ComputationSchedulerPerf.subscribeOn      1000  thrpt         5    31503.640   64446.984  
r.s.ComputationSchedulerPerf.subscribeOn     10000  thrpt         5     3932.988    8200.048
r.s.ComputationSchedulerPerf.subscribeOn    100000  thrpt         5      437.626    1439.069
r.s.ComputationSchedulerPerf.subscribeOn   1000000  thrpt         5       43.104     146.385
```
",2015-02-20 09:55:24,2015-02-21 04:46:28,https://api.github.com/repos/ReactiveX/RxJava/issues/2762,['Enhancement'],98,65,ReactiveX_RxJava_pull_2762.diff
ReactiveX/RxJava,Helper method to submit an (interruptible) action to an ExecutorService,"Adds two helper methods to `Schedulers` which performs the correct ScheduledAction hookups when interacting with an ExecutorService.

Replacement for #2592 
",2015-02-20 09:04:32,2015-02-25 08:24:38,https://api.github.com/repos/ReactiveX/RxJava/issues/2761,['Enhancement'],420,13,ReactiveX_RxJava_pull_2761.diff
ReactiveX/RxJava,Operator: WithLatestFrom,"Named after RxJS, for issue #405
",2015-02-19 09:22:43,2015-02-21 04:53:18,https://api.github.com/repos/ReactiveX/RxJava/issues/2760,['Enhancement'],437,1,ReactiveX_RxJava_pull_2760.diff
ReactiveX/RxJava,Observable.using should use unsafeSubscribe and enable eager disposal,"See #2604 where it was discovered that `Observable.using` used `subscribe` instead of `unsafeSubscribe` which provoked a race condition leading to an IllegalArgumentException from the merge operator.

This PR uses `unsafeSubscribe` and adds an overload for `using` to optionally dispose of resources eagerly (just before completion or error). The use case for this is a _synchronous_ observable where a downstream operation wants to reuse a resource (but because the observable is synchronous the resource cannot get disposed till the downstream completes).

Unit tests included.
",2015-02-19 05:09:23,2015-02-21 04:44:56,https://api.github.com/repos/ReactiveX/RxJava/issues/2759,"['Bug', 'Enhancement']",338,28,ReactiveX_RxJava_pull_2759.diff
ReactiveX/RxJava,SwitchOnNext: fix upstream producer replacing the ops own producer,"Fix for issue #2654.

By calling the `super(child)` in SwitchSubscriber's constructor, the upstream's merge producer overwrote the producer placed by the SwitchOnNext operator thus any downstream request went into the upstream an not into the currently active observable.
",2015-02-13 20:51:33,2015-02-16 13:30:53,https://api.github.com/repos/ReactiveX/RxJava/issues/2655,['Bug'],53,8,ReactiveX_RxJava_pull_2655.diff
ReactiveX/RxJava,ThrottleFirst fix in case of multiple subscriptions,"Hi,

Before, `lastOnNext` (the last time an event went through the throttling) was initialized at every subscription. This caused issues when dealing with a _hot_ observable, where multiple subscriptions (& unsubscriptions) can happen. It should be initialized at operator instantiation instead.

Hope I didn't miss something !
",2015-02-11 10:21:49,2015-02-11 11:48:55,https://api.github.com/repos/ReactiveX/RxJava/issues/2649,[],1,2,ReactiveX_RxJava_pull_2649.diff
ReactiveX/RxJava,TakeWhile: don't unsubscribe downstream.,"Fixes #2647 issue with TakeWhile.
",2015-02-11 08:09:03,2015-02-11 21:12:39,https://api.github.com/repos/ReactiveX/RxJava/issues/2648,['Bug'],68,16,ReactiveX_RxJava_pull_2648.diff
ReactiveX/RxJava,Missing Unsafe class yields NoClassDefFoundError,"Missing Unsafe class yields NoClassDefFoundError so checking for Exception is not really appropriate. Let's catch all throwables.
",2015-02-10 15:25:00,2015-02-11 02:07:43,https://api.github.com/repos/ReactiveX/RxJava/issues/2644,[],1,1,ReactiveX_RxJava_pull_2644.diff
ReactiveX/RxJava,Seeking various RxJavaPlugins via java.util.ServiceLoader,"The standard JDK way for registering plugins is via java.util.ServiceLoader. I can see RxJava invented few home-made solutions to such registration, but all of them require some configuration (set a property or invoke some bootstrap code). I'd like to extend the set of possible registration styles to ServiceLoader as well: all that is needed with ServiceLoader is to add a JAR with standard META-INF/services/pgk.iterface.name file on classpath which I consider the least intrusive way to register a plugin.

Btw. my notes on service loader & related stuff: http://wiki.apidesign.org/wiki/ServiceLoader
",2015-02-10 14:01:46,2015-08-12 20:08:02,https://api.github.com/repos/ReactiveX/RxJava/issues/2643,"['Discussion', 'Enhancement']",187,4,ReactiveX_RxJava_pull_2643.diff
ReactiveX/RxJava,Fix a potential memory leak in schedulePeriodically,"There is a potential memory leak in `schedulePeriodically` that may keep a reference to `action` after `unsubscribe`. 

Because `mas.set` is called after `schedule`,  it may replace a new Subscription (created in `recursiveAction`) with the old one. Therefore, `unsubscribe` won't be able to unsubscribe the new Subscription and will keep the reference to `action` until the period time elapses.

This PR fixed it by calling `mas.set` before `schedule`.
",2015-02-09 12:31:53,2015-02-10 07:57:55,https://api.github.com/repos/ReactiveX/RxJava/issues/2642,['Bug'],4,1,ReactiveX_RxJava_pull_2642.diff
ReactiveX/RxJava,Experimental Proposal of rx.Task,"Adds `rx.Task` as a ""scalar Observable"" for representing work with a single return value.

See https://github.com/ReactiveX/RxJava/issues/1594 rx.Future/Task

This provides a type similar to `Future` in that it represents a scalar unit of work, but it is lazy like an `Observable` and many `Task`s can be combined into an `Observable` stream. Note how `Task.zip` returns `Task<R>` whereas `Task.merge` returns `Observable<R>`.

NOTE: This is for experimentation and feedback at this time.

Items requiring review and work that I'm particularly aware of:
- naming of `OnExecute`
- naming of `TaskObserver` (this one in particular I don't like)
- design and implementation of `Task.Promise`
- should the public `lift` use the `Observable.Operator` or should that only be for internal reuse?
- should we have a public `lift` that uses a `Task.Operator`?
- the `Task.toObservable` implementation right now is efficient but will likely break something so it likely needs to change to use `subscribe`
- implementation of this merge variant: `Task<T> merge(final Task<? extends Task<? extends T>> source)`
- several operators currently just wrap as `Observable` to reuse existing operators ... is that okay performance wise?
- Javadocs

Examples of using this class:

``` java
import rx.Observable;
import rx.Task;
import rx.Task.Promise;

public class TaskExamples {

    public static void main(String... args) {
        // scalar synchronous value
        Task<String> t1 = Task.create(t -> {
            t.onSuccess(""Hello World!"");
        });

        // scalar synchronous value using helper method
        Task<Integer> t2 = Task.just(1);

        // synchronous error
        Task<String> error = Task.create(t -> {
            t.onError(new RuntimeException(""failed!""));
        });

        // executing
        t1.subscribe(System.out::println);
        t2.subscribe(System.out::println);
        error.subscribe(System.out::println, e -> System.out.println(e.getMessage()));

        // scalar Tasks for request/response like a Future
        getData(1).subscribe(System.out::println);
        getDataUsingPromise(2).subscribe(System.out::println);

        // combining Tasks into another Task
        Task<String> zipped = Task.zip(t1, t2, (a, b) -> a + "" -- "" + b);

        // combining Tasks into an Observable stream
        Observable<String> merged = Task.merge(t1, t2.map(String::valueOf), getData(3));
        Observable<String> mergeWith = t1.mergeWith(t2.map(String::valueOf));

        zipped.subscribe(v -> System.out.println(""zipped => "" + v));
        merged.subscribe(v -> System.out.println(""merged => "" + v));
        mergeWith.subscribe(v -> System.out.println(""mergeWith => "" + v));
    }

    /**
     * Example of an async scalar execution using Task.create
     * <p>
     * This shows the lazy, idiomatic approach for Rx exactly like an Observable except scalar.
     *
     * @param arg
     * @return
     */
    public static Task<String> getData(int arg) {
        return Task.create(s -> {
            new Thread(() -> {
                try {
                    Thread.sleep(500);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                // deliver value
                    s.onSuccess(""Data="" + arg);
                }).start();
        });
    }

    /**
     * Example of an async scalar execution using a Task.Promise
     * <p>
     * This shows how an eager (hot) process would work like using a Future.
     *
     * @param arg
     * @return
     */
    public static Task<String> getDataUsingPromise(int arg) {
        Task.Promise<String> p = Promise.create();

        new Thread(() -> {
            try {
                Thread.sleep(500);
            } catch (Exception e) {
                e.printStackTrace();
            }
            // deliver value
                p.onSuccess(""Data="" + arg);
            }).start();

        return p.getTask();
    }
}
```
",2015-02-08 23:54:34,2015-06-09 20:57:40,https://api.github.com/repos/ReactiveX/RxJava/issues/2641,['Enhancement'],2146,0,ReactiveX_RxJava_pull_2641.diff
ReactiveX/RxJava,Implement hook to render specific types in OnNextValue,"as discussed in #2468, allow implementations of RxJavaErrorHandler to define a rendering behavior for safe and known types to be rendered in the stacktrace of OnNextValue.
",2015-02-06 22:11:17,2015-03-17 16:24:06,https://api.github.com/repos/ReactiveX/RxJava/issues/2632,[],167,3,ReactiveX_RxJava_pull_2632.diff
ReactiveX/RxJava,Cast back Observer to Subscriber if passed to subscribe(Observer),"Rebased #2600.
",2015-02-06 11:44:43,2015-02-06 11:55:38,https://api.github.com/repos/ReactiveX/RxJava/issues/2630,['Bug'],12,0,ReactiveX_RxJava_pull_2630.diff
ReactiveX/RxJava,Dump the graph of subscriptions via toString(),"Example:

```
rx.internal.operators.OperatorMerge$MergeSubscriber[id=0, unsubscribed=false, requested=128] {
    op={
        rx.internal.operators.OperatorScan$2[id=1, unsubscribed=false, requested=-9223372036854775808] {
            op={
                rx.internal.operators.OperatorTakeLast$1[id=2, unsubscribed=false, requested=9223372036854775807] {
                    op={
                        rx.internal.operators.OperatorSingle$1[id=3, unsubscribed=false, requested=-9223372036854775808] {
                            op={
                                rx.observers.SafeSubscriber[id=4, unsubscribed=false, requested=-9223372036854775808] {
                                    op={
                                        rx.observables.BlockingObservable$3[id=5, unsubscribed=false, requested=-9223372036854775808] {
                                            op=null
                                            cs={
                                                rx.internal.util.SubscriptionList[id=6, size=2, unsubscribed=false] {
                                                    rx.subscriptions.BooleanSubscription[id=7, unsubscribed=false, action=rx.internal.operators.OnSubscribeUsing$1@704921a5[id=8]]
                                                    rx.internal.operators.OperatorMerge$MergeSubscriber[id=0] { ... }
                                                }
                                            }
                                            p=rx.internal.operators.TakeLastQueueProducer@df27fae[id=9]]
                                        }
                                    }
                                    cs={
                                        rx.internal.util.SubscriptionList[id=6] { ... }
                                    }
                                    p=rx.internal.operators.TakeLastQueueProducer@df27fae[id=9]]
                                }
                            }
                            cs={
                                rx.internal.util.SubscriptionList[id=6] { ... }
                            }
                            p=rx.internal.operators.TakeLastQueueProducer@df27fae[id=9]]
                        }
                    }
                    cs={
                        rx.internal.util.SubscriptionList[id=6] { ... }
                    }
                    p=rx.internal.operators.OperatorScan$2$1@24a35978[id=10]]
                }
            }
            cs={
                rx.internal.util.SubscriptionList[id=6] { ... }
            }
            p=null
        }
    }
    cs={
        rx.internal.util.SubscriptionList[id=6] { ... }
    }
    p=null
}
```
",2015-02-06 11:36:06,2015-05-06 06:37:06,https://api.github.com/repos/ReactiveX/RxJava/issues/2629,['Enhancement'],326,14,ReactiveX_RxJava_pull_2629.diff
ReactiveX/RxJava,Make travis run a proper build.,"Master doesn't build because the lack of parameter for gradlew.
",2015-02-06 08:45:03,2015-02-06 09:01:18,https://api.github.com/repos/ReactiveX/RxJava/issues/2628,[],1,1,ReactiveX_RxJava_pull_2628.diff
ReactiveX/RxJava,FlatMap overloads with maximum concurrency parameter,"For issue #2626.

There is no point in adding maxConcurrent to flatMapIterable because each iterable is subscribed to sequentially and run to completion.
",2015-02-06 08:42:34,2015-02-11 21:37:27,https://api.github.com/repos/ReactiveX/RxJava/issues/2627,['Enhancement'],207,11,ReactiveX_RxJava_pull_2627.diff
ReactiveX/RxJava,Changed Observable.empty() into a stateless constant observable.,"Empty was always stateless so creating a new instance all the time (especially through a `from(Iterable)`) is wasteful. Besides, `onCompleted` events don't have to be backpressured.

Should enable identity based optimizations discussed in #1653.
",2015-02-05 17:07:07,2015-02-06 11:31:30,https://api.github.com/repos/ReactiveX/RxJava/issues/2622,['Enhancement'],25,5,ReactiveX_RxJava_pull_2622.diff
ReactiveX/RxJava,Build at least as if it was a pull request.,,2015-02-05 12:35:46,2015-02-05 12:40:04,https://api.github.com/repos/ReactiveX/RxJava/issues/2610,[],2,1,ReactiveX_RxJava_pull_2610.diff
ReactiveX/RxJava,Fixed comment and missing value,"Syntax error in build.gradle prevents PRs to be verified.
",2015-02-05 12:03:21,2015-02-05 12:10:33,https://api.github.com/repos/ReactiveX/RxJava/issues/2609,[],4,4,ReactiveX_RxJava_pull_2609.diff
ReactiveX/RxJava,OnSubscribeRefCount - improve comments,"As mentioned in #2567, improve the comments 
",2015-02-05 06:14:14,2015-02-06 11:14:23,https://api.github.com/repos/ReactiveX/RxJava/issues/2607,[],5,3,ReactiveX_RxJava_pull_2607.diff
ReactiveX/RxJava,Optimized observeOn/subscribeOn,"Doing observeOn/subscribeOn on these is essentially the same operation.

Benchmark results: (i7 4770k, Java 1.8u31, Windows 7 x64)

```
gradlew benchmarks ""-Pjmh=-f 1 -tu s -bm thrpt -wi 10 -i 10 -r 5 .*ComputationSchedulerPerf.*""

Benchmark                        (size)    1.x Score  Score error   PR  Score  Score error
CompSchedulerPerf.observeOn           1   182479,416    11686,648  210536,292     9760,937  
CompSchedulerPerf.observeOn          10   174911,567    13659,846  179245,342    12725,807  
CompSchedulerPerf.observeOn         100    30997,516      958,587   27000,106      623,127  
CompSchedulerPerf.observeOn        1000     6701,672      314,471    8623,296      703,255  
CompSchedulerPerf.observeOn       10000      927,207       98,571     985,409       32,412  
CompSchedulerPerf.observeOn      100000      111,968        1,176     110,597        2,883  
CompSchedulerPerf.observeOn     1000000       11,790        0,195      11,512        0,146  
CompSchedulerPerf.subscribeOn         1   202557,014    13692,298  204616,231    11272,351  
CompSchedulerPerf.subscribeOn        10   180090,498    14058,995  190338,591     1822,349  
CompSchedulerPerf.subscribeOn       100   113625,737    32012,148  114659,399    50494,246  
CompSchedulerPerf.subscribeOn      1000    35600,359     2975,926   36856,078     1770,347  
CompSchedulerPerf.subscribeOn     10000     4220,548      311,551    3942,293      368,052  
CompSchedulerPerf.subscribeOn    100000      487,187       18,150     472,594       22,474  
CompSchedulerPerf.subscribeOn   1000000       52,191        0,349      50,250        0,510  
```

Unfortunately, the benchmark results were quite hectic even with more warmup and iteration. I'd say the changes give +10% for the size = 1 case, but running the same code twice (observeOn 1, subscribeOn 1) gives inconsistent values. I suspect the main cause is the GC.
",2015-02-04 22:53:41,2015-02-23 08:27:42,https://api.github.com/repos/ReactiveX/RxJava/issues/2603,['Enhancement'],218,87,ReactiveX_RxJava_pull_2603.diff
ReactiveX/RxJava,Added common Exceptions.throwIfAny to throw a collection of exceptions,"Tried to be as flexible with the error text as possible.
",2015-02-04 14:56:20,2015-02-11 19:46:16,https://api.github.com/repos/ReactiveX/RxJava/issues/2601,['Enhancement'],54,113,ReactiveX_RxJava_pull_2601.diff
ReactiveX/RxJava,Make sure we keep a Subscriber’s subscription when passed as Observer,"Fixes https://github.com/ReactiveX/RxJava/issues/2599
",2015-02-04 14:24:59,2015-02-06 11:45:31,https://api.github.com/repos/ReactiveX/RxJava/issues/2600,['Bug'],28,14,ReactiveX_RxJava_pull_2600.diff
ReactiveX/RxJava,Gradle & Travis Release Config,"Configuring Travis for build and release. This was tested at https://github.com/ReactiveX/BuildInfrastructure
",2015-02-04 06:31:22,2015-02-04 06:36:43,https://api.github.com/repos/ReactiveX/RxJava/issues/2595,[],25,0,ReactiveX_RxJava_pull_2595.diff
ReactiveX/RxJava,Revert Behavior Change in TestSubscriber.awaitTerminalEvent,"Reverts change made at https://github.com/ReactiveX/RxJava/pull/2332/files#diff-fbed6a16f49022fd2b10f45fd6dd015bR230

See discussion at https://github.com/ReactiveX/RxJava/issues/2549#issuecomment-72783738

The Javadoc for this method clearly states that it will wait until completion or timeout. It does not say it will throw an exception on timeout, so we can not start throwing as that is a behavioral change.
",2015-02-04 05:59:44,2015-02-04 05:59:50,https://api.github.com/repos/ReactiveX/RxJava/issues/2594,[],1,3,ReactiveX_RxJava_pull_2594.diff
ReactiveX/RxJava,Zip: emit onCompleted without waiting for request + avoid re-reading fields,"Could also fix #2588 but can't be sure because the test created from the example app works for me.
",2015-02-03 23:21:14,2015-02-04 05:50:22,https://api.github.com/repos/ReactiveX/RxJava/issues/2593,"['Bug', 'Enhancement']",51,5,ReactiveX_RxJava_pull_2593.diff
ReactiveX/RxJava,Adding ScheduledAction to public API,"Resubmit of #2579.

I've copied the internal `ScheduledAction` into the public `rx.schedulers` package to allow custom `Scheduler` implementors in other projects to take advantage of its correct unsubscription management.

I've removed the internal `ScheduledAction`. Since relying on internal features are discouraged anyway, use places outside RxJava need to be updated. Deprecating it doesn't work because the class is final and the internals now return the new `rx.schedulers.ScheduledAction` and would result in `ClassCastException` anyway.

I've introduced a system-wide parameter `io.reactivex.scheduler.interrupt-on-unsubscribe` to enable interruption globally. In addition, each `ScheduledAction` has its own `setInterruptOnUnsubscribe` which allows enabling/disabling interrupts on an individual basis (overrides the default from the system-wide parameter above for the instance).

I've also added detailed documentation to it and (while I was in the mood) to the `NewThreadWorker`. 
",2015-02-03 21:16:29,2015-02-20 08:05:53,https://api.github.com/repos/ReactiveX/RxJava/issues/2592,['Enhancement'],441,168,ReactiveX_RxJava_pull_2592.diff
ReactiveX/RxJava,Changed the naming of the NewThreadWorker's system parameters,"Changed the parameter naming as per [discussed](https://github.com/ReactiveX/RxJava/pull/2465#discussion_r24035981).
",2015-02-03 20:32:19,2015-02-03 20:56:40,https://api.github.com/repos/ReactiveX/RxJava/issues/2591,[],2,2,ReactiveX_RxJava_pull_2591.diff
ReactiveX/RxJava,Zip: fixed unbounded downstream requesting above Long.MAX_VALUE,"Should fix issue reported in #2588.

Ps. What are the odds two bug reports issued so close to each other have the same cause and same fix? @davidmoten the `BackpressureUtils` was a fantastic idea.
",2015-02-03 20:06:15,2015-02-03 21:10:53,https://api.github.com/repos/ReactiveX/RxJava/issues/2590,['Bug'],28,2,ReactiveX_RxJava_pull_2590.diff
ReactiveX/RxJava,Repeat/retry: fixed unbounded downstream requesting above Long.MAX_VALUE,"Reported in #2587.
",2015-02-03 19:50:17,2015-02-03 21:11:55,https://api.github.com/repos/ReactiveX/RxJava/issues/2589,['Bug'],21,5,ReactiveX_RxJava_pull_2589.diff
ReactiveX/RxJava,Operator: switchIfEmpty,"Changes to #2091
",2015-02-03 08:36:42,2015-02-03 08:48:12,https://api.github.com/repos/ReactiveX/RxJava/issues/2585,['Enhancement'],309,0,ReactiveX_RxJava_pull_2585.diff
ReactiveX/RxJava,Added perf tests for various container-like subscriptions,"Subscription perf tests with JMH.

```
gradlew benchmarks ""-Pjmh=-f 1 -tu s -bm thrpt -wi 10 -i 10 -r 1 rx.subscriptions.*Perf.*""
```

[Perf run](https://gist.github.com/akarnokd/9b493209fc27c858b85a) took 90 minutes on my i7 4770k, JDK 1.8u31, Windows 7 x64.
",2015-02-02 22:44:01,2015-02-03 08:12:48,https://api.github.com/repos/ReactiveX/RxJava/issues/2583,[],721,2,ReactiveX_RxJava_pull_2583.diff
ReactiveX/RxJava,Perf tests for CompositeSubscription,"To have a base perf test for future enhancements into CompositeSubscription.

Results on i7 4770k:

```
Benchmark        (count) (loop)         Score  Score error
-- CompositeSubscription --
addRemove              1      1  21566280,435   897719,297
addRemove              1   1000     21744,117      725,172
addRemove              1 100000       225,767       10,520
addRemove              5      1   4244985,637   187738,731
addRemove              5   1000      4361,022      246,403
addRemove              5 100000        43,525        1,307
addRemove             10      1   2107790,393   223569,720
addRemove             10   1000      2235,458      175,819
addRemove             10 100000        21,825        4,023
addRemove            100      1    214685,299    15760,090
addRemove            100   1000       205,781       19,402
addRemove            100 100000         2,163        0,053
addRemoveLocal         1      1  20331750,587  3599949,368
addRemoveLocal         1   1000     38273,785      771,095
addRemoveLocal         1 100000       414,414       20,694
addRemoveLocal         5      1   5552091,345   162447,203
addRemoveLocal         5   1000      7960,813      805,915
addRemoveLocal         5 100000        84,715        3,972
addRemoveLocal        10      1   2949311,028   253016,154
addRemoveLocal        10   1000      4156,523      242,239
addRemoveLocal        10 100000        42,859        2,718
addRemoveLocal       100      1    333769,154    70669,910
addRemoveLocal       100   1000       423,002       57,891
addRemoveLocal       100 100000         4,258        0,180

g1                     1      1   5672134,440   223369,579
g1                     1   1000      4614,953      385,399
g1                     1 100000        51,921       16,205
g1                     5      1    882872,043   466671,880
g1                     5   1000      1051,633       76,720
g1                     5 100000        11,912        0,689
g1                    10      1    510000,808   126915,288
g1                    10   1000       559,365       34,489
g1                    10 100000         5,683        0,497
g1                    20      1    281242,876    22400,397
g1                    20   1000       272,247       10,438
g1                    20 100000         2,917        0,759
g2                     1      1   8451900,270  3096723,213
g2                     1   1000      9992,091      643,342
g2                     1 100000        94,634        9,811
g2                     5      1   2067976,003    63851,450
g2                     5   1000      2304,841       87,373
g2                     5 100000        21,572        1,270
g2                    10      1   1235938,040    81760,627
g2                    10   1000      1069,392       91,578
g2                    10 100000        10,080        1,982
g2                    20      1    535880,770    72836,543
g2                    20   1000       488,165       48,351
g2                    20 100000         5,131        1,502

-- SubscriptionList --

addRemove              1      1  20646357,391  1481026,348 
addRemove              1   1000     23566,840     1597,573 
addRemove              1 100000       226,301       17,256 
addRemove              5      1   7426681,685   342442,038 
addRemove              5   1000      7570,683      490,145 
addRemove              5 100000        76,321        4,511 
addRemove             10      1   4165400,087   103956,402 
addRemove             10   1000      4220,931      296,238 
addRemove             10 100000        42,027        2,114 
addRemove            100      1    450531,056    29060,558 
addRemove            100   1000       447,434       26,883 
addRemove            100 100000         4,647        0,364 
addRemoveLocal         1      1  97457352,781  7817228,665 
addRemoveLocal         1   1000    100282,754     3704,426 
addRemoveLocal         1 100000      1061,597       41,867 
addRemoveLocal         5      1  26634367,988   395180,351 
addRemoveLocal         5   1000     29361,364     1476,926 
addRemoveLocal         5 100000       274,888       11,303 
addRemoveLocal        10      1  13907109,655   890452,793 
addRemoveLocal        10   1000     14813,697      972,158 
addRemoveLocal        10 100000       145,607        7,493 
addRemoveLocal       100      1   1515417,558    57144,964 
addRemoveLocal       100   1000      1505,084      111,230 
addRemoveLocal       100 100000        15,258        0,665 
```

(Units: ops/s, 5 iterations, mode: throughput).
",2015-02-02 20:17:38,2015-02-02 22:11:57,https://api.github.com/repos/ReactiveX/RxJava/issues/2581,[],349,0,ReactiveX_RxJava_pull_2581.diff
ReactiveX/RxJava,Allow configuring the maximum number of computation scheduler threads,"This change allows limiting the number of computation threads to 1 .. availableProcessors.
",2015-02-02 19:33:37,2015-02-11 19:41:08,https://api.github.com/repos/ReactiveX/RxJava/issues/2580,['Enhancement'],19,2,ReactiveX_RxJava_pull_2580.diff
ReactiveX/RxJava,Adding ScheduledAction to the official API,"I've copied the internal `ScheduledAction` into the public `rx.schedulers` package to allow custom `Scheduler` implementors in other projects to take advantage of its correct unsubscription management.

I've removed the internal `ScheduledAction`. Since relying on internal features are discouraged anyway, use places outside RxJava need to be updated. Deprecating it doesn't work because the class is final and the internals now return the new `rx.schedulers.ScheduledAction` and would result in `ClassCastException` anyway.

I've introduced a system-wide parameter `io.reactivex.scheduler.interrupt-on-unsubscribe` to enable interruption globally. In addition, each `ScheduledAction` has its own `setInterruptOnUnsubscribe` which allows enabling/disabling interrupts on an individual basis (overrides the default from the system-wide parameter above for the instance).

I've also added detailed documentation to it and (while I was in the mood) to the `NewThreadWorker`. 

There is a slight performance drawback now since setting the current thread id at the beginning of the `run()` method has to preserve the interruptible flag thus it has to perform a CAS instead of a 32-bit lazySet. Also note that the instance size change is unavoidable because a reference+int has the same allocation cost as a single long (there is no byte-atomics).
",2015-02-02 15:51:57,2015-02-03 21:13:04,https://api.github.com/repos/ReactiveX/RxJava/issues/2579,['Enhancement'],441,168,ReactiveX_RxJava_pull_2579.diff
ReactiveX/RxJava,"Revert ""subscribeOn drops the subscriptions returned from the scheduler....","Reverts ReactiveX/RxJava#2575

At best, the change is a no-op if the Scheduler.Worker conforms the requirements by tracking all tasks.
",2015-01-31 22:33:04,2015-01-31 22:42:25,https://api.github.com/repos/ReactiveX/RxJava/issues/2578,[],2,4,ReactiveX_RxJava_pull_2578.diff
ReactiveX/RxJava,Lost Subscriptions,"After thinking about #2575 I added a note to all the places where a Subscription is lost from a Scheduler.
",2015-01-31 21:53:42,2015-02-01 05:44:25,https://api.github.com/repos/ReactiveX/RxJava/issues/2576,['Bug'],27,0,ReactiveX_RxJava_pull_2576.diff
ReactiveX/RxJava,subscribeOn drops the subscriptions returned from the scheduler.,"@mattrjacobs noticed that the unsubscribe from timeouts of Hystrix commands was not being propagated across the subscribeOn.

https://github.com/Netflix/Hystrix/issues/354
",2015-01-31 08:15:22,2015-01-31 16:44:17,https://api.github.com/repos/ReactiveX/RxJava/issues/2575,['Bug'],4,2,ReactiveX_RxJava_pull_2575.diff
ReactiveX/RxJava,SizeEviction test needs to return false ,"When a replay subject with size and time eviction policy is used then any observer that subscribes after some events are already pushed will not get those older events. 
This is because if an observable is not yet terminated then on subscription by any new observer the check for event validity fails on the Size Eviction policy hence that event is dropped and not pushed to the new subscriber.

Relevant call stack:
   {{{

```
 TimeOnAdd.call
     BoundedState.replayObserverFromIndexTest
        BoundedState.replayObserverFromIndexTest
             PairEvictionPolicy.test
}}}
```

Test Case: 
- add test case for this use case, Fails if without changes.
",2015-01-31 02:09:03,2015-01-31 02:52:51,https://api.github.com/repos/ReactiveX/RxJava/issues/2574,[],53,1,ReactiveX_RxJava_pull_2574.diff
ReactiveX/RxJava,"Search plugins via ServiceLoader, if the properties are not defined","This PR adds the `ServiceLoader`mechanism to the plugins system.
This way the library could be used by multiple applications in a JavaEE server, and also confers the ability to use managed threads via a custom `RxJavaSchedulersHook`
",2015-01-30 15:49:42,2015-03-05 08:50:44,https://api.github.com/repos/ReactiveX/RxJava/issues/2573,['Enhancement'],30,0,ReactiveX_RxJava_pull_2573.diff
ReactiveX/RxJava,Give more time to certain concurrency tests.,"On my Windows machine, I've virtualized an Ubuntu machine and adjusted some tests according to the time it takes on this ""slow machine"".
",2015-01-30 11:04:38,2015-01-30 11:09:04,https://api.github.com/repos/ReactiveX/RxJava/issues/2572,[],4,4,ReactiveX_RxJava_pull_2572.diff
ReactiveX/RxJava,RefCount: disconnect all if upstream terminates,"This should fix the problem in #2564. @davidmoten I hope you can review the changes and implications.

The particular issue was caused by the refCount unable to unsubscribe from upstream in case the current client count was greater than 1. If the upstream sent an error and each client had a retry() in its chain, the retry would immediately resubscribe, thus the refCount would see only a 2 -> 1 -> 2 change in sequence as errors are dispatched sequentially. In the change, each client is wrapped and a termination event triggers the refcount to become 0 atomically and unsubscribes the upstream. When each client then call disconnect, that becomes a no-op.
",2015-01-29 14:29:48,2015-02-04 05:47:53,https://api.github.com/repos/ReactiveX/RxJava/issues/2567,['Bug'],135,44,ReactiveX_RxJava_pull_2567.diff
ReactiveX/RxJava,CombineLatest: fixed concurrent requestUpTo yielding -1 requests,"sometimes.

Discovered in #2560.
",2015-01-29 12:03:18,2015-01-31 16:48:54,https://api.github.com/repos/ReactiveX/RxJava/issues/2566,['Bug'],15,3,ReactiveX_RxJava_pull_2566.diff
ReactiveX/RxJava,Obstruction detection in tests.,"To make sure tests don't hang the computation scheduler.
",2015-01-29 11:20:09,2015-01-30 09:39:01,https://api.github.com/repos/ReactiveX/RxJava/issues/2565,"['Enhancement', 'Test-Failures']",176,10,ReactiveX_RxJava_pull_2565.diff
ReactiveX/RxJava,Retry backpressure test: split error conditions into separate test lines.,"To discover the actual problem for issue #2560.
",2015-01-29 10:45:01,2015-01-30 09:43:28,https://api.github.com/repos/ReactiveX/RxJava/issues/2563,['Test-Failures'],24,25,ReactiveX_RxJava_pull_2563.diff
ReactiveX/RxJava,Updating queue code from JCTools,"Rebased onto master.
",2015-01-29 09:44:03,2015-01-31 16:39:10,https://api.github.com/repos/ReactiveX/RxJava/issues/2561,['Enhancement'],202,97,ReactiveX_RxJava_pull_2561.diff
ReactiveX/RxJava,OnSubscribeFromIterable - add request overflow check ,"A subscriber like so provokes a hang from `OnSubscribeFromIterable` due to overflow to negative of requested field:

``` java
    @Override
    public void onStart() {
        request(2);
    }

    @Override
    public void onNext(Integer t) {
        request(Long.MAX_VALUE-1);
    }
```

I've moved the `getAndAddRequest` method that does the overflow check to a new `rx.internal.operators.Util` class that is also now used by the request overflow check in `OperatorMerge`.

Of course there are plenty more of these to be done. I propose to do them bit by bit.
",2015-01-29 06:50:16,2015-01-30 11:14:47,https://api.github.com/repos/ReactiveX/RxJava/issues/2559,['Enhancement'],137,12,ReactiveX_RxJava_pull_2559.diff
ReactiveX/RxJava,add Dump debug method,"Add a shortcut to dump the sequence and display message for complete and error event. Its usage is demonstrated in [Introduction to Rx](http://www.introtorx.com/Content/v1.0.10621.0/07_Aggregation.html). I think it's very convenient for newbies to play with different type of Observables.
",2015-01-28 18:04:38,2015-01-28 23:22:27,https://api.github.com/repos/ReactiveX/RxJava/issues/2554,[],30,0,ReactiveX_RxJava_pull_2554.diff
ReactiveX/RxJava,RxRingBuffer with synchronization,"Changed RxRingBuffer to use synchronized blocks for correctness. We are relying here upon biased locking and lock-elision. It gets pretty close to the baseline

Benchmark:

```
Benchmark              (size)        1.x   |    PR#2333  |    this   
1SyncStreamOfN              1  3779678,748 | 3767936,028 | 3775157,195
1SyncStreamOfN           1000    21250,675 |   18530,542 |   20759,900
1SyncStreamOfN        1000000       20,406 |      17,712 |      19,768
NAsyncStreamsOfN            1   115390,116 |  115629,480 |  113859,532
NAsyncStreamsOfN         1000        2,579 |       2,546 |       2,435
NSyncStreamsOf1             1  3543551,254 | 3602242,709 | 3539162,675
NSyncStreamsOf1           100   299166,910 |  301703,721 |  302642,458
NSyncStreamsOf1          1000    28404,751 |   28420,833 |   28030,881
NSyncStreamsOfN             1  4054571,577 | 4003156,953 | 4061124,105
NSyncStreamsOfN          1000       24,324 |      20,601 |      23,137
TwoAsyncStreamsOfN          1    85846,727 |   85682,983 |   86691,331
TwoAsyncStreamsOfN       1000     1823,137 |    1889,458 |    1761,977
reamOfNthatMergesIn1        1  3724179,351 | 3725068,220 | 3715637,985
reamOfNthatMergesIn1     1000    19051,928 |   19392,595 |   19487,059
reamOfNthatMergesIn1  1000000       18,265 |      18,069 |      18,102
```

Changes (in respect of 1.x):
- using SpscArrayQueue, removed look-ahead and null check
- using peek to check for emptyness in certain positions
- using short-as-possible synchronization blocks
",2015-01-28 15:53:22,2015-01-28 20:27:38,https://api.github.com/repos/ReactiveX/RxJava/issues/2553,['Enhancement'],54,52,ReactiveX_RxJava_pull_2553.diff
ReactiveX/RxJava,Publish: fixed incorrect subscriber requested accounting,"Reported in a [rxjava group](https://groups.google.com/forum/#!topic/rxjava/iOA_wl-fReI) post.

The shared emissioncounter subtracted from all subscribers accounting made late coming subscribers appear to have received the same amount of events.
",2015-01-28 14:32:09,2015-01-31 16:53:15,https://api.github.com/repos/ReactiveX/RxJava/issues/2552,['Bug'],109,49,ReactiveX_RxJava_pull_2552.diff
ReactiveX/RxJava,Make testFlatMapAsync pass by allowing 3% overflow caused by gc delays,"testFlatMapAsync is non-deterministic because a slight delay in consumption lets the producer thread run quite ahead. The change now measures this over 1000 runs and allows 30 of such to happen at max. Testing on Windows (not so good scheduler), I get 10-20 overruns.
",2015-01-28 12:55:07,2015-01-28 13:22:22,https://api.github.com/repos/ReactiveX/RxJava/issues/2551,[],35,20,ReactiveX_RxJava_pull_2551.diff
ReactiveX/RxJava,Subscriber.onStart requests should be additive (and check for overflow),"As per discussion in #2544.
",2015-01-28 12:14:08,2015-01-28 12:21:35,https://api.github.com/repos/ReactiveX/RxJava/issues/2550,[],66,4,ReactiveX_RxJava_pull_2550.diff
ReactiveX/RxJava,Subscriber.request should throw exception if negative request made,"As per discussion in #1956 and #2545, making a call to `Subscriber.request(n)` with negative n should throw an `IllegalArgumentException`.

Includes unit test.
",2015-01-28 05:23:47,2015-01-28 11:00:57,https://api.github.com/repos/ReactiveX/RxJava/issues/2548,['Enhancement'],40,0,ReactiveX_RxJava_pull_2548.diff
ReactiveX/RxJava,Warnings cleanup,"more cleanup:
- removed unnecessary imports
- added missing generic types
- added SuppressWarning annotations 
",2015-01-28 02:56:53,2015-01-28 08:03:21,https://api.github.com/repos/ReactiveX/RxJava/issues/2547,[],9,13,ReactiveX_RxJava_pull_2547.diff
ReactiveX/RxJava,Observable.java - remove unnecessary SuppressWarnings annotations,"a little bit of cleanup. I think these have been hanging around since we were using varargs parameters.
",2015-01-28 02:36:35,2015-01-28 11:00:59,https://api.github.com/repos/ReactiveX/RxJava/issues/2546,[],0,34,ReactiveX_RxJava_pull_2546.diff
ReactiveX/RxJava,OperatorMerge handle request overflow,"Calling 

``` java
request(2);
request(Long.MAX_VALUE-1);
```

hangs `OperatorMerge` because the internal requested count overflows and becomes negative. 

This PR adds fix and unit test.

I imagine this will be in other operators as well. I'll have a hunt around.
",2015-01-28 00:24:27,2015-01-28 10:30:51,https://api.github.com/repos/ReactiveX/RxJava/issues/2543,['Bug'],42,1,ReactiveX_RxJava_pull_2543.diff
ReactiveX/RxJava,Updated queue code from JCTools,"Plus I've added tests to make sure these queues allow queueing up until their capacity because if they rejected values 75% above their capacity due to false sharing optimization, our backpressure logic would break.
",2015-01-27 10:25:53,2015-01-28 20:34:15,https://api.github.com/repos/ReactiveX/RxJava/issues/2541,['Enhancement'],256,100,ReactiveX_RxJava_pull_2541.diff
ReactiveX/RxJava,Merge with max concurrency now supports backpressure.,"See #2291
",2015-01-26 12:29:23,2015-01-29 09:59:44,https://api.github.com/repos/ReactiveX/RxJava/issues/2540,['Enhancement'],393,52,ReactiveX_RxJava_pull_2540.diff
ReactiveX/RxJava,Operator TakeUntil with predicate,"Take values and check the condition after the value is emitted.

For enhancement request #1649.
",2015-01-23 08:36:06,2015-02-04 05:47:21,https://api.github.com/repos/ReactiveX/RxJava/issues/2493,['Enhancement'],252,0,ReactiveX_RxJava_pull_2493.diff
ReactiveX/RxJava,Merge: fixed hangs & missed scalar emissions,"I think I hunted down the bug that was causing missed value emission if scalar source such as `just()` was involved. This either manifested as completion without a value or non-completion because the missing scalar value would sit in the queue and prevented onCompleted from draining. (I've also fixed some visibility issues which might had an effect in this.)

In addition, I've discovered a good practice for spuriously failing tests: I create a new `@Test`method with a loop in it, calling the original test method. This way, the original is not disturbed and the likelihood of failure is increased by the looping test.

Since the whole `merge`operator is quite complicated, I can't be 100% certain this works despite local tests passing.

See also #2480, #2466 and #1941.
",2015-01-22 11:22:36,2015-01-28 07:33:46,https://api.github.com/repos/ReactiveX/RxJava/issues/2482,['Bug'],60,40,ReactiveX_RxJava_pull_2482.diff
ReactiveX/RxJava,RefCountAsync: adjusted time values as 1 ms is unreliable,"Because of the 1 ms interval, it is possible a single source value might get emitted but not reach the output.
",2015-01-21 14:22:50,2015-01-21 14:28:58,https://api.github.com/repos/ReactiveX/RxJava/issues/2478,[],2,2,ReactiveX_RxJava_pull_2478.diff
ReactiveX/RxJava,Backpressure tests fix0121,"- Increased the limits of `testMergeAsyncThenObserveOn`
- Fixed `testOnBackpressureDrop` because in case there was no drop at all, the last value would be NUM - 1.
- Changed `SLOW_PASS_THRU` to perform non-trivial work that can't be optimized away by JIT.
",2015-01-21 13:57:54,2015-01-21 14:02:56,https://api.github.com/repos/ReactiveX/RxJava/issues/2477,[],51,16,ReactiveX_RxJava_pull_2477.diff
ReactiveX/RxJava,Fixed off-by-one error and value-drop in the window operator.,"Fixes #2290.
",2015-01-21 12:34:42,2015-01-21 14:08:20,https://api.github.com/repos/ReactiveX/RxJava/issues/2476,[],44,29,ReactiveX_RxJava_pull_2476.diff
ReactiveX/RxJava,SynchronousQueue.clone fix,"Fixes #1756.
",2015-01-21 12:14:34,2015-01-21 12:20:30,https://api.github.com/repos/ReactiveX/RxJava/issues/2475,[],3,1,ReactiveX_RxJava_pull_2475.diff
ReactiveX/RxJava,MergeTest.testConcurrency timeout to let other tests run,,2015-01-21 11:12:26,2015-01-21 11:53:53,https://api.github.com/repos/ReactiveX/RxJava/issues/2474,[],1,1,ReactiveX_RxJava_pull_2474.diff
ReactiveX/RxJava,Cleans up and deflakes up testRetryWithBackpressure,"This should solve #2192, since this test has been failing most of the time on travis.
",2015-01-20 21:08:35,2015-01-21 17:00:54,https://api.github.com/repos/ReactiveX/RxJava/issues/2472,[],30,27,ReactiveX_RxJava_pull_2472.diff
ReactiveX/RxJava,Fixes NPEs reported in ReactiveX#1702 by synchronizing queue.,"Also adds a unit test for regression.

It appears there is a potential race condition if something adds to/removes from the PQ while it's _inside_ the 'poll' operation, which is where the exceptions in #1702 seem to have actually come from. Therefore, the initial null check didn't really address the original problem. The test here seems to reliably recreate those conditions.

I considered using a PriorityBlockingQueue instead of synchronized, but since the isEmpty and poll calls should not allow something to interleave between them and access the queue, a synchronized block seemed wiser here.
",2015-01-20 19:35:01,2015-01-23 17:43:38,https://api.github.com/repos/ReactiveX/RxJava/issues/2471,['Bug'],57,17,ReactiveX_RxJava_pull_2471.diff
ReactiveX/RxJava,Subject state information methods & bounded ReplaySubject termination,"fix.

This PR aims to support the requests in #2331 and #1897 by adding methods to the (final) subject classes that let developers access in-flight state in a snapshot fashion. 

This may be considered safe API change because all subject classes were final already so adding extra methods won't break anyone's code (and we will be careful with our Observable in the future).
- `NotificationLite` is now extended with two missing value checks: isNull and isNext.
- Each subject has `hasCompleted`, `hasThrowable` and `getThrowable` methods, however, I can't add them to `Subject` because that would be an incompatible API change.
- Where applicable, `getValue` and `getThrowable` return `null` instead of throwing exceptions so users are encouraged to call hasXXX methods beforehand.
- There was a chaining bug in the bounded ReplaySubject: because the terminal value was added after a potential pruning, the node links could get broken and concurrent replays might not have seen the terminal value.
- Since `ReplaySubject` can have multiple values, I've added `size()`, `hasAnyValue()` (isEmpty is taken) and `getValues()` methods to make a snapshot of the current buffer contents whether or not the `ReplaySubject` has terminated (the usual toList() would wait until the subject has terminated). 
- The unrelated `OperatorMergeTest.testConcurrency` hangs for me for some reason without activity (either a buffer bug or a merge bug is in play there). I've added a timeout so it doesn't stop the other tests.
",2015-01-20 15:22:14,2015-01-28 14:47:54,https://api.github.com/repos/ReactiveX/RxJava/issues/2470,['Enhancement'],1066,15,ReactiveX_RxJava_pull_2470.diff
ReactiveX/RxJava,Remove the execute permission from source files,,2015-01-20 12:50:54,2015-01-20 14:30:28,https://api.github.com/repos/ReactiveX/RxJava/issues/2469,[],0,0,ReactiveX_RxJava_pull_2469.diff
ReactiveX/RxJava,ScheduledExecutorService: call purge periodically on JDK 6 to avoid,"cancelled task-retention.

First debated in #1922, see also #1919.

We may want to discuss the naming of system parameters. I chose these so RxJava 2.0 specific properties may be trivially separated:

`io.reactivex.rxjava.scheduler.jdk6.purge-frequency-millis`
Specifies the purge frequency in milliseconds. Default is 1000.

`io.reactivex.rxjava.scheduler.jdk6.purge-force`
Forces the use of the purge (if set to true) even if the setRemoveOnCancelPolicy is supported. The benefit is that removing cancelled tasks now runs on a different thread so the main pool thread doesn't waste time on them. The drawback is the retention window can be still to large.

Do we have a wiki page where such parameters are listed?
",2015-01-19 08:20:04,2015-01-28 08:42:11,https://api.github.com/repos/ReactiveX/RxJava/issues/2465,['Enhancement'],158,66,ReactiveX_RxJava_pull_2465.diff
ReactiveX/RxJava,Fix the race condition in OnBackpressureBuffer,"Fixed #2459
",2015-01-16 08:01:47,2015-01-16 08:51:08,https://api.github.com/repos/ReactiveX/RxJava/issues/2460,[],38,39,ReactiveX_RxJava_pull_2460.diff
ReactiveX/RxJava,Increase the timeout of testRetryWithBackpressure to 30 seconds,,2015-01-15 07:27:21,2015-01-15 07:43:12,https://api.github.com/repos/ReactiveX/RxJava/issues/2456,[],1,1,ReactiveX_RxJava_pull_2456.diff
ReactiveX/RxJava,Fix for #2191 - OperatorMulticast fails to unsubscribe from source,"OperatorMulticast fails to unsubscribe from source. #2191 
",2015-01-15 04:11:25,2015-01-21 10:53:00,https://api.github.com/repos/ReactiveX/RxJava/issues/2455,[],217,6,ReactiveX_RxJava_pull_2455.diff
ReactiveX/RxJava,Fail early if a null subscription is added to a CompositeSubscription.,"Otherwise, it'll just fail late when unsubscribing, which is much harder to trace.

I discovered this while writing  a unit test, when I didn't properly mock out a method to return a valid Observable. Seems like it would be more likely to happen in test code than production, but still could be a stumbling block that's hard to track down if there's a bug in app logic adding a null subscription.
",2015-01-12 22:53:43,2015-01-21 12:20:00,https://api.github.com/repos/ReactiveX/RxJava/issues/2447,[],13,3,ReactiveX_RxJava_pull_2447.diff
ReactiveX/RxJava,A set of stateless operators that don't need to be instantiated,"for `lift()` all the time.
",2015-01-06 16:06:05,2015-01-21 12:00:33,https://api.github.com/repos/ReactiveX/RxJava/issues/2335,[],157,68,ReactiveX_RxJava_pull_2335.diff
ReactiveX/RxJava,RxRingBuffer fixes and improvements,"This PR contains the fixes and improvements on the RxRingBuffer and its single-consumer-single-producer queue.
- Added `SWSRPhaser` which is a variant of Gil Tene's WriterReaderPhaser that uses cheaper atomic operations because the single reader and single writer use case. Note that pre Java 8 Unsafe doesn't support atomic addAndGetLong operation. The simplified phaser costs only a single atomic increment per use.
- Updated `SpscArrayQueue` to match JCTools' current version: the queue now can be fully utilized to its capacity.
- The `RxRingBuffer` now uses two phasers: one for the offer side and one for the poll/peek side. The benefits: reduced interference between readers and writers; allows using the simplified phaser because each side is now single threaded (a shared phaser implies up to 2 threads at once).

Benchmark results:

```
Benchmark              (size)        1.x   |      this   
1SyncStreamOfN              1  3779678,748 | 3767936,028 
1SyncStreamOfN           1000    21250,675 |   18530,542 
1SyncStreamOfN        1000000       20,406 |      17,712 
NAsyncStreamsOfN            1   115390,116 |  115629,480 
NAsyncStreamsOfN         1000        2,579 |       2,546 
NSyncStreamsOf1             1  3543551,254 | 3602242,709 
NSyncStreamsOf1           100   299166,910 |  301703,721 
NSyncStreamsOf1          1000    28404,751 |   28420,833 
NSyncStreamsOfN             1  4054571,577 | 4003156,953 
NSyncStreamsOfN          1000       24,324 |      20,601 
TwoAsyncStreamsOfN          1    85846,727 |   85682,983 
TwoAsyncStreamsOfN       1000     1823,137 |    1889,458 
reamOfNthatMergesIn1        1  3724179,351 | 3725068,220 
reamOfNthatMergesIn1     1000    19051,928 |   19392,595 
reamOfNthatMergesIn1  1000000       18,265 |      18,069
```
",2015-01-06 07:53:53,2015-01-28 23:27:50,https://api.github.com/repos/ReactiveX/RxJava/issues/2333,"['Bug', 'Enhancement']",222,97,ReactiveX_RxJava_pull_2333.diff
ReactiveX/RxJava,Operator retry test fix attempt,"Maybe the error function was not emitting events properly.
",2015-01-05 23:06:13,2015-01-19 06:17:43,https://api.github.com/repos/ReactiveX/RxJava/issues/2332,[],92,30,ReactiveX_RxJava_pull_2332.diff
ReactiveX/RxJava,Adds a isInitialised call to check if the BehaviorSubject is initialised,"Since the BehaviorSubject can be created without a default value, it could be interesting to be able to know if the subject is initialised (if it holds a value).
Adding this check allows for lazy initialisation of the behavior's value.
",2015-01-05 14:53:26,2015-01-21 14:18:28,https://api.github.com/repos/ReactiveX/RxJava/issues/2331,[],29,0,ReactiveX_RxJava_pull_2331.diff
ReactiveX/RxJava,Fixed off-by-one error and value-drop in the window operator,"Fixes #2290 
",2015-01-05 09:06:59,2015-01-21 12:27:33,https://api.github.com/repos/ReactiveX/RxJava/issues/2330,[],43,28,ReactiveX_RxJava_pull_2330.diff
ReactiveX/RxJava,OperatorTakeLast add check for isUnsubscribed to fast path,"Went looking for a bug that wasn't a bug but found this anyway.  `OperatorTakeLast` doesn't check `subscriber.isUnsubscribed()` while emitting its queued events so I added a failing unit test and the fix.
",2014-12-24 19:26:42,2015-01-19 06:43:31,https://api.github.com/repos/ReactiveX/RxJava/issues/2244,[],31,0,ReactiveX_RxJava_pull_2244.diff
ReactiveX/RxJava,Experimental RingBuffer using WriterReaderPhaser,"As per discussion in #2189 this is an attempt at implementing `RxRingBuffer` using `WriterReaderPhaser`. 

The performance numbers are worse than #2189, inline with the RW Lock and WIP implementations. 

See the last column:

```
Benchmark                                          (size)   Mode   Samples          1.x   Inline Volatile    + finalize       RW Lock          WIP     WRPhaser
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  4757888.048       5264594.520   4956256.323   5288310.755  5032942.628  5147447.030
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    44877.618         42845.758     39209.439     25742.696    29025.955    27779.876
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       42.366            40.979        37.036        24.769       27.260       27.694
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5    99981.127         99910.070     94307.080    103112.286   103176.289   100516.101
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        4.675             4.620         4.670         4.374        4.313        4.413
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4751265.583       4706441.452   4376983.062   4739418.557  4673633.614  4510099.724
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   458704.984        480075.261    427165.143    483313.588   476318.407   462373.555
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    42493.290         42178.254     39640.240     42728.480    42542.171    41354.668
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5406448.872       5375090.752   5066264.570   5628401.294  4974892.417  4986054.668
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       44.528            40.990        41.106        24.974       28.212       27.755
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    76898.222         72655.377     69748.305     78283.565    78987.646    78550.912
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3172.653          2955.854      3064.749      1858.361     2204.948     2310.804
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5157134.576       5163837.644   4846336.744   5290961.536  5139893.848  4486879.415
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    39961.491         39341.526     37312.117     40418.492    39163.267    37424.146
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       35.925            35.730        33.948        35.526       35.611       32.287
```
",2014-12-24 18:10:20,2015-01-22 19:54:55,https://api.github.com/repos/ReactiveX/RxJava/issues/2243,[],295,55,ReactiveX_RxJava_pull_2243.diff
ReactiveX/RxJava,Fix the bug that cache doesn't unsubscribe the source Observable when th...,"...e source is terminated

Fix #2191 
",2014-12-24 07:59:43,2015-01-21 14:29:47,https://api.github.com/repos/ReactiveX/RxJava/issues/2238,[],17,3,ReactiveX_RxJava_pull_2238.diff
ReactiveX/RxJava,Make Publish Operator Release RingBuffer,"It was retaining the RxRingBuffer reference between subscribes which meant it was never released to the object pool.

As per discussion in #2189 there are other issues in the `OperatorPublish` implementation but those will be fixed later. This PR is just for fixing the issue related to use of RxRingBuffer. 
",2014-12-24 05:00:08,2014-12-24 05:30:28,https://api.github.com/repos/ReactiveX/RxJava/issues/2237,[],22,10,ReactiveX_RxJava_pull_2237.diff
ReactiveX/RxJava,RxRingBuffer with Inline Release,"Since previous tests have shown that pooling does still make a big difference, I'm trying to find a way to do pooling without the concurrency issue. I've tried with work-in-progress counters, ReadWrite locks and other variants and all of them impact performance far too much. 

This one makes different trade-offs:

It will release automatically when a ... 
- terminal event is emitted
- unsubscribe/release occurs and queue is empty
- unsubscribe/release has occurred and poll/peek occurs

This can result in a queue not being put back in the pool if an early unsubscribe occurs from a different thread and causes the poll/peek to not trigger the release. In this case GC will reclaim the pool so it still functions, it just misses the pooling optimization.

There is a commented out test of using finalize(). It works as a safety net for the edge case, but at the cost of increased GC time.

Here are performance numbers of the various tests, this one being ""Inline Volatile"":

```
Benchmark                                          (size)   Mode   Samples          1.x   Inline Volatile    + finalize       RW Lock          WIP
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  4757888.048       5264594.520   4956256.323   5288310.755  5032942.628
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    44877.618         42845.758     39209.439     25742.696    29025.955
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       42.366            40.979        37.036        24.769       27.260
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5    99981.127         99910.070     94307.080    103112.286   103176.289
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        4.675             4.620         4.670         4.374        4.313
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4751265.583       4706441.452   4376983.062   4739418.557  4673633.614
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   458704.984        480075.261    427165.143    483313.588   476318.407
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    42493.290         42178.254     39640.240     42728.480    42542.171
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5406448.872       5375090.752   5066264.570   5628401.294  4974892.417
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       44.528            40.990        41.106        24.974       28.212
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    76898.222         72655.377     69748.305     78283.565    78987.646
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3172.653          2955.854      3064.749      1858.361     2204.948
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5157134.576       5163837.644   4846336.744   5290961.536  5139893.848
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    39961.491         39341.526     37312.117     40418.492    39163.267
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       35.925            35.730        33.948        35.526       35.611
```

The memory allocation amounts look good, though I don't understand the shape of the red graph at the top. That is making me question this. 

![screen shot 2014-12-22 at 9 05 06 pm](https://cloud.githubusercontent.com/assets/813492/5534740/3c346190-8a1e-11e4-8a57-5ced2954eb8c.png)

With `finalize()` (as an experiment, aware of all the reasons to not use `finalize()` from Effective Java, 2nd Edition) this is what it looks like:

![screen shot 2014-12-22 at 9 05 56 pm](https://cloud.githubusercontent.com/assets/813492/5534748/657c3140-8a1e-11e4-8459-3dd92571c0a7.png)

The GC times on this one are higher than without `finalize()`:

![screen shot 2014-12-22 at 9 06 33 pm](https://cloud.githubusercontent.com/assets/813492/5534751/6e91e86a-8a1e-11e4-9cb6-2689edc5a143.png)

compared with:

![screen shot 2014-12-22 at 9 07 10 pm](https://cloud.githubusercontent.com/assets/813492/5534754/850f38e0-8a1e-11e4-9e8a-4fc230df8013.png)
",2014-12-23 05:11:27,2015-01-22 19:55:20,https://api.github.com/repos/ReactiveX/RxJava/issues/2189,[],62,10,ReactiveX_RxJava_pull_2189.diff
ReactiveX/RxJava,Fix the issue that map may swallow fatal exceptions,"The issue was reported by @mofleury in https://github.com/ReactiveX/RxJava/pull/1367#issuecomment-67783532
",2014-12-22 08:09:51,2014-12-24 04:53:30,https://api.github.com/repos/ReactiveX/RxJava/issues/2156,[],22,0,ReactiveX_RxJava_pull_2156.diff
ReactiveX/RxJava,Added Operator switchIfEmpty,"Like defaultIfEmpty but subscribes to and emits the items in an Observable if the source is empty.

Fixes #1878 
",2014-12-19 21:14:10,2015-02-03 08:48:13,https://api.github.com/repos/ReactiveX/RxJava/issues/2091,['Enhancement'],310,0,ReactiveX_RxJava_pull_2091.diff
ReactiveX/RxJava,Fixed wrong bounded ReplaySubject use in test.,"Same issue as before.
",2014-12-18 07:53:18,2014-12-18 22:16:26,https://api.github.com/repos/ReactiveX/RxJava/issues/2053,[],6,1,ReactiveX_RxJava_pull_2053.diff
ReactiveX/RxJava,OperatorDoOnRequest.ParentSubscriber should be static class,"minor fix this. `OperatorDoOnRequest.ParentSubscriber` does not require access to the state or methods of its surrounding class thus can be static.
",2014-12-18 06:29:28,2014-12-24 04:54:16,https://api.github.com/repos/ReactiveX/RxJava/issues/2052,[],1,1,ReactiveX_RxJava_pull_2052.diff
ReactiveX/RxJava,Fixed test issuing non-serialized messages to the subject.,"Should resolve the test failure of #1972 .

When the main part of the test succeded, an onCompleted was sent out from the main thread which was not serialized in respect to the onNext(1) issued from the worker thread, therefore, two replay was attempted sometimes. At first the caughtUp was seen false, the replay was entered but the next instruction cleared the index causing the IllegalStateException.
",2014-12-15 07:48:46,2014-12-16 04:26:34,https://api.github.com/repos/ReactiveX/RxJava/issues/1973,[],64,54,ReactiveX_RxJava_pull_1973.diff
ReactiveX/RxJava,Remove Object Pool,"PR https://github.com/ReactiveX/RxJava/pull/1944 rebased onto 1.x. 

This removes the use of object pooling as per discussion in  #1908 to achieve correctness. Performance stats will follow in comments. 
",2014-12-13 18:40:12,2014-12-13 19:25:34,https://api.github.com/repos/ReactiveX/RxJava/issues/1969,[],4,308,ReactiveX_RxJava_pull_1969.diff
ReactiveX/RxJava,Upgrade to Gradle 2.2,,2014-12-13 08:57:41,2014-12-13 18:22:57,https://api.github.com/repos/ReactiveX/RxJava/issues/1968,[],4,3,ReactiveX_RxJava_pull_1968.diff
ReactiveX/RxJava,Fix the issue that GroupBy may not call 'unsubscribe',,2014-12-12 15:22:00,2014-12-17 20:55:27,https://api.github.com/repos/ReactiveX/RxJava/issues/1967,[],137,16,ReactiveX_RxJava_pull_1967.diff
ReactiveX/RxJava,Fix NPE when the key is null in GroupBy,"Fix the issue that when the key is null, groupby will throw NPE.
",2014-12-12 15:16:35,2014-12-13 19:04:44,https://api.github.com/repos/ReactiveX/RxJava/issues/1966,[],43,6,ReactiveX_RxJava_pull_1966.diff
ReactiveX/RxJava,Fix the issue that Sample doesn't call 'unsubscribe',"Fix #1958
",2014-12-12 15:06:31,2014-12-15 04:02:04,https://api.github.com/repos/ReactiveX/RxJava/issues/1965,[],18,4,ReactiveX_RxJava_pull_1965.diff
ReactiveX/RxJava,Handle 0 or negative request in Buffer,"If n == 0, buffer may emit a negative request.
",2014-12-12 14:41:40,2014-12-13 19:03:43,https://api.github.com/repos/ReactiveX/RxJava/issues/1964,[],6,0,ReactiveX_RxJava_pull_1964.diff
ReactiveX/RxJava,Remove Request Batching in Merge,"Removing the batching until we can find a correct way to do it as per discussion at https://github.com/ReactiveX/RxJava/issues/1941#issuecomment-66734495

The performance impact of this change is seen here:

```
Benchmark                                          (size)   Mode   Samples          1.x    No Request Batching
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  4585554.607    4666745.314 102%
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    51273.033      39922.246 78%
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       47.515         37.634 79%
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5    90901.735      93454.726 103%
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        5.407          4.910 91%
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4181618.767    4173322.551 100%
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   422193.599     408972.130 97%
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    36886.812      36448.978 99%
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  4815945.720    4887943.643 101%
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       43.926         39.027 89%
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    72578.046      70412.656 97%
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3260.024       3064.403 94%
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  4678858.201    4808504.588 103%
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    34407.547      36364.476 106%
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       31.312         32.261 103%
```
",2014-12-12 07:23:05,2014-12-13 18:18:16,https://api.github.com/repos/ReactiveX/RxJava/issues/1961,[],97,40,ReactiveX_RxJava_pull_1961.diff
ReactiveX/RxJava,doOnRequest,"Similar to doOnSubscribe, doOnNext, etc
",2014-12-12 05:20:29,2014-12-12 07:00:06,https://api.github.com/repos/ReactiveX/RxJava/issues/1960,[],97,0,ReactiveX_RxJava_pull_1960.diff
ReactiveX/RxJava,Fix issues that GroupBy and Sample doesn't call 'unsubscribe' and also NPE when the key is null in GroupBy,"Fix #1958
",2014-12-12 03:20:26,2014-12-12 15:04:26,https://api.github.com/repos/ReactiveX/RxJava/issues/1959,[],128,18,ReactiveX_RxJava_pull_1959.diff
ReactiveX/RxJava,Fix 'request(0)' issue in Scan,"#1904 didn't all cases.
",2014-12-12 02:50:34,2014-12-13 19:03:25,https://api.github.com/repos/ReactiveX/RxJava/issues/1957,[],59,13,ReactiveX_RxJava_pull_1957.diff
ReactiveX/RxJava,OnBackpressureXXX: support for common drain manager & fix for former concurrency bugs,"This is quite a complex operator with lots of cases.

Properties:
1) If there aren't any elements queued up and nothing is requested but terminal event received, emit terminal event and quit.
2) If there are elements in the queue and a terminal flag, and at least the same amount is requested, deliver the events and the terminal event.
3) If more was requested and more became available just after the loop and before the synchronized block, keep looping.
3.a) If more was requested but nothing is available or nothing was requested and something is available: quit and let either the onNext or request do the subsequent drain.
3.b) If elements and termination was produced but not requested: quit and let the request do the drain
3.c) If termination was requested and no elements produced: loop , emit terminal event and quit.

In table form:

```
Available | Terminated | Requested | Action | Reason
   yes         yes          yes       loop    can deliver available
   yes         yes          false     quit    can't deliver available
   yes         no           yes       loop    can deliver available
   yes         no           no        quit    can't deliver available
   no          yes          yes       loop    loop will deliver termination only and quit
   no          yes          no        loop    loop will deliver termination only and quit
   no          no           yes       quit    nothing to deliver
   no          no           no        quit    nothing to deliver
```
",2014-12-11 21:23:58,2015-02-03 09:00:35,https://api.github.com/repos/ReactiveX/RxJava/issues/1955,"['Bug', 'Enhancement']",447,194,ReactiveX_RxJava_pull_1955.diff
ReactiveX/RxJava,Fix OperatorOnBackpressureBlock race & termination condition issue.,"Fix a race condition when there is a new request value or a new element/termination in the queue appearing just after the while loop:

1) more is requested before the sync block but there is no new element in the queue: quit (because nothing to do).
2) run out of requests but there is an element in the queue: quit (because the next request will drain the queue)
3) more requests and more elements in the queue: loop again (we got more work to deliver)
4) a terminal event arrived: loop again (since a terminal event quits completely, this may happen only once).
",2014-12-11 19:51:55,2014-12-11 20:00:22,https://api.github.com/repos/ReactiveX/RxJava/issues/1954,[],8,6,ReactiveX_RxJava_pull_1954.diff
ReactiveX/RxJava,Fixed timer cast-to-int crash causing incorrect benchmark.,"The perf benchmark uses a 1 millisecond timer to interfere with the serializing process. However, the original benchmark used `cast(Integer.class)` which just simply throws an error on a long value thus terminating the whole serialization process almost immediately. What gets measured is how fast can the whole process restarted to fail again.

With the fix, I get the following numbers:

```
Benchmark                                        (size)         Score  Score error
r.o.OSP.noSerializationSingleThreaded                 1  15632242,955   576291,356
r.o.OSP.noSerializationSingleThreaded              1000    143971,769     1129,048
r.o.OSP.noSerializationSingleThreaded           1000000       153,444        8,286
r.o.OSP.serializedSingleStream                        1   7249531,621   140827,908
r.o.OSP.serializedSingleStream                     1000     52595,958     1845,084
r.o.OSP.serializedSingleStream                  1000000        53,001        1,155
r.o.OSP.serializedTwoStreamsHighlyContended           1    143335,868     3643,346
r.o.OSP.serializedTwoStreamsHighlyContended        1000      3453,108       22,826
r.o.OSP.serializedTwoStreamsHighlyContended     1000000         3,113        0,127
r.o.OSP.serializedTwoStreamsOneFastOneSlow            1     99417,300     5162,370
r.o.OSP.serializedTwoStreamsOneFastOneSlow         1000     14857,037     7131,489
r.o.OSP.serializedTwoStreamsSlightlyContended         1     82621,317     1977,208
r.o.OSP.serializedTwoStreamsSlightlyContended      1000         1,007        0,026
```

Clearly, the serializedTwoStreamsSlightlyContended() shows that under a second, you can serialize two 1 millisecond sources.

For comparison with my latest endeavors, the custom WriterReaderPhaser + AtomicResizableArray + Fast-path queue drain with front check produces the following values:
(Mode: thrpt, Samples: 5)

```
r.o.OSP.serializedSingleStream                        1   4702012,445    65485,925    64.86%
r.o.OSP.serializedSingleStream                     1000     43189,631     1508,771    82.12%
r.o.OSP.serializedSingleStream                  1000000        42,384        1,531    79.97%
r.o.OSP.serializedTwoStreamsHighlyContended           1    138302,278     3530,496    96.45%
r.o.OSP.serializedTwoStreamsHighlyContended        1000      3085,205      118,029    89.34%
r.o.OSP.serializedTwoStreamsHighlyContended     1000000         3,284        0,555   105.49%
r.o.OSP.serializedTwoStreamsOneFastOneSlow            1    100760,210     6614,699   101.35%
r.o.OSP.serializedTwoStreamsOneFastOneSlow         1000      1464,140     1015,858     9.85%
r.o.OSP.serializedTwoStreamsSlightlyContended         1     82823,995      835,143   102.44%
r.o.OSP.serializedTwoStreamsSlightlyContended      1000         1,002        0,014
```

A specialized two-way only striped custom WriterReaderPhaser produces these:

```
r.o.OSP2.serializedSingleStream                        1  4551488,444   776149,420
r.o.OSP2.serializedSingleStream                     1000    14567,954      246,157
r.o.OSP2.serializedSingleStream                  1000000       14,358        0,574
r.o.OSP2.serializedTwoStreamsHighlyContended           1   165429,534     1245,682
r.o.OSP2.serializedTwoStreamsHighlyContended        1000     3383,878       62,534
r.o.OSP2.serializedTwoStreamsHighlyContended     1000000        3,459        0,759
r.o.OSP2.serializedTwoStreamsOneFastOneSlow            1   105104,317     1247,636
r.o.OSP2.serializedTwoStreamsOneFastOneSlow         1000      265,691       90,654
r.o.OSP2.serializedTwoStreamsSlightlyContended         1    82814,850     1824,645
r.o.OSP2.serializedTwoStreamsSlightlyContended      1000        1,002        0,014
```

I'm not quite sure why `serializedTwoStreamsOneFastOneSlow` is so low in my versions. My guess is that since they are lock-free, the timer's thread ends up shoveling the events more frequently than in the synchronized case (because it can sleep).
",2014-12-11 15:46:29,2014-12-12 03:41:47,https://api.github.com/repos/ReactiveX/RxJava/issues/1953,[],10,13,ReactiveX_RxJava_pull_1953.diff
ReactiveX/RxJava,Remove ActionSubscription,"After adding `isUnsubscribed`, `BooleanSubscription` and `ActionSubscription` have the same behavior. So we can remove `ActionSubscription` to eliminate duplicate codes.
",2014-12-11 14:02:57,2014-12-12 03:39:44,https://api.github.com/repos/ReactiveX/RxJava/issues/1952,[],1,31,ReactiveX_RxJava_pull_1952.diff
ReactiveX/RxJava,Remove extraneous request(n) and onCompleted() calls when unsubscribed.,"Added simple checks to make the best effort to not do anything after the down stream has unsubscribed.
",2014-12-11 05:40:12,2014-12-12 03:39:13,https://api.github.com/repos/ReactiveX/RxJava/issues/1951,[],5,2,ReactiveX_RxJava_pull_1951.diff
ReactiveX/RxJava,"Add ""Subscriptions.unsubscribed"" to fix the 'isUnsubscribed' issue","As per #1943
",2014-12-11 02:16:38,2014-12-13 18:59:18,https://api.github.com/repos/ReactiveX/RxJava/issues/1950,[],67,26,ReactiveX_RxJava_pull_1950.diff
ReactiveX/RxJava,Fixed first emission racing with pre and post subscription.,"There was a subtle race between the subscription and emission which delayed the delivery of the first emission if it happened between the pre- and post-subscription of a subscriber. The fix is the same logic used by the BehaviorSubject to avoid the same problem.
",2014-12-09 09:21:54,2014-12-12 03:32:45,https://api.github.com/repos/ReactiveX/RxJava/issues/1947,[],303,24,ReactiveX_RxJava_pull_1947.diff
ReactiveX/RxJava,AbstractOnSubscribe to help build Observables one onNext at a time.,"Repost of #1931.
",2014-12-09 07:44:40,2014-12-09 17:26:28,https://api.github.com/repos/ReactiveX/RxJava/issues/1946,[],1078,0,ReactiveX_RxJava_pull_1946.diff
ReactiveX/RxJava,Fix the 'isUnsubscribed' issue for Subscrptions.empty(),"As per #1943
",2014-12-09 06:36:09,2014-12-11 02:00:43,https://api.github.com/repos/ReactiveX/RxJava/issues/1945,[],10,1,ReactiveX_RxJava_pull_1945.diff
ReactiveX/RxJava,Experimental: Remove Object Pool,"Test removing object pool as per https://github.com/ReactiveX/RxJava/issues/1908
",2014-12-09 05:58:49,2014-12-13 18:38:52,https://api.github.com/repos/ReactiveX/RxJava/issues/1944,[],4,308,ReactiveX_RxJava_pull_1944.diff
ReactiveX/RxJava,OperatorMerge does not request enough #1941,"Looks to me that an inner request count is needed and tracked so that more can be requested from the inner observable if required. Review from anyone familiar with `OperatorMerge` very welcome as I'm not that familiar with its current incarnation and it's a tricky place!

Just one unit test included but I imagine more would be nice.
",2014-12-09 02:02:32,2014-12-09 22:35:20,https://api.github.com/repos/ReactiveX/RxJava/issues/1942,[],75,1,ReactiveX_RxJava_pull_1942.diff
ReactiveX/RxJava,Any/All should not unsubscribe downstream.,"Should fix issue #1935 

When in doubt, see `take`.
",2014-12-08 09:13:22,2014-12-13 18:53:11,https://api.github.com/repos/ReactiveX/RxJava/issues/1938,[],44,18,ReactiveX_RxJava_pull_1938.diff
ReactiveX/RxJava,Scheduler.Worker to be finally unsubscribed to avoid interference,"... and leaks.
",2014-12-08 08:56:01,2014-12-09 04:23:34,https://api.github.com/repos/ReactiveX/RxJava/issues/1937,[],598,523,ReactiveX_RxJava_pull_1937.diff
ReactiveX/RxJava,Hook usage,"Make the hook and instance field so that plugin reset works between unit tests.
Remove unnecessary request(n) and onCompleted() calls when unsubscribed.
",2014-12-08 04:43:02,2014-12-13 18:54:43,https://api.github.com/repos/ReactiveX/RxJava/issues/1936,[],6,6,ReactiveX_RxJava_pull_1936.diff
ReactiveX/RxJava,Request hook,"Adding the ability to track `request(n)` events with the RxJavaDebug hooks.
And a fix for #1933
",2014-12-07 10:37:00,2014-12-07 19:00:01,https://api.github.com/repos/ReactiveX/RxJava/issues/1934,[],25,6,ReactiveX_RxJava_pull_1934.diff
ReactiveX/RxJava,AbstractOnSubscribe to help implement backpressure-respecting,"observables.

Proposed implementation for #1930. See tests for use cases.
",2014-12-05 13:08:29,2014-12-09 07:45:20,https://api.github.com/repos/ReactiveX/RxJava/issues/1931,['Enhancement'],1078,0,ReactiveX_RxJava_pull_1931.diff
ReactiveX/RxJava,Experimental: ObjectPool with WeakReferences,"An experimental implementation of ObjectPool that removes the explicit release and uses WeakReferences.

Part of exploration for https://github.com/ReactiveX/RxJava/issues/1908

The perf numbers on `observeOn` suggest none of this matters :-)

```
1.x Branch

Benchmark                                         (size)   Mode   Samples        Score  Score error    Units
r.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5   108090.165     3468.773    ops/s
r.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5     7010.679      283.868    ops/s
r.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5       13.588        0.354    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5 16268519.793   707702.931    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   149998.180    31025.889    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      159.109       11.987    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5    17182.508      629.781    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     7892.906      139.532    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       13.489        0.527    ops/s

This PullRequest using WeakReferences

Benchmark                                         (size)   Mode   Samples        Score  Score error    Units
r.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5   108133.231     9569.065    ops/s
r.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5     6389.620      581.448    ops/s
r.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5       13.181        1.719    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5 15153898.775   927814.232    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   169459.680    15935.085    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      154.516       32.170    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5    15585.688     1205.259    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     7871.875      295.553    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       14.040        0.628    ops/s


Pooling Disabled (create a new object each time in `borrowObject`)

Benchmark                                         (size)   Mode   Samples        Score  Score error    Units
r.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5   108130.153    10452.845    ops/s
r.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5     6948.319      123.024    ops/s
r.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5       13.294        1.165    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5 15107600.987  1565384.083    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   170127.608    16674.301    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      155.075       20.204    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5    15730.556     1586.146    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     7911.561      439.432    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       14.472        0.982    ops/s
```

Need to sleep on this more but wanted to post this in case it triggers thoughts on ideas for anyone else.
",2014-12-05 08:09:27,2014-12-09 04:04:57,https://api.github.com/repos/ReactiveX/RxJava/issues/1929,[],150,126,ReactiveX_RxJava_pull_1929.diff
ReactiveX/RxJava,Add onBackpressureBuffer with capacity,"The operator takes an optional capacity for the buffer and a callback
that will be invoked if the buffer fills up, along with a
MissingBackpressureException in the Observable's onError.
",2014-12-04 23:28:14,2014-12-09 04:04:45,https://api.github.com/repos/ReactiveX/RxJava/issues/1928,[],169,10,ReactiveX_RxJava_pull_1928.diff
ReactiveX/RxJava,Move the codes out of the finally block,"Found there were complex codes in the `finally` block. It's a bad practice because:
- The `return` statement in the `finally` block will swallow the exception.
- The codes in the finally block will continue to run even if any exception happens in the `try` block. If the `finally` block contains complex codes, they may continue to run for long time or throw an exception which will override the initial one. It will make us hard to debug and find the real problem.

Therefore I moved them out of the `finally` block in this PR.
",2014-12-04 11:56:17,2014-12-09 04:03:15,https://api.github.com/repos/ReactiveX/RxJava/issues/1926,[],30,21,ReactiveX_RxJava_pull_1926.diff
ReactiveX/RxJava,Spsc experiments: AtomicArrayQueue,"Just for fun, I've tried to implement an SPSC ArrayQueue which can resize itself on demand, aimed mainly for using with merge(). Some other classes are from #1909.

Running

```
gradlew benchmarks ""-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 1 .*ConcurrentQueueThroughputBusy.*""
```

Gives me generally nice performance but with high error:

```
Benchmark                                       Mode   Samples        Score  Score error    Units
r.i.ConcurrentQueueThroughputBusy.tpt          thrpt         5 39270769,666 13360732,543    ops/s
r.i.ConcurrentQueueThroughputBusy.tpt:offer    thrpt         5 19789356,594  6803017,182    ops/s
r.i.ConcurrentQueueThroughputBusy.tpt:poll     thrpt         5 19481413,072  6575732,347    ops/s
```

In comparison, the SpscLinkedQueue of #1909 performs better:

```
Benchmark                                       Mode   Samples        Score  Score error    Units
r.i.ConcurrentQueueThroughputBusy.tpt          thrpt         5 46097687,727 15813637,226    ops/s
r.i.ConcurrentQueueThroughputBusy.tpt:offer    thrpt         5 23048904,994  7907022,271    ops/s
r.i.ConcurrentQueueThroughputBusy.tpt:poll     thrpt         5 23048782,733  7906615,063    ops/s
```

Don't know if various padding techniques could help or not. Hopefully, experts such as @nitsanw can review this and tell if it's worth pursuing or not.
",2014-12-02 15:59:34,2014-12-03 09:32:54,https://api.github.com/repos/ReactiveX/RxJava/issues/1924,[],879,0,ReactiveX_RxJava_pull_1924.diff
ReactiveX/RxJava,Set removeOnCancelPolicy on the threadpool if supported,"This should solve the task retention problem of unused timeout tasks mentioned in #1919.

I know Java 7+ ScheduledThreadPoolExecutor has the `setRemoveOnCancelPolicy` and I remember seeing it in Android although I can't tell from which API version.

In Java 6, this can't be solved without rewriting the entire scheduler or using a backported executor.
",2014-12-02 13:30:01,2014-12-09 04:02:28,https://api.github.com/repos/ReactiveX/RxJava/issues/1922,[],80,9,ReactiveX_RxJava_pull_1922.diff
ReactiveX/RxJava,"Revert ""Experimental onBackpressureBufferWithCapacity""","Reverts ReactiveX/RxJava#1916

This breaks unit tests all over for some reason. I completely missed it before merging as the unit tests related to `onBackpressureBuffer` themselves pass. It's elsewhere that things break. 

From what I can tell it is because `onBackpressureBuffer` is used in unit tests and those fail (often with timeouts or what appears to be infinite loops ... since my CPU pegs itself).
",2014-12-02 06:22:33,2014-12-02 06:22:46,https://api.github.com/repos/ReactiveX/RxJava/issues/1918,[],6,172,ReactiveX_RxJava_pull_1918.diff
ReactiveX/RxJava,Experimental onBackpressureBufferWithCapacity,"Manual merge of https://github.com/ReactiveX/RxJava/pull/1899
- changed Func0<Void> to Action
- added Beta markers
",2014-12-02 00:12:01,2014-12-02 05:59:39,https://api.github.com/repos/ReactiveX/RxJava/issues/1916,[],172,6,ReactiveX_RxJava_pull_1916.diff
ReactiveX/RxJava,Fixed retry without backpressure & test function to support bp.,"Fixes include:
- do not decrement the client capacity if it is unbounded,
- do not request 0,
- propagate request count (n) instead of capacity + request (c + n),
- FuncWithErrors to support backpressure; there was a non-zero chance the final succeding pair of onNexts would trigger a MissingBackpressureException.
",2014-12-01 12:24:22,2014-12-01 23:41:32,https://api.github.com/repos/ReactiveX/RxJava/issues/1912,[],69,56,ReactiveX_RxJava_pull_1912.diff
ReactiveX/RxJava,Atomic operations JMH benchmarks,"Created some JMH benchmarks for the typical volatile and atomic operations.
",2014-12-01 09:51:25,2014-12-01 18:00:29,https://api.github.com/repos/ReactiveX/RxJava/issues/1911,[],280,0,ReactiveX_RxJava_pull_1911.diff
ReactiveX/RxJava,Rxqueue spsc non-contended count proposal,"Just a suggestion about making the current element count non-contended. I saw this trick in Disruptor / mechanicalsympathy if I remember correctly. Not benchmarked. 

(Also don't know how to aim a PR at @benjchristensen 's repository instead of main.)
",2014-12-01 08:07:00,2014-12-24 04:55:19,https://api.github.com/repos/ReactiveX/RxJava/issues/1910,[],522,150,ReactiveX_RxJava_pull_1910.diff
ReactiveX/RxJava,EXPERIMENTAL: SpscLinkedQueue,"Experimentation with using SpscLinkedQueue instead of ArrayQueue (ring buffer) + object pooling.

See https://github.com/ReactiveX/RxJava/issues/1908 for discussion. 

This comment in particular is about this PR: https://github.com/ReactiveX/RxJava/issues/1908#issuecomment-64998783
",2014-11-30 20:26:50,2014-12-09 04:01:00,https://api.github.com/repos/ReactiveX/RxJava/issues/1909,[],473,140,ReactiveX_RxJava_pull_1909.diff
ReactiveX/RxJava,Experimental: onBackpressureBlock,"An experimental implementation of `onBackpressureBlock`.

An open question is whether this should be allowed to block if running on a known eventloop such as `Schedulers.computation()` or should instead emit an error in that situation. 
",2014-11-29 21:52:03,2014-12-01 23:42:22,https://api.github.com/repos/ReactiveX/RxJava/issues/1907,[],462,1,ReactiveX_RxJava_pull_1907.diff
ReactiveX/RxJava,Fixed potential NPE due to many reads to an instance variable.,"Factored out of #1895
",2014-11-29 21:04:45,2014-12-01 12:33:30,https://api.github.com/repos/ReactiveX/RxJava/issues/1906,[],17,12,ReactiveX_RxJava_pull_1906.diff
ReactiveX/RxJava,Beta & Experimental Annotations,"See https://github.com/ReactiveX/RxJava/issues/1824
",2014-11-29 20:33:10,2014-11-29 21:44:49,https://api.github.com/repos/ReactiveX/RxJava/issues/1905,[],92,0,ReactiveX_RxJava_pull_1905.diff
ReactiveX/RxJava,Fix the bug that Scan may request 0 when n is 1,"`Scan` may request 0 when n is 1 and `request(0)` makes the source `Observable` do nothing. The unit test demonstrates this bug.
",2014-11-29 16:57:53,2014-11-29 21:20:02,https://api.github.com/repos/ReactiveX/RxJava/issues/1904,['Bug'],32,2,ReactiveX_RxJava_pull_1904.diff
ReactiveX/RxJava,Fix TestScheduler Handling of Immediate vs Virtual Time,"Manual merge of https://github.com/ReactiveX/RxJava/pull/1790 by @ylecaillez
",2014-11-29 04:39:05,2014-11-29 05:51:17,https://api.github.com/repos/ReactiveX/RxJava/issues/1903,[],44,2,ReactiveX_RxJava_pull_1903.diff
ReactiveX/RxJava,On backpressure block,"After watching Ben's great JavaOne 2014 talk, I was wondering why there isn't a onBackpressureBlock, i.e., a strategy which blocks the producer thread. 

On one hand, I can accept we don't want to encourage blocking operations, on the other hand, this operator may allow casual Observable.create() implementations to not worry about backpressure at the expense of blocking one Schedulers.io() thread.
",2014-11-26 13:04:17,2014-11-29 21:52:30,https://api.github.com/repos/ReactiveX/RxJava/issues/1902,['Enhancement'],457,0,ReactiveX_RxJava_pull_1902.diff
ReactiveX/RxJava,Fixed redo & groupBy backpressure management,"Issue #1900 
",2014-11-25 11:14:15,2014-11-29 05:06:48,https://api.github.com/repos/ReactiveX/RxJava/issues/1901,[],103,16,ReactiveX_RxJava_pull_1901.diff
ReactiveX/RxJava,Add optional bound to onBackpressureBuffer,"The operator takes an optional capacity for the buffer and a callback to
be triggered when the buffer fills up.
",2014-11-22 00:00:02,2014-12-02 00:15:20,https://api.github.com/repos/ReactiveX/RxJava/issues/1899,['Enhancement'],169,8,ReactiveX_RxJava_pull_1899.diff
ReactiveX/RxJava,Scheduled action no interrupt,"At the end of the run, ScheduledAction unsubscribes itself which triggers a set of cleanup actions, and since it is also the way to cancel a running action, it calls future.cancel(true) as well which interrupts the task in the underlying executor framework. However, on a normal completion path, it is unnecessary to interrupt itself at the end of the run since it will complete anyway, and not to mention, it has some performance implications for short running tasks. The downside is the +4 bytes per ScheduledAction.
",2014-11-21 08:20:45,2014-11-29 20:05:06,https://api.github.com/repos/ReactiveX/RxJava/issues/1898,[],101,16,ReactiveX_RxJava_pull_1898.diff
ReactiveX/RxJava,Merge many fixes,"Contains the PR #1893 and a possible fix for the premature RxRingBuffer unsubscription and NPE.
",2014-11-19 16:16:51,2014-12-01 12:35:09,https://api.github.com/repos/ReactiveX/RxJava/issues/1895,[],121,82,ReactiveX_RxJava_pull_1895.diff
ReactiveX/RxJava,Fixed incorrect error merging.,"The `wip` was decremented if the parent received an onError which prevented legitimate inner subscribers from delivering events.
",2014-11-19 09:12:01,2014-11-21 12:19:20,https://api.github.com/repos/ReactiveX/RxJava/issues/1893,[],80,64,ReactiveX_RxJava_pull_1893.diff
ReactiveX/RxJava,Zip potential NPE fix.,"Issue #1891

My best guess is that the visibility of the items in the observers array is not guaranteed and some CPU/JVM optimizations may expose this. The fix initializes the observers array locally and uses the memory barrier provided by the incrementAndGet on the producer to ensure everything before that becomes visible for the subsequent subscriptions.
",2014-11-19 08:21:18,2014-12-01 12:36:03,https://api.github.com/repos/ReactiveX/RxJava/issues/1892,[],5,2,ReactiveX_RxJava_pull_1892.diff
ReactiveX/RxJava,Create an Observable that emits each char in the source String.,"Motivation:
- RxJS has this [from](http://xgrommx.github.io/rx-book/content/core_objects/observable/observable_methods/from.html) feature and it's simple awesome, so, why not included it :)

Example

``` java
Observable.from(""foo"").subscribe(new StringPrinterObserver());
```

Output:

```
onNext : f
onNext : o
onNext : o
onCompleted
```
",2014-11-17 20:03:03,2014-11-17 21:27:38,https://api.github.com/repos/ReactiveX/RxJava/issues/1888,[],47,0,ReactiveX_RxJava_pull_1888.diff
ReactiveX/RxJava,Buffer with time and merge fix,"Bug report #1867.

I'm not sure if the wrong guard in merge contributed to this bug or not.
",2014-11-17 09:27:14,2014-11-17 17:48:54,https://api.github.com/repos/ReactiveX/RxJava/issues/1886,[],42,6,ReactiveX_RxJava_pull_1886.diff
ReactiveX/RxJava,Fix Scan/Reduce/Collect Factory Ambiguity,"This puts the seed factory on `collect` and removes it from `scan` and `reduce` due to ambiguity.
See https://github.com/ReactiveX/RxJava/pull/1883 and https://github.com/ReactiveX/RxJava/issues/1881

The `collect` API was already very close so this fixes it to use a seed factory so the signature is now:

``` java
public final <R> Observable<R> collect(Func0<R> stateFactory, final Action2<R, ? super T> collector) {
```

I remove the factory overloads for `scan` and `reduce` due to the issue in #1881 related to generics, type erasure and lambdas causing ambiguity and compilation failures.

We may want to add at least a `scan` impl in the future with a seed factory, but it will need a different name if we do such as `scanTo`. I don't want to do that now for 1.0 so we'll need to revisit that for 1.1 with more time to think about it.
",2014-11-15 19:04:47,2014-11-15 19:48:57,https://api.github.com/repos/ReactiveX/RxJava/issues/1884,[],45,75,ReactiveX_RxJava_pull_1884.diff
ReactiveX/RxJava,Fix Scan/Reduce/Collect Lambda Ambiguity,"This fixes the Java 8 lambda ambiguity between the overloads: https://github.com/ReactiveX/RxJava/issues/1881

This is a breaking change for anyone using `scan`, `reduce`, `collect` with an initial value. 

There are two approaches to adapting.

If the initial value is the same type such as this:

``` java
stream.scan(1, Func2<Integer, Integer, Integer>)
```

then you can use `startWith`:

``` java
stream.startWith(1).scan(Func2<Integer, Integer, Integer>)
```

If it is a different type then a seed factory is needed:

``` java
stream.scan(Func0<List>, Func2< List, Integer, List >)
```

In Java 8 this would change from this:

``` java
stream.scan(new ArrayList(), (list, item) -> {
    list.add(item);
    return list;
});
```

to this:

``` java
stream.scan(() -> new ArrayList(), (list, item) -> {
    list.add(item);
    return list;
});
```

The same change happens in `reduce` and `collect`.
",2014-11-15 14:31:10,2014-11-15 17:24:26,https://api.github.com/repos/ReactiveX/RxJava/issues/1883,[],104,87,ReactiveX_RxJava_pull_1883.diff
ReactiveX/RxJava,Remove Unused Scheduler.parallelism,"Before hitting 1.0 removing this API as it is not used.
",2014-11-15 06:49:22,2014-11-15 14:06:41,https://api.github.com/repos/ReactiveX/RxJava/issues/1882,['Enhancement'],0,12,ReactiveX_RxJava_pull_1882.diff
ReactiveX/RxJava,Fix memory leak in bounded ReplaySubject due to retaining the node index,"indefinitely once the Subscriber caught up.

For issue #1865.
",2014-11-12 13:11:18,2014-11-15 19:58:37,https://api.github.com/repos/ReactiveX/RxJava/issues/1866,[],1,1,ReactiveX_RxJava_pull_1866.diff
ReactiveX/RxJava,Fix Concat Breaks with Double onCompleted,"Fixes https://github.com/ReactiveX/RxJava/issues/1818 in the 0.20.x branch
",2014-11-11 18:50:21,2014-11-11 19:11:57,https://api.github.com/repos/ReactiveX/RxJava/issues/1863,[],34,4,ReactiveX_RxJava_pull_1863.diff
ReactiveX/RxJava,Backpressure suppport for Window by size,"For #1828. Extracted Producers from OperatorBufferWithSize and reused them in OperatorWindowWithSize.
",2014-11-11 14:39:24,2014-11-12 01:34:47,https://api.github.com/repos/ReactiveX/RxJava/issues/1862,[],248,73,ReactiveX_RxJava_pull_1862.diff
ReactiveX/RxJava,Unsubscribe when thread is interrupted,"Originated from discussion #1804.

I was considering to make it opt-in, but it would drastically increase number of methods in public API.
What do you think?
",2014-11-10 10:35:17,2015-01-21 15:18:03,https://api.github.com/repos/ReactiveX/RxJava/issues/1840,['Enhancement'],142,3,ReactiveX_RxJava_pull_1840.diff
ReactiveX/RxJava,Reduce Ring Buffer Default Sizes (and lower for Android),"- This adds platform dependent checks to lower the buffer sizes on Android to use less memory. It also reduces the normal defaults as perf testing showed we didn't need to be as high.
- This adds System properties for overriding the defaults, `rx.ring-buffer.size` and `rx.indexed-ring-buffer.size`

Fixes https://github.com/ReactiveX/RxJava/issues/1820
",2014-11-08 18:21:53,2014-11-08 22:27:47,https://api.github.com/repos/ReactiveX/RxJava/issues/1836,[],373,2,ReactiveX_RxJava_pull_1836.diff
ReactiveX/RxJava,Scan/Reduce with Seed Factory,"Adds overload with seed factory as per https://github.com/ReactiveX/RxJava/issues/1831
",2014-11-08 16:56:41,2014-11-08 22:28:31,https://api.github.com/repos/ReactiveX/RxJava/issues/1835,[],114,4,ReactiveX_RxJava_pull_1835.diff
ReactiveX/RxJava,Subject.toSerialized,"Adds toSerialized as discussed in https://github.com/ReactiveX/RxJava/issues/1748
",2014-11-08 16:25:11,2014-11-09 00:03:49,https://api.github.com/repos/ReactiveX/RxJava/issues/1834,[],20,0,ReactiveX_RxJava_pull_1834.diff
ReactiveX/RxJava,Fix Thread Safety for Unsubscribe of Window,"I'm using a separate variable so the volatile is only touching during window start/end and unsubscribe rather than every onNext.
",2014-11-07 07:24:24,2014-11-08 03:23:21,https://api.github.com/repos/ReactiveX/RxJava/issues/1833,[],6,3,ReactiveX_RxJava_pull_1833.diff
ReactiveX/RxJava,Fix Take Early Unsubscription Causing Interrupts,"Fixes https://github.com/ReactiveX/RxJava/issues/1804

This is one approach to fixing #1804 that still works with the unit tests that `take` had been changed for originally.

Still not sure if we should change the default behavior though to not interrupt a thread.
",2014-11-07 07:09:47,2014-11-08 22:29:14,https://api.github.com/repos/ReactiveX/RxJava/issues/1832,[],35,12,ReactiveX_RxJava_pull_1832.diff
ReactiveX/RxJava,Fix mergeDelayError Handling of Error in Parent Observable,"Fixes https://github.com/ReactiveX/RxJava/issues/313
",2014-11-06 06:13:46,2014-11-06 06:37:38,https://api.github.com/repos/ReactiveX/RxJava/issues/1830,[],73,3,ReactiveX_RxJava_pull_1830.diff
ReactiveX/RxJava,Fix Window by Count Unsubscribe Behavior,"This fixes https://github.com/ReactiveX/RxJava/issues/1546 where unsubscribes would occur prematurely for non-overlapping `window(size)` and would not unsubscribe at all for overlapping `window(size, skip)`.

It also reorganizes the `window` unit tests which were all combined in one file when the implementations are split across 4 files. This is now easier to understand and use.
",2014-11-06 05:29:32,2014-11-06 06:07:05,https://api.github.com/repos/ReactiveX/RxJava/issues/1829,[],878,570,ReactiveX_RxJava_pull_1829.diff
ReactiveX/RxJava,CacheThreadScheduler Evictor should Check Removal,"Before unsubscribing the worker, the Evictor should check that it actually removed the worker from the queue.

FIxes #1826 
",2014-11-06 00:22:32,2014-11-06 07:05:16,https://api.github.com/repos/ReactiveX/RxJava/issues/1827,[],4,6,ReactiveX_RxJava_pull_1827.diff
ReactiveX/RxJava,Fix Concat Breaks with Double onCompleted,"Fixes https://github.com/ReactiveX/RxJava/issues/1818
",2014-11-02 06:50:06,2014-11-02 06:50:12,https://api.github.com/repos/ReactiveX/RxJava/issues/1819,[],34,4,ReactiveX_RxJava_pull_1819.diff
ReactiveX/RxJava,Fix Synchronous OnSubscribe Exception Skips Operators,"Fixes https://github.com/ReactiveX/RxJava/issues/1816
",2014-11-02 03:57:46,2014-11-02 04:08:05,https://api.github.com/repos/ReactiveX/RxJava/issues/1817,[],65,6,ReactiveX_RxJava_pull_1817.diff
ReactiveX/RxJava,Fix issue #1812 that zip may swallow requests,"Fixed #1812
",2014-10-31 09:09:09,2014-10-31 19:28:49,https://api.github.com/repos/ReactiveX/RxJava/issues/1813,[],29,1,ReactiveX_RxJava_pull_1813.diff
ReactiveX/RxJava,Remove Utility Functions from Public API,"Fixes https://github.com/ReactiveX/RxJava/issues/1797
",2014-10-29 20:34:20,2014-10-30 02:25:17,https://api.github.com/repos/ReactiveX/RxJava/issues/1809,[],221,199,ReactiveX_RxJava_pull_1809.diff
ReactiveX/RxJava,Fix the RxClojure project link.,,2014-10-29 16:54:36,2014-10-29 17:09:16,https://api.github.com/repos/ReactiveX/RxJava/issues/1808,[],1,1,ReactiveX_RxJava_pull_1808.diff
ReactiveX/RxJava,Remove Unnecessary Utilities,"Remove utility methods and classes as per https://github.com/ReactiveX/RxJava/issues/1799 and https://github.com/ReactiveX/RxJava/issues/1798
",2014-10-29 03:01:42,2014-10-29 20:09:49,https://api.github.com/repos/ReactiveX/RxJava/issues/1806,[],0,109,ReactiveX_RxJava_pull_1806.diff
ReactiveX/RxJava,Print full classname (inner class support) and fix enum output,"@benjchristensen 

`Class.getSimpleName()` is empty for inner classes, leading to an error message that looks like this: ""OnError while emitting onNext value: .class""

Also, `Enum.name()` is always safe and not expensive so we can use that when there's a failure emitting an enum value.
",2014-10-28 14:13:55,2014-10-28 16:42:43,https://api.github.com/repos/ReactiveX/RxJava/issues/1803,[],8,5,ReactiveX_RxJava_pull_1803.diff
ReactiveX/RxJava,add hasObservers method to Subjects (#1772),"as per https://github.com/ReactiveX/RxJava/issues/1772

SerializedSubject now keeps track of the actual Subject.
BufferUntilSubscriber synchronizes on the state guard.
",2014-10-27 11:17:28,2014-10-28 21:59:55,https://api.github.com/repos/ReactiveX/RxJava/issues/1802,[],55,6,ReactiveX_RxJava_pull_1802.diff
ReactiveX/RxJava,Improve TestSubject Javadoc,"As per https://github.com/ReactiveX/RxJava/issues/1759
",2014-10-24 20:18:35,2014-10-24 20:18:44,https://api.github.com/repos/ReactiveX/RxJava/issues/1796,[],19,11,ReactiveX_RxJava_pull_1796.diff
ReactiveX/RxJava,Take/Redo Unsubscribe,"Do not do further work after unsubscribed.

I added a fix to `take` on top of the change by @alexwen that fixes the source of the issue with `take`. It now unsubscribes before `onNext` so side-effects of `onNext` such as `request(n)` happen after `unsubscribe` and thus no further work will be scheduled.

I left the changes to `OnSubscribeRedo` as they are a good safety net in case another operator has a similar issue as `take` (an easy bug to creep in) as it does no harm to `redo` to have the `isUnsubscribed` check going forward.

Fixes #1791.
",2014-10-23 21:23:07,2014-10-23 21:48:27,https://api.github.com/repos/ReactiveX/RxJava/issues/1793,[],41,2,ReactiveX_RxJava_pull_1793.diff
ReactiveX/RxJava,Fix for #1791,"Fixes #1791 

don't retry (subscribe) to source if child has unsubscribed.
",2014-10-23 20:53:20,2014-10-23 21:48:29,https://api.github.com/repos/ReactiveX/RxJava/issues/1792,[],35,0,ReactiveX_RxJava_pull_1792.diff
ReactiveX/RxJava,Time marker is reset when schedule is immediate.,,2014-10-23 15:23:25,2014-11-29 04:39:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1790,['Bug'],62,18,ReactiveX_RxJava_pull_1790.diff
ReactiveX/RxJava,GroupedObservable.from/create,"See https://github.com/ReactiveX/RxJava/issues/1668
",2014-10-23 06:17:47,2014-10-23 06:19:22,https://api.github.com/repos/ReactiveX/RxJava/issues/1789,[],58,6,ReactiveX_RxJava_pull_1789.diff
ReactiveX/RxJava,Remove PublishLast/InitialValue,"See https://github.com/ReactiveX/RxJava/issues/1785
",2014-10-23 06:11:44,2014-10-24 20:00:49,https://api.github.com/repos/ReactiveX/RxJava/issues/1788,[],1,100,ReactiveX_RxJava_pull_1788.diff
ReactiveX/RxJava,Remove *withIndex Operators,"See https://github.com/ReactiveX/RxJava/issues/1782 -> Remove takeWhileWithIndex & skipWhileWithIndex
",2014-10-23 06:09:44,2014-10-23 06:18:22,https://api.github.com/repos/ReactiveX/RxJava/issues/1787,[],15,56,ReactiveX_RxJava_pull_1787.diff
ReactiveX/RxJava,Remove Multicast,"The implementation is still there as `replay` is still using it, but the public API is removed.

See https://github.com/ReactiveX/RxJava/issues/1779 for discussion.
",2014-10-23 06:03:51,2014-10-23 06:04:13,https://api.github.com/repos/ReactiveX/RxJava/issues/1786,[],7,115,ReactiveX_RxJava_pull_1786.diff
ReactiveX/RxJava,Publish with Backpressure,"Implementation of `publish` with backpressure: https://github.com/ReactiveX/RxJava/issues/1732

This moves away from using the `multicast` operator and `PublishSubject` as per discussion in #1732 and #1779
",2014-10-23 05:42:22,2014-10-23 05:49:17,https://api.github.com/repos/ReactiveX/RxJava/issues/1784,[],563,66,ReactiveX_RxJava_pull_1784.diff
ReactiveX/RxJava,"Change Transformer to Func1<Observable<T>, Observable<R>>","Less variance is better. I cannot find any bad case for this PR. Can someone help test it in Java 8 and Groovy?
",2014-10-19 14:51:30,2014-10-20 16:52:43,https://api.github.com/repos/ReactiveX/RxJava/issues/1778,[],7,9,ReactiveX_RxJava_pull_1778.diff
ReactiveX/RxJava,Excluding things from the javadoc,"For one of the sub issues in #1502.

exclude rx.internal.
exclude RxJavaErrorHandlerDefault by deleting it.
",2014-10-19 07:29:20,2014-10-21 16:47:50,https://api.github.com/repos/ReactiveX/RxJava/issues/1777,[],10,33,ReactiveX_RxJava_pull_1777.diff
ReactiveX/RxJava,Observable.compose Generics,"Manual merge of https://github.com/ReactiveX/RxJava/pull/1762 with an extra unit test added.
",2014-10-18 22:35:42,2014-10-18 22:37:13,https://api.github.com/repos/ReactiveX/RxJava/issues/1776,[],101,9,ReactiveX_RxJava_pull_1776.diff
ReactiveX/RxJava,BlockingOperatorNextTest.testSingleSourceManyIterators fix,"#1655
",2014-10-17 12:46:52,2014-10-18 22:45:45,https://api.github.com/repos/ReactiveX/RxJava/issues/1775,[],1,1,ReactiveX_RxJava_pull_1775.diff
ReactiveX/RxJava,Serialized backpressure support proposal.,"For #1671

It took me a while to get it working and I'm not sure what tests to write to check backpressure behavior besides the request 5s from a sequence of 15.

In addition, it was a bit confusing when to call onStart, what exactly the setProducer call supposed to do and what to do when noone calls setProducer from upstream. 
",2014-10-17 11:57:00,2015-01-20 17:06:15,https://api.github.com/repos/ReactiveX/RxJava/issues/1774,[],353,35,ReactiveX_RxJava_pull_1774.diff
ReactiveX/RxJava,On error return backpressure,"connect parent and child producers to allow backpressure signals to flow.
",2014-10-16 16:58:48,2014-10-16 17:01:23,https://api.github.com/repos/ReactiveX/RxJava/issues/1771,[],93,0,ReactiveX_RxJava_pull_1771.diff
ReactiveX/RxJava,Compose generics without Transformer,,2014-10-16 15:49:45,2014-10-19 02:58:23,https://api.github.com/repos/ReactiveX/RxJava/issues/1770,[],64,25,ReactiveX_RxJava_pull_1770.diff
ReactiveX/RxJava,Schedulers shutdown capability.,"Proposal for shutting down the computation and io schedulers on demand.
#1730
",2014-10-16 09:59:16,2015-01-28 23:28:26,https://api.github.com/repos/ReactiveX/RxJava/issues/1769,['Enhancement'],256,51,ReactiveX_RxJava_pull_1769.diff
ReactiveX/RxJava,OnErrorResume Backpressure Tests,,2014-10-16 04:53:10,2014-10-16 04:53:14,https://api.github.com/repos/ReactiveX/RxJava/issues/1768,[],67,0,ReactiveX_RxJava_pull_1768.diff
ReactiveX/RxJava,ExecutorScheduler delivers uncaught exceptions,"Instead of swallowing unhandled errors, ExecutorScheduler delivers them
to the executing thread's UncaughtExceptionHandler.

This addresses the same issue as ReactiveX/RxJava#1682, but for
ExecutorScheduler which does not used ScheduledAction.
",2014-10-16 04:53:03,2014-10-16 05:54:38,https://api.github.com/repos/ReactiveX/RxJava/issues/1767,[],13,1,ReactiveX_RxJava_pull_1767.diff
ReactiveX/RxJava,Unhandled errors go to UncaughtExceptionHandler,"Rather than swallowing/logging errors, ScheduledAction now delivers them
to the UncaughtExceptionHandler for the executing Thread. This gives
client applications control over the handling of errors that occur off
of the calling Thread.
",2014-10-16 04:19:09,2014-10-16 04:43:48,https://api.github.com/repos/ReactiveX/RxJava/issues/1766,[],166,4,ReactiveX_RxJava_pull_1766.diff
ReactiveX/RxJava,backpressure support in onErrorResumeNext* operators,"set producer to allow back pressure signals to flow between parent and child
",2014-10-16 04:17:23,2014-10-16 04:44:00,https://api.github.com/repos/ReactiveX/RxJava/issues/1765,[],22,0,ReactiveX_RxJava_pull_1765.diff
ReactiveX/RxJava,Cleanup RefCount Tests,,2014-10-16 03:00:48,2014-10-16 03:00:53,https://api.github.com/repos/ReactiveX/RxJava/issues/1764,[],535,290,ReactiveX_RxJava_pull_1764.diff
ReactiveX/RxJava,Combine RefCount Tests,,2014-10-16 02:57:40,2014-10-16 03:17:05,https://api.github.com/repos/ReactiveX/RxJava/issues/1763,[],209,242,ReactiveX_RxJava_pull_1763.diff
ReactiveX/RxJava,Compose generics,,2014-10-16 01:04:59,2014-10-18 22:37:13,https://api.github.com/repos/ReactiveX/RxJava/issues/1762,[],58,8,ReactiveX_RxJava_pull_1762.diff
ReactiveX/RxJava,Issue #1642 Fix null-emitting combineLatest,"Same as https://github.com/ReactiveX/RxJava/pull/1705 but for the 0.20.\* folks
",2014-10-16 00:06:06,2014-10-16 02:58:05,https://api.github.com/repos/ReactiveX/RxJava/issues/1761,[],24,1,ReactiveX_RxJava_pull_1761.diff
ReactiveX/RxJava,ReplaySubject backpressure first try,"Added backpressure support to the unbounded ReplaySubject case. Since it buffers values anyway, this is just an attempt to honor the Subscriber's request amount. In addition, I removed some unnecessary complications from SubjectObserver and ReplayState. One notable effect is that the onCompleted event isn't immediately delivered (if requested < Long.MAX_VALUE) but only when the client Subscriber actually `request()` for the next value.

In addition, the bounded replay had an unfortunate bug if the list got completely evicted before a terminal event and Subscribers had a broken chain not ending in the tail terminal event. This was uncovered by the removal of `caughtUp` flag.
",2014-10-15 15:19:44,2014-12-11 19:11:36,https://api.github.com/repos/ReactiveX/RxJava/issues/1760,[],191,105,ReactiveX_RxJava_pull_1760.diff
ReactiveX/RxJava,Fix TestSubject to schedule events correctly,"The bug is that using `innerScheduler.now()` as the delay time. This PR called `innerScheduler.schedule(Action0)` directly.
",2014-10-15 09:32:22,2014-10-15 09:47:22,https://api.github.com/repos/ReactiveX/RxJava/issues/1758,[],99,4,ReactiveX_RxJava_pull_1758.diff
ReactiveX/RxJava,"Cleanup: added missing annotations, removed unnecesary annotations","plus fixed a few unnecessary casts I missed last time.
",2014-10-15 08:21:20,2014-10-15 15:38:45,https://api.github.com/repos/ReactiveX/RxJava/issues/1757,[],86,23,ReactiveX_RxJava_pull_1757.diff
ReactiveX/RxJava,OnSubscribeRefCount with Synchronous Support,"Redo of https://github.com/ReactiveX/RxJava/pull/1753 with fixes to unit tests.

Fixes https://github.com/ReactiveX/RxJava/issues/1688
",2014-10-15 07:02:33,2014-10-15 07:35:42,https://api.github.com/repos/ReactiveX/RxJava/issues/1755,[],430,168,ReactiveX_RxJava_pull_1755.diff
ReactiveX/RxJava,WIP: OnSubscribeRefCount Synchronous,"This is a work in progress... do not merge or use this.

Submitting as PR to allow discussion.
",2014-10-15 06:50:01,2014-10-15 06:57:22,https://api.github.com/repos/ReactiveX/RxJava/issues/1754,[],390,168,ReactiveX_RxJava_pull_1754.diff
ReactiveX/RxJava,Support Synchronous Source in OnSubscribeRefCount,"Merge of https://github.com/ReactiveX/RxJava/pull/1695 into 1.x branch.
",2014-10-14 17:33:35,2014-10-14 20:04:13,https://api.github.com/repos/ReactiveX/RxJava/issues/1753,[],150,166,ReactiveX_RxJava_pull_1753.diff
ReactiveX/RxJava,"Added missing headers, removed unnecessary casts",,2014-10-14 08:00:18,2014-10-14 16:40:40,https://api.github.com/repos/ReactiveX/RxJava/issues/1752,[],219,145,ReactiveX_RxJava_pull_1752.diff
ReactiveX/RxJava,Removed unused imports and variables.,,2014-10-13 06:26:17,2014-10-13 15:53:29,https://api.github.com/repos/ReactiveX/RxJava/issues/1751,[],10,41,ReactiveX_RxJava_pull_1751.diff
ReactiveX/RxJava,Fix NPE when iterable is null,"As per #1676, I prefer that throwing an NullPointerException in the constructor of `OnSubscribeFromIterable`. 

BTW, because https://github.com/ReactiveX/RxJava/blob/v1.0.0-rc.5/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java#L43 does not return after `o.onCompleted();`, there is still a NPE bug here.
",2014-10-12 16:14:16,2014-10-13 15:53:44,https://api.github.com/repos/ReactiveX/RxJava/issues/1750,[],5,12,ReactiveX_RxJava_pull_1750.diff
ReactiveX/RxJava,BufferUntilSubscriber EmptyObserver,"As per https://github.com/ReactiveX/RxJava/pull/1742/files#r18738531
",2014-10-11 02:37:43,2014-10-11 02:53:30,https://api.github.com/repos/ReactiveX/RxJava/issues/1749,[],23,1,ReactiveX_RxJava_pull_1749.diff
ReactiveX/RxJava,Cleanup: final and utility classes,"- Added `final` to utility classes.
- Added private constructor to utility classes.
",2014-10-10 06:38:06,2014-10-10 20:07:18,https://api.github.com/repos/ReactiveX/RxJava/issues/1747,[],59,25,ReactiveX_RxJava_pull_1747.diff
ReactiveX/RxJava,Fatal System.err Logs on Unhandled Exceptions,"If an exception is thrown on a thread then we can't do anything with it so will log out to System.err.

Fixes https://github.com/ReactiveX/RxJava/issues/1682 ScheduledAction Swallows Errors
",2014-10-10 05:41:58,2014-10-10 05:42:10,https://api.github.com/repos/ReactiveX/RxJava/issues/1746,[],15,3,ReactiveX_RxJava_pull_1746.diff
ReactiveX/RxJava,SerializedSubject,"Proposal for a `SerializedSubject` type to simplify solution for multi-threaded emissions to a `Subject`.

See https://github.com/ReactiveX/RxJava/issues/1744
",2014-10-10 04:52:35,2014-10-10 05:50:43,https://api.github.com/repos/ReactiveX/RxJava/issues/1745,[],87,0,ReactiveX_RxJava_pull_1745.diff
ReactiveX/RxJava,Subject Error Handling,"Fixes https://github.com/ReactiveX/RxJava/issues/1685 by delaying errors that are caught until after all subscribers have a chance to receive the event.

Note that this has a lot of code duplication to handle this across the Subject implementations. It may be worth abstracting this logic ... but right now I'm just doing what makes sense to fix this as the Subject abstractions are non-trivial.
",2014-10-10 04:29:37,2014-10-10 04:29:43,https://api.github.com/repos/ReactiveX/RxJava/issues/1743,[],297,6,ReactiveX_RxJava_pull_1743.diff
ReactiveX/RxJava,EmptyObserver and TestObserver,"- Remove `EmptyObserver` as it was confusing compared to `Observers.empty()` (fixes #1741)
- Make `TestObserver` not throw `OnErrorNotImplemented` if a delegate is not provided (fixes #1571)
",2014-10-10 03:44:16,2014-10-10 03:44:23,https://api.github.com/repos/ReactiveX/RxJava/issues/1742,[],31,53,ReactiveX_RxJava_pull_1742.diff
ReactiveX/RxJava,longCount -> countLong,"Fixes https://github.com/ReactiveX/RxJava/issues/1684
",2014-10-10 03:23:43,2014-10-10 03:23:47,https://api.github.com/repos/ReactiveX/RxJava/issues/1740,[],28,28,ReactiveX_RxJava_pull_1740.diff
ReactiveX/RxJava,Fix Slow Non-deterministic Test,"Somehow I missed the Thread.sleep to force the scenario so most of the time this test would run very slow (or forever).
I'm surprised the unit tests passed before... just random luck on thread scheduling.
",2014-10-10 03:09:08,2014-10-10 03:18:07,https://api.github.com/repos/ReactiveX/RxJava/issues/1739,[],6,2,ReactiveX_RxJava_pull_1739.diff
ReactiveX/RxJava,Delay Operator with Reactive Pull Backpressure,"Updated the implementations to support reactive pull backpressure.
Fixes https://github.com/ReactiveX/RxJava/issues/1724
",2014-10-10 03:02:56,2014-10-10 03:18:16,https://api.github.com/repos/ReactiveX/RxJava/issues/1738,[],444,258,ReactiveX_RxJava_pull_1738.diff
ReactiveX/RxJava,Fix TrampolineScheduler NullPointerException,"I tried for about 30 minutes to replicate the NPE reported in https://github.com/ReactiveX/RxJava/issues/1702 but couldn't.
It makes sense reading the code that an unsubscribe could trigger an NPE though so I'm fixing it as per recommendation of @DylanSale even though I can't replicate.
I confirmed that the items are being put in the queue BEFORE the wip variable is incremented, so that concurrency seems okay.
",2014-10-09 17:38:23,2014-10-10 03:20:33,https://api.github.com/repos/ReactiveX/RxJava/issues/1736,[],7,10,ReactiveX_RxJava_pull_1736.diff
ReactiveX/RxJava,Cleanup1008,"This PR diff without whitespace changes: [?w=1](https://github.com/ReactiveX/RxJava/pull/1734/files?w=1)

A ton of style fixes:
- Removed spaces from empty lines and from end of code lines.
- Added spaces after some keywords and brackets.
- Changed tabs to 4 spaces.
- Added final modifiers to classes with just static methods and classes with private constructor.
- Removed final modifiers from methods in final classes.
- Modified casing of some local variables.
- Added missing headers to some java files.
- Added { } to if statements where missing.
- Removed unnecessary `public` and `abstract` and `static` modifiers from interfaces.
- Changed modifiers to be in correct order `public static final`.
- Removed unused imports and local variables.
- Removed unnecessary casts.
- Removed `</dt>` and `</dd>` tags from the javadoc of `Observable` as these tags don't need closing in javadoc.
- Added missing `@Override` and `@SuppressWarnings` annotations.
- Added more time to `BlockingOperatorNextTest.testSingleSourceManyIterators` as the original 10ms was unreliable.
",2014-10-08 11:33:08,2014-10-10 20:07:33,https://api.github.com/repos/ReactiveX/RxJava/issues/1734,[],2512,2340,ReactiveX_RxJava_pull_1734.diff
ReactiveX/RxJava,Move To Proper Location,"Was accidentally committed in old rxjava-core src folder.
",2014-10-08 00:03:39,2014-10-08 00:03:45,https://api.github.com/repos/ReactiveX/RxJava/issues/1733,[],0,0,ReactiveX_RxJava_pull_1733.diff
ReactiveX/RxJava,Remove Unused Code,"Fixes https://github.com/ReactiveX/RxJava/issues/1525
",2014-10-07 23:04:13,2014-10-07 23:04:18,https://api.github.com/repos/ReactiveX/RxJava/issues/1731,[],0,162,ReactiveX_RxJava_pull_1731.diff
ReactiveX/RxJava,CombineLatest: Request Up When Dropping Values,"combineLatest was not replacing requests when it dropped values during the first phase when waiting for all Observables to emit. 

This fixes the first bug in https://github.com/ReactiveX/RxJava/issues/1717
",2014-10-06 18:52:06,2014-10-06 20:26:59,https://api.github.com/repos/ReactiveX/RxJava/issues/1729,[],60,10,ReactiveX_RxJava_pull_1729.diff
ReactiveX/RxJava,ObserveOn Error Propagation,"onError was not being propagated if the child subscriber was backpressured (requested==0)

This fixes the second bug mentioned in https://github.com/ReactiveX/RxJava/issues/1717
",2014-10-06 18:51:11,2014-10-06 20:26:51,https://api.github.com/repos/ReactiveX/RxJava/issues/1728,[],103,39,ReactiveX_RxJava_pull_1728.diff
ReactiveX/RxJava,GroupBy/GroupByUntil Changes,"This is a proposed change to `groupBy` and `groupByUntil` that does the following:

1) Eliminate `groupByUntil` and rolls that functionality into `groupBy`
2) Adds support for reactive pull backpressure to `groupBy`
3) Child `GroupedObservable`s can now be unsubscribed and they will be cleaned up and then new instances for the same key can be emitted, like `groupByUntil` worked, except that now instead of passing in a special durationSelector function, the child can be composed using `take`/`takeUntil`/etc to cause an unsubscribe.

If the previous non-obvious groupBy behavior is wanted, then instead of unsubscribing, it can be filtered to ignore all further data, which is what the old groupBy used to do when a child was unsubscribed.

The reason for these changes are:
- Adding backpressure to `groupByUntil` was very difficult with its existing signature as the duration selector function effectively required a `GroupedObservable` being a `PublishSubject` which meant multicasting. In this specific case it may have been possible to do backpressure with the multicasting, but it would be difficult and non-obvious as generally multicasting means the stream is ""hot"" and reactive pull backpressure can't be applied.
- The existing `groupBy` almost always confused people as to what would happen when they unsubscribed a child using `take` or `takeUntil`. It always surprised people that it meant all further data would be dropped but the key and group would not be garbage collected. Almost always on an infinite stream people determined they needed `groupByUntil`, but only after stumbling around. After speaking with @headinthebox about this briefly we had enough agreement to submit this proposal and discuss further.

Now `groupBy` can behave by default as people expect with `unsubscribe` and support infinite streams, garbage collection, etc as well as backpressure.

I will provide usage examples below.
",2014-10-06 05:39:42,2014-10-06 17:50:04,https://api.github.com/repos/ReactiveX/RxJava/issues/1727,[],616,868,ReactiveX_RxJava_pull_1727.diff
ReactiveX/RxJava,Fix Merge: backpressure + scalarValueQueue don't play nicely ,"Manual merge of unit tests and fix by @dmgd for https://github.com/ReactiveX/RxJava/issues/1723 

Thank you @dmgd for debugging this as `merge` is very complicated code (unfortunately).
",2014-10-06 03:47:29,2014-10-06 03:55:45,https://api.github.com/repos/ReactiveX/RxJava/issues/1726,[],117,10,ReactiveX_RxJava_pull_1726.diff
ReactiveX/RxJava,Groupby with back pressure,"backpressure support for groupby
",2014-10-03 23:07:43,2014-10-06 05:40:02,https://api.github.com/repos/ReactiveX/RxJava/issues/1722,[],448,188,ReactiveX_RxJava_pull_1722.diff
ReactiveX/RxJava,Bug in the onBackpressure operators,"cherry pick from 1.0 #1719
",2014-10-03 22:24:28,2014-10-04 04:26:13,https://api.github.com/repos/ReactiveX/RxJava/issues/1721,[],18,2,ReactiveX_RxJava_pull_1721.diff
ReactiveX/RxJava,Change repeatWhen and retryWhen signatures.,"Add a shim to make it so the public api for repeatWhen and retryWhen don't expose Notification<?>
https://github.com/ReactiveX/RxScala/pull/24
",2014-10-03 21:49:32,2014-10-04 04:29:46,https://api.github.com/repos/ReactiveX/RxJava/issues/1720,[],80,37,ReactiveX_RxJava_pull_1720.diff
ReactiveX/RxJava,Bug in the onBackpressure operators,"The onBackpressure operators need to send `request(Long.MAX_VALUE)` on start.
",2014-10-03 21:38:18,2014-10-04 04:26:02,https://api.github.com/repos/ReactiveX/RxJava/issues/1719,[],18,2,ReactiveX_RxJava_pull_1719.diff
ReactiveX/RxJava,Remove Observable.Parallel,"see https://github.com/ReactiveX/RxJava/issues/1673
",2014-10-02 23:17:53,2014-10-02 23:17:56,https://api.github.com/repos/ReactiveX/RxJava/issues/1716,[],0,415,ReactiveX_RxJava_pull_1716.diff
ReactiveX/RxJava,Deprecate Parallel,"see https://github.com/ReactiveX/RxJava/issues/1673
",2014-10-02 23:03:17,2014-10-02 23:03:23,https://api.github.com/repos/ReactiveX/RxJava/issues/1715,[],2,0,ReactiveX_RxJava_pull_1715.diff
ReactiveX/RxJava,Merge 0.20.5 into 1.x,"Merge the following:
- https://github.com/ReactiveX/RxJava/pull/1686 Fix Rx serialization bug in takeUntil again and the concurrent issue in BufferUntilSubscriber
- https://github.com/ReactiveX/RxJava/pull/1701 Fix the compose generics
- https://github.com/ReactiveX/RxJava/pull/1712 Fixing regression in mergeDelayError
",2014-10-02 22:56:08,2014-10-02 22:56:16,https://api.github.com/repos/ReactiveX/RxJava/issues/1714,[],250,145,ReactiveX_RxJava_pull_1714.diff
ReactiveX/RxJava,Slightly cleaner code for onNext from buffer,,2014-10-02 22:26:07,2014-10-02 22:26:10,https://api.github.com/repos/ReactiveX/RxJava/issues/1713,[],1,2,ReactiveX_RxJava_pull_1713.diff
ReactiveX/RxJava,Fixing regression in mergeDelayError,,2014-10-02 04:11:12,2014-10-02 22:14:28,https://api.github.com/repos/ReactiveX/RxJava/issues/1712,[],39,16,ReactiveX_RxJava_pull_1712.diff
ReactiveX/RxJava,Demonstrate a regression in a special case exposed by Groovy,"In 0.19.2, Observable.mergeDelayError(Observable.error(ex)) emits an OnError
In 0.20.4, Observable.mergeDelayError(Observable.error(ex)) emits nothing
",2014-10-02 00:12:46,2014-10-02 03:53:39,https://api.github.com/repos/ReactiveX/RxJava/issues/1711,[],25,8,ReactiveX_RxJava_pull_1711.diff
ReactiveX/RxJava,Issue #1642 Fix null-emitting combineLatest,"@benjchristensen 
",2014-09-29 18:01:08,2014-10-02 22:21:10,https://api.github.com/repos/ReactiveX/RxJava/issues/1705,[],24,1,ReactiveX_RxJava_pull_1705.diff
ReactiveX/RxJava,Fix the compose generics,,2014-09-24 15:46:08,2014-10-02 22:28:36,https://api.github.com/repos/ReactiveX/RxJava/issues/1701,[],48,12,ReactiveX_RxJava_pull_1701.diff
ReactiveX/RxJava,rewrite OnSubscribeRefCount to handle synchronous source,"Resubmitting this one having stuffed up the rebase.

Rewrite of `OnSubscribeRefCount` because original didn't handle synchronous source (#1688) and as far as I could see the original was fundamentally broken by this use case. Please note also includes a fix in `OperatorMulticast` where a null check was required. I've done the rewrite using locks rather than submit a lock-free version just to ensure that the approach is valid with the experts first.
",2014-09-22 02:37:26,2014-10-14 16:55:44,https://api.github.com/repos/ReactiveX/RxJava/issues/1695,[],150,166,ReactiveX_RxJava_pull_1695.diff
ReactiveX/RxJava,OnSubscribeRefCount rewrite to handle synchronous source #1688,"Rewrite of `OnSubscribeRefCount` because original didn't handle synchronous source (#1688) and as far as I could see the original was fundamentally broken by this use case. Please note also includes a fix in `OperatorMulticast` where a null check was required. I've done the rewrite using locks rather than submit a lock-free version just to ensure that the approach is valid with the experts first.  
",2014-09-21 21:39:34,2014-09-22 02:34:43,https://api.github.com/repos/ReactiveX/RxJava/issues/1694,[],294,174,ReactiveX_RxJava_pull_1694.diff
ReactiveX/RxJava,Don't allocate an empty ArrayList for each Observable.empty call,,2014-09-14 08:30:10,2014-10-01 00:43:43,https://api.github.com/repos/ReactiveX/RxJava/issues/1687,[],1,1,ReactiveX_RxJava_pull_1687.diff
ReactiveX/RxJava,Fix Rx serialization bug in takeUntil again and the concurrent issue in BufferUntilSubscriber,"Sorry that #1656 is not a correct fix.
",2014-09-12 09:46:57,2014-10-02 22:45:43,https://api.github.com/repos/ReactiveX/RxJava/issues/1686,[],167,121,ReactiveX_RxJava_pull_1686.diff
ReactiveX/RxJava,ObserveOn Error Handling,"Proposed solution for https://github.com/ReactiveX/RxJava/issues/1681 and https://github.com/ReactiveX/RxJava/issues/1680
",2014-09-11 04:52:06,2014-10-02 22:29:30,https://api.github.com/repos/ReactiveX/RxJava/issues/1683,[],65,4,ReactiveX_RxJava_pull_1683.diff
ReactiveX/RxJava,Merge 0.20.4 Fixes,"Merge fixes from 0.20.4 into 1.x
",2014-09-05 23:33:24,2014-09-05 23:41:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1672,[],177,5,ReactiveX_RxJava_pull_1672.diff
ReactiveX/RxJava,Error Handling Unsubscribe and Terminal State,"This is related to work done in https://github.com/ReactiveX/RxJava/pull/1657
",2014-09-05 19:34:31,2014-09-05 21:35:32,https://api.github.com/repos/ReactiveX/RxJava/issues/1669,[],143,3,ReactiveX_RxJava_pull_1669.diff
ReactiveX/RxJava,Fix the bug that Switch doesn't propagate 'unsubscribe',"Found in #1666
",2014-09-05 05:55:13,2014-09-05 15:52:40,https://api.github.com/repos/ReactiveX/RxJava/issues/1667,[],18,0,ReactiveX_RxJava_pull_1667.diff
ReactiveX/RxJava,Fix Javadoc README link,"http://netflix.github.com/RxJava/javadoc/ gives 404. I presume this should point to http://reactivex.io/RxJava/javadoc/
",2014-09-04 18:15:54,2014-09-04 18:31:04,https://api.github.com/repos/ReactiveX/RxJava/issues/1665,[],1,1,ReactiveX_RxJava_pull_1665.diff
ReactiveX/RxJava,StringObservable.split NPE fixes,"check for null values of leftOver in onCompleted and onError.

Added two failing unit tests that passed with fix.

@benjchristensen I suppose should I make PR on RxJavaString as well? 
",2014-09-04 10:45:32,2014-09-04 18:31:37,https://api.github.com/repos/ReactiveX/RxJava/issues/1664,[],22,2,ReactiveX_RxJava_pull_1664.diff
ReactiveX/RxJava,Correct README Javadoc link.,,2014-09-03 06:45:33,2014-09-04 18:33:22,https://api.github.com/repos/ReactiveX/RxJava/issues/1660,[],1,1,ReactiveX_RxJava_pull_1660.diff
ReactiveX/RxJava,OperatorScan should check for MAX_VALUE on request,"A check for `n == Long.MAX_VALUE` is missing from the `Producer` implementation which opens up the possibility of passing through an unintended request for `Long.MAX_VALUE-1`.
",2014-09-03 04:56:21,2014-09-05 18:15:52,https://api.github.com/repos/ReactiveX/RxJava/issues/1659,[],1,1,ReactiveX_RxJava_pull_1659.diff
ReactiveX/RxJava,Ignore furthur messages after entering terminate state,"As per #1633
",2014-09-02 09:22:44,2014-09-05 18:22:03,https://api.github.com/repos/ReactiveX/RxJava/issues/1657,[],13,0,ReactiveX_RxJava_pull_1657.diff
ReactiveX/RxJava,Make TakeUntil obey Rx serialization contract,"`TakeUntil` didn't synchronize messages from different Observables.
",2014-09-02 07:20:30,2014-09-05 22:29:34,https://api.github.com/repos/ReactiveX/RxJava/issues/1656,[],2,1,ReactiveX_RxJava_pull_1656.diff
ReactiveX/RxJava,Operator Scan Backpressure Fix,"Problem 1) The initial value was being emitted before subscription which caused issues with request/producer state, particularly if filter() was used to skip that initial value and then called request(1) before the real request had been sent.
Problem 2) The initial value was not accounted for by the request so it was sending 1 more value than requested. It now modifies the request to account for it.
Problem 3) Redo relied upon these nuances to work. I've fixed this by using a simpler implementation that just maintains state within a map function.

Already merged and released in 0.20.x https://github.com/ReactiveX/RxJava/pull/1648
",2014-08-31 19:24:15,2014-09-01 02:01:15,https://api.github.com/repos/ReactiveX/RxJava/issues/1652,[],219,21,ReactiveX_RxJava_pull_1652.diff
ReactiveX/RxJava,RxScala: Fix the problem that Subscriber.onStart isn't called,"Just realized #1641 didn't fix the problem in `onStart`. This PR fixed it and added unit tests.

/cc @jbripley, @headinthebox, @samuelgruetter
",2014-08-31 15:16:49,2014-08-31 17:54:12,https://api.github.com/repos/ReactiveX/RxJava/issues/1651,[],46,2,ReactiveX_RxJava_pull_1651.diff
ReactiveX/RxJava,Add takeUntil(predicate) operator,"That would close #1649.
",2014-08-31 11:34:32,2014-10-10 08:51:47,https://api.github.com/repos/ReactiveX/RxJava/issues/1650,[],78,0,ReactiveX_RxJava_pull_1650.diff
ReactiveX/RxJava,Operator Scan Backpressure Fix,"Problem 1) The initial value was being emitted before subscription which caused issues with request/producer state, particularly if filter() was used to skip that initial value and then called request(1) before the real request had been sent.
Problem 2) The initial value was not accounted for by the request so it was sending 1 more value than requested. It now modifies the request to account for it.
Problem 3) Redo relied upon these nuances to work. I've fixed this by using a simpler implementation that just maintains state within a map function.
",2014-08-31 05:44:58,2014-08-31 18:17:46,https://api.github.com/repos/ReactiveX/RxJava/issues/1648,[],220,27,ReactiveX_RxJava_pull_1648.diff
ReactiveX/RxJava,Operator Scan Backpressure Fix,"Problem 1) The initial value was being emitted before subscription which caused issues with request/producer state, particularly if filter() was used to skip that initial value and then called request(1) before the real request had been sent.
Problem 2) The initial value was not accounted for by the request so it was sending 1 more value than requested. It now modifies the request to account for it.
",2014-08-31 04:10:04,2014-08-31 05:19:04,https://api.github.com/repos/ReactiveX/RxJava/issues/1647,[],196,12,ReactiveX_RxJava_pull_1647.diff
ReactiveX/RxJava,Deprecate ParallelMerge,"Removing in 1.0 as it is confusing and rarely useful.
",2014-08-30 06:17:28,2014-08-30 06:17:36,https://api.github.com/repos/ReactiveX/RxJava/issues/1646,[],4,0,ReactiveX_RxJava_pull_1646.diff
ReactiveX/RxJava,Remove ParallelMerge,"Removing confusing operator before locked in stone with 1.0.0 Final
",2014-08-30 06:11:36,2014-08-30 06:17:17,https://api.github.com/repos/ReactiveX/RxJava/issues/1645,[],0,273,ReactiveX_RxJava_pull_1645.diff
ReactiveX/RxJava,Nebula Build - Single Module,,2014-08-29 21:40:45,2014-08-29 21:44:52,https://api.github.com/repos/ReactiveX/RxJava/issues/1644,[],9,694,ReactiveX_RxJava_pull_1644.diff
ReactiveX/RxJava,RxScala: Fix infinite recursive onStart call in Subscriber,"Without this fix, when subscribing using a `new Subscriber`, onStart would be called in an infinite loop. Giving a strack trace similar to this:

```
java.lang.StackOverflowError
    at rx.lang.scala.SubscriberTests$$anon$1.onStart(SubscriberTests.scala:65)
    at rx.lang.scala.Subscriber$$anon$1.onStart(Subscriber.scala:8)
    at rx.lang.scala.Subscriber$class.onStart(Subscriber.scala:43)
    at rx.lang.scala.SubscriberTests$$anon$1.onStart(SubscriberTests.scala:65)
    at rx.lang.scala.Subscriber$$anon$1.onStart(Subscriber.scala:8)
    at rx.lang.scala.Subscriber$class.onStart(Subscriber.scala:43)
```
",2014-08-28 19:55:49,2014-08-30 06:30:34,https://api.github.com/repos/ReactiveX/RxJava/issues/1641,[],26,2,ReactiveX_RxJava_pull_1641.diff
ReactiveX/RxJava,Migrate Build to Nebula,"Using plugin from https://github.com/nebula-plugins/gradle-rxjava-project-plugin

/cc @quidryan 
",2014-08-28 06:52:25,2014-08-29 21:37:38,https://api.github.com/repos/ReactiveX/RxJava/issues/1640,[],14,629,ReactiveX_RxJava_pull_1640.diff
ReactiveX/RxJava,doOnEach - Handle Fatal Exceptions,"Merging change from 0.20 into 1.x => https://github.com/ReactiveX/RxJava/pull/1631/files
",2014-08-27 23:52:43,2014-08-27 23:52:47,https://api.github.com/repos/ReactiveX/RxJava/issues/1639,[],41,6,ReactiveX_RxJava_pull_1639.diff
ReactiveX/RxJava,Composite Exception - Circular Reference Handling,"Same change as https://github.com/ReactiveX/RxJava/pull/1632 against 0.20 for 1.x
",2014-08-27 23:50:33,2014-08-27 23:50:37,https://api.github.com/repos/ReactiveX/RxJava/issues/1638,[],270,105,ReactiveX_RxJava_pull_1638.diff
ReactiveX/RxJava,Optimize single BlockingObservable operations,"Backport from 1.x to 0.20.x of #1635
",2014-08-27 23:29:39,2014-08-27 23:37:54,https://api.github.com/repos/ReactiveX/RxJava/issues/1637,[],199,74,ReactiveX_RxJava_pull_1637.diff
ReactiveX/RxJava,Optimize single BlockingObservable operations.,"This changeset optimizes all blocking operations that just return a single
value. The previous code used an iterator all the time, adding significant
GC pressure with iterators and a backing LBQ.

The following numbers are from the added JMH tests just as a general
measurement. The most boost is gained from small results and less
GC pressure.

Before this change:

```
r.o.BlockingObservablePerf.benchFirst          1  thrpt         5  2839391.882    17771.079    ops/s
r.o.BlockingObservablePerf.benchFirst       1000  thrpt         5  2046716.781    22884.125    ops/s
r.o.BlockingObservablePerf.benchFirst    1000000  thrpt         5  2067456.792    15499.650    ops/s
r.o.BlockingObservablePerf.benchLast           1  thrpt         5  2160081.041    21230.437    ops/s
r.o.BlockingObservablePerf.benchLast        1000  thrpt         5    83270.845      871.836    ops/s
r.o.BlockingObservablePerf.benchLast     1000000  thrpt         5      100.190        1.001    ops/s
r.o.BlockingObservablePerf.benchSingle         1  thrpt         5  3702921.521   154008.164    ops/s
```

After this change:

```
r.o.BlockingObservablePerf.benchFirst          1  thrpt         5  6466732.996   191239.670    ops/s
r.o.BlockingObservablePerf.benchFirst       1000  thrpt         5  3752276.751   135138.711    ops/s
r.o.BlockingObservablePerf.benchFirst    1000000  thrpt         5  3840942.600    59305.202    ops/s
r.o.BlockingObservablePerf.benchLast           1  thrpt         5  4110186.134    98795.733    ops/s
r.o.BlockingObservablePerf.benchLast        1000  thrpt         5    84528.104     1710.853    ops/s
r.o.BlockingObservablePerf.benchLast     1000000  thrpt         5       99.460        2.091    ops/s
r.o.BlockingObservablePerf.benchSingle         1  thrpt         5 11897793.778   321260.803    ops/s
```
",2014-08-27 17:09:33,2014-08-27 23:45:27,https://api.github.com/repos/ReactiveX/RxJava/issues/1635,[],162,37,ReactiveX_RxJava_pull_1635.diff
ReactiveX/RxJava,WIP: Fast path for BlockingObservables.,"I did more benchmarking with blocking observables and found they're quite wasteful, even in the T cases because they always use the iterator which in turn needs a LBQ. They produce quite some amount of garbage in there.

I think optimizing this is quite important because a lot of users will, even finally at the end of their observable stream, block at some point to return the result into a servlet or whatever.

I set out to fix that as as a start with single() and it seems to pan out quite nicely. I want to modify all of the T getter methods appropriately and do some refactoring, but wanted to share some early results.

Before on single():

Iteration   1: 3949703.236 ops/s
Iteration   2: 3947313.447 ops/s
Iteration   3: 3955001.570 ops/s
Iteration   4: 3839775.088 ops/s
Iteration   5: 3916265.155 ops/s

After:

Iteration   1: 13254605.691 ops/s
Iteration   2: 13115515.080 ops/s
Iteration   3: 13238426.756 ops/s
Iteration   4: 13165076.351 ops/s
Iteration   5: 13208966.944 ops/s

That's over 3x perf improvement, also we're getting rid of the LBQ in the iterator.

It basically reuses the code from forEach, so things can be refactored into helper methods later.

I'd like to get your thoughts on that @benjchristensen and others, if I don't hear back that I should stop going down that route I'll update this PR once it's done.
",2014-08-27 11:08:55,2014-08-27 17:10:04,https://api.github.com/repos/ReactiveX/RxJava/issues/1634,[],110,7,ReactiveX_RxJava_pull_1634.diff
ReactiveX/RxJava,Composite Exception - Circular Reference Handling,"The printStackTrace and getCause implementations have different approaches to handling circular references.
If on a JVM where printStackTrace is called directly, the full causal chain will always be printed. If on one such as Dalvik where getCause is invoked directly then it will cut the causal chain if it sees a duplicate.

See https://github.com/ReactiveX/RxJava/issues/1405
",2014-08-26 21:44:50,2014-08-27 15:53:05,https://api.github.com/repos/ReactiveX/RxJava/issues/1632,[],269,104,ReactiveX_RxJava_pull_1632.diff
ReactiveX/RxJava,Handle Fatal Exceptions,"They were being swallowed before this fix when doOn\* operators were used.
",2014-08-26 16:33:05,2014-08-26 16:46:18,https://api.github.com/repos/ReactiveX/RxJava/issues/1631,[],38,3,ReactiveX_RxJava_pull_1631.diff
ReactiveX/RxJava,Reverting to the work immutable CompositeException but add the option to...,"Rolling back to the immutable version of `CompositeException` but always create them with the `RxJavaErrorHandler` plugin so that other environments can override the default.

For #1405 
",2014-08-25 18:24:35,2014-08-27 15:54:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1629,[],187,150,ReactiveX_RxJava_pull_1629.diff
ReactiveX/RxJava,Lock-Free-IndexRingBuffer,"Distilled from the changes, removed need for ""synchronized"" keyword on several methods by changing the IndexSection to a rough version of a lock-free stack.  Before and after benchmarks on my system show an improvement on all tests, more so on the pure Add tests (not sure this is a likely real world test?).
",2014-08-25 17:03:11,2015-01-29 14:40:28,https://api.github.com/repos/ReactiveX/RxJava/issues/1627,[],79,96,ReactiveX_RxJava_pull_1627.diff
ReactiveX/RxJava,Exploratory work,,2014-08-25 16:55:20,2014-08-25 16:58:14,https://api.github.com/repos/ReactiveX/RxJava/issues/1626,[],79,96,ReactiveX_RxJava_pull_1626.diff
ReactiveX/RxJava,RxScala: Mark superfluous from/empty methods with scheduler parameter as...,"... deprecated
",2014-08-24 18:38:06,2014-08-26 16:46:32,https://api.github.com/repos/ReactiveX/RxJava/issues/1625,[],4,0,ReactiveX_RxJava_pull_1625.diff
ReactiveX/RxJava,RxScala: Add more operators to match RxJava,"including `window(span, shift, unit, count, scheduler)`, `cache(Int)`, `groupBy[K, V](keySelector: T => K, valueSelector: T => V)`, `compose`, `onBackpressureBuffer`, `onBackpressureDrop`, `collect` and `using`.

/cc @headinthebox, @samuelgruetter
",2014-08-22 09:32:45,2014-08-26 16:46:56,https://api.github.com/repos/ReactiveX/RxJava/issues/1623,[],335,16,ReactiveX_RxJava_pull_1623.diff
ReactiveX/RxJava,Deprecation Removal,"Removing all deprecated methods and types for 1.0 https://github.com/ReactiveX/RxJava/issues/1001
",2014-08-21 21:42:02,2014-08-21 22:12:22,https://api.github.com/repos/ReactiveX/RxJava/issues/1621,[],116,1317,ReactiveX_RxJava_pull_1621.diff
ReactiveX/RxJava,Non blocking future to observable implementation.,,2014-08-20 06:10:18,2015-01-29 14:42:09,https://api.github.com/repos/ReactiveX/RxJava/issues/1618,[],245,90,ReactiveX_RxJava_pull_1618.diff
ReactiveX/RxJava,Non blocking future,,2014-08-20 05:17:07,2014-08-20 05:32:38,https://api.github.com/repos/ReactiveX/RxJava/issues/1617,[],241,92,ReactiveX_RxJava_pull_1617.diff
ReactiveX/RxJava,fix the usage of deprecated methods.,"A completely non-breaking change to switch to using the non-deprecated versions of:
- `using()`
- `from()` to `just()`
- `toBlockingObservable()` to `toBlocking()`
",2014-08-19 17:48:13,2014-08-19 18:23:28,https://api.github.com/repos/ReactiveX/RxJava/issues/1615,[],38,59,ReactiveX_RxJava_pull_1615.diff
ReactiveX/RxJava,Moving Netflix to ReactiveX,"I fixed the README by hand and then did a replace search for Netflix/RxJava to ReactiveX/RxJava to replace github wiki and issue occurences.

I did a eyeball sanity check so I hope things are good. My gut feeling says there are many more com.netflix occurences somewhere else, but it's a start to get it all back to ""normal"".
",2014-08-19 07:16:07,2014-08-19 17:00:52,https://api.github.com/repos/ReactiveX/RxJava/issues/1613,[],2107,2116,ReactiveX_RxJava_pull_1613.diff
ReactiveX/RxJava,Update README to reflect repository move.,"I figured updating the README makes sense now.
",2014-08-19 06:58:27,2014-08-19 07:16:14,https://api.github.com/repos/ReactiveX/RxJava/issues/1612,[],24,33,ReactiveX_RxJava_pull_1612.diff
ReactiveX/RxJava,Deprecate Superfluous Methods with Scheduler Overload,"These should just use subscribeOn if scheduling is wanted.

As per https://github.com/Netflix/RxJava/issues/1580
",2014-08-19 03:30:47,2014-08-19 03:30:51,https://api.github.com/repos/ReactiveX/RxJava/issues/1611,[],14,0,ReactiveX_RxJava_pull_1611.diff
ReactiveX/RxJava,Deprecate Multicast without Factory,"This method is nuanced and generally causes broken behavior if the Observable is subscribed to more than once.
",2014-08-19 03:25:14,2014-08-19 03:31:00,https://api.github.com/repos/ReactiveX/RxJava/issues/1610,[],18,6,ReactiveX_RxJava_pull_1610.diff
ReactiveX/RxJava,RxScala: Add backpressure support,"As per #1603.

/cc @headinthebox, @samuelgruetter
",2014-08-19 02:14:04,2014-08-19 03:14:20,https://api.github.com/repos/ReactiveX/RxJava/issues/1609,[],126,4,ReactiveX_RxJava_pull_1609.diff
ReactiveX/RxJava,Add missing window with time overload,"`Observable.window` is missing an overload, the one overload to rule them all (couldn't resist). 

The missing overload is below and corresponds to the ability to customize every parameter associated with the window with time functionality.

`public final Observable<Observable<T>> window(long timespan, long timeshift, TimeUnit unit, int count, Scheduler scheduler)`
",2014-08-18 22:53:21,2014-08-19 03:08:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1608,[],37,3,ReactiveX_RxJava_pull_1608.diff
ReactiveX/RxJava,Added a merge instance method,"The use of this operator presumes that the developer knows that the type of the input Observable is an `Observable<Observable<T>>` (similar to `Observable<T>.dematerialize()`).
",2014-08-18 17:44:37,2014-08-19 03:52:30,https://api.github.com/repos/ReactiveX/RxJava/issues/1606,[],22,0,ReactiveX_RxJava_pull_1606.diff
ReactiveX/RxJava,RxScala: Update signatures of retryWhen/repeatWhen to match RxJava,,2014-08-18 16:23:43,2014-08-18 16:33:54,https://api.github.com/repos/ReactiveX/RxJava/issues/1605,[],10,10,ReactiveX_RxJava_pull_1605.diff
ReactiveX/RxJava,Make retryWhen the same with the Scheduler as the retryWhen without the Scheduler,"came up in #1580
",2014-08-18 05:09:07,2014-08-18 16:04:31,https://api.github.com/repos/ReactiveX/RxJava/issues/1602,[],3,3,ReactiveX_RxJava_pull_1602.diff
ReactiveX/RxJava,"RxScala: Change ""multicast"" to be consistent with RxJava","Since RxJava adds `ConnectableObservable<R> multicast(Func0<? extends Subject<? super T, ? extends R>> subjectFactory)`,  we can change `def multicast[R >: T](subject: rx.lang.scala.Subject[R])` to `def multicast[R >: T](subject: => rx.lang.scala.Subject[R])` in RxScala.

/cc @headinthebox, @samuelgruetter
/cc @benjchristensen considering this is a breaking change, please merge it before releasing 0.20 if possible.
",2014-08-17 15:55:08,2014-08-18 17:17:10,https://api.github.com/repos/ReactiveX/RxJava/issues/1601,[],7,4,ReactiveX_RxJava_pull_1601.diff
ReactiveX/RxJava,RxScala: JavaDoc fixes to not use code or link,,2014-08-17 00:58:45,2014-08-18 16:06:13,https://api.github.com/repos/ReactiveX/RxJava/issues/1600,[],50,41,ReactiveX_RxJava_pull_1600.diff
ReactiveX/RxJava,reuse existing methods,"This is a little cleanup of methods in Observable.java that could be reusing existing methods.
",2014-08-16 22:26:41,2014-08-18 16:07:01,https://api.github.com/repos/ReactiveX/RxJava/issues/1599,[],16,16,ReactiveX_RxJava_pull_1599.diff
ReactiveX/RxJava,RxScala: Add mapping to RxJava doOnUnsubscribe,,2014-08-15 22:05:09,2014-08-18 16:06:27,https://api.github.com/repos/ReactiveX/RxJava/issues/1598,[],64,0,ReactiveX_RxJava_pull_1598.diff
ReactiveX/RxJava,reactivex.io: RxScala getting started examples,"This PR adds a new examples folder called `reactivex` to RxScala. The idea is to embed these examples directly from the repo in the reactivex.io website.

Contains (runnable) Scala versions of the examples used in [how to use](https://github.com/Netflix/RxJava/wiki/How-To-Use-RxJava). 
",2014-08-15 20:24:56,2014-08-18 16:07:57,https://api.github.com/repos/ReactiveX/RxJava/issues/1597,[],175,0,ReactiveX_RxJava_pull_1597.diff
ReactiveX/RxJava,doOnSubscribe,,2014-08-15 17:09:17,2014-08-15 19:24:47,https://api.github.com/repos/ReactiveX/RxJava/issues/1593,[],353,141,ReactiveX_RxJava_pull_1593.diff
ReactiveX/RxJava,Decouple Dispose Function for Using,"As per discussion at https://github.com/Netflix/RxJava/issues/1466
",2014-08-15 16:32:57,2014-08-19 03:26:21,https://api.github.com/repos/ReactiveX/RxJava/issues/1592,[],92,29,ReactiveX_RxJava_pull_1592.diff
ReactiveX/RxJava,Added doOnSubscribe() to Observable,"We often need to be notified when an Observable is unsubscribed, for cleaning up internal states, logging, metrics gathering, and etc. With this added method, users can save the effort of writing the similar boilerplate to register a listener for un-subscription events.
",2014-08-15 01:44:41,2014-08-15 16:26:42,https://api.github.com/repos/ReactiveX/RxJava/issues/1589,[],185,0,ReactiveX_RxJava_pull_1589.diff
ReactiveX/RxJava,Added doOnUnsubscribed() to Observable,"We often need to be notified when an Observable is unsubscribed, for cleaning up internal states, logging, metrics gathering, and etc. With this added method, users can save the effort of writing the similar boilerplate to register a listener for un-subscription events.  
",2014-08-15 00:53:15,2014-08-15 01:19:47,https://api.github.com/repos/ReactiveX/RxJava/issues/1588,[],184,0,ReactiveX_RxJava_pull_1588.diff
ReactiveX/RxJava,RxScala: Switch mapped RxJava methods to non-deprecated versions,"- Mark onErrorFlatMap/from(Iterable, Scheduler) as deprecated, since the RxJava versions will go away
",2014-08-14 22:57:46,2014-08-14 23:00:29,https://api.github.com/repos/ReactiveX/RxJava/issues/1587,[],8,6,ReactiveX_RxJava_pull_1587.diff
ReactiveX/RxJava,RxScala: Observable.items(T*) -> Observable.just(T*),,2014-08-14 22:44:11,2014-08-14 23:00:47,https://api.github.com/repos/ReactiveX/RxJava/issues/1586,[],156,135,ReactiveX_RxJava_pull_1586.diff
ReactiveX/RxJava,Add ViewActions utilities for Android,,2014-08-14 20:22:43,2014-08-19 03:52:30,https://api.github.com/repos/ReactiveX/RxJava/issues/1584,[],695,0,ReactiveX_RxJava_pull_1584.diff
ReactiveX/RxJava,Redo/Repeat Backpressure,"Fix backpressure and memory leaks

This now works:

``` java
    public static void main(String[] args) {
        Observable<Integer> o1 = Observable.from(1, 1).concatWith(Observable.just(-1).repeat());
        Observable<Integer> o2 = Observable.from(2, 2, 2, 2);
        Observable.zip(o1, o2, (a, b) -> a + b).forEach(System.out::println);
    }
```
",2014-08-14 19:48:48,2014-08-14 19:57:13,https://api.github.com/repos/ReactiveX/RxJava/issues/1583,[],67,32,ReactiveX_RxJava_pull_1583.diff
ReactiveX/RxJava,Deprecate GroupedObservable.from,"It was a bad solution. Use Observable.groupBy with element selector instead

See https://github.com/Netflix/RxJava/issues/1579
",2014-08-14 18:59:24,2014-08-14 18:59:28,https://api.github.com/repos/ReactiveX/RxJava/issues/1582,[],2,0,ReactiveX_RxJava_pull_1582.diff
ReactiveX/RxJava,zip(Iterable) -> zipWith(Iterable),"As per https://github.com/Netflix/RxJava/issues/1578
",2014-08-14 17:55:20,2014-08-14 18:28:02,https://api.github.com/repos/ReactiveX/RxJava/issues/1581,[],33,0,ReactiveX_RxJava_pull_1581.diff
ReactiveX/RxJava,Fix the compose covariance,"Changed the return type of `compose` from `Observable<? extends R>` to `Observable<R>`. The reason is that if returning `Observable<? extends R>`, the following codes won't work in Java:

``` Java
        Observable<String> o1 = Observable.from(""s1"");
        Observable<String> o2 = o1.compose(new Transformer<String, String>() {
            @Override
            public Observable<? extends String> call(Observable<? extends String> t1) {
                return Observable.from(""s2"");
            }
        });
```

we have to write:

``` Java
        Observable<String> o1 = Observable.from(""s1"");
        Observable<? extends String> o2 = o1.compose(new Transformer<String, String>() {
            @Override
            public Observable<? extends String> call(Observable<? extends String> t1) {
                return Observable.from(""s2"");
            }
        });
```

Because we cannot assign `Observable<? extends R>` to a `Observable<R>` variable, we should avoid to return `Observable<? extends R>`, otherwise the API will be inconvenient.
",2014-08-14 11:17:49,2014-08-14 16:52:14,https://api.github.com/repos/ReactiveX/RxJava/issues/1577,[],7,7,ReactiveX_RxJava_pull_1577.diff
ReactiveX/RxJava,from(T) -> just(T),"Deprecate the from(T) methods in favor of items(T)

As per discussion in https://github.com/Netflix/RxJava/issues/1563.
",2014-08-14 05:26:52,2014-08-14 21:41:10,https://api.github.com/repos/ReactiveX/RxJava/issues/1576,[],698,408,ReactiveX_RxJava_pull_1576.diff
ReactiveX/RxJava,combineLatest with backpressure,"Implementation updated to support reactive pull: https://github.com/Netflix/RxJava/issues/1476
",2014-08-14 05:11:44,2014-08-14 05:29:23,https://api.github.com/repos/ReactiveX/RxJava/issues/1575,[],332,228,ReactiveX_RxJava_pull_1575.diff
ReactiveX/RxJava,Backpressure: parallel,"Fixes https://github.com/Netflix/RxJava/issues/1485
",2014-08-12 19:27:28,2014-08-12 19:36:38,https://api.github.com/repos/ReactiveX/RxJava/issues/1573,[],79,67,ReactiveX_RxJava_pull_1573.diff
ReactiveX/RxJava,Remove Timeout in Blocking Iterator,"This was a temporary timeout to track down bugs.
",2014-08-12 18:54:33,2014-08-12 18:54:36,https://api.github.com/repos/ReactiveX/RxJava/issues/1572,[],1,12,ReactiveX_RxJava_pull_1572.diff
ReactiveX/RxJava,"Fix for mapcat, issue #1556","Corrected mapcat to actually concat its results rather than merging.
Added warning to docstring thta this might not be ideal.

Added flatmap to cover map+merge case.
",2014-08-12 06:01:21,2014-08-12 15:52:09,https://api.github.com/repos/ReactiveX/RxJava/issues/1570,[],70,3,ReactiveX_RxJava_pull_1570.diff
ReactiveX/RxJava,Compose/Transform Covariance,"Failing test while exploring generic variance for https://github.com/Netflix/RxJava/issues/1416

Code like this makes these generics work:

``` java
    @Test
    public void testCovarianceOfCompose() {
        Observable<HorrorMovie> movie = Observable.<HorrorMovie> from(new HorrorMovie());
        movie.compose(new Transformer<Movie, Movie>() {

            @Override
            public Observable<? extends Movie> call(Observable<? super Movie> t1) {
                return Observable.from(new Movie());
            }

        });
    }

    @Test
    public void testCovarianceOfCompose2() {
        Observable<Movie> movie = Observable.<Movie> from(new HorrorMovie());
        movie.compose(new Transformer<Movie, Movie>() {

            @Override
            public Observable<? extends Movie> call(Observable<? super Movie> t1) {
                return Observable.from(new HorrorMovie());
            }

        });
    }
```

however, I couldn't get the `compose`/`Transformer` types to correctly work.

Anyone else want to help figure out generics for this?

See https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L195
",2014-08-12 05:21:52,2014-08-14 05:54:09,https://api.github.com/repos/ReactiveX/RxJava/issues/1569,[],31,4,ReactiveX_RxJava_pull_1569.diff
ReactiveX/RxJava,Compose/Transformer,"See https://github.com/Netflix/RxJava/issues/1416 for discussion that led to this.

This does not have co/contra-variance which needs to be figured out.
",2014-08-12 05:20:13,2014-08-12 05:20:20,https://api.github.com/repos/ReactiveX/RxJava/issues/1568,[],50,1,ReactiveX_RxJava_pull_1568.diff
ReactiveX/RxJava,groupBy with element selector,"Fixes https://github.com/Netflix/RxJava/issues/1554
",2014-08-12 03:49:40,2014-08-12 04:11:12,https://api.github.com/repos/ReactiveX/RxJava/issues/1567,[],96,14,ReactiveX_RxJava_pull_1567.diff
ReactiveX/RxJava,Fixing Kotlin Defer,"Broke this with https://github.com/Netflix/RxJava/pull/1561
",2014-08-11 23:36:03,2014-08-12 00:33:20,https://api.github.com/repos/ReactiveX/RxJava/issues/1565,[],1,1,ReactiveX_RxJava_pull_1565.diff
ReactiveX/RxJava,RxScala: Fix errors in Completeness.scala and also improve it,"- Fixed some errors in CompletenessTest.scala and improve it.
- Fixed the error of `defer` for #1561

/cc @headinthebox, @samuelgruetter
",2014-08-11 05:12:48,2014-08-11 22:07:00,https://api.github.com/repos/ReactiveX/RxJava/issues/1564,[],19,15,ReactiveX_RxJava_pull_1564.diff
ReactiveX/RxJava,TakeLastTimed with backpressure support,"Implemented #1488. I moved `OperatorTakeLast.QueueProducer` to `TakeLastQueueProducer` to reuse it.
",2014-08-09 16:08:51,2014-08-11 22:09:59,https://api.github.com/repos/ReactiveX/RxJava/issues/1562,[],126,124,ReactiveX_RxJava_pull_1562.diff
ReactiveX/RxJava,Remove Variance on Defer,"See https://github.com/Netflix/RxJava/issues/1157 for painful background.
",2014-08-08 21:39:01,2014-08-08 22:01:18,https://api.github.com/repos/ReactiveX/RxJava/issues/1561,[],1,1,ReactiveX_RxJava_pull_1561.diff
ReactiveX/RxJava,flatMap overloads,"- migrate mapPair to use actual merge instead of reimplementing it
- deprecate mergeMap

Done during API review with @headinthebox
",2014-08-08 19:32:51,2014-08-08 19:32:55,https://api.github.com/repos/ReactiveX/RxJava/issues/1560,[],220,155,ReactiveX_RxJava_pull_1560.diff
ReactiveX/RxJava,More consistent hooks for scheduler plugins.  This is a rework of #1514.,"- Deprecated RxJavaDefaultSchedulers and RxJavaDefaultSchedulersDefault (I think these names are confusing)
- Added RxJavaSchedulersHook
- Ability to override entire schedulers from scratch
- Ability to decorate Action0 before submission to Scheduler

The main change from #1514 is the decoration of Action0 instead of Runnable.  Action0 is an improvement as all Schedulers must handle these, whereas not all Schedulers handle Runnables.
",2014-08-08 19:07:29,2014-08-11 21:18:44,https://api.github.com/repos/ReactiveX/RxJava/issues/1559,[],138,1,ReactiveX_RxJava_pull_1559.diff
ReactiveX/RxJava,mergeMap generics,"Fixes issue #1550
",2014-08-08 18:57:27,2014-08-08 19:02:44,https://api.github.com/repos/ReactiveX/RxJava/issues/1558,[],83,152,ReactiveX_RxJava_pull_1558.diff
ReactiveX/RxJava,SwitchOnNext with backpressure support,"#1482
",2014-08-08 09:27:45,2014-08-11 22:12:47,https://api.github.com/repos/ReactiveX/RxJava/issues/1557,[],352,168,ReactiveX_RxJava_pull_1557.diff
ReactiveX/RxJava,RxScala: Add retryWhen/repeatWhen methods,"- Add example usage of retryWhen/repeatWhen to RxScalaDemo
",2014-08-06 17:03:53,2014-08-08 04:53:05,https://api.github.com/repos/ReactiveX/RxJava/issues/1555,[],173,0,ReactiveX_RxJava_pull_1555.diff
ReactiveX/RxJava,Fixing a bug and a potential for other concurrency issues.,"Fix for #1542.

the root cause of the issue was this line of code where it was casting the notification list object to T.

```
        private T getRecentValue() {
            return (T)value;
        }
```

While I was in there I noticed that is was a race condition between calling `hasNext()` and `next()` on the `Iterator`.
",2014-08-05 18:12:18,2014-08-08 04:54:21,https://api.github.com/repos/ReactiveX/RxJava/issues/1552,[],48,45,ReactiveX_RxJava_pull_1552.diff
ReactiveX/RxJava,Adding backpressure to OnSubscribeRedo,,2014-08-04 19:23:48,2014-08-11 22:04:50,https://api.github.com/repos/ReactiveX/RxJava/issues/1548,[],52,11,ReactiveX_RxJava_pull_1548.diff
ReactiveX/RxJava,Make Android ViewObservable.input observe TextView instead of String,"The previous version required `ViewObservable.input(TextView, boolean)` to emit just `String`s of the updated text, but not `CharSequence`s, which is the declared implementation of `TextView`'s `mText`. This still allows for similar functionality as before via: 

``` java
ViewObservable.input(myTextView, false).map((textView) -> textView.getText().toString())
```

It is also flexible like `ViewObservable.clicks` in that it returns a reference to the `View`, which should make it more flexible for using it with other reactive methods.

I held off from doing the same to `ViewObservable.input(CompoundButton, boolean)` but could do so if you think it would be valuable/more consistent.

This would be a breaking change. In order to make it not a breaking change, this method could be renamed and the initial method could `map` like the above snippet. Let me know if you think this is important and I'd be happy to make this change.
",2014-08-04 05:01:25,2014-08-14 21:44:36,https://api.github.com/repos/ReactiveX/RxJava/issues/1545,[],330,0,ReactiveX_RxJava_pull_1545.diff
ReactiveX/RxJava,BufferWithSize backpressure,"Added backpressure handling to `OperatorBufferWithSize`. 

This was required because requesting 1 item (a list) from an `OperatorBufferWithSize`  subscriber translates to requesting `count + (n-1) * skip` items from upstream.

Includes unit tests that failed with 0.20.0-RC4.
",2014-08-01 03:54:10,2014-08-01 04:26:55,https://api.github.com/repos/ReactiveX/RxJava/issues/1540,[],75,0,ReactiveX_RxJava_pull_1540.diff
ReactiveX/RxJava,recursive scheduling in RxScala,"This PR adds a `scheduleRec` method to the `Scheduler.Worker` trait to make recursive scheduling more convenient in Scala. This issue is raised in #1348.
",2014-07-31 12:03:56,2014-08-08 20:52:27,https://api.github.com/repos/ReactiveX/RxJava/issues/1537,[],63,0,ReactiveX_RxJava_pull_1537.diff
ReactiveX/RxJava,Concat Backpressure,"Route backpressure through the inner subscribers.
Fixes https://github.com/Netflix/RxJava/issues/1480
",2014-07-30 06:52:13,2014-07-30 16:33:07,https://api.github.com/repos/ReactiveX/RxJava/issues/1534,[],149,37,ReactiveX_RxJava_pull_1534.diff
ReactiveX/RxJava,Amb + Backpressure,"Building on top of https://github.com/Netflix/RxJava/pull/1516
",2014-07-30 04:41:21,2014-07-30 16:31:18,https://api.github.com/repos/ReactiveX/RxJava/issues/1533,['Bug'],154,29,ReactiveX_RxJava_pull_1533.diff
ReactiveX/RxJava,Added unit tests of backpressure to OperatorReduce,"Replaced PR #1527
",2014-07-29 16:39:50,2014-07-29 16:49:21,https://api.github.com/repos/ReactiveX/RxJava/issues/1532,[],18,0,ReactiveX_RxJava_pull_1532.diff
ReactiveX/RxJava,Fix the unbounded check for merge,,2014-07-29 13:45:42,2014-07-29 16:19:26,https://api.github.com/repos/ReactiveX/RxJava/issues/1530,[],4,1,ReactiveX_RxJava_pull_1530.diff
ReactiveX/RxJava,"Make ""single""  support backpressure (Fix #1527)","Fix #1527
",2014-07-29 13:21:14,2014-07-29 14:11:45,https://api.github.com/repos/ReactiveX/RxJava/issues/1529,[],55,3,ReactiveX_RxJava_pull_1529.diff
ReactiveX/RxJava,Add operators to create Observables from BroadcastReceiver (rebased),"Rebase https://github.com/Netflix/RxJava/pull/1449 on the top of https://github.com/Netflix/RxJava/pull/1524

Add test for OperatorBroadcastRegister
",2014-07-29 10:41:45,2014-07-29 16:30:37,https://api.github.com/repos/ReactiveX/RxJava/issues/1528,[],375,9,ReactiveX_RxJava_pull_1528.diff
ReactiveX/RxJava,"Failing unit test for reduce, showing it does not implement backpressure correctly",,2014-07-29 04:47:02,2014-07-29 16:40:10,https://api.github.com/repos/ReactiveX/RxJava/issues/1527,[],21,0,ReactiveX_RxJava_pull_1527.diff
ReactiveX/RxJava,Restore use of SpmcArrayQueue in RxRingBuffer,"- Modification of SpmcArrayQueue with fix from https://github.com/JCTools/JCTools/issues/21
  - I expect updates to this code over time but wanted to move forward with a working solution for now
- Restore RxRingBuffer to use SpmcArrayQueue
  - this reduces object allocation significantly and increases performance in some use cases
### Performance Diff
#### 0.20.0-RC3

```
../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 2 .*rx.internal.RxRingBufferPerf.*'

Benchmark                                            Mode   Samples        Score  Score error    Units
r.i.RxRingBufferPerf.spmcCreateUseAndDestroy1       thrpt         5 33224158.580   399867.898    ops/s
r.i.RxRingBufferPerf.spmcCreateUseAndDestroy1000    thrpt         5    73346.934      853.989    ops/s
r.i.RxRingBufferPerf.spmcRingBufferAddRemove1       thrpt         5 22034846.226   579563.777    ops/s
r.i.RxRingBufferPerf.spmcRingBufferAddRemove1000    thrpt         5    21612.517      567.086    ops/s
r.i.RxRingBufferPerf.spscCreateUseAndDestroy1       thrpt         5 32277699.473  2481022.929    ops/s
r.i.RxRingBufferPerf.spscCreateUseAndDestroy1000    thrpt         5    72782.657     3836.229    ops/s
r.i.RxRingBufferPerf.spscRingBufferAddRemove1       thrpt         5 21625427.399   555584.413    ops/s
r.i.RxRingBufferPerf.spscRingBufferAddRemove1000    thrpt         5    21588.532      875.871    ops/s
```

```
../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 2 .*rx.operators.OperatorMergePerf.*'

Benchmark                                          (size)   Mode   Samples        Score  Score error    Units
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5066495.356    73296.083    ops/s
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    55094.237     1067.519    ops/s
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       57.981        1.324    ops/s
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5    97273.839     9582.028    ops/s
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        4.754        0.115    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4384357.616   302930.385    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   278124.421    36626.222    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    35179.120     1059.293    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5383548.483   125915.654    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       54.551        3.245    ops/s
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    66546.808    30474.772    ops/s
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     2828.244      103.470    ops/s
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5030721.519   181734.814    ops/s
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    24489.183      759.520    ops/s
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       30.101        0.802    ops/s
```

Memory allocation capture with Java Flight Recorder while executing:

```
../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 20 .*rx.operators.OperatorMergePerf.mergeNAsyncStreamsOfN.*'
```

![object-allocation-with-linkedlist](https://cloud.githubusercontent.com/assets/813492/3727745/35c44dca-16a1-11e4-89c1-7a1c2475bcbb.png)
#### with JCTools impl

```
../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 2 .*rx.internal.RxRingBufferPerf.*'

Benchmark                                            Mode   Samples        Score  Score error    Units
r.i.RxRingBufferPerf.spmcCreateUseAndDestroy1       thrpt         5 27028267.871  2547216.752    ops/s
r.i.RxRingBufferPerf.spmcCreateUseAndDestroy1000    thrpt         5    78238.446     2539.165    ops/s
r.i.RxRingBufferPerf.spmcRingBufferAddRemove1       thrpt         5 43396574.546   918454.062    ops/s
r.i.RxRingBufferPerf.spmcRingBufferAddRemove1000    thrpt         5    64074.506      531.873    ops/s
r.i.RxRingBufferPerf.spscCreateUseAndDestroy1       thrpt         5 27163028.506   506868.149    ops/s
r.i.RxRingBufferPerf.spscCreateUseAndDestroy1000    thrpt         5    77472.474     2875.597    ops/s
r.i.RxRingBufferPerf.spscRingBufferAddRemove1       thrpt         5 43309504.983   337590.502    ops/s
r.i.RxRingBufferPerf.spscRingBufferAddRemove1000    thrpt         5    64140.916     1292.265    ops/s
```

```
../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 2 .*rx.operators.OperatorMergePerf.*'

Benchmark                                          (size)   Mode   Samples        Score  Score error    Units
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5146417.279   168011.480    ops/s
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    56640.224      789.709    ops/s
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       60.610        1.022    ops/s
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5    97759.963     1897.592    ops/s
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        5.937        0.404    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4511685.053   136414.240    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   285644.030     9325.626    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    32789.901     1143.208    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  5415231.898   107538.428    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       55.918        0.660    ops/s
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    74341.892     3274.847    ops/s
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     4138.087      329.935    ops/s
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5026384.994   242183.595    ops/s
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    24700.473      334.516    ops/s
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       30.458        0.603    ops/s
```

Memory allocation capture with Java Flight Recorder while executing:

```
../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 20 .*rx.operators.OperatorMergePerf.mergeNAsyncStreamsOfN.*'
```

![object-allocation-with-arrayqueue](https://cloud.githubusercontent.com/assets/813492/3727746/38de2d8c-16a1-11e4-93cd-32dba4497a5f.png)
",2014-07-28 21:51:05,2014-07-29 00:41:30,https://api.github.com/repos/ReactiveX/RxJava/issues/1526,[],32,16,ReactiveX_RxJava_pull_1526.diff
ReactiveX/RxJava,"Bump to Robolectric 2.3, make samples build under Studio 0.8.+","This should help get https://github.com/Netflix/RxJava/pull/1449 off the ground
",2014-07-27 19:20:25,2014-07-29 16:30:39,https://api.github.com/repos/ReactiveX/RxJava/issues/1524,[],6,4,ReactiveX_RxJava_pull_1524.diff
ReactiveX/RxJava,Fix issue #1522,"`TakeLast` should ignore other `request`s if it's requested with `Long.MAX_VALUE`. #1522
",2014-07-26 16:28:20,2014-07-29 16:27:26,https://api.github.com/repos/ReactiveX/RxJava/issues/1523,[],203,18,ReactiveX_RxJava_pull_1523.diff
ReactiveX/RxJava,Fix toIterator Exception Handling,"Fixes https://github.com/Netflix/RxJava/issues/1450
",2014-07-25 21:10:20,2014-07-25 21:10:22,https://api.github.com/repos/ReactiveX/RxJava/issues/1521,[],15,1,ReactiveX_RxJava_pull_1521.diff
ReactiveX/RxJava,Fix non-deterministic test,"Fixes https://github.com/Netflix/RxJava/issues/1429
",2014-07-25 20:39:48,2014-07-25 20:39:51,https://api.github.com/repos/ReactiveX/RxJava/issues/1520,[],21,30,ReactiveX_RxJava_pull_1520.diff
ReactiveX/RxJava,Remove unused param comments,"Fixed https://github.com/Netflix/RxJava/issues/1426
",2014-07-25 20:32:14,2014-07-25 20:32:16,https://api.github.com/repos/ReactiveX/RxJava/issues/1519,[],0,16,ReactiveX_RxJava_pull_1519.diff
ReactiveX/RxJava,Fix typos in javadoc comments.,"""Recieve"" -> ""Receive""
",2014-07-25 20:27:00,2014-07-25 21:12:18,https://api.github.com/repos/ReactiveX/RxJava/issues/1518,[],4,4,ReactiveX_RxJava_pull_1518.diff
ReactiveX/RxJava,Amb with backpressure support,"For #1475
",2014-07-25 12:39:01,2014-07-30 16:32:47,https://api.github.com/repos/ReactiveX/RxJava/issues/1516,['Bug'],75,1,ReactiveX_RxJava_pull_1516.diff
ReactiveX/RxJava,Support Subject Factory with Multicast,"This is a proposed change to allow using a `Subject` factory with `multicast` and for methods such as `publish()` and `replay()` to use the factory so that each time `ConnectableObservable.connect()` is invoked, a new `Subject` is created and used. Otherwise, an `Observable` sequence can not be reused.
#### Use Case

``` java
        final AtomicInteger count = new AtomicInteger();
        Observable<Integer> subject1 = Observable.just(10);
        Observable<Integer> subject2 = Observable.just(20);
        Observable<Integer> combined = Observable.combineLatest(subject1, subject2, (fst, snd) -> {
            int i = count.incrementAndGet();
            System.out.println((fst + i) + "" + "" + (snd + i));
            return fst + snd;
        }).publish().refCount();

        combined.subscribe(
                System.out::println,
                t -> t.printStackTrace(),
                () -> System.out.println(""Completed""));

        combined.subscribe(
                System.out::println,
                t -> t.printStackTrace(),
                () -> System.out.println(""Completed""));
```

Output without these changes:

```
11 + 21
30
Completed
Completed
```

Output with changes:

```
11 + 21
30
Completed
12 + 22
30
Completed
```
#### Test Case

``` java
    @Test
    public void testConnectDisconnectConnectAndSubjectState() {
        Observable<Integer> o1 = Observable.just(10);
        Observable<Integer> o2 = Observable.just(20);
        Observable<Integer> combined = Observable.combineLatest(o1, o2, new Func2<Integer, Integer, Integer>() {

            @Override
            public Integer call(Integer t1, Integer t2) {
                return t1 + t2;
            }

        }).publish().refCount();

        TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>();
        TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>();

        combined.subscribe(ts1);
        combined.subscribe(ts2);

        ts1.assertTerminalEvent();
        ts1.assertNoErrors();
        ts1.assertReceivedOnNext(Arrays.asList(30));

        ts2.assertTerminalEvent();
        ts2.assertNoErrors();
        ts2.assertReceivedOnNext(Arrays.asList(30));
    }
```
",2014-07-25 00:04:55,2014-07-28 16:10:19,https://api.github.com/repos/ReactiveX/RxJava/issues/1515,[],235,54,ReactiveX_RxJava_pull_1515.diff
ReactiveX/RxJava,Provide a facility for decorating a Runnable before submission to ExecutorService via Scheduler,"For Issue #1279

This provides another method of hooking into the Scheduler process.  Rather than forcing the plugin writer to write all 3 Schedulers (computation/io/newThread) from scratch, it allows the plugin writer to have access to the Runnable before it gets submitted to the ExecutorService.

In my implementation which needs to decorate Runnables, this reduced the effort from a copy-n-paste of the entire Scheduler codebase to a 1-liner.

Happy to debate names or any other aspect of this proposal
",2014-07-24 23:06:53,2014-08-11 22:13:54,https://api.github.com/repos/ReactiveX/RxJava/issues/1514,[],105,3,ReactiveX_RxJava_pull_1514.diff
ReactiveX/RxJava,Revert to copying list in toList,"It is a breaking change to existing code to make it immutable, so reverting back to copying.
",2014-07-24 20:10:57,2014-07-24 21:02:36,https://api.github.com/repos/ReactiveX/RxJava/issues/1513,[],16,1,ReactiveX_RxJava_pull_1513.diff
ReactiveX/RxJava,BufferWithSize with Backpressure Support,"For #1479
",2014-07-24 13:54:40,2014-08-11 22:19:11,https://api.github.com/repos/ReactiveX/RxJava/issues/1507,['Bug'],275,0,ReactiveX_RxJava_pull_1507.diff
ReactiveX/RxJava,Eliminate duplication of List in toList,"Fixes https://github.com/Netflix/RxJava/issues/1218
",2014-07-24 07:17:22,2014-07-24 07:54:46,https://api.github.com/repos/ReactiveX/RxJava/issues/1504,[],7,2,ReactiveX_RxJava_pull_1504.diff
ReactiveX/RxJava,blocking synchronous next,"Fixes https://github.com/Netflix/RxJava/issues/624
",2014-07-24 06:18:10,2014-07-24 07:54:59,https://api.github.com/repos/ReactiveX/RxJava/issues/1501,[],28,31,ReactiveX_RxJava_pull_1501.diff
ReactiveX/RxJava,retrytest.iterativeBackoff,"Unable to replicate failure of this test ... but adding assertNoErrors so we can see an exception if it happens again.
",2014-07-23 23:25:02,2014-07-23 23:25:04,https://api.github.com/repos/ReactiveX/RxJava/issues/1499,[],1,0,ReactiveX_RxJava_pull_1499.diff
ReactiveX/RxJava,non-deterministic testUserSubscriberUsingRequestAsync,"fix non-deterministic failures of BackpressureTests.testUserSubscriberUsingRequestAsync

I was able to replicate the occasional failure by putting it in a tight loop. With these changes it no longer fails.
",2014-07-23 23:08:37,2014-07-23 23:08:42,https://api.github.com/repos/ReactiveX/RxJava/issues/1498,[],10,4,ReactiveX_RxJava_pull_1498.diff
ReactiveX/RxJava,spsc ring buffer concurrency test,,2014-07-23 22:55:08,2014-07-23 22:56:30,https://api.github.com/repos/ReactiveX/RxJava/issues/1497,[],120,0,ReactiveX_RxJava_pull_1497.diff
ReactiveX/RxJava,Change RxRingBuffer Queue Usage,"There are non-determinisitic failures in the `offer` behavior of the JCTools code that I don't understand yet, so reverting to `SynchronizedQueue` which does not show the problem. The performance hit is not huge, it's even better in some cases.

This should result in more object allocation though, so that needs to be tested (I'll do so along with Netflix production testing).
",2014-07-23 21:27:43,2014-07-23 21:28:04,https://api.github.com/repos/ReactiveX/RxJava/issues/1496,[],543,684,ReactiveX_RxJava_pull_1496.diff
ReactiveX/RxJava,Upgrade to Quasar 0.6.0,,2014-07-23 19:25:12,2014-07-23 21:28:23,https://api.github.com/repos/ReactiveX/RxJava/issues/1495,[],4,5,ReactiveX_RxJava_pull_1495.diff
ReactiveX/RxJava,zipWith,"Match the naming convention of `mergeWith`, `concatWith`, `ambWith` etc.
",2014-07-23 17:41:02,2014-07-23 17:41:22,https://api.github.com/repos/ReactiveX/RxJava/issues/1494,[],29,1,ReactiveX_RxJava_pull_1494.diff
ReactiveX/RxJava,Manual merge of retryWhen/repeatWhen,"Manual merge and rebase of https://github.com/Netflix/RxJava/pull/1470
",2014-07-23 17:24:28,2014-07-23 17:37:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1493,[],649,297,ReactiveX_RxJava_pull_1493.diff
ReactiveX/RxJava,Concat Outer Backpressure,"Fixed https://github.com/Netflix/RxJava/issues/1481
",2014-07-23 06:50:46,2014-07-23 06:50:50,https://api.github.com/repos/ReactiveX/RxJava/issues/1491,[],35,3,ReactiveX_RxJava_pull_1491.diff
ReactiveX/RxJava,non-deterministic timeouts on slow machines,,2014-07-23 06:31:57,2014-07-23 06:32:00,https://api.github.com/repos/ReactiveX/RxJava/issues/1490,[],4,4,ReactiveX_RxJava_pull_1490.diff
ReactiveX/RxJava,Backpressure Fixes and Docs,"Docs for operators that don't support backpressure, particularly all the temporal operators.

Fixes for several that needed to request(1) or request(Long.MAX_VALUE).
",2014-07-23 06:15:26,2014-07-23 06:15:30,https://api.github.com/repos/ReactiveX/RxJava/issues/1489,[],524,3,ReactiveX_RxJava_pull_1489.diff
ReactiveX/RxJava,Ignore backpressure for OperatorToObservableSortedList,,2014-07-22 21:24:10,2014-07-22 21:24:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1474,[],12,0,ReactiveX_RxJava_pull_1474.diff
ReactiveX/RxJava,OperatorAny needs to handle backpressure,,2014-07-22 20:44:40,2014-07-22 21:01:56,https://api.github.com/repos/ReactiveX/RxJava/issues/1473,[],20,1,ReactiveX_RxJava_pull_1473.diff
ReactiveX/RxJava,Add test of backpressure to OperatorAll,,2014-07-22 20:39:27,2014-07-22 20:46:07,https://api.github.com/repos/ReactiveX/RxJava/issues/1472,[],15,0,ReactiveX_RxJava_pull_1472.diff
ReactiveX/RxJava,OperatorAny needs to ignore backpressure,,2014-07-22 20:29:55,2014-07-22 20:44:53,https://api.github.com/repos/ReactiveX/RxJava/issues/1471,[],22,1,ReactiveX_RxJava_pull_1471.diff
ReactiveX/RxJava,retryWhen/repeatWhen,"Rebase and clean up of #1326 while Aaron is at LambdaJam.
",2014-07-22 18:59:13,2014-07-23 17:37:37,https://api.github.com/repos/ReactiveX/RxJava/issues/1470,[],669,337,ReactiveX_RxJava_pull_1470.diff
ReactiveX/RxJava,ToList operator needs to ignore backpressure,,2014-07-22 18:50:26,2014-07-22 19:13:50,https://api.github.com/repos/ReactiveX/RxJava/issues/1469,[],13,0,ReactiveX_RxJava_pull_1469.diff
ReactiveX/RxJava,RxScala: Update CompletenessTest.scala,"Cleaned up `CompletenessTest.scala`.

`onBackpressureBuffer` and `onBackpressureDrop` are missing in RxScala now. Wait until they are finalized in RxJava.

/cc @headinthebox, @samuelgruetter
",2014-07-22 10:35:11,2014-07-28 19:09:14,https://api.github.com/repos/ReactiveX/RxJava/issues/1468,[],22,30,ReactiveX_RxJava_pull_1468.diff
ReactiveX/RxJava,Javadocs for cache operator,,2014-07-22 05:27:43,2014-07-22 05:27:49,https://api.github.com/repos/ReactiveX/RxJava/issues/1467,[],22,5,ReactiveX_RxJava_pull_1467.diff
ReactiveX/RxJava,Merge Bug: Missing Emissions,"Notes and temporary fix using `synchronized` to achieve correctness until a proper solution can be found.

This code does not exhibit the issue when I do production testing. Without the two `synchronized` methods I get errors in prod that I've temporarily added to `BlockingOperatorToIterator` until this is fixed so it's visible.

```
/apps/tomcat/logs$ tail -f catalina.out |grep ""Timed out waiting for value""
Timed out waiting for value. File a bug at github.com/Netflix/RxJava
Timed out waiting for value. File a bug at github.com/Netflix/RxJava
Timed out waiting for value. File a bug at github.com/Netflix/RxJava
Timed out waiting for value. File a bug at github.com/Netflix/RxJava
Timed out waiting for value. File a bug at github.com/Netflix/RxJava
Timed out waiting for value. File a bug at github.com/Netflix/RxJava
Timed out waiting for value. File a bug at github.com/Netflix/RxJava
Timed out waiting for value. File a bug at github.com/Netflix/RxJava
Timed out waiting for value. File a bug at github.com/Netflix/RxJava
Timed out waiting for value. File a bug at github.com/Netflix/RxJava
Timed out waiting for value. File a bug at github.com/Netflix/RxJava
Timed out waiting for value. File a bug at github.com/Netflix/RxJava
Timed out waiting for value. File a bug at github.com/Netflix/RxJava
Timed out waiting for value. File a bug at github.com/Netflix/RxJava
Timed out waiting for value. File a bug at github.com/Netflix/RxJava
Timed out waiting for value. File a bug at github.com/Netflix/RxJava
Timed out waiting for value. File a bug at github.com/Netflix/RxJava
```
",2014-07-18 16:55:35,2014-07-18 17:02:17,https://api.github.com/repos/ReactiveX/RxJava/issues/1463,[],46,4,ReactiveX_RxJava_pull_1463.diff
ReactiveX/RxJava,Merge Perf Fix: Re-enable fast-path,"Fixes https://github.com/Netflix/RxJava/issues/1461
",2014-07-18 00:43:30,2014-07-18 00:43:40,https://api.github.com/repos/ReactiveX/RxJava/issues/1462,[],14,1,ReactiveX_RxJava_pull_1462.diff
ReactiveX/RxJava,Change Java future observable implementation from blocking to non blocking,,2014-07-17 22:46:00,2014-08-19 03:52:30,https://api.github.com/repos/ReactiveX/RxJava/issues/1460,['Enhancement'],241,92,ReactiveX_RxJava_pull_1460.diff
ReactiveX/RxJava,Remove Subscriber.onSetProducer,"This is a manual merge of https://github.com/Netflix/RxJava/pull/1456

Removes the awkward `Subscriber.onSetProducer` API and makes `Subscriber.request` protected so it can't easily be misused.
",2014-07-17 21:35:02,2014-07-17 21:35:06,https://api.github.com/repos/ReactiveX/RxJava/issues/1459,[],82,340,ReactiveX_RxJava_pull_1459.diff
ReactiveX/RxJava,Remove Pivot Operator,"as per https://github.com/Netflix/RxJava/issues/1402
",2014-07-17 21:17:04,2014-07-17 21:29:48,https://api.github.com/repos/ReactiveX/RxJava/issues/1458,[],0,969,ReactiveX_RxJava_pull_1458.diff
ReactiveX/RxJava,MergeDelayError & OnErrorFlatMap w/ Merge,,2014-07-17 21:05:36,2014-07-17 21:07:31,https://api.github.com/repos/ReactiveX/RxJava/issues/1457,[],148,149,ReactiveX_RxJava_pull_1457.diff
ReactiveX/RxJava,Removing onSetProducer from the API,,2014-07-17 20:20:06,2014-07-17 21:35:07,https://api.github.com/repos/ReactiveX/RxJava/issues/1456,[],77,339,ReactiveX_RxJava_pull_1456.diff
ReactiveX/RxJava,Fix issue #1451,"Add `done` to make sure calling `doOnEachObserver` obey the Rx contract.
",2014-07-17 02:03:11,2014-07-17 20:05:37,https://api.github.com/repos/ReactiveX/RxJava/issues/1454,[],86,4,ReactiveX_RxJava_pull_1454.diff
ReactiveX/RxJava,New test case for takeWhile that currently fails,"Created a test case to verify the failing case of takeWhile() followed by toList() as mentioned in <a href=""https://github.com/Netflix/RxJava/issues/1451"">Issue 1451</a>.
",2014-07-17 00:20:45,2014-07-17 20:05:45,https://api.github.com/repos/ReactiveX/RxJava/issues/1453,[],25,0,ReactiveX_RxJava_pull_1453.diff
ReactiveX/RxJava,Removing onStart and onSetProducer from rx.Subscriber...,"...because they are unnecessary and it can't be undone once it is released.  The `rx.Subscriber` is part of the public API and these methods aren't really needed for the Rx to work.
",2014-07-16 19:49:17,2014-07-17 19:47:58,https://api.github.com/repos/ReactiveX/RxJava/issues/1452,[],84,261,ReactiveX_RxJava_pull_1452.diff
ReactiveX/RxJava,Add operators to create Observables from BroadcastReceiver,"wraps BroadcastReceiver with Observable. Can be used with gloabl broadcasts and with local (using LocalBroadcastManager)
",2014-07-16 13:19:03,2014-07-29 10:42:12,https://api.github.com/repos/ReactiveX/RxJava/issues/1449,['Enhancement'],245,5,ReactiveX_RxJava_pull_1449.diff
ReactiveX/RxJava,RxScala: Add Scala idiomatic methods,"For #523

/cc @headinthebox, @samuelgruetter
",2014-07-16 12:20:35,2014-07-16 14:50:00,https://api.github.com/repos/ReactiveX/RxJava/issues/1448,[],48,4,ReactiveX_RxJava_pull_1448.diff
ReactiveX/RxJava,Zip with Backpressure Support,"This supports both upstream and downstream backpressure.
",2014-07-16 05:55:04,2014-07-17 19:51:49,https://api.github.com/repos/ReactiveX/RxJava/issues/1446,[],390,194,ReactiveX_RxJava_pull_1446.diff
ReactiveX/RxJava,Infinite request with Long.MAX_VALUE instead of -1,"Migrating to this after discussions at https://github.com/reactive-streams/reactive-streams/issues/62
",2014-07-15 05:31:10,2014-07-15 05:31:14,https://api.github.com/repos/ReactiveX/RxJava/issues/1443,[],20,20,ReactiveX_RxJava_pull_1443.diff
ReactiveX/RxJava,Merge Bug,"Working on https://github.com/Netflix/RxJava/issues/1420

In testing on prod this looks like it may solve it .... running longer term tests to confirm.
",2014-07-15 05:01:15,2014-07-15 05:01:23,https://api.github.com/repos/ReactiveX/RxJava/issues/1442,[],42,35,ReactiveX_RxJava_pull_1442.diff
ReactiveX/RxJava,OnErrorFlatMap & FlatMap,"Allow onError to be treated as a non-terminal event when flowing through flatMap/merge/SerializedObserver so onErrorFlatMap can be used.
",2014-07-14 21:11:10,2014-07-17 21:35:39,https://api.github.com/repos/ReactiveX/RxJava/issues/1441,[],42,3,ReactiveX_RxJava_pull_1441.diff
ReactiveX/RxJava,Micro-optimization by nulling out list,"A micro-optimization done as per discussion in https://github.com/Netflix/RxJava/issues/1292. It is questionable whether this will help, but if it can help Android memory pressure then it's worth it as it is a trivial change.
",2014-07-14 20:40:36,2014-07-14 20:40:39,https://api.github.com/repos/ReactiveX/RxJava/issues/1440,[],1,0,ReactiveX_RxJava_pull_1440.diff
ReactiveX/RxJava,Allow us to make custom Scheduler,"If someone wants to extend `Scheduler` he needs to override `asJavaScheduler`, but it's very tedious due to the `private [scala] val` declaration. In RxJava it's pretty easy to make custom Scheduler. In my opinion RxScala shouldn't prevent people doing so.
",2014-07-12 12:45:52,2014-07-21 16:37:14,https://api.github.com/repos/ReactiveX/RxJava/issues/1437,[],1,1,ReactiveX_RxJava_pull_1437.diff
ReactiveX/RxJava,Correct warnings,,2014-07-12 01:22:09,2014-07-21 16:39:26,https://api.github.com/repos/ReactiveX/RxJava/issues/1436,[],28,38,ReactiveX_RxJava_pull_1436.diff
ReactiveX/RxJava,Don't use postdelayed if already on right looper,"There is no need to do postDelayed if we are on the right looper already and no delay needed.

Fix is required because for some UI scenarios postDelayed latency is not acceptable. 

I don't know how to write test for this case. Let me know if have an idea and I will add it.

@loganj @akarnokd @benjchristensen
",2014-07-11 23:58:42,2014-07-25 20:53:05,https://api.github.com/repos/ReactiveX/RxJava/issues/1435,[],6,1,ReactiveX_RxJava_pull_1435.diff
ReactiveX/RxJava,Take 3,"Removed unneeded variance and replaced a few type variables in result types that don't matter with Any.

Used `@uncheckedVariance` in one place that I think is safe and correspond better with Java signature. which also just takes a `T`.

```
def publish[R](selector: Observable[T] => Observable[R], initialValue: T @uncheckedVariance): Observable[R]
ublic final <R> Observable<R> publish(Func1<? super Observable<T>, ? extends Observable<R>> selector, final T initialValue) {
```
",2014-07-11 16:35:56,2014-07-11 16:49:56,https://api.github.com/repos/ReactiveX/RxJava/issues/1433,[],71,110,ReactiveX_RxJava_pull_1433.diff
ReactiveX/RxJava,"Remove variance, try 2","Removed unneeded variance and replaced a few type variables in result types that don't matter with Any.

Used `@uncheckedVariance` in one place that I think is safe and correspond better with Java signature. which also just takes a `T`.

```
def publish[R](selector: Observable[T] => Observable[R], initialValue: T @uncheckedVariance): Observable[R]
ublic final <R> Observable<R> publish(Func1<? super Observable<T>, ? extends Observable<R>> selector, final T initialValue) {
```
",2014-07-11 16:30:59,2014-07-11 16:33:29,https://api.github.com/repos/ReactiveX/RxJava/issues/1432,[],76,115,ReactiveX_RxJava_pull_1432.diff
ReactiveX/RxJava,CompositeException fix for Android,"Fixes #1405
- revert changes from f4ae92aa
- remove duplicated causes in stack trace chain
",2014-07-11 13:10:50,2014-07-21 23:22:07,https://api.github.com/repos/ReactiveX/RxJava/issues/1431,[],106,142,ReactiveX_RxJava_pull_1431.diff
ReactiveX/RxJava,Unneeded Variance Cleanup,"Removed unneeded variance and replaced a few type variables in result types that don't matter with Any.

Used `@uncheckedVariance` in one place that I think is safe and correspond better with Java signature. which also just takes a `T`.

```
def publish[R](selector: Observable[T] => Observable[R], initialValue: T @uncheckedVariance): Observable[R]
ublic final <R> Observable<R> publish(Func1<? super Observable<T>, ? extends Observable<R>> selector, final T initialValue) {
```

[Aside: Is the `class CompletenessTest extends JUnitSuite` useful, not for me at least, it requires too much manual messing around, and I am never sure what to change (and why)]
",2014-07-11 12:53:43,2014-07-11 16:27:59,https://api.github.com/repos/ReactiveX/RxJava/issues/1430,[],83,122,ReactiveX_RxJava_pull_1430.diff
ReactiveX/RxJava,Simplify creation of single thread used by event loop based Schedulers,"Removes overhead of using a ScheduledThreadPool for the single thread used by the event loop based Schedulers. Explicitly creates a single thread and uses a minimal queue implementation so that execution of scheduled actions are serialized.

I've seen some spurious unit tests failures that I'm unable to reproduce, so a code review to point any concurrency issues would be much appreciated.

Also, if someone could point me to which JMH benchmarks that would be relevant for this change and how to run them, I can post some numbers to see if this change is worthwhile.
",2014-07-11 10:33:57,2014-07-22 09:49:05,https://api.github.com/repos/ReactiveX/RxJava/issues/1428,[],1458,24,ReactiveX_RxJava_pull_1428.diff
ReactiveX/RxJava,Changed producer interface to work with long instead of int,"Changing `int` to `long` in `Producer` implementations. 
",2014-07-10 23:18:41,2014-07-11 02:42:05,https://api.github.com/repos/ReactiveX/RxJava/issues/1423,[],92,90,ReactiveX_RxJava_pull_1423.diff
ReactiveX/RxJava,Concurrency Fixes for RxRingBuffer & Merge,"Possible fix for #1420

I was unable to exactly reproduce the issue, but was able to create a possibly related one. This fixes it.
It also simplifies the logic and code somewhat, at a possible small performance cost for these:

```
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    59407.716     2073.945    ops/s
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       66.557        2.693    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       59.293        5.046    ops/s
```
",2014-07-10 22:04:12,2014-07-10 22:04:23,https://api.github.com/repos/ReactiveX/RxJava/issues/1422,[],133,83,ReactiveX_RxJava_pull_1422.diff
ReactiveX/RxJava,Range backpressure concurrency & off-by-one bugfix,"Bugs/deficiencies fixed:
- reading of the volatile `requested` multiple times
- `numLeft` calculated incorrectly if `start` was not 0
- since `end` is an absolute index and `index` goes up to it, there is no need for `start`
- `index` gets only updated by a single thread thanks to the barriers provided by the atomic `REQUESTED` updater, there is no need for volatile.
- `numLeft` calculated incorrectly since `end` is an inclusive end index, thus the remaining count is +1
- `completeOnFinish` was false if the exact remaining amount is requested.
",2014-07-10 08:05:34,2014-07-10 16:06:04,https://api.github.com/repos/ReactiveX/RxJava/issues/1421,[],70,9,ReactiveX_RxJava_pull_1421.diff
ReactiveX/RxJava,Zip with backpressure support,"If I understand the backpressure correctly, zip with backpressure is relatively simple: if the client requests N items, it is forwarded to all sources because they would need to produce N events each in order to get N events zipped. Since N may vary, bounded buffering may not be feasible. 

In addition, I'm not sure what type of typical backpressure tests should be written so I only included a simple one.

I've also fixed the unsynchronized read of `requested` in `Subscriber.setProducer`.
",2014-07-09 07:08:44,2014-07-15 15:09:52,https://api.github.com/repos/ReactiveX/RxJava/issues/1418,[],76,3,ReactiveX_RxJava_pull_1418.diff
ReactiveX/RxJava,Proposal: Subscriber.onStart,"This is a proposal derived from conversations with @headinthebox to use `Subscriber.onStart` rather than constructor overloads as the mechanism for allowing `request(n)` to be called to operationally start backpressure (or do anything else at the start of a stream).

The idea is that it is at the start the same as `onError` or `onCompleted` are terminal events. It will always be called.

Usage for subscribing is like this:

``` java
        Observable.from(1, 2, 3, 4).take(2).subscribe(new Subscriber<Integer>() {

            @Override
            public void onStart() {
                request(1);
            }

            @Override
            public void onCompleted() {

            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onNext(Integer t) {
                System.out.println(t);
                request(1);
            }

        });
```

or when writing an `Operator` via `lift`:

``` java
        Observable.from(1, 2, 3, 4).lift(new Operator<Integer, Integer>() {

            @Override
            public Subscriber<? super Integer> call(final Subscriber<? super Integer> child) {
                return new Subscriber<Integer>() {

                    @Override
                    public void onStart() {
                        request(1);
                    }

                    @Override
                    public void onCompleted() {
                        child.onCompleted();
                    }

                    @Override
                    public void onError(Throwable e) {
                        child.onError(e);
                    }

                    @Override
                    public void onNext(Integer t) {
                        System.out.println(t);
                        child.onNext(t);
                        request(1);
                    }

                };
            }

        }).subscribe();
```

Both of these examples are requesting 1 item at a time.
",2014-07-08 20:56:14,2014-07-08 22:46:52,https://api.github.com/repos/ReactiveX/RxJava/issues/1417,[],284,29,ReactiveX_RxJava_pull_1417.diff
ReactiveX/RxJava,Merge Fixes,"A handful of fixes, particularly one that could cause non-deterministic missing data.
",2014-07-08 05:47:21,2014-07-08 05:47:28,https://api.github.com/repos/ReactiveX/RxJava/issues/1414,[],29,9,ReactiveX_RxJava_pull_1414.diff
ReactiveX/RxJava,Switch build to Gradle 1.9,,2014-07-08 00:49:02,2014-07-21 16:53:09,https://api.github.com/repos/ReactiveX/RxJava/issues/1413,[],2,2,ReactiveX_RxJava_pull_1413.diff
ReactiveX/RxJava,Backpressure & 0.20.0-RC1,"This is a functioning implementation of backpressure. Of the major unbounded queue operators in 0.19, this implements `observeOn` and `merge` but not yet `zip`. 
### New Signatures

``` java
public interface Producer {
    public void request(int n);
}
```

``` java
public abstract class Subscriber<T> implements Observer<T>, Subscription {

    /**
     * Optionally called from `Observable.OnSubscribe`.
     */
    public final void setProducer(Producer producer);

    /**
     * Allow implementing classes to capture, decorate or override the `Producer` without affecting the `Subscriber` logic.
     */
    protected Producer onSetProducer(Producer producer);

    public final void request(int n);
}
```
",2014-07-07 22:46:08,2014-07-08 00:05:21,https://api.github.com/repos/ReactiveX/RxJava/issues/1412,[],4757,475,ReactiveX_RxJava_pull_1412.diff
ReactiveX/RxJava,Avoiding OperatorObserveOn from calling subscriber.onNext(..) after unsu...,"...bscribe().

The OperatorObserveOn operator uses a scheduler to cancel subscriptions as well
as to deliver the objects passing through it's onNext(..) in the right context.

Calling unsubscribe will schedule the actual unsubscription while not making sure
that the child subscriber will no longer receive calls to onNext(..) after
unsubscribe() returns.

This fix makes sure that after unsubscribe() returns no more onNext(..) calls will be
made on the child subscribers.

Signed-off-by: David Marques dpsmarques@gmail.com
",2014-07-04 17:43:00,2014-07-07 18:54:01,https://api.github.com/repos/ReactiveX/RxJava/issues/1409,[],22,2,ReactiveX_RxJava_pull_1409.diff
ReactiveX/RxJava,Kotlin M8,"- Update to Kotlin milestone 8, 
- Some reformat on test 
- Replacing deprecated method calls 
",2014-07-04 00:25:26,2014-07-07 16:58:37,https://api.github.com/repos/ReactiveX/RxJava/issues/1406,[],31,35,ReactiveX_RxJava_pull_1406.diff
ReactiveX/RxJava,Backpressure-8 – Merge & ObserveOn,"This is a functioning implementation of backpressure. Of the major unbounded queue operators in 0.19, this implements `observeOn` and `merge` but not yet `zip`. Compared with the previous PRs (backpressure-7 and earlier) this brings performance to levels that are possible to be merged into master.
### New Signatures

``` java
public interface Producer {
    public void request(int n);
}
```

``` java
public abstract class Subscriber<T> implements Observer<T>, Subscription {

    /**
     * Optionally called from `Observable.OnSubscribe`.
     */
    public final void setProducer(Producer producer);

    /**
     * Allow implementing classes to capture, decorate or override the `Producer` without affecting the `Subscriber` logic.
     */
    protected Producer onSetProducer(Producer producer);

    public final void request(int n);
}
```
### Operator Changes

`OnSubscribeFromIterable` and `OnSubscribeRange` are both updated to support `Producer` and will only emit as many `onNext` as requested. The implementations are a little more complex than needed as they optimize for cases where backpressure is not requested and fallback to the ""firehose"" model of 0.19 and earlier. This allows for higher throughput in case where backpressure is not needed.

`parallel` had to be rewritten with a different approach to support backpressure. The `filter`, `take`, and `skip` operators were modified to support backpressure and propagate request modifications based on each of their logic. `takeUntil` needed to be rewritten because `NotificationLite` can't be allowed to leak across operators. The `subscribeOn` operator was modified to correctly reschedule work on the given `Scheduler` when a `request(n)` occurs after the `Producer` has let itself shut down. 
### Design Questions
##### 1) Producer

Is the name and signature of `Producer.request(n)` correct?
##### 2) Subscriber.setProducer

Is this the correct signature for an `Observable.OnSubscribe` to register the `Producer`?
##### 3) Requesting <0 for Infinite (no backpressure)

To be backwards compatible, and support performance optimizations when backpressure is not needed, `Producer.request(n)` can be invoked with a negative number. This means ""no backpressure"" and the `Producer` can then emit data in a tight-loop without further limitations.

Is this acceptable and the best solution?
##### 4) onBackpressure*

Are the `onBackpressureBuffer` and `onBackpressureDrop` operators well-named, clear in their usage and implemented correctly? Should we implemented others such as `onBackpressureUnsubscribe` and `onBackpressureBuffer(int limitUntilDropping)`?
##### 5) Unit Tests and Use Cases

Are there major use cases that are missing from `BackpressureTests`? 

What problems are there that are not yet resolved or handled by the design?
### Performance

```
-------------- ../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 2 .*PerfBaseline.observable.*'

------- 0.19

Benchmark                                       (size)   Mode   Samples        Score  Score error    Units
r.PerfBaseline.iterableViaForLoopConsumption         1  thrpt         5 250139466.600  6920354.087    ops/s
r.PerfBaseline.iterableViaForLoopConsumption      1000  thrpt         5    182500.174     5244.888    ops/s
r.PerfBaseline.iterableViaForLoopConsumption   1000000  thrpt         5       170.911        3.823    ops/s
r.PerfBaseline.iterableViaHasNextConsumption         1  thrpt         5 320148600.957 11599243.208    ops/s
r.PerfBaseline.iterableViaHasNextConsumption      1000  thrpt         5    297314.203     9485.727    ops/s
r.PerfBaseline.iterableViaHasNextConsumption   1000000  thrpt         5       269.004        4.151    ops/s
-----------------------------------------------------------------------------------------------------------
r.PerfBaseline.observableConsumption                 1  thrpt         5  29298639.717   277675.587    ops/s
r.PerfBaseline.observableConsumption              1000  thrpt         5    243968.954    10311.720    ops/s
r.PerfBaseline.observableConsumption           1000000  thrpt         5       252.916        3.420    ops/s
r.PerfBaseline.observableConsumptionUnsafe           1  thrpt         5 199935597.149 31884367.299    ops/s
r.PerfBaseline.observableConsumptionUnsafe        1000  thrpt         5    311704.723    39346.976    ops/s
r.PerfBaseline.observableConsumptionUnsafe     1000000  thrpt         5       307.188       58.163    ops/s
r.PerfBaseline.observableViaRange                    1  thrpt         5  23843851.260   324794.935    ops/s
r.PerfBaseline.observableViaRange                 1000  thrpt         5    193208.479     3741.146    ops/s
r.PerfBaseline.observableViaRange              1000000  thrpt         5       188.261       12.172    ops/s
r.PerfBaseline.observableViaRangeUnsafe              1  thrpt         5  45762792.585  1379450.701    ops/s
r.PerfBaseline.observableViaRangeUnsafe           1000  thrpt         5    240280.347     3312.756    ops/s
r.PerfBaseline.observableViaRangeUnsafe        1000000  thrpt         5       234.143        1.163    ops/s



------- backpressure-8

Benchmark                                       (size)   Mode   Samples        Score  Score error    Units
r.PerfBaseline.iterableViaForLoopConsumption         1  thrpt         5 250601807.892 12009864.080    ops/s
r.PerfBaseline.iterableViaForLoopConsumption      1000  thrpt         5    184859.869     2400.585    ops/s
r.PerfBaseline.iterableViaForLoopConsumption   1000000  thrpt         5       172.127        4.979    ops/s
r.PerfBaseline.iterableViaHasNextConsumption         1  thrpt         5 322464817.267  8117858.197    ops/s
r.PerfBaseline.iterableViaHasNextConsumption      1000  thrpt         5    294868.674     7349.485    ops/s
r.PerfBaseline.iterableViaHasNextConsumption   1000000  thrpt         5       266.602        5.682    ops/s
-----------------------------------------------------------------------------------------------------------
r.PerfBaseline.observableConsumption                 1  thrpt         5  33622221.238   963042.530    ops/s +
r.PerfBaseline.observableConsumption              1000  thrpt         5    244097.704     4564.965    ops/s =
r.PerfBaseline.observableConsumption           1000000  thrpt         5       256.587        5.404    ops/s =
r.PerfBaseline.observableConsumptionUnsafe           1  thrpt         5 206453075.285  4940138.228    ops/s =
r.PerfBaseline.observableConsumptionUnsafe        1000  thrpt         5    320284.165     6034.968    ops/s =
r.PerfBaseline.observableConsumptionUnsafe     1000000  thrpt         5       314.259        7.683    ops/s =
r.PerfBaseline.observableViaRange                    1  thrpt         5  37486671.210   887127.291    ops/s ++
r.PerfBaseline.observableViaRange                 1000  thrpt         5    172643.588     7439.349    ops/s -
r.PerfBaseline.observableViaRange              1000000  thrpt         5       173.171        2.794    ops/s -
r.PerfBaseline.observableViaRangeUnsafe              1  thrpt         5 236013059.425  7822030.114    ops/s +++
r.PerfBaseline.observableViaRangeUnsafe           1000  thrpt         5    211461.722    13717.277    ops/s -
r.PerfBaseline.observableViaRangeUnsafe        1000000  thrpt         5       202.761       12.915    ops/s -



-------------- ../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 2 .*rx.operators.OperatorMapPerf.*'

------- 0.19

Benchmark                                 (size)   Mode   Samples        Score  Score error    Units
r.o.OperatorMapPerf.mapPassThru                1  thrpt         5 17853002.462   556655.574    ops/s 
r.o.OperatorMapPerf.mapPassThru             1000  thrpt         5   150669.958    16170.385    ops/s
r.o.OperatorMapPerf.mapPassThru          1000000  thrpt         5      162.473        3.961    ops/s
r.o.OperatorMapPerf.mapPassThruViaLift         1  thrpt         5 18947641.742   644348.550    ops/s
r.o.OperatorMapPerf.mapPassThruViaLift      1000  thrpt         5   160047.002    20086.976    ops/s
r.o.OperatorMapPerf.mapPassThruViaLift   1000000  thrpt         5      162.310        6.204    ops/s


------- backpressure-8

Benchmark                                 (size)   Mode   Samples        Score  Score error    Units
r.o.OperatorMapPerf.mapPassThru                1  thrpt         5 24092718.114   586172.216    ops/s ++
r.o.OperatorMapPerf.mapPassThru             1000  thrpt         5   149191.341     3154.653    ops/s -
r.o.OperatorMapPerf.mapPassThru          1000000  thrpt         5      150.013        3.124    ops/s -
r.o.OperatorMapPerf.mapPassThruViaLift         1  thrpt         5 26144219.306   368383.801    ops/s ++
r.o.OperatorMapPerf.mapPassThruViaLift      1000  thrpt         5   150500.298     2074.296    ops/s - 
r.o.OperatorMapPerf.mapPassThruViaLift   1000000  thrpt         5      150.896        1.945    ops/s -





-------------- ../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 2 .*rx.operators.OperatorObserveOnPerf.*'

------- 0.19

Benchmark                                         (size)   Mode   Samples        Score  Score error    Units
r.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5   110481.792      991.073    ops/s
r.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5     8386.714      103.294    ops/s
r.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5        8.568        4.330    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5 13144808.808   852878.900    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   191230.661     4066.226    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      186.919        6.075    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5    15972.029     1955.679    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     6606.316      104.860    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       10.683        2.060    ops/s


------- backpressure-8

Benchmark                                         (size)   Mode   Samples        Score  Score error    Units
r.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5    93371.544    12564.954    ops/s
r.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5     5209.287      161.070    ops/s
r.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5       10.070        5.387    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5 15855354.194    74122.090    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   173351.676     5924.790    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      170.760        4.379    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5    15524.785     1373.757    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     4878.633       54.696    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       15.285        0.564    ops/s






-------------- ../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 2 .*rx.operators.OperatorMergePerf.*'

------- 0.19


Benchmark                                          (size)   Mode   Samples        Score  Score error    Units
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  3047431.417    33607.539    ops/s
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    70708.027     2468.027    ops/s
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       70.950        3.242    ops/s
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5   106426.955     3921.743    ops/s
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        7.645        0.409    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  2924643.167    90602.452    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5    65041.997     4387.032    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5     6727.579      140.162    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  2923542.700    55565.638    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       71.998        1.992    ops/s
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    80321.863    19568.569    ops/s
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     3832.958      236.712    ops/s
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  2927868.656   517769.910    ops/s
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5     6799.933      180.123    ops/s
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5        6.408        0.206    ops/s



------- backpressure-8

Benchmark                                          (size)   Mode   Samples        Score  Score error    Units
r.o.OperatorMergePerf.merge1SyncStreamOfN               1  thrpt         5  5475300.198   156741.334    ops/s
r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    68932.278     1311.023    ops/s
r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       64.405        0.611    ops/s
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN             1  thrpt         5   102736.219     2948.102    ops/s
r.o.OperatorMergePerf.mergeNAsyncStreamsOfN          1000  thrpt         5        5.893        0.278    ops/s xxxxx
r.o.OperatorMergePerf.mergeNSyncStreamsOf1              1  thrpt         5  4941243.788   109965.809    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOf1            100  thrpt         5   368061.743    11456.008    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOf1           1000  thrpt         5    38941.345     1974.002    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOfN              1  thrpt         5  6070127.935    58505.579    ops/s
r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       57.002        1.708    ops/s
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN           1  thrpt         5    77911.340     2413.596    ops/s
r.o.OperatorMergePerf.mergeTwoAsyncStreamsOfN        1000  thrpt         5     4258.650      116.595    ops/s
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1         1  thrpt         5  5429881.489    26728.872    ops/s
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1      1000  thrpt         5    28932.279      572.963    ops/s
r.o.OperatorMergePerf.oneStreamOfNthatMergesIn1   1000000  thrpt         5       30.147        1.253    ops/s




-------------- ../gradlew benchmarks '-Pjmh=-f 1 -wi 5 -i 5 -r 2 .*rx.operators.OperatorFlatMapPerf.*'

------- 0.19

Benchmark                                          (size)   Mode   Samples        Score  Score error    Units
r.o.OperatorFlatMapPerf.flatMapIntPassthruAsync         1  thrpt         5   352212.163    24668.380    ops/s
r.o.OperatorFlatMapPerf.flatMapIntPassthruAsync      1000  thrpt         5      350.930        8.635    ops/s
r.o.OperatorFlatMapPerf.flatMapIntPassthruAsync   1000000  thrpt         5        0.352        0.010    ops/s
r.o.OperatorFlatMapPerf.flatMapIntPassthruSync          1  thrpt         5  3323839.174    38716.562    ops/s
r.o.OperatorFlatMapPerf.flatMapIntPassthruSync       1000  thrpt         5     6456.484     1262.577    ops/s
r.o.OperatorFlatMapPerf.flatMapIntPassthruSync    1000000  thrpt         5        6.337        0.149    ops/s
r.o.OperatorFlatMapPerf.flatMapTwoNestedSync            1  thrpt         5  2117425.124    45292.911    ops/s
r.o.OperatorFlatMapPerf.flatMapTwoNestedSync         1000  thrpt         5    35047.747      637.443    ops/s
r.o.OperatorFlatMapPerf.flatMapTwoNestedSync      1000000  thrpt         5       35.408        1.304    ops/s



------- backpressure-8

Benchmark                                          (size)   Mode   Samples        Score  Score error    Units
r.o.OperatorFlatMapPerf.flatMapIntPassthruAsync         1  thrpt         5   307489.156    24595.370    ops/s -
r.o.OperatorFlatMapPerf.flatMapIntPassthruAsync      1000  thrpt         5      315.122       79.497    ops/s -
r.o.OperatorFlatMapPerf.flatMapIntPassthruAsync   1000000  thrpt         5      305.585       33.345    ops/s +++ (why is this better?)
r.o.OperatorFlatMapPerf.flatMapIntPassthruSync          1  thrpt         5  5932020.586   123609.972    ops/s ++
r.o.OperatorFlatMapPerf.flatMapIntPassthruSync       1000  thrpt         5    26402.347     4096.510    ops/s +++
r.o.OperatorFlatMapPerf.flatMapIntPassthruSync    1000000  thrpt         5       29.338        5.235    ops/s +++
r.o.OperatorFlatMapPerf.flatMapTwoNestedSync            1  thrpt         5  3843959.776   204899.691    ops/s ++
r.o.OperatorFlatMapPerf.flatMapTwoNestedSync         1000  thrpt         5    29316.657      446.403    ops/s ++
r.o.OperatorFlatMapPerf.flatMapTwoNestedSync      1000000  thrpt         5       32.767        0.754    ops/s -
```
",2014-07-03 07:29:20,2014-07-07 22:46:16,https://api.github.com/repos/ReactiveX/RxJava/issues/1403,[],4780,331,ReactiveX_RxJava_pull_1403.diff
ReactiveX/RxJava,OnError while emitting onNext value: object.toString,"```
  public OnNextValue(Object value) {
        super(""OnError while emitting onNext value: "" + value);
        this.value = value;
    }
```

I know this is probably a helpful error message in some cases but this can be a really costly operation when an objects toString is an expensive call or contains alot of output. I don't think we should be printing this in any case but if so it should be on demand (overload of getMessage()) rather than eagerly.

In my case it is causing a toString of a large context object that is normally only used for debugging purposes which makes the exception logs hard to use and they are rolling over the log files very quickly.

There is an added danger that if there is a bug in the toString method it will cause inconsistent exception creation. If the object throws an exception while rendering a string it will actually end up not seeing the real exception.
",2014-07-02 19:14:05,2014-07-07 21:24:15,https://api.github.com/repos/ReactiveX/RxJava/issues/1401,[],127,1,ReactiveX_RxJava_pull_1401.diff
ReactiveX/RxJava,Internal Data Structures,"Various data structures to allow performance improvements.
I am committing these separately from the code that uses it to keep the pull requests simpler.
Nothing in RxJava depends on these classes in this commit.
",2014-07-02 17:41:26,2014-07-02 17:45:32,https://api.github.com/repos/ReactiveX/RxJava/issues/1400,[],2997,1,ReactiveX_RxJava_pull_1400.diff
ReactiveX/RxJava,Update Perf Tests,"matching with work being done for 0.20 to allow comparisons
",2014-07-02 16:45:57,2014-07-02 16:46:02,https://api.github.com/repos/ReactiveX/RxJava/issues/1399,[],80,17,ReactiveX_RxJava_pull_1399.diff
ReactiveX/RxJava,RxScala: Use currying to improve type inference,"As per discussion in #1392.

/cc @headinthebox, @samuelgruetter
",2014-07-02 09:25:25,2014-07-08 19:41:13,https://api.github.com/repos/ReactiveX/RxJava/issues/1398,[],149,107,ReactiveX_RxJava_pull_1398.diff
ReactiveX/RxJava,Adding the hooks unsafeSubscribe,"by making the execution and error handling exactly same as safe version without the safety checks.
",2014-06-30 22:23:57,2014-07-02 16:33:36,https://api.github.com/repos/ReactiveX/RxJava/issues/1397,[],34,19,ReactiveX_RxJava_pull_1397.diff
ReactiveX/RxJava,RxScala: Fix the compiler warnings,"This PR fixed the annoying warnings in RxScala, include replacing `toBlockingObservable` with `toBlocking` and adding language.\* imports.

/cc @headinthebox, @samuelgruetter
",2014-06-29 17:04:00,2014-07-02 16:34:18,https://api.github.com/repos/ReactiveX/RxJava/issues/1396,[],131,127,ReactiveX_RxJava_pull_1396.diff
ReactiveX/RxJava,Gradle Builds: Change provided to testCompile,"Gradle now generates correct eclipse dependencies
",2014-06-27 01:06:53,2014-07-10 16:11:12,https://api.github.com/repos/ReactiveX/RxJava/issues/1394,[],361,280,ReactiveX_RxJava_pull_1394.diff
ReactiveX/RxJava,Add cache(int capacity) to Observable,"Proposed patch for #1303
",2014-06-26 23:49:37,2014-07-22 05:00:40,https://api.github.com/repos/ReactiveX/RxJava/issues/1393,[],65,0,ReactiveX_RxJava_pull_1393.diff
ReactiveX/RxJava,CompositeException stops mutating nested Exceptions,"Instead, it aggregates them at print-time. Since nothing is being mutated, there's no chance of accidentally creating a cycle in the Exception chain.  We ran into this in production very intermittently and had to add handling any time we were touching the Exception chain.
",2014-06-25 22:53:28,2014-06-25 23:29:26,https://api.github.com/repos/ReactiveX/RxJava/issues/1388,[],182,108,ReactiveX_RxJava_pull_1388.diff
ReactiveX/RxJava,Upgrade to JMH 0.9,,2014-06-25 17:35:29,2014-06-25 17:35:34,https://api.github.com/repos/ReactiveX/RxJava/issues/1387,[],53,53,ReactiveX_RxJava_pull_1387.diff
ReactiveX/RxJava,add Observable.sort() instance methods,"Added two `Observable.sort` instance methods that are equivalent to 

``` java
Observable.toSortedList().flatMap(x -> Observable.from(x))
```

I guess you might ask well why don't people just code that. I think it adds the following:
- a more natural reading api method
- doesn't interrupt the observable flow with buffered type `Observable<List<T>>`
- less mess for those people coding without lambdas
",2014-06-25 07:34:29,2014-07-08 19:46:47,https://api.github.com/repos/ReactiveX/RxJava/issues/1386,[],83,12,ReactiveX_RxJava_pull_1386.diff
ReactiveX/RxJava,OperatorTake: remove unsubscribe call to parent on take(0),"This is a very minor cleanup of `OperatorTake`. By changing the order of the existing code I removed a call to `parent.unsubscribe()`.
",2014-06-25 04:28:43,2014-06-25 12:46:55,https://api.github.com/repos/ReactiveX/RxJava/issues/1385,[],5,5,ReactiveX_RxJava_pull_1385.diff
ReactiveX/RxJava,Explore SubscriptionList/Subscriber & Synchronization,"This is an exploratory pull request related to https://github.com/Netflix/RxJava/issues/1383 that removes SubscriptionList synchronization and synchronizes ObserveOn.unsubscribe.

The performance impact on rapid subscribe/unsubscribe (such as an `Observable` with 1 item) is significant (31m -> 47m ops/second).

What I don't know however is if this is completely safe. Some unit tests did indeed fail when I removed the synchronization from `SubscriptionList` until I modified `observeOn` – so that's good. Then the unit tests all passed again when I made `observeOn` handle the synchronization. I have to think however that there are use cases I'm not covering with unit tests. 

I'd appreciate other peoples thoughts on this.

```
BEFORE

Benchmark                               (size)   Mode   Samples         Mean   Mean error    Units
r.PerfBaseline.observableConsumption         1  thrpt         5 31167007.424  2027918.084    ops/s
r.PerfBaseline.observableConsumption      1000  thrpt         5   227387.447    32738.021    ops/s
r.PerfBaseline.observableConsumption   1000000  thrpt         5      245.632       13.743    ops/s

AFTER

Benchmark                               (size)   Mode   Samples         Mean   Mean error    Units
r.PerfBaseline.observableConsumption         1  thrpt         5 47142418.802  5341223.740    ops/s
r.PerfBaseline.observableConsumption      1000  thrpt         5   220175.324    35936.506    ops/s
r.PerfBaseline.observableConsumption   1000000  thrpt         5      221.077       44.437    ops/s
```

BEFORE

```
Benchmark                                         (size)   Mode   Samples         Mean   Mean error    Units
r.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5    86331.092     5181.739    ops/s
r.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5     8787.634      316.166    ops/s
r.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5        8.590        4.527    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5 13074710.596   217808.611    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   188868.055     5448.065    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      185.372        4.190    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5    13848.943     2601.271    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     6867.300      172.123    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       10.100        1.925    ops/s

AFTER

Benchmark                                         (size)   Mode   Samples         Mean   Mean error    Units
r.o.OperatorObserveOnPerf.observeOnComputation         1  thrpt         5    69120.389    16422.228    ops/s
r.o.OperatorObserveOnPerf.observeOnComputation      1000  thrpt         5    12261.472      267.137    ops/s
r.o.OperatorObserveOnPerf.observeOnComputation   1000000  thrpt         5       15.466        0.269    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate           1  thrpt         5 13200910.511   418278.691    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate        1000  thrpt         5   179868.400     6465.965    ops/s
r.o.OperatorObserveOnPerf.observeOnImmediate     1000000  thrpt         5      184.210        2.299    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread           1  thrpt         5    12880.951     2183.905    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread        1000  thrpt         5     9164.764      385.580    ops/s
r.o.OperatorObserveOnPerf.observeOnNewThread     1000000  thrpt         5       17.249        1.173    ops/s
```
",2014-06-24 17:09:42,2014-07-07 21:24:46,https://api.github.com/repos/ReactiveX/RxJava/issues/1384,[],45,27,ReactiveX_RxJava_pull_1384.diff
ReactiveX/RxJava,Backpressure-7 - Merge & ObserveOn,"This is a functioning but non-performant implementation of backpressure. Of the major unbounded queue operators in 0.19, this implements `observeOn` and `merge` but not yet `zip`. Several attempts at performance improvements last week failed so I have rolled them back and left this with naive data structures while restarting the performance work.

I want to kick off the design and functionality review while continuing to work on performance.
### New Signatures

``` java
public interface Producer {
    public void request(int n);
}
```

``` java
public abstract class Subscriber<T> implements Observer<T>, Subscription {

    /**
     * Optionally called from `Observable.OnSubscribe`.
     */
    public final void setProducer(Producer producer);

    /**
     * Allow implementing classes to capture, decorate or override the `Producer` without affecting the `Subscriber` logic.
     */
    protected Producer onSetProducer(Producer producer);

    public final void request(int n);
}
```
### `Subscriber.request` vs `Producer.request`

This is possibly confusing and I think we may want to eliminate `Subscriber.request`. It would make some operators like `take` more complicated, but for the rare time it is needed, I think it's more clear that you must ""capture"" the `Producer` and call `Producer.request`.
### Operator Changes

`OnSubscribeFromIterable` and `OnSubscribeRange` are both updated to support `Producer` and will only emit as many `onNext` as requested. The implementations are a little more complex than needed as they optimize for cases where backpressure is not requested and fallback to the ""firehose"" model of 0.19 and earlier. This allows for higher throughput in case where backpressure is not needed.

`parallel` had to be rewritten with a different approach to support backpressure. The `filter`, `take`, and `skip` operators were modified to support backpressure and propagate request modifications based on each of their logic. `takeUntil` needed to be rewritten because `NotificationLite` can't be allowed to leak across operators. The `subscribeOn` operator was modified to correctly reschedule work on the given `Scheduler` when a `request(n)` occurs after the `Producer` has let itself shut down. 
### Design Questions
##### 1) Producer

Is the name and signature of `Producer.request(n)` correct?
##### 2) Subscriber.setProducer

Is this the correct signature for an `Observable.OnSubscribe` to register the `Producer`?
##### 3) Subscriber.request

This seems confusing and should probably be removed, despite it making some use cases such as `take` and `filter` more complicated.
##### 4) Requesting <0 for Infinite (no backpressure)

To be backwards compatible, and support performance optimizations when backpressure is not needed, `Producer.request(n)` can be invoked with a negative number. This means ""no backpressure"" and the `Producer` can then emit data in a tight-loop without further limitations.

Is this acceptable and the best solution?
##### 5) Producer.BUFFER_SIZE

Currently there is a public constant, `Producer.BUFFER_SIZE` that represents the system-wide size of buffers used for backpressure. This is exposed so that an operator implementation can optimize to skip the `setProducer` path when it knows it will emit less data that the BUFFER_SIZE. 

This does have a performance benefit, but it comes at the cost of exposing implementation details. It also means all buffers MUST use the same buffer size, or at least not be any smaller.

Is this something we want? Is the performance benefit worth the trade-offs and complexity?
##### 6) Other operators like filter?

Are there other operators that filter out `onNext` like `filter` does that we must modify to call `request(1)` each time it filters something out? Is there a better way of handling this so operators do not need to manually handle this?
##### 7) onBackpressure*

Are the `onBackpressureBuffer` and `onBackpressureDrop` operators well-named, clear in their usage and implemented correctly? Should we implemented others such as `onBackpressureUnsubscribe` and `onBackpressureBuffer(int limitUntilDropping)`?
##### 8) Unit Tests and Use Cases

Are there major use cases that are missing from `BackpressureTests`? 

What problems are there that are not yet resolved or handled by the design?
##### 9) observeOn

Is the design of `observeOn` as efficient and correct as it can be?
##### 10) merge

The `merge` operator currently has a naive algorithm for handling the queue of buffers. We need to design a better one. 

There are some unit tests marked as ignored for `merge` in the `BackpressureTests` class. Should those work? What should be the behavior of `merge` when merging all synchronous, all asynchronous, or mixed sync/async Observables?
### Performance

Performance is not good right now. The biggest problem is `merge`, and that's critical since it's key to `flatMap` which is a core operator.

Performance can be tested via the JMH performance tests. This is where I'm currently focusing.
",2014-06-24 03:49:41,2014-07-03 07:29:35,https://api.github.com/repos/ReactiveX/RxJava/issues/1382,[],7431,300,ReactiveX_RxJava_pull_1382.diff
ReactiveX/RxJava,Replace Arrays.copyOf* with System.arraycopy,"Arrays.copyOf is not supported on android api8

Maybe it make sense to create helper class like ArraysCompat to have all copyOf\* in one place?
",2014-06-24 03:37:08,2014-07-08 19:48:53,https://api.github.com/repos/ReactiveX/RxJava/issues/1381,[],11,3,ReactiveX_RxJava_pull_1381.diff
ReactiveX/RxJava,Variety of Fixes,"... found while working on backpressure.
",2014-06-24 03:01:54,2014-06-24 03:01:58,https://api.github.com/repos/ReactiveX/RxJava/issues/1380,[],133,112,ReactiveX_RxJava_pull_1380.diff
ReactiveX/RxJava,Parallel Operator Rewrite,"A rewrite of the `parallel` operator that is more efficient by not using `groupBy` and ready to support backpressure.
",2014-06-24 02:46:05,2014-06-24 02:46:08,https://api.github.com/repos/ReactiveX/RxJava/issues/1379,[],81,26,ReactiveX_RxJava_pull_1379.diff
ReactiveX/RxJava,BugFix: Pivot Concurrency,"It wasn't serializing the `onNext`.
",2014-06-24 02:45:47,2014-06-24 02:45:50,https://api.github.com/repos/ReactiveX/RxJava/issues/1378,[],26,13,ReactiveX_RxJava_pull_1378.diff
ReactiveX/RxJava,Utility Class for Accessing Unsafe,"While working on code for v0.20 I have come across reasons for using sun.misc.Unsafe (such as #1372).

This provides a common way for getting access to `sun.misc.Unsafe` as well as utility methods for commonly needed APIs (that exist in Java 8, but not Java 6).

I need someone to help me confirm whether this works on Android, and if not how we can make this be aware of what platform it is running on, as per https://github.com/Netflix/RxJava/issues/1372#issuecomment-46717293
",2014-06-23 21:45:52,2014-07-02 20:05:17,https://api.github.com/repos/ReactiveX/RxJava/issues/1377,[],100,0,ReactiveX_RxJava_pull_1377.diff
ReactiveX/RxJava,Revision of JMH Tests,"This updates all perf testing to use only JMH. I tried to get all of them to follow a common pattern, and to comply with examples at https://github.com/nitsanw/jmh-samples/blob/master/src/main/java/org/openjdk/jmh/samples/ by @nitsanw. (@nitsanw if you're willing to take a look at this and confirm or correct them, I'd appreciate that).

I am doing this in 0.19 so that work on 0.20 has a common set of perf tests to use for comparison.
",2014-06-23 21:41:48,2014-06-23 21:48:13,https://api.github.com/repos/ReactiveX/RxJava/issues/1376,[],659,2750,ReactiveX_RxJava_pull_1376.diff
ReactiveX/RxJava,RxScala: Add idiomatic toXXX methods,"Suggested by @headinthebox in https://github.com/Netflix/RxJava/pull/1336#issuecomment-46118339

/cc @headinthebox, @samuelgruetter
",2014-06-23 07:44:52,2014-06-23 15:58:08,https://api.github.com/repos/ReactiveX/RxJava/issues/1375,[],222,1,ReactiveX_RxJava_pull_1375.diff
ReactiveX/RxJava,Fix head/tail false sharing issues,"See discussion in issue #1310 
",2014-06-20 16:04:31,2014-06-21 14:22:16,https://api.github.com/repos/ReactiveX/RxJava/issues/1374,[],73,49,ReactiveX_RxJava_pull_1374.diff
ReactiveX/RxJava,"Backpressure-6: Merge, ObserveOn, SubscribeOn, etc","Mostly functional backpressure with `merge` and `observeOn`.
This is NOT production ready. Need to work on algorithms in merge, data structures and concurrency implementations.

This does not yet have `zip` implemented, and despite effort on performance there are still degradations as shown below.

```
../gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 2 -prof GC rx.usecases.*'
```

Performance for 0.19.x vs 0.20 (this branch):

```
Benchmark                                        (size)           0.19             0.20     diff
r.u.PerfBaseline.forLoopConsumption                   1  344850705.588    356169426.506     within mean error
r.u.PerfBaseline.forLoopConsumption                1024     304909.309       311743.590     within mean error
r.u.PerfBaseline.iterableViaForLoopConsumption        1  239518717.088    241586374.313     within mean error
r.u.PerfBaseline.iterableViaForLoopConsumption     1024     177090.461       180974.316     within mean error
r.u.PerfBaseline.iterableViaHasNextConsumption        1  302479118.588    307508627.346     within mean error
r.u.PerfBaseline.iterableViaHasNextConsumption     1024     282783.917       287813.401     within mean error
r.u.PerfBaseline.observableConsumption                1   29295739.451     28748055.426     within mean error => 29.2m vs 28.7m, mean error ~0.45m
r.u.PerfBaseline.observableConsumption             1024     233194.851       234253.687     within mean error
r.u.PerfBaseline.observableViaRange                                        21535829.318
r.u.PerfBaseline.observableViaRange                                           51645.436
r.u.PerfObserveOn.observeOnComputation                1     378476.870       310228.157     378k vs 310k, mean error ~50k
r.u.PerfObserveOn.observeOnComputation             1024      13122.964         4423.132     WORSE: 13k vs 4k
r.u.PerfObserveOn.observeOnImmediate                  1   20465307.041     17203295.323     WORSE: 20.4m vs 17.2m, mean error ~800k
r.u.PerfObserveOn.observeOnImmediate               1024     232424.832        51503.696     WORSE: 232k vs 51k
r.u.PerfObserveOn.observeOnNewThread                  1      20209.183        20055.322     within mean error
r.u.PerfObserveOn.observeOnNewThread               1024      10170.748         4224.503     WORSE: 10k vs 4k
r.u.PerfTransforms.flatMapInt                         1    3308740.889      2404699.223     WORSE: 3.3m vs 2.4m
r.u.PerfTransforms.flatMapInt                      1024       6522.641         3053.996     WORSE: 6.5k vs 3.0k
r.u.PerfTransforms.flatMapNestedMapFilterTake         1    2150209.920      1777010.078     WORSE: 2.1m vs 1.8m, mean error ~60k
r.u.PerfTransforms.flatMapNestedMapFilterTake      1024         15.943           80.803     BETTER: 15 vs 80, mean error ~3
r.u.PerfTransforms.mapIntStringInt                    1    9107565.666      9004589.569     within mean error
r.u.PerfTransforms.mapIntStringInt                 1024      18774.750        15238.517     WORSE: 18.7k vs 15.2k, mean error ~500
r.u.PerfTransforms.mapPassThru                        1   19336755.193     15719416.479     WORSE: 19.3m vs 15.7m, mean error ~500k
r.u.PerfTransforms.mapPassThru                     1024     199751.628        49089.139     WORSE: 200k vs 49k
```
",2014-06-18 00:11:41,2014-06-21 14:25:37,https://api.github.com/repos/ReactiveX/RxJava/issues/1371,[],7226,432,ReactiveX_RxJava_pull_1371.diff
ReactiveX/RxJava,DebugHook got miswired before,"This was throwing ClassCastExceptions when used.  Now it works
",2014-06-17 18:49:25,2014-06-17 19:20:17,https://api.github.com/repos/ReactiveX/RxJava/issues/1369,[],1,1,ReactiveX_RxJava_pull_1369.diff
ReactiveX/RxJava,Fix the bug that 'flatMap' swallows OnErrorNotImplementedException,"Fixed #1365
Not sure if any other place will swallow `OnErrorNotImplementedException` or the fatal errors.
",2014-06-17 05:50:21,2014-06-21 14:25:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1367,[],15,0,ReactiveX_RxJava_pull_1367.diff
ReactiveX/RxJava,"Backpressure-5: Merge, ObserveOn, SubscribeOn, etc","- Mostly functional backpressure with `merge` and `observeOn`.
- Pivot and Parallel operators have issues and unit tests and ignored.
- This is NOT production ready. Need to work on algorithms in merge, data structures and concurrency implementations.

Performance of `flatMap` compared with 0.19:

```
../gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 2 -prof GC rx.usecases.PerfObserveOn.observeOnComputation'
```

Current

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapInt                        1  thrpt         5  1513055.461    35120.889    ops/s
r.u.PerfTransforms.flatMapInt                     1024  thrpt         5     2229.818       50.863    ops/s
r.u.PerfTransforms.flatMapNestedMapFilterTake        1  thrpt         5  1114912.405   137096.910    ops/s
r.u.PerfTransforms.flatMapNestedMapFilterTake     1024  thrpt         5       82.799        1.695    ops/s
```

0.19 master

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapInt                        1  thrpt         5  3372557.564   131729.592    ops/s
r.u.PerfTransforms.flatMapInt                     1024  thrpt         5     6713.975      159.005    ops/s
r.u.PerfTransforms.flatMapNestedMapFilterTake        1  thrpt         5  2231392.499    50190.297    ops/s
r.u.PerfTransforms.flatMapNestedMapFilterTake     1024  thrpt         5       16.437        0.413    ops/s
```

``` java
        input.observable.flatMap(i -> {
            return Observable.from(i);
        }).subscribe(input.observer);
```

Current

```
Run: 10 - 1,697,014 ops/sec
Run: 11 - 1,675,210 ops/sec
Run: 12 - 1,781,483 ops/sec
Run: 13 - 1,674,677 ops/sec
Run: 14 - 1,714,354 ops/sec
```

vs 0.19

```
Run: 10 - 2,809,225 ops/sec
Run: 11 - 3,051,850 ops/sec
Run: 12 - 3,100,006 ops/sec
Run: 13 - 3,007,699 ops/sec
Run: 14 - 3,114,585 ops/sec
```
",2014-06-16 23:51:33,2014-06-18 00:11:52,https://api.github.com/repos/ReactiveX/RxJava/issues/1366,[],6238,372,ReactiveX_RxJava_pull_1366.diff
ReactiveX/RxJava,Fix the bug that 'single' may unsubscribe the whole Subscription chain incorrectly,"Decoupled the parent and child Subscribers to fix this bug.
",2014-06-15 10:14:10,2014-06-17 05:57:32,https://api.github.com/repos/ReactiveX/RxJava/issues/1363,[],57,9,ReactiveX_RxJava_pull_1363.diff
ReactiveX/RxJava,RxScala: Fix #1340 and #1343,"- Implement `create` for #1340
- Remove `/*XXX*/` for #1343

/cc @headinthebox, @samuelgruetter
",2014-06-15 07:53:54,2014-06-16 22:59:43,https://api.github.com/repos/ReactiveX/RxJava/issues/1362,[],22,7,ReactiveX_RxJava_pull_1362.diff
ReactiveX/RxJava,Fix a race condition if queued actions have been handled already,"This should fix #1354.

Cc @Bananeweizen @akarnokd
",2014-06-14 23:27:43,2014-06-16 23:04:01,https://api.github.com/repos/ReactiveX/RxJava/issues/1361,[],1,1,ReactiveX_RxJava_pull_1361.diff
ReactiveX/RxJava,Fixed padding of the integer and node classes.,"Added proper padding of MpscLinkedQueue and PaddedAtomicInteger, based on Netty's implementation.

Note that each padded class now occupies 256 bytes (which translates to either 2 or 4 cache lines) to avoid false sharing in both before and after the actual value and to avoid adjacent cache line fetch effects.

For issue #1310 
",2014-06-13 07:23:58,2014-06-13 16:16:05,https://api.github.com/repos/ReactiveX/RxJava/issues/1359,[],148,62,ReactiveX_RxJava_pull_1359.diff
ReactiveX/RxJava,Backpressure-4: Merge & ObserveOn (Not Production Ready),"Further progress on top of https://github.com/Netflix/RxJava/pull/1351 that adds object pooling (of ring buffers) and various improvements while looking at performance.
- Next is to redo the merge implementation that I'm not happy with.
- Pivot and parallel operators seem broken (concurrency bugs with `merge` I think).
- Still have performance problems.

```
../gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 2 -prof GC rx.usecases.PerfBaseline.*'
```

```
Benchmark                                        (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfBaseline.observableConsumption                1  thrpt         5 29341887.334  1377398.290    ops/s
r.u.PerfBaseline.observableConsumption             1024  thrpt         5   235288.206    36803.980    ops/s
r.u.PerfBaseline.observableViaRange                   1  thrpt         5 10995116.886   851761.135    ops/s
r.u.PerfBaseline.observableViaRange                1024  thrpt         5    83175.180     2983.626    ops/s
```

vs 0.19:

```
Benchmark                                        (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfBaseline.observableConsumption                1  thrpt         5 31394747.471   781746.789    ops/s
r.u.PerfBaseline.observableConsumption             1024  thrpt         5   245864.811     6657.154    ops/s
```
",2014-06-13 06:19:35,2014-06-16 23:51:47,https://api.github.com/repos/ReactiveX/RxJava/issues/1358,[],4250,324,ReactiveX_RxJava_pull_1358.diff
ReactiveX/RxJava,"MergeWith, ConcatWith, AmbWith","Single-arity instance versions of merge, concat and amb.
Since we can't use the `merge`/`concat`/`amb` names on both static and instance methods, these have the `With` suffix, which actually reads quite well.

``` java
o.mergeWith(o2).subscribe(ts);
o.concatWith(o2).subscribe(ts);
o.ambWith(o2).subscribe(ts);
```

If we feel the need for more arities fine, but I wanted to start simple.

This originated from discussions with @headinthebox and over a year of wanting instance methods for `merge`.
",2014-06-12 17:27:42,2014-06-12 17:34:41,https://api.github.com/repos/ReactiveX/RxJava/issues/1357,[],80,1,ReactiveX_RxJava_pull_1357.diff
ReactiveX/RxJava,Don't add the subscriber to the manager if it unsubscribed during the on...,"...Start call

This may happen, for example, when subscribing to a ReplaySubject containing some elements and taking fewer elements than available. In the original, the logic opened a small window where the SubjectSubscriber could get an onNext event even if the actual Subscriber was already unsubscribed at that point.
",2014-06-12 10:28:30,2014-06-12 16:29:48,https://api.github.com/repos/ReactiveX/RxJava/issues/1355,[],4,2,ReactiveX_RxJava_pull_1355.diff
ReactiveX/RxJava,Backpressure-3: Merge & ObserveOn (Not Production Ready),"Here is a snapshot of working on backpressure. This is NOT production ready and I'm not all that happy with it right now.
- bad performance
- pivot and parallel operators seem broken (concurrency bugs with `merge` I think)
- bad algorithm in `merge`
- need to replace data structures (lists/queues)
- apparent memory leak in `observeOn` with `Schedulers.computation()` that causes JMH tests to fail on it

```
../gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 2 -prof GC rx.usecases.*'
```

Master branch (v0.19):

```
Benchmark                                        (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfBaseline.forLoopConsumption                   1  thrpt         5 379615485.594 15379754.350    ops/s
r.u.PerfBaseline.forLoopConsumption                1024  thrpt         5   328864.473    18187.666    ops/s
r.u.PerfBaseline.iterableViaForLoopConsumption        1  thrpt         5 253622547.509 27125669.781    ops/s
r.u.PerfBaseline.iterableViaForLoopConsumption     1024  thrpt         5   188193.794    10372.260    ops/s
r.u.PerfBaseline.iterableViaHasNextConsumption        1  thrpt         5 338153673.244 13436554.726    ops/s
r.u.PerfBaseline.iterableViaHasNextConsumption     1024  thrpt         5   299124.445    28327.383    ops/s
r.u.PerfBaseline.observableConsumption                1  thrpt         5 31394747.471   781746.789    ops/s
r.u.PerfBaseline.observableConsumption             1024  thrpt         5   245864.811     6657.154    ops/s
r.u.PerfObserveOn.observeOnComputation                1  thrpt         5   391499.859    18397.563    ops/s
r.u.PerfObserveOn.observeOnComputation             1024  thrpt         5    13328.636      306.077    ops/s
r.u.PerfObserveOn.observeOnImmediate                  1  thrpt         5 21230728.918   892820.007    ops/s
r.u.PerfObserveOn.observeOnImmediate               1024  thrpt         5   251638.525     3525.681    ops/s
r.u.PerfObserveOn.observeOnNewThread                  1  thrpt         5    21527.805     2739.158    ops/s
r.u.PerfObserveOn.observeOnNewThread               1024  thrpt         5    10020.191      188.225    ops/s
r.u.PerfTransforms.flatMapInt                         1  thrpt         5  3564189.441    39217.324    ops/s
r.u.PerfTransforms.flatMapInt                      1024  thrpt         5     7093.382      179.934    ops/s
r.u.PerfTransforms.flatMapNestedMapFilterTake         1  thrpt         5  2292314.964   137546.825    ops/s
r.u.PerfTransforms.flatMapNestedMapFilterTake      1024  thrpt         5       17.375        0.430    ops/s
r.u.PerfTransforms.mapIntStringInt                    1  thrpt         5  9653977.591   122946.457    ops/s
r.u.PerfTransforms.mapIntStringInt                 1024  thrpt         5    19772.989     1649.906    ops/s
r.u.PerfTransforms.mapPassThru                        1  thrpt         5 19220291.170  1408394.928    ops/s
r.u.PerfTransforms.mapPassThru                     1024  thrpt         5   202820.081    27896.934    ops/s
```

With backpressure changes:

```
Benchmark                                        (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfBaseline.forLoopConsumption                   1  thrpt         5 357110005.600 40841385.201    ops/s
r.u.PerfBaseline.forLoopConsumption                1024  thrpt         5   323485.335    12560.808    ops/s
r.u.PerfBaseline.iterableViaForLoopConsumption        1  thrpt         5 250763283.151 41052831.579    ops/s
r.u.PerfBaseline.iterableViaForLoopConsumption     1024  thrpt         5   184443.933    17732.768    ops/s
r.u.PerfBaseline.iterableViaHasNextConsumption        1  thrpt         5 328354319.566 20021232.226    ops/s
r.u.PerfBaseline.iterableViaHasNextConsumption     1024  thrpt         5   295521.735    60981.106    ops/s
r.u.PerfBaseline.observableConsumption                1  thrpt         5  9523326.320  1946455.684    ops/s     9.5m vs 31.3m
r.u.PerfBaseline.observableConsumption             1024  thrpt         5    84990.974     4275.619    ops/s
r.u.PerfObserveOn.observeOnComputation                1  thrpt         5   367281.334    88162.113    ops/s     367k vs 391k
r.u.PerfObserveOn.observeOnComputation             1024  thrpt         failed (ran out of memory apparently, see below)
r.u.PerfObserveOn.observeOnImmediate                  1  thrpt         5  7411354.828  1380680.011    ops/s     7.4m vs 21.2m
r.u.PerfObserveOn.observeOnImmediate               1024  thrpt         5    83914.883     6175.528    ops/s
r.u.PerfObserveOn.observeOnNewThread                  1  thrpt         5    21795.495      696.339    ops/s     21.7k vs 21.5k
r.u.PerfObserveOn.observeOnNewThread               1024  thrpt         5    15361.160     1052.314    ops/s     15.3k vs 10k
r.u.PerfTransforms.flatMapInt                         1  thrpt         5  1194526.066    91077.184    ops/s     1.2m vs 3.6m
r.u.PerfTransforms.flatMapInt                      1024  thrpt         5     1799.220       70.146    ops/s
r.u.PerfTransforms.flatMapNestedMapFilterTake         1  thrpt         5   858432.448   135990.002    ops/s     858k vs 2292k
r.u.PerfTransforms.flatMapNestedMapFilterTake      1024  thrpt         5       45.345        1.928    ops/s     17 vs 45 (something is wrong here on both)
r.u.PerfTransforms.mapIntStringInt                    1  thrpt         5  4433584.545  1336597.807    ops/s     4.4m vs 9.6m
r.u.PerfTransforms.mapIntStringInt                 1024  thrpt         5    17271.313      881.956    ops/s
r.u.PerfTransforms.mapPassThru                        1  thrpt         5  6098106.967   526635.319    ops/s     6.1m vs 19.2m
r.u.PerfTransforms.mapPassThru                     1024  thrpt         5    81472.209     5419.922    ops/s


r.u.PerfObserveOn.observeOnComputation with size 1024

Iteration   1: 1052.083 ops/s
          GC | wall time = 2.952 secs,  GC time = 2.945 secs, GC% = 99.76%, GC count = +3
             |

Iteration   2: 161.619 ops/s
          GC | wall time = 2.766 secs,  GC time = 2.765 secs, GC% = 99.96%, GC count = +3
             |
```
",2014-06-11 03:54:21,2014-06-13 06:19:58,https://api.github.com/repos/ReactiveX/RxJava/issues/1351,[],3254,285,ReactiveX_RxJava_pull_1351.diff
ReactiveX/RxJava,Baseline Performance Tests,"Start of suite of general performance tests for comparing overall changes.
",2014-06-11 02:48:26,2014-06-11 02:50:30,https://api.github.com/repos/ReactiveX/RxJava/issues/1350,[],94,4,ReactiveX_RxJava_pull_1350.diff
ReactiveX/RxJava,Allow use of the returned subscription to cancel periodic scheduling,"The documentation for schedulePeriodically indicates that the returned
subscription can be used to unsubscribe from the periodic action, or to
unschedule it if it has not been scheduled yet. That was the case only
before the first action took place, and it was then impossible to
unsubscribe using the given subscription, although unsubscribing the
worker did work.

This fixes #1344.
",2014-06-10 07:21:39,2014-06-12 16:31:06,https://api.github.com/repos/ReactiveX/RxJava/issues/1347,[],69,3,ReactiveX_RxJava_pull_1347.diff
ReactiveX/RxJava,"RxScala: Simplify doOnCompleted/Terminate, finallyDo callback usage","As mentioned in #1342
",2014-06-09 21:45:17,2014-06-12 16:53:58,https://api.github.com/repos/ReactiveX/RxJava/issues/1345,[],19,10,ReactiveX_RxJava_pull_1345.diff
ReactiveX/RxJava,Add capacity hint version of Observable.cache(),"- Special case in ReplaySubject for create(1) to optimize for single emitted value
- Add unit tests for Observable.cache(1) and ReplaySubject.create(1)

@benjchristensen is this the kind of solution you wanted for #1303?
",2014-06-08 13:28:56,2014-07-22 09:32:40,https://api.github.com/repos/ReactiveX/RxJava/issues/1338,[],336,16,ReactiveX_RxJava_pull_1338.diff
ReactiveX/RxJava,Make Future receive NoSuchElementException when the BlockingObservable is empty,"Now `Future.get` will return `null` if there is a single `null` in the BlockingObservable, or it is empty. People cannot distinguish between these two cases.

This PR has 2 breaking changes:
- Throw an `NoSuchElementException` rather than returning `null` when the BlockingObservable is empty.
- Change the exception from `IllegalStateException` to `IllegalArgumentException` when the BlockingObservable emits more than one items. This is because I used `single` directly.
",2014-06-08 10:15:36,2014-06-12 16:48:13,https://api.github.com/repos/ReactiveX/RxJava/issues/1337,[],38,13,ReactiveX_RxJava_pull_1337.diff
ReactiveX/RxJava,RxScala: Add the rest missing methods to BlockingObservable,"Some comments about this PR:
- Changed the constructor from `BlockingObservable[+T] private[scala] (val asJava: rx.observables.BlockingObservable[_ <: T])` to `BlockingObservable[+T] private[scala] (val o: Observable[T])` so that we can implement logic in `BlockingObservable`.
- Avoided to use `toIterable` to implement `***Option` and `***OrElse` because if some exception happens, we can not unsubscribe the underlying `Observable` by `Iterable` at once.

/cc @headinthebox, @samuelgruetter
",2014-06-08 08:16:46,2014-06-16 23:00:55,https://api.github.com/repos/ReactiveX/RxJava/issues/1336,[],301,31,ReactiveX_RxJava_pull_1336.diff
ReactiveX/RxJava,Bump build tools to 19.1 and android plugin to 0.11,"This is to make the project compatible with Android Studio 0.6.x (the latest release)
",2014-06-07 14:41:25,2014-06-12 16:44:41,https://api.github.com/repos/ReactiveX/RxJava/issues/1335,[],4,4,ReactiveX_RxJava_pull_1335.diff
ReactiveX/RxJava,Merge pull request #1 from Netflix/master,"Remote sync
",2014-06-06 16:21:22,2014-06-06 16:21:35,https://api.github.com/repos/ReactiveX/RxJava/issues/1333,[],0,0,ReactiveX_RxJava_pull_1333.diff
ReactiveX/RxJava,IOSSchedulers for RoboVM,"Added support for IOSchedulers for RoboVM

I haven't added unit tests as 
1) they can't be automated
2) they require the simulator
It sucks, I know and I'm working on a way to automate this.

Apologies for the double PR -- had to rebranch
",2014-06-06 05:48:02,2014-06-25 17:11:28,https://api.github.com/repos/ReactiveX/RxJava/issues/1332,[],332,0,ReactiveX_RxJava_pull_1332.diff
ReactiveX/RxJava,Adding an unzip operator to split 1 observable into N observables.,"This isn't ready for merging but should work for #1317.  It's a naive implementation that bases the N observables off of ReplaySubject of the source.
",2014-06-05 18:06:20,2014-06-06 19:29:45,https://api.github.com/repos/ReactiveX/RxJava/issues/1330,[],138,0,ReactiveX_RxJava_pull_1330.diff
ReactiveX/RxJava,Join patterns extension for 4..9 and N arity joins.,"Issue #1318

I made some potential breaking changes:
- made classes final
- made most methods protected or package private
",2014-06-05 10:45:50,2014-06-12 16:43:23,https://api.github.com/repos/ReactiveX/RxJava/issues/1327,[],3333,264,ReactiveX_RxJava_pull_1327.diff
ReactiveX/RxJava,"Added overload for retry to accept a Func1<Obs, Obs>","Implemented a new overload for Retry operator that accepts a `Func1<Observable<Notification>>, Observable<?>>` for determining retry behavior and reimplemented the existing retry overloads in terms of the new overload. I intend for this change to allow for implementing clean-up logic on notification of a failure prior to the retry behavior as well as expressive functional retry logic. 
",2014-06-05 07:03:05,2014-07-24 07:43:33,https://api.github.com/repos/ReactiveX/RxJava/issues/1326,[],675,334,ReactiveX_RxJava_pull_1326.diff
ReactiveX/RxJava,"PREVIEW-1 => Backpressure: Subscriber, Producer & ObserveOn","This is the first round of dev on backpressure and not even close to final. I am publishing as PR for collaboration. /cc @headinthebox @abersnaze @akarnokd 
- 2 unit tests are failing as the sources don't yet support backpressure.
- There are stray printlns throughout code still.
- I have not yet attempted `merge` though I have a general strategy in mind. It is most likely my next thing to work on.
- I have not looked at performance impact at all.
- All names and object models are open to change.
- I've got `Atomic*` uses that need to become `*FieldUpdaters`
- Several TODOs showing where improvements need to be made, such as a proper ring-buffer implementation.

What to look at:
- `Subscriber` -> the `request` and `setProducer` methods
- `OnSubscribeFromIterable`
- `OperatorObserveOn`
- `RxSpscRingBuffer`

Work to do:
- the `subscribeOn` operator needs to decorate `setProducer` to compose the scheduling of starting up the `Producer` again
- `merge`
- backpressure operators such as `onBackpressureDrop`, `onBackpressureBuffer`, `onBackpressureUnsubscribe`, `onBackpressureSample/Throttle/etc`
- unit tests for various use cases
- performance and memory allocation testing
- prove with Netty channels
- determine if there are any use cases that will kill this ...
  - for example, the `filter` operator must take `request` into account otherwise when it filters out events they won't propagate and then `request` may never get called again and the chain hangs
  - there are likely other scenarios like `take` ... and some I'm concerned are nuanced
",2014-06-05 05:04:53,2014-06-11 03:54:48,https://api.github.com/repos/ReactiveX/RxJava/issues/1325,[],2323,271,ReactiveX_RxJava_pull_1325.diff
ReactiveX/RxJava,TrampolineScheduler & Unsubscribe,"Unsubscribing should prevent new additions to a Worker, but not prevent already scheduled work, and definitely not affect other Workers using the same thread (by modifying the ThreadLocal as it was doing).

See the unit test for details of how unsubscribing 1 Worker could prevent work from being done on a completely separate Worker.
",2014-06-04 23:09:35,2014-06-04 23:09:38,https://api.github.com/repos/ReactiveX/RxJava/issues/1324,[],64,4,ReactiveX_RxJava_pull_1324.diff
ReactiveX/RxJava,Ensuring Runnables posted with delay to a Handler are removed when unsub...,"...scribed.

This patch ensures the delayed runnables posted to a Handler are properly
removed when Subscription.unsubscribe() is called on the Observable.

The original code returns the subscription from schedule() but is not used
by the callers who instead add the Worker itself as a subsciption.

Signed-off-by: David Marques dpsmarques@gmail.com
",2014-06-04 16:34:46,2014-06-12 16:33:42,https://api.github.com/repos/ReactiveX/RxJava/issues/1321,[],71,27,ReactiveX_RxJava_pull_1321.diff
ReactiveX/RxJava,Add the rest operators to RxScala,"This PR added the rest operators to RxScala. However, I think some operators in rxjava-math, rxjava-string , such as `min`, `max`, `average`, are worth to add to RxScala. What do you think? @headinthebox, @samuelgruetter
",2014-06-04 14:07:27,2014-06-08 15:41:20,https://api.github.com/repos/ReactiveX/RxJava/issues/1316,[],681,2,ReactiveX_RxJava_pull_1316.diff
ReactiveX/RxJava,Tiny integration test change,"It's a tiny change.

I've been following this project for a while as a hobby, also want to contribute to it. 

Currently I am going through test cases to learn. Found some tiny problems as we are testing ""concat"", we should care not only the total number of elements, but also the sequences.

Creating this request mainly want to make sure I am writing/commiting code to the correct place.

Let me know if there is any problem.

Best Regards,
Mingtao
",2014-06-03 23:16:34,2014-06-04 16:38:31,https://api.github.com/repos/ReactiveX/RxJava/issues/1311,[],53,19,ReactiveX_RxJava_pull_1311.diff
ReactiveX/RxJava,Hide ChainedSubscription/SubscriptionList from Public API,"Instead of adding this type to the public API, it hides it as an internal implementation detail and does not expose it via the `Subscriber` constructor.

If we want to expose it later we can figure out a proper name and do so.

This also changes operator implementations to not inject a `SubscriptionList` but instead just create the `Subscriber` and use it directly.
",2014-06-03 05:35:44,2014-06-03 16:08:45,https://api.github.com/repos/ReactiveX/RxJava/issues/1309,[],69,82,ReactiveX_RxJava_pull_1309.diff
ReactiveX/RxJava,ChainedSubscription -> SubscriptionList,"This matches the name decided upon in 0.18.4
",2014-06-02 23:04:48,2014-06-03 16:09:06,https://api.github.com/repos/ReactiveX/RxJava/issues/1308,[],29,29,ReactiveX_RxJava_pull_1308.diff
ReactiveX/RxJava,testNotificationDelay - Attempt at determinism,"Trying to make this deterministic ... I think it was possible for scheduling in the Executor to cause different threads to be used, even when queueing happened. This forces the same thread to be used as it is different Executors.
",2014-06-02 22:36:08,2014-06-02 22:36:11,https://api.github.com/repos/ReactiveX/RxJava/issues/1307,[],6,4,ReactiveX_RxJava_pull_1307.diff
ReactiveX/RxJava,Hooked RxJavaPlugins errorHandler up within all operators that swallow onErrors,"Otherwise, the only onErrors visible to RxJavaPlugins.errorHandler plugin are the ones which propagate all the way to SafeSubscriber.
",2014-06-02 21:27:52,2014-06-02 23:53:10,https://api.github.com/repos/ReactiveX/RxJava/issues/1306,[],14,0,ReactiveX_RxJava_pull_1306.diff
ReactiveX/RxJava,Checked Exceptions,"This pull request:
- makes the Rx user's code cleaner.
- removes the necessity for wrapping all checked `Exception`s with `RuntimeException`s.
- is not a breaking change.
- lets the compiler help us find places where we've made mistakes.

It's benefit is more obvious in Java 8. before:

```
() -> {
    try {
        return new FileReader(file);
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
```

after:

```
() -> new FileReader(file)
```

I made a new set of interfaces `Func<0..9,N>Checked` and `Action<0..9,N>Checked`.  The original `Func<0..9,N>` and `Action<0..9,N>` now extend from the checked version but remove the `throws Exception`.  Anywhere an observable operator already invokes `Func`s or `Action`s and already wraps that call in the try catch to handle Throwables than the checked version can be woven through.

I've also included a sample change where I used `Func1Checked` for `Observable::map(f)`.
",2014-06-02 17:17:00,2014-07-08 19:57:21,https://api.github.com/repos/ReactiveX/RxJava/issues/1305,[],584,78,ReactiveX_RxJava_pull_1305.diff
ReactiveX/RxJava,Add flatMap and concatMap to RxScala,"For #1251

/cc @headinthebox, @samuelgruetter
",2014-06-02 14:57:16,2014-06-02 16:01:44,https://api.github.com/repos/ReactiveX/RxJava/issues/1304,[],181,0,ReactiveX_RxJava_pull_1304.diff
ReactiveX/RxJava,improve variable names in OperatorGroupBy,"renamed `childObserver` to `child` as is now a `Subscriber`, `gps` to `group`,`_gps` to `_group` (gps implies multiple but is not).
",2014-06-01 02:00:25,2014-06-02 18:30:53,https://api.github.com/repos/ReactiveX/RxJava/issues/1302,[],19,19,ReactiveX_RxJava_pull_1302.diff
ReactiveX/RxJava,RxScala: Add convenience method for adding unsubscription callback,"Implements enhancement detailed in #1258. Now with less git screw ups.
",2014-05-31 16:21:17,2014-06-01 15:04:10,https://api.github.com/repos/ReactiveX/RxJava/issues/1301,[],24,0,ReactiveX_RxJava_pull_1301.diff
ReactiveX/RxJava,RxScala: Add convenience method for adding unsubscription callback,"Implements enhancement detailed in #1258
",2014-05-31 11:09:06,2014-05-31 16:03:54,https://api.github.com/repos/ReactiveX/RxJava/issues/1300,[],24,0,ReactiveX_RxJava_pull_1300.diff
ReactiveX/RxJava,Remove Bad Perf Test,"- this just stresses scheduling and at this throughput creates massive garbage and tests the wrong thing
",2014-05-31 05:23:10,2014-05-31 05:23:14,https://api.github.com/repos/ReactiveX/RxJava/issues/1298,[],0,13,ReactiveX_RxJava_pull_1298.diff
ReactiveX/RxJava,[RxScala] rxjava-scalaz: providing some type class instances.,"Introduced 'rxjava-scalaz' project. This project provides some type class instances for Observable.
- _Monoid_: <br/>Observable obviously forms a monoid in terms of concatenation.
- _Functor, Applicative, Monad, MonadPlus_: <br/>Observable can be a Stream-like Monad and can be MonadPlus as well as Monoid.
- _Traverse, Foldable_: <br/>Observable can be Stream-like traversable.  Please note that the operations for the instance is blocking calls.
- etc.

About testing, property based tests are applied by Scalaz's ScalaCheck binding.
For getting started, please refer to rx.java.scala.scalaz.examples.RxScalazDemo, or README.md.
### Sample Usages

``` scala
import scalaz._, Scalaz._
import rx.lang.scala.Observable
import rx.lang.scala.scalaz._

Observable.items(1, 2) |+| Observable.items(3, 4)               // === Observable.items(1 2 3 4)
Observable.items(1, 2) ∘ {_ + 1}                                // === Observable.items(2, 3)
(Observable.items(1, 2) |@| Observable.items(3, 4)) {_ + _}     // === Observable.items(4, 5, 5, 6)
1.η[Observable]                                                 // === Observable.items(1)
(Observable.items(3) >>= {(i: Int) => Observable.items(i + 1)}) // === Observable.items(4)
```

_My original proposal is #1167_
",2014-05-31 03:25:59,2014-06-25 17:11:37,https://api.github.com/repos/ReactiveX/RxJava/issues/1297,[],571,1,ReactiveX_RxJava_pull_1297.diff
ReactiveX/RxJava,Move re-used internal Scheduler classes to their own package,"As discussed in #1294
",2014-05-30 23:29:25,2014-05-30 23:56:54,https://api.github.com/repos/ReactiveX/RxJava/issues/1296,[],233,169,ReactiveX_RxJava_pull_1296.diff
ReactiveX/RxJava,Change `void accept` to `boolean accept`,"As per a change @akarnokd did elsewhere with `accept2` method.
",2014-05-30 21:10:11,2014-05-30 21:14:09,https://api.github.com/repos/ReactiveX/RxJava/issues/1295,[],12,14,ReactiveX_RxJava_pull_1295.diff
ReactiveX/RxJava,rx.operators -> rx.internal.operators,"Move `rx.operators` to `rx.internal.operators` for clarity that these can change at any time and are not part of the public API.

Discussed at https://github.com/Netflix/RxJava/issues/1270#issuecomment-44668606
",2014-05-30 19:05:09,2014-05-30 19:05:14,https://api.github.com/repos/ReactiveX/RxJava/issues/1294,[],230,219,ReactiveX_RxJava_pull_1294.diff
ReactiveX/RxJava,Fix and Update JMH Perf Tests,"- The tests were wrong and re-using a single Subscriber instance which meant they weren't really testing much.
- Same with the CountDownLatch which meant they weren't waiting if async.
- Added several SerializePerf and PerfTransform tests
",2014-05-30 18:54:59,2014-05-30 18:55:02,https://api.github.com/repos/ReactiveX/RxJava/issues/1293,[],134,44,ReactiveX_RxJava_pull_1293.diff
ReactiveX/RxJava,Check unsubscribe within observable from future,"Right now, Observable.from(Future f) emits onError(CancellationException) when f starts out in a cancelled state. This change makes Observable.from(f) emit nothing in this case, and also when an unsubscribe occurs during a Future.get() that results in an Exception.
",2014-05-30 17:02:41,2014-05-30 18:55:48,https://api.github.com/repos/ReactiveX/RxJava/issues/1291,[],77,0,ReactiveX_RxJava_pull_1291.diff
ReactiveX/RxJava,Upgrade to JMH 0.7.3,"As per https://github.com/Netflix/RxJava/issues/1205
",2014-05-30 16:56:54,2014-05-30 16:57:01,https://api.github.com/repos/ReactiveX/RxJava/issues/1290,[],8,35,ReactiveX_RxJava_pull_1290.diff
ReactiveX/RxJava,Schedulers.from(Executor),"As per decision at https://github.com/Netflix/RxJava/issues/1219#issuecomment-44454729
",2014-05-30 16:48:50,2014-05-30 16:48:53,https://api.github.com/repos/ReactiveX/RxJava/issues/1289,[],2,2,ReactiveX_RxJava_pull_1289.diff
ReactiveX/RxJava,Ensure StringObservable.from() does not perform unnecessary read ,"An extra check is useful to check for unsubscription because as is even `StringObservable.from(InputStream).first()` performs two reads and the second read may block. 

Added another check just before the `InputStream.read()` and simplified the initialization of `n`.
",2014-05-30 11:40:01,2014-05-30 16:07:43,https://api.github.com/repos/ReactiveX/RxJava/issues/1288,[],20,3,ReactiveX_RxJava_pull_1288.diff
ReactiveX/RxJava,ReplaySubject remove replayState CHM and related SubjectObserver changes,"For issue #1204

This change should help avoid CHM garbage (although boxed Integers will still fly around). In addition, I moved the NotificationLite around to make room for the index. I've also removed the callback onAdd in PublishSubject because it was unnecessary.
",2014-05-30 09:11:57,2014-05-30 16:40:10,https://api.github.com/repos/ReactiveX/RxJava/issues/1287,[],59,81,ReactiveX_RxJava_pull_1287.diff
ReactiveX/RxJava,Rename some Operator* classes to OnSubscribe* as per #1270,"See discussion in issue #1270. 

Numerous classes in the `rx.operator` package are not implementations of `Operator` but are actually implementations of `OnSubscribe`. The classes have been renamed in this pull request.

Excuse me not squashing commits, looked complicated after doing a pull from upstream in the middle.
",2014-05-30 07:47:22,2014-05-30 16:08:39,https://api.github.com/repos/ReactiveX/RxJava/issues/1286,[],85,85,ReactiveX_RxJava_pull_1286.diff
ReactiveX/RxJava,"Manual merge of Lock-free, MPSC-queue based","Pulling in the MPSC queue from https://github.com/Netflix/RxJava/pull/1235. Leaving out the SerializedObserver change until further analysis. Getting this data structure in as we likely want to use it in other places.

Moved it into rx.internal.util and added a README so it is very clear this is an internal package and not part of the public API.
",2014-05-29 22:50:29,2014-05-29 22:53:31,https://api.github.com/repos/ReactiveX/RxJava/issues/1284,[],188,0,ReactiveX_RxJava_pull_1284.diff
ReactiveX/RxJava,Reduce Subscription Object Allocation,"- significant reduction in object allocations
- details on research available at https://github.com/Netflix/RxJava/issues/1204
",2014-05-29 22:19:14,2014-05-29 22:22:53,https://api.github.com/repos/ReactiveX/RxJava/issues/1283,[],470,126,ReactiveX_RxJava_pull_1283.diff
ReactiveX/RxJava,utility function for creating observables for closeable resources,"#1199 the answer to the issue was nagging at me when I tried to recommend it recently.  I think @zsxwing's solution was ok but would fail if there were repeated subscriptions to the observable returned.  I created a utility function on StringObservable to make it easier to use `using()` for objects that implement the `AutoCloseable` interface.

PS. I made a breaking change to arguments of `join(Observable<Object>)` to `join(Observable<String>)` and added a `Observable<String> toString(Observable<Object>)` to make up for it.

PPS. I made a `UnsafeFunc0<R>` scoped to this class but I would like to have `UnsafeFunc<N>` in the rx.functions packages and have `Func<N>` extends `UnsafeFunc<N>`.   Makes it clear to the compiler that we don't expect the code the user's are giving us to always work. This also helps the users because they don't have to always fill their closures with try catch blocks

```
() -> new FileReader(file)
```

vs.

```
() -> {
    try {
        return new FileReader(file);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
```
",2014-05-29 21:49:04,2014-07-08 19:58:44,https://api.github.com/repos/ReactiveX/RxJava/issues/1282,[],232,45,ReactiveX_RxJava_pull_1282.diff
ReactiveX/RxJava,Reduce Subscription Object Allocation,"### Changes
- rewrite of `CompositeSubscription` and added `ChainedSubscription`
- significant reduction in object allocations
- details on research available at https://github.com/Netflix/RxJava/issues/1204
##### Atomic State Machine -> Mutation & Locks

The `CompositeSubscription` implementation was changed from using an atomic state machine to using locks. The state machine requires immutable `State` that is swapped using CAS. This means an object allocation is needed each time.

It now uses locks to protect mutable state so very few objects are created.
##### ChainedSubscription

The `CompositeSubscription` requires support of randomly removing a `Subscription` via the `remove` method. The `Subscriber` type does not expose this so can be optimized. There is now a `ChainedSubscription` that is used by `Subscriber` instead. This allows using a `LinkedList` or `ArrayList` rather than `HashSet` as random access is never needed. This provides a slight performance boost and reduces memory usage (1 minute test shows 16.5GB allocation for `Composite` versus 14.4GC for `Chained`).
### Allocation Comparison

This shows Java Flight Recorder output from master without these changes:

![master-without-changing-compositesubscription](https://cloud.githubusercontent.com/assets/813492/3122035/66ea4e22-e762-11e3-8915-5aead429e120.png)

This shows object allocation after changing `CompositeSubscription`:

![master-with-new-compositesubscription ong](https://cloud.githubusercontent.com/assets/813492/3122195/9f3641bc-e764-11e3-930f-845efc99b84a.png)
### Throughput Comparison

Testing this code:

``` java
    public void mapTransformation(UseCaseInput input) throws InterruptedException {
        input.observable.map(i -> {
            return String.valueOf(i);

        }).map(i -> {
            return Integer.parseInt(i);
        }).subscribe(input.observer);
        input.awaitCompletion();
    }
```
##### Rx 0.16.1

```
Run: 10 - 2,879,355 ops/sec 
Run: 11 - 3,236,245 ops/sec 
Run: 12 - 4,468,275 ops/sec 
Run: 13 - 3,237,293 ops/sec 
Run: 14 - 4,683,840 ops/sec 
```
##### Rx 0.17.6 - using OnSubscribeFunc

```
Run: 10 - 3,621,876 ops/sec 
Run: 11 - 6,702,412 ops/sec 
Run: 12 - 7,401,924 ops/sec 
Run: 13 - 6,653,359 ops/sec 
Run: 14 - 5,834,305 ops/sec 
```
##### Rx 0.17.6 - using OnSubscribe

```
Run: 10 - 3,320,053 ops/sec 
Run: 11 - 4,520,795 ops/sec 
Run: 12 - 7,107,320 ops/sec 
Run: 13 - 5,089,058 ops/sec 
Run: 14 - 5,534,034 ops/sec 

Run: 10 - 4,930,966 ops/sec 
Run: 11 - 6,119,951 ops/sec 
Run: 12 - 7,062,146 ops/sec 
Run: 13 - 6,514,657 ops/sec 
Run: 14 - 6,369,426 ops/sec 
```
##### Rx 0.18.3 - using OnSubscribe

```
Run: 10 - 4,178,854 ops/sec 
Run: 11 - 4,446,420 ops/sec 
Run: 12 - 5,458,515 ops/sec 
Run: 13 - 8,006,405 ops/sec 
Run: 14 - 7,849,293 ops/sec 

Run: 10 - 4,145,936 ops/sec 
Run: 11 - 6,553,079 ops/sec 
Run: 12 - 7,645,259 ops/sec 
Run: 13 - 7,385,524 ops/sec 
Run: 14 - 7,830,853 ops/sec 
```
##### Rx 0.19 master - CompositeSubscription state machine

```
Run: 10 - 10,576,302 ops/sec 
Run: 11 - 10,518,786 ops/sec 
Run: 12 - 10,554,646 ops/sec 
Run: 13 - 10,314,063 ops/sec 
Run: 14 - 10,666,439 ops/sec 
```
##### Rx 0.19 master - CompositeSubscription with synchronized HashSet

```
Run: 10 - 9,949,060 ops/sec 
Run: 11 - 10,122,379 ops/sec 
Run: 12 - 10,018,032 ops/sec 
Run: 13 - 10,072,522 ops/sec 
Run: 14 - 10,132,636 ops/sec 
```
##### Rx 0.19 master - ChainedSubscription with synchronized ArrayList

```
Run: 10 - 11,086,351 ops/sec 
Run: 11 - 10,932,426 ops/sec 
Run: 12 - 11,002,431 ops/sec 
Run: 13 - 10,888,620 ops/sec 
Run: 14 - 11,157,227 ops/sec 

Run: 10 - 9,371,192 ops/sec 
Run: 11 - 9,829,169 ops/sec 
Run: 12 - 10,139,005 ops/sec 
Run: 13 - 10,099,785 ops/sec 
Run: 14 - 10,017,631 ops/sec 
```
##### Rx 0.19 master - ChainedSubscription with synchronized LinkedList

```
Run: 10 - 10,619,431 ops/sec 
Run: 11 - 11,063,293 ops/sec 
Run: 12 - 11,001,463 ops/sec 
Run: 13 - 11,054,243 ops/sec 
Run: 14 - 10,898,826 ops/sec 

Run: 10 - 10,075,465 ops/sec 
Run: 11 - 9,780,716 ops/sec 
Run: 12 - 9,885,134 ops/sec 
Run: 13 - 9,584,143 ops/sec 
Run: 14 - 10,000,700 ops/sec 
```
",2014-05-29 19:14:50,2014-05-29 22:21:47,https://api.github.com/repos/ReactiveX/RxJava/issues/1281,[],471,127,ReactiveX_RxJava_pull_1281.diff
ReactiveX/RxJava,Re-submission of CachedThreadScheduler,"Merged in the latest from the master branch and refactored some internals in CachedThreadScheduler to better match the latest `Scheduler` changes. Aimed at solving #1140
",2014-05-28 20:27:56,2014-05-30 16:27:39,https://api.github.com/repos/ReactiveX/RxJava/issues/1276,[],232,37,ReactiveX_RxJava_pull_1276.diff
ReactiveX/RxJava,Fix Encoding/Formatting,"The encoding on these files is not liked by Git and it is forcing them to be updated.

/cc @akarnokd As you may want to look at your setup ... this happens somewhat often on commits from you.

I believe it is related to these `.gitattribute` settings:

```
# Set default behaviour, in case users don't have core.autocrlf set.
* text=auto

# Explicitly declare text files we want to always be normalized and converted 
# to native line endings on checkout.
*.java text
*.groovy text
*.scala text
*.clj text
*.txt text
*.md text

# Denote all files that are truly binary and should not be modified.
*.png binary
*.jpg binary
```
",2014-05-28 19:57:46,2014-05-28 19:57:50,https://api.github.com/repos/ReactiveX/RxJava/issues/1275,[],214,214,ReactiveX_RxJava_pull_1275.diff
ReactiveX/RxJava,ExecutorScheduler to wrap an Executor,"For issue #1219 (and #1206)

This implementation should conform with the Scheduler contract except it is not possible to avoid thread-hopping (don't worry, the tasks execute serially, but maybe not on the same physical thread).

Few open improvement possibilities:
- Usage of `MpscLinkedQueue` once available.
- A better performing subscription container for this kind of queue-drain task tracking instead of `CompositeSubscription`.
- Ability to remove a `Subscription` from a `CompositeSubscription` without it calling unsubscribe on the removed Subscription, á la `MultipleAssignmentSubscription.set()`.
",2014-05-28 09:42:20,2014-05-28 19:33:56,https://api.github.com/repos/ReactiveX/RxJava/issues/1272,[],222,0,ReactiveX_RxJava_pull_1272.diff
ReactiveX/RxJava,Operator Retry with predicate,"Operator Retry with predicate + 1 overload for Issue #1214.

The Func1 version is simply named `retry`, the Func2 version is named `retryIf` due to lack of ideas and because to avoid overload resolution issues. I also had to open up the OperatorRetryTest classes a bit.
",2014-05-28 08:03:24,2014-05-28 21:47:30,https://api.github.com/repos/ReactiveX/RxJava/issues/1271,[],408,6,ReactiveX_RxJava_pull_1271.diff
ReactiveX/RxJava,Fix the bug that int overflow can bypass the range check,"Fix the bug mentioned in #1266
",2014-05-28 06:28:30,2014-05-28 19:28:35,https://api.github.com/repos/ReactiveX/RxJava/issues/1269,[],31,2,ReactiveX_RxJava_pull_1269.diff
ReactiveX/RxJava,Cursor observable for Android,"Change version of scala to newest 2.11 for properly work and gradle execution
Add CursorObservable for observing android cursor changes
",2014-05-28 05:56:25,2014-05-28 10:07:22,https://api.github.com/repos/ReactiveX/RxJava/issues/1268,[],604,305,ReactiveX_RxJava_pull_1268.diff
ReactiveX/RxJava,Fix to future cancellation,"Right now, Observable.from(Future f) emits onError(CancellationException) when f starts out in a cancelled state.  This change makes Observable.from(f) emit nothing at all.
",2014-05-27 22:51:36,2014-05-30 18:56:02,https://api.github.com/repos/ReactiveX/RxJava/issues/1267,[],77,0,ReactiveX_RxJava_pull_1267.diff
ReactiveX/RxJava,Add more operators to RxScala,"The commits explain this PR.

In addition, the reason that I changed `window(closings: () => Observable[Any])` to `window(boundary: => Observable[Any])` is `window(boundary: => Observable[Any])` can support both two overloads `window(Observable[U])` and `window(Func0[_ <: Observable[_ <: TClosing]])` in RxJava. 
",2014-05-27 14:24:58,2014-05-29 01:00:44,https://api.github.com/repos/ReactiveX/RxJava/issues/1265,[],453,57,ReactiveX_RxJava_pull_1265.diff
ReactiveX/RxJava,ObserveOn scheduled unsubscription,"Proposed fix for #1241.

Some operators eagerly unsubscribe the chain in case of an error, however, this may prevent the delivery of the onError if it is run through the `observeOn` operator as the worker gets unsubscribed and may or may not reach the point where it emits the onError in the other thread. This change will schedule the unsubscription along with the event delivery and thus ensure that all events sent to observeOn prior to unsubscription will be delivered in the new thread.

Note that this change makes the unsubscription delayed and if event processing is slow in the new thread, it may take a while to happen; the original version just dropped any unprocessed work and thus was faster to terminate.
",2014-05-27 06:57:52,2014-05-28 20:36:27,https://api.github.com/repos/ReactiveX/RxJava/issues/1264,[],66,1,ReactiveX_RxJava_pull_1264.diff
ReactiveX/RxJava,Merge from Netflix,,2014-05-25 11:50:52,2014-05-25 11:50:56,https://api.github.com/repos/ReactiveX/RxJava/issues/1263,[],0,0,ReactiveX_RxJava_pull_1263.diff
ReactiveX/RxJava,Merge from Netflix,,2014-05-25 11:49:29,2014-05-25 11:49:47,https://api.github.com/repos/ReactiveX/RxJava/issues/1262,[],0,0,ReactiveX_RxJava_pull_1262.diff
ReactiveX/RxJava,Merge with Netflix,,2014-05-25 11:45:47,2014-05-25 11:45:56,https://api.github.com/repos/ReactiveX/RxJava/issues/1261,[],0,0,ReactiveX_RxJava_pull_1261.diff
ReactiveX/RxJava,Fix the bug that BlockingObservable.singleOrDefault doesn't call unsubscribe,"`BlockingObservable.singleOrDefault` doesn't call `unsubscribe` when throws `IllegalArgumentException(""Sequence contains too many elements"")`. `testSingleOrDefaultUnsubscribe` proves this bug. 
",2014-05-25 09:48:06,2014-05-27 04:40:11,https://api.github.com/repos/ReactiveX/RxJava/issues/1260,[],35,11,ReactiveX_RxJava_pull_1260.diff
ReactiveX/RxJava,ZipIterable unsubscription fix,"For issue #1253.
",2014-05-23 09:39:55,2014-05-27 02:45:07,https://api.github.com/repos/ReactiveX/RxJava/issues/1254,[],38,2,ReactiveX_RxJava_pull_1254.diff
ReactiveX/RxJava,Fixed testConcurrentOnNextFailsValidation,"The two instructions need to be swapped to make sure woken-up awaiters see the error reliably.
",2014-05-22 18:27:54,2014-05-23 04:21:09,https://api.github.com/repos/ReactiveX/RxJava/issues/1248,[],1,1,ReactiveX_RxJava_pull_1248.diff
ReactiveX/RxJava,"Add zip(iterable, selector) to RxScala","- Add `zip(iterable, selector)` to RxScala
- Use `zip(iterable, selector)` to reimplement `zipWithIndex` to resolve the issue mentioned in #1226

/cc @samuelgruetter
",2014-05-22 15:18:45,2014-05-27 04:38:08,https://api.github.com/repos/ReactiveX/RxJava/issues/1247,[],67,1,ReactiveX_RxJava_pull_1247.diff
ReactiveX/RxJava,Moved to atomic field updaters.,"Replaced the AtomicBoolean, AtomicInteger, AtomicLong and AtomicReference instances with volatile fields and field updaters to save on memory and allocation.

Unfortunately, the Clojure test `chunk_test.clj:test-chunk` fails and I don't know why since I don't understand what it is supposed to do. It appears numbers get lost somehow.
",2014-05-22 11:42:40,2014-05-27 02:18:03,https://api.github.com/repos/ReactiveX/RxJava/issues/1246,[],1048,820,ReactiveX_RxJava_pull_1246.diff
ReactiveX/RxJava,Observable.from(T) using Observable.just(T),"For code like `Observable.from(1)` Improve performance from ~3.9m to 4.5+m ops/second

Before;

```
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  3923845.687    46657.660    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     8924.953     1983.161    ops/s

r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  3623228.857   490894.492    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     9176.330      923.929    ops/s
```

After:

```
Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  4052364.587   100971.234    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5    11682.783      496.656    ops/s

Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units
r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  4700583.987    77742.037    ops/s
r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5    12588.803       58.935    ops/s
```

Using this test:

```
../gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof GC .*PerfTransforms.flatMapTransformsUsingFrom*'
```
",2014-05-22 04:37:18,2014-05-22 04:38:27,https://api.github.com/repos/ReactiveX/RxJava/issues/1244,[],1,3,ReactiveX_RxJava_pull_1244.diff
ReactiveX/RxJava,Remove Subscription Wrapper from Observable.subscribe,"Remove Subscription Wrapper from Observable.subscribe

Performance increase from 7.7m to 8.8m ops/second

Before:

```
Benchmark (size) Mode Samples Mean Mean error Units
r.u.PerfTransforms.mapTransformation 1 thrpt 5 7714453.187 362218.633 ops/s
r.u.PerfTransforms.mapTransformation 1 thrpt 5 7527144.767 497816.471 ops/s
```

After:

```
Benchmark (size) Mode Samples Mean Mean error Units
r.u.PerfTransforms.mapTransformation 1 thrpt 5 8853534.333 183494.242 ops/s
r.u.PerfTransforms.mapTransformation 1 thrpt 5 8806958.403 452595.219 ops/s
```

Test can be run  using:

```
../gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof GC .*PerfTransforms.mapTransformation*'
```
",2014-05-22 04:25:38,2014-05-22 04:25:43,https://api.github.com/repos/ReactiveX/RxJava/issues/1243,[],183,10,ReactiveX_RxJava_pull_1243.diff
ReactiveX/RxJava,Android HandlerThreadScheduler fix (closes #1241),"Some events are not delivered due to race condition around the check to `innerSubscription.isUnsubscribed()` in the posted runnable. It's currently possible for the Handler thread to be delayed enough that innerSubscription becomes unsubscribed, and causing the action not to run.

After cross-checking the code with `NewThreadScheduler`, it seems that the expected behavior is to continue to run the action even if the inner/parent subscription is unsubscribed, and only stop when the outer subscription is unsubscribed (which is already happening with `handler.removeCallbacks(runnable)`).

This fixes #1241.
",2014-05-21 22:31:57,2014-05-23 09:29:23,https://api.github.com/repos/ReactiveX/RxJava/issues/1242,[],4,6,ReactiveX_RxJava_pull_1242.diff
ReactiveX/RxJava,Observable from Func0<Enumeration>,"dealing with `HttpServletRequest` API that returns `Enumeration`s and want to get out of there as fast a possible.  The `Func0` emulates the `Iterable` interface so subsequent subscribes get a fresh `Enumeration`.
",2014-05-21 16:54:06,2014-07-08 20:02:02,https://api.github.com/repos/ReactiveX/RxJava/issues/1240,[],187,0,ReactiveX_RxJava_pull_1240.diff
ReactiveX/RxJava,"Update docs for ""apply"" and add an example","Try to solve #1076. @vchekan, any suggestion?

/cc @headinthebox, @samuelgruetter
",2014-05-21 14:54:57,2014-05-23 04:09:44,https://api.github.com/repos/ReactiveX/RxJava/issues/1239,[],41,4,ReactiveX_RxJava_pull_1239.diff
ReactiveX/RxJava,SafeSubscriber memory reduction,"For #1204. This saves 24 bytes per instance. 
",2014-05-21 12:52:00,2014-05-21 16:43:39,https://api.github.com/repos/ReactiveX/RxJava/issues/1237,[],9,5,ReactiveX_RxJava_pull_1237.diff
ReactiveX/RxJava,CompositeSubscription with atomic field updater,"This PR is aimed at #1204 to reduce unnecessary memory overhead in frequently used classes. This change in `CompositeSubscription` saves about 24 bytes per instance.

In addition, the field updaters may be faster by about 8-15% for small adds and removals. I've changed the implementation of unsubscribe to use getAndSet which leverages platform intrinsics and is usually compiled to a single instruction: this makes unsubscribing a tiny bit faster and thus reducing latency in benchmarks that only pass on single element around.
",2014-05-21 12:34:23,2014-05-21 16:47:43,https://api.github.com/repos/ReactiveX/RxJava/issues/1236,[],23,21,ReactiveX_RxJava_pull_1236.diff
ReactiveX/RxJava,"Lock-free, MPSC-queue based, fast-path serializing Observer.","I've rewritten the `SerializedObserver` to improve performance. It is now lock-free, uses a multiple-producer-single-consumer queue based on Netty's implementation and employs a fast-path logic for single-threaded write-through.

Benchmarked by measuring how fast 500k integers can get through it, if running 1-8 producers at the same time. For a single threaded case, master gives about 18 MOps/s, this implementation gives ~36 MOps/s (would be ~16 MOps/s on the slow path). For producers > 2, master gives ~5.5 MOps/s and this gives ~11.5 MOps/s. For 2 producers, aka 1 producer - 1 consumer, master gives ~4.5 MOps and this gives ~8.5 MOps/s.

The two new class, `PaddedAtomicInteger` and `MpscPaddedQueue` will come in handy with other lock-free structures such as Schedulers, etc. We may consider adding back the `rx.util` or some other sub-package to store these helper classes: they don't need to be part of the public API but can be left `public` to enable cross-package access internally.

Things I learned during the implementation:
- It is worth padding the wip counter to fit a cache line so the constant cache thrashing won't affect the parent class' other fields, most likely.
- Using FieldUpdaters saves space but `sun.misc.Unsafe` can add 8-10% more throughput. To avoid platform issues, I stayed with the FieldUpdaters.
- Using `getAndIncrement` and `decrementAndGet` are intrinsified in Java 8 and are compiled to a single x86 instruction, which generally outperforms any CAS loop. Same is true for the `getAndSet`.
- Padding out the `tail` in the `MpscPaddedQueue` again helps separate producers trashing on the tail and a consumer reading the head. Without it, the throughput would decrease by about ~1.5 MOps/s
- By adding the fast-path logic, the single-threaded throughput increases by a factor of 2 since it avoids an unnecessary enqueue and dequeue and all associated volatile writes. However, if taking the fast-path fails, it incurs extra cost on the slow path for everyone else because of the +1 failed CAS at the start. To fix this case, I've introduced a flag that enables and disables fast-path. To disable the fast path, the active fast path checks if it was able to change wip to zero. If not, it means there was concurrent access and continues on the emission loop path, but disables the fast-path then on. It is basically a detector for concurrent use. Since such concurrent use may be transient, the loop counts how many elements it had to emit, an if it was only 1 or 2, it reenables the fast-path. This limit is the result of trying several values with the benchmark above.
- The fast-path logic has its weak spot in 2 producer case compared to a plain MPSC queue running in SPSC mode; the latter gives about ~11 MOps/s which is better than this implementation's ~8.5 MOps/s. In contrast, the single-treaded use for the plain MPSC is only ~16 MOps/s. Both implementations perform the same if producers > 2. Therefore, I decided it is more worth having an implementation that is weak for 2 producers but otherwise is as good or outperforms the alternatives. Note that if one knows the number of producers up front, one can create a more specialized implementation, but this is not the case with RxJava operators. This may affect `merge` and co which serialize multiple sources. Note however, that if the source speed isn't that high as in the benchmark, this implementation still provide less latency than the alternatives because the fast-path would be most likely open if the source emission is interleaved.
",2014-05-21 12:00:10,2014-05-29 22:53:31,https://api.github.com/repos/ReactiveX/RxJava/issues/1235,[],331,143,ReactiveX_RxJava_pull_1235.diff
ReactiveX/RxJava,Deprecate toBlockingObservable in favor of toBlocking,"As per discussion at https://github.com/Netflix/RxJava/pull/1224#issuecomment-43658284

This will better match `toParallel` and is shorter to use while still being clear as to what is happening.
",2014-05-20 18:13:05,2014-05-20 18:13:15,https://api.github.com/repos/ReactiveX/RxJava/issues/1233,[],125,124,ReactiveX_RxJava_pull_1233.diff
ReactiveX/RxJava,Adopt Limit and ForEach Java 8 Naming Conventions,"As per discussion at https://github.com/Netflix/RxJava/issues/678

Code now can look like this:

``` java
Observable.from(1, 2, 3).limit(2).forEach(System.out::println);
```

as an alias to this:

``` java
Observable.from(1, 2, 3).take(2).subscribe(System.out::println);
```
",2014-05-20 18:08:34,2014-05-20 18:08:52,https://api.github.com/repos/ReactiveX/RxJava/issues/1232,[],83,0,ReactiveX_RxJava_pull_1232.diff
ReactiveX/RxJava,Operator Alias: Share,"As per discussion in #682
",2014-05-20 17:54:11,2014-05-20 17:54:13,https://api.github.com/repos/ReactiveX/RxJava/issues/1231,[],17,0,ReactiveX_RxJava_pull_1231.diff
ReactiveX/RxJava,Remove Ambiguous Subscribe Overloads with Scheduler,"- Fixes https://github.com/Netflix/RxJava/issues/1116
- These should never have been added, the subscribeOn operator already provides this functionality
",2014-05-20 17:47:32,2014-05-20 17:47:35,https://api.github.com/repos/ReactiveX/RxJava/issues/1229,[],2,170,ReactiveX_RxJava_pull_1229.diff
ReactiveX/RxJava,Git Reformats This File,,2014-05-20 17:25:52,2014-05-20 17:25:55,https://api.github.com/repos/ReactiveX/RxJava/issues/1228,[],339,339,ReactiveX_RxJava_pull_1228.diff
ReactiveX/RxJava,"Fix bug in `zipWithIndex` and set `zip(that, selector)` public in RxScala","- The function used in `zipWithIndex` is mutable, which make the Observable cannot be reused. Fixed it using `zip((0 until Int.MaxValue).toObservable)`.
- Make `zip(that, selector)` public and rename to `zipWith`. #1189

/cc @headinthebox, @samuelgruetter  
",2014-05-20 16:02:32,2014-05-20 16:09:11,https://api.github.com/repos/ReactiveX/RxJava/issues/1226,[],11,6,ReactiveX_RxJava_pull_1226.diff
ReactiveX/RxJava,Implement shorter toBlocking as shorter alias for toBlockingObservable.,"Fixes #1220
",2014-05-20 12:51:12,2014-05-20 16:22:03,https://api.github.com/repos/ReactiveX/RxJava/issues/1224,[],12,0,ReactiveX_RxJava_pull_1224.diff
ReactiveX/RxJava,ReplaySubject enhancement with time and/or size bounds,"Reapplied the enhancements to bring size and/or time bound `ReplaySubject` capabilities while exposing a single subject class (i.e., no separate BoundedReplaySubject or CustomReplaySubject). It now uses the renewed `SubjectSubscriptionManager`.

In addition, I've moved a confusing behavior from SubjectObserver into AsyncSubject where it belongs.
",2014-05-20 10:37:20,2014-05-20 16:25:09,https://api.github.com/repos/ReactiveX/RxJava/issues/1223,[],1178,896,ReactiveX_RxJava_pull_1223.diff
ReactiveX/RxJava,Exposing PublishSubject,"All other subjects (Async, Behavior, Replay) have non-private companion objects.
",2014-05-19 19:03:44,2014-05-20 04:08:18,https://api.github.com/repos/ReactiveX/RxJava/issues/1216,[],1,1,ReactiveX_RxJava_pull_1216.diff
ReactiveX/RxJava,Time and/or size bounded ReplaySubject extensions,"ReplaySubject with time and/or size bounds.

I've implemented this so that there is no need for a separate BoundedReplaySubject or CustomReplaySubject.

(The previous PR was messed up a bit after the merge with main.)
",2014-05-19 06:36:36,2014-05-20 08:38:54,https://api.github.com/repos/ReactiveX/RxJava/issues/1211,[],1224,927,ReactiveX_RxJava_pull_1211.diff
ReactiveX/RxJava,Add more operators to RxScala,"Conflicts against #1178, too. I will rebase once #1178 is merged to master.

/cc @samuelgruetter
",2014-05-18 09:03:07,2014-05-20 04:07:31,https://api.github.com/repos/ReactiveX/RxJava/issues/1210,[],349,1,ReactiveX_RxJava_pull_1210.diff
ReactiveX/RxJava,OperatorToObservableList: use LinkedList to buffer the sequence’s items,"LinkedList has guaranteed constant insertion time when appending to the end of the list, whereas ArrayList takes O(1) amortized, since a reallocation might be necessary to insert further items. Since no capacity was specified for the buffer, on Hotspot this would cause the array to reallocate after the first 10 insertions, on Android even after the first insertion (since Android’s ArrayList uses a default capacity of zero.)

Since the buffer is copied to an ArrayList before emission, subscriber performance when working with the list should remain unaffected.

Sorry for the import noise, that's IntelliJ reformatting them every time I look at the file.

Refs #1141
",2014-05-17 09:36:56,2014-05-20 04:10:39,https://api.github.com/repos/ReactiveX/RxJava/issues/1208,[],5,4,ReactiveX_RxJava_pull_1208.diff
ReactiveX/RxJava,AndroidObservable to hold weak reference to Activity or Fragment,"bindActivity() and bindFragment() hold strong references to the
Activity or Fragment, thus requiring explicit unsubscription to avoid
leaks. This commit weakens that reference.

The observable chain should never be the owner of an Activity or
Fragment, so weakening the reference here should be safe.  An earlier
version of bindActivity() used weak references for both the Activity
and the source Observable. Weakening the reference to the Observable may
be unsafe, as the observable chain might be the owner of an anonymous
source Observable.

This commit removes the need to explicitly unsubscribe, as long as the
final Subscriber holds only a weak reference to the Context (i.e.,
View, Activity, or Fragment).

For example, consider a class:

```
  public class ClickableProperty extends Subscriber<Boolean> {

    private final WeakReference<View> mViewRef;

    public ClickableProperty(View view) {
      mViewRef = new WeakReference<View>(view);
    }

    @Override
    public void onNext(Boolean clickable) {
      View view = mViewRef.get();
      if (view != null) {
        view.setClickable(clickable);
      } else {
        unsubscribe();
      }
    }

    @Override
    public void onCompleted() {
      // ignore
    }

    @Override
    public void onError(Throwable e) {
      // ignore
    }

  }
```

The clickable property of a view can be safely bound to a boolean
observable as follows, without needing to explicitly unsubscribe in the
Activity's onDestroy().

```
  public class MainActivity extends Activity {

    Button mButton;

    protected void onCreate(Bundle savedInstanceState) {
      setContextView(R.id.activity_main);
      mButton = findViewById(R.id.button);

      Observable<Boolean> allowClicks = GlobalStaticObservables.allowClicks();
      ClickableProperty clickableProperty = new ClickableProperty(mButton);
      bindActivity(this, allowClicks).subscribe(clickableProperty);
    }

    protected void onDestroy() {
      // nothing to do here
    }

  }
```

Without weakening the Activity reference in bindActivity(), explicit
unsubscription would still be needed to prevent Context leaks.
",2014-05-15 07:34:51,2014-07-08 20:02:37,https://api.github.com/repos/ReactiveX/RxJava/issues/1203,[],22,9,ReactiveX_RxJava_pull_1203.diff
ReactiveX/RxJava,Scheduler dispatch algorithm and tests,"Implemented an event loop scheduler based on thread pinning and work stealing for #1149. In addition, I've merged #1197, added tests and fixed a few minor issues.

Here are the comparative benchmark results using the `MultipleObserversOnOneBusyObservable`JMH from #1197 

```
Benchmark (NUM_INTEGERS) (schedulerIndex)   Mode   Samples         Mean   Mean error    Units
runAll                50                0  thrpt        10     3012,015      176,800    ops/s
runAll                50                1  thrpt        10       32,035        0,014    ops/s
runAll                50                2  thrpt        10     2537,292      201,377    ops/s
runAll                50                3  thrpt        10     2452,117       60,938    ops/s
runAll               500                0  thrpt        10      296,673        4,419    ops/s
runAll               500                1  thrpt        10       32,037        0,011    ops/s
runAll               500                2  thrpt        10      211,382       21,754    ops/s
runAll               500                3  thrpt        10      246,312        3,714    ops/s
runAll              5000                0  thrpt        10       27,458        0,083    ops/s
runAll              5000                1  thrpt        10       32,070        0,238    ops/s
runAll              5000                2  thrpt        10       27,718        0,343    ops/s
runAll              5000                3  thrpt        10       21,415        0,289    ops/s
```

where 0 is the current computation scheduler, 1 is the balanced scheduler, 2 is the rerouting scheduler and 3 is the pinning scheduler. The reason for the 32 ops/s throughput of the balanced scheduler seems to be due to the drain loop, which made some self-scheduling tests run extremely slow. Adding the `MAX_TIGHT_LOOPS` improved on the test speed and the benchmark speed to 255 ops/s. I'm not sure why it is that slow.

I haven't run the other perf test, but run my own simple benchmark code: one that observes a single item 1M times and the other observes 16M items once. Results:

```
Algorithm    Single          Many
Current      1970 ns/item    117 ns/item
Balancing    30403 ns/item   110 ns/item
Rerouting    1979 ns/item    115 ns/item
Pinning      2122 ns/item    140 ns/item
```

The reason for the extra slowness of my implementation is the use of `LinkedBlockingDeque` as I need the `offerFirst`, but `ConcurrentLinkedDeque` is in Java 7. In addition, the cost of waiting and parking is doubled.
",2014-05-14 15:20:05,2014-05-31 08:51:04,https://api.github.com/repos/ReactiveX/RxJava/issues/1200,[],1489,16,ReactiveX_RxJava_pull_1200.diff
ReactiveX/RxJava,Support for IOSSchedulers,"IOSScheduler implementation for iOS, for use with RoboVM
",2014-05-13 21:58:13,2014-06-06 04:43:11,https://api.github.com/repos/ReactiveX/RxJava/issues/1198,[],190,1,ReactiveX_RxJava_pull_1198.diff
ReactiveX/RxJava,initial rev of two experimental event loop schedulers,"I created two new variations of EventLoopsScheduler - BalancingEventLoopScheduler and ReroutingEventLoopScheduler. These are currently experimental since they are not fully implemented for performance, but are fully functional. There are a couple of known problems and still evolving solutions. However, the ideas are concrete enough to garner discussion and feedback. The objective of rebalancing workload when there is non-trivial disparity in loads across cores is constrained by costs to both maintain state as well as to run rebalancing algorithms. Especially while maintaining the contracts of event concurrency, etc. and minimizing synchronization for gathering state and rebalancing.
I also created a new JMH benchmark, MultipleObserversOnOneBusyObservable.java (pardon the naming), to help compare these two new variants with the existing scheduler.

Here's a description of the benchmark and the two new schedulers.

JMH Benchmark MultipleObserversOnOneBusyObservable.java

<pre>
setup Input
    theArray = Array of N numbers
    Array of schedulers (schedlrIndex)
        0: EventLoopsScheduler
        1: BalancingEventLoopScheduler
        2: ReroutingEventLoopScheduler
    numObservers = NUM_CORES * 10
    @GenerateMicroBenchmark
    runAll(input)
        for(i = 1 .. input.numObservers)
        if(i%4 == 0)
            theO = Observable.from(1,2,3,4,5)
        else
            theO = Observable.from(input.theArray)
        theO.observeOn(input.scheduler[schedlrIndex]).subscribe(... input.blackhHole.consume(number)...)
</pre>


Benchmark run  on Ubuntu desktop: Intel Xeon W3550 @ 3.7 GHz, 8-Cores, 40GB memory.

```
gradlew benchmarks '-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 10 -r 1 .*MultipleObserversOnOneBusyObservable.*'
```

Results:

<pre>
N=50

Benchmark                                         (schedulerIndex)   Mode   Samples         Mean   Mean error    Units
r.s.MultipleObserversOnOneBusyObservable.runAll                  0  thrpt        10     3460.543       50.047   ops/s
r.s.MultipleObserversOnOneBusyObservable.runAll                  1  thrpt        10      430.402        1.783    ops/s
r.s.MultipleObserversOnOneBusyObservable.runAll                  2  thrpt        10     3200.517      140.199   ops/s


N=500

Benchmark                                         (schedulerIndex)   Mode   Samples         Mean   Mean error    Units
r.s.MultipleObserversOnOneBusyObservable.runAll                  0  thrpt        10      345.918        8.889   ops/s
r.s.MultipleObserversOnOneBusyObservable.runAll                  1  thrpt        10      366.105       11.945    ops/s
r.s.MultipleObserversOnOneBusyObservable.runAll                  2  thrpt        10      361.587       10.627   ops/s


N=5000

Benchmark                                         (schedulerIndex)   Mode   Samples         Mean   Mean error    Units
r.s.MultipleObserversOnOneBusyObservable.runAll                  0  thrpt        10       36.383        1.698    ops/s
r.s.MultipleObserversOnOneBusyObservable.runAll                  1  thrpt        10       88.317        4.917    ops/s
r.s.MultipleObserversOnOneBusyObservable.runAll                  2  thrpt        10       37.533        0.951   ops/s
</pre>


Note that the workload in this benchmark isn't such that there's a much rebalancing, if any, to do. However, we need to make sure that the variants do not degrade performance in that case. 

Some observations:

<ul>
  <li>BalancingEventLoopScheduler does poorly for small N, but does pretty well beyond a threshold.</li>
  <li>RebalancingEventLoopScheduler
    <ul>
        <li>added logic to evaluate and maintain state (1. avgLatency per core, 2. hot queue per core) and still is able to do as good as the old EventLoopsScheduler. That is, there's near zero cost to maintaining that state.</li>
<li>Even if rebalancing proves costly and we evolve an algorithm later, the result so far itself might be a good improvement over the current one if we just ""pause"" the hot Q and randomly pick another core. </li>
    </ul></li>
</ul>


Below, I point out the problem area for each of the new schedulers. Ideas/feedback welcome.

<h2>BalancingEventLoopScheduler</h2>

<pre>
N worker threads are created, 1 per core
Each of N worker threads are assigned 0 or more worker queues to process
One of the worker threads is assigned as the RebalancerThread for load balancing
Scheduler.createWorker()  creates a queue and assigns to one of the worker threads
WorkerThread.run():
    act on Q transfers (transferring queue in, or out)
    grab updated list of Qs
    totalLoad=0
    for(Q q: theQlist)
        q.drainTo(workList)
        now = currentTime
        for(Action a: workList)
        a.call()
        load = currentTime - now
        totalLoad += load
        maintain hotQueue: name and load; that has the highest load
    update current worker thread's hot queue 
    if I am the RebalancerThread, call rebalanceQs()
    if(totalLoad == 0)
        did no work, sleep a bit to prevent busy cpu   **PROBLEM**
        would be nice to have a multi-queue poll() here to be called on all our Qs
        this sleep kills performance when work comes in relatively slowly
rebalanceQs()
    if did rebalance recently, return
    get HotQueues from each core thread workers
    if none of them had a hot q, return
    sort in increasing order, hot Qs based on core thread worker's totalLoad and the qLoad
    for loadedWorker: from end of sorted hot Q list
        for availableWorker: from beginning of sorted hotQ list until loadedWorker
            if(shouldRebalancePair(loadedWorker, availableWorker), then
                move the hotQ from loadedWorker to availableWorker
                That is, WorkerThread[loadedWorker].transferQueue(theHotQ, WorkerThread[availableWorker])
shouldRebalancePair(loadedWorker, availableWorker)
    if( (loadedWorker.totalLoad - loadedWorker.hotQLoad) >= (availableWorker.totalLoad + loadedWorker.hotQLoad) )
        return true
    return false
</pre>


<h2>ReroutingEventLoopsScheduler</h2>

<pre>
N worker threads are created, 1 per core
Each of N worker threads has a single thread executor (ScheduledThreadPoolExecutor)
Scheduler.createWorker() creates a WorkerQueue and assigns to one of the worker threads (could possibly make it pick the least loaded one; that info is available based on the details below)
WorkerQueue.schedule() calls workerThread.schedule() on the currently assigned workerThread
WorkerThread routinely schedules a house keeping action, latencyEval,  into its schedulerService to note time it takes for it to get executed (this measures latency)
WorkerThread.schedule(callerQId, action)
    wrap each runnable with 
        increment counter to track #items
        increment per queue counter to track per queueId throughput (queueCounts)
    executor.schedule(wrapped runnable)
WorkerThread essentially maintains two numbers: avgLatency and throughput (overall + perWorker)
WorkerThread.latencyEval
    note latency (currentTime - latencyEvalLaunchTime)
    if(queueCounts.size > 1)
        maxQ = queue from queueCounts with max number, where number > EPS (threshold)
        destination = shouldReroute(myWorkerIndex)
        if(desination >= 0)
            WorkerQueue[maxQ].rerouteTo(destination)
shouldReroute(sourceWorker)
    ensure nobody else is rerouting right now or just did
    get avgLatencies for all workers (as many as #Cores)
    pick a worker with that can take sourceWorker's load based on latencies (currently always return -1, effectively actual load balancing is turned off)
    return picked worker 
WorkerQueue.schedule(action)
    if am being rerouted
        initialize reroute
            put an ending marker action into current worker that notifies us of the last action handled
            we can use the new worker only after the last one sent to previous one completes
        if (ending marker indicated)
            switch worker to the new one
            move all actions in transfer queue to new worker
        else
            park action into a transfer queue
            Don't yet know how to manage subscriptions when parking actions  **PROBLEM**
            It is functional though since actual rebalancing isn't happening.
            Perhaps, don't park actions, just pause until ending marker comes through. Subscriptions are managed just like before then. The caller is then blocked until rebalancing finishes. Which make be OK?
    else
        worker.schedule(action)
</pre>
",2014-05-13 19:31:22,2014-07-08 20:06:52,https://api.github.com/repos/ReactiveX/RxJava/issues/1197,[],794,0,ReactiveX_RxJava_pull_1197.diff
ReactiveX/RxJava,SwingScheduler: allow negative schedule,"Fix for issue #1193 

The new `schedulePeriodic` may calculate negative delay times if the next task was already due. This change will allow negative timing on the swing scheduler indicating an immediate schedule.
",2014-05-12 16:18:15,2014-05-16 04:18:31,https://api.github.com/repos/ReactiveX/RxJava/issues/1195,[],10,7,ReactiveX_RxJava_pull_1195.diff
ReactiveX/RxJava,ReplaySubject with time and size bounds,"I've implemented the bounded `ReplaySubject` variants and removed the old `OperatorReplay.CustomReplaySubject` so the various `Observable.replay()` now use this version.
Note that this is based on the current `SubjectSubscriptionManager` and not my manager from PR #1185. I've copied the `ReplaySubjectConcurrencyTest` to check the concurrency properties.

The bounded buffering is implemented via a doubly-linked list where the back reference is a weak reference. This allows keeping a reference to the latest `Node` for each replayState and once a Node is no longer indexed, it will be removed by GC. 

A concurrency review would be much appreciated.
",2014-05-12 14:32:41,2014-05-19 06:22:18,https://api.github.com/repos/ReactiveX/RxJava/issues/1192,[],1814,1386,ReactiveX_RxJava_pull_1192.diff
ReactiveX/RxJava,Fix attempt for OperatorPivotTest,"This is an attempt to fix the lack of concurrency in the `OperatorPivotTest.testConcurrencyAndSerialization`. Since this fails mostly on the build server, I'll try to minimize the attempts to not flood it.
",2014-05-12 08:31:46,2014-05-16 04:15:36,https://api.github.com/repos/ReactiveX/RxJava/issues/1191,[],11,2,ReactiveX_RxJava_pull_1191.diff
ReactiveX/RxJava,Scheduler fixes and related improvements,"A newer set of scheduler improvements.
- Fixed `schedulePeriodic` to properly capture the Subscription of the repeated schedule calls to allow unsubscribing the periodic task without the need to unsubscribe the whole worker.
- Fixed `NewThreadScheduler` to call `shutdownNow` to correctly cancel all pending tasks.
- Removed `innerSubscription` from `NewThreadScheduler` because it was unnecessary and didn't even work.
- Took `CompositeSubscription` from #1145 to improve on the add/removal time of timed tasks with a help of a `HashSet` and atomic field updaters.
- Added `SubscriptionQueue` that works like an ringbuffer and can add/remove non-delayed tasks faster than `CompositeSubscription`.
- Reduced memory footprint of `CompositeSubscription` and `ScheduledAction`.
- Modified `EventLoopScheduler` to track delayed and non-delayed task Subscriptions separately.
- Added a few `final` modifiers.
",2014-05-12 08:14:38,2014-05-20 11:26:13,https://api.github.com/repos/ReactiveX/RxJava/issues/1190,[],469,73,ReactiveX_RxJava_pull_1190.diff
ReactiveX/RxJava,Fix issue #1187 and #1196,"This PR fixed issue #1187.

Although using `(action: => Unit)` will require the following odd codes when somebody wants to use `Function0` directly:

``` Scala
  @Test def schedulerExample5(): Unit = {
    val worker = IOScheduler().createWorker
    var no = 1
    val subscription = worker.schedule(new Function0[Unit]{
      def apply(): Unit = {
        println(s""Hello(${no}) from Scheduler"")
        no += 1
        worker.schedule(apply(), 100 millis)
      }
    }.apply(), 1 seconds)
    TimeUnit.SECONDS.sleep(2)
    subscription.unsubscribe()
  }
```

I think people rarely use `Function0` directly in Scala. 

So I chose `(action: => Unit)` finally. `schedulerExample4` is an more realistic example for recursive schedule.

This PR is a breaking change.
",2014-05-12 03:57:45,2014-05-16 04:00:58,https://api.github.com/repos/ReactiveX/RxJava/issues/1188,[],108,22,ReactiveX_RxJava_pull_1188.diff
ReactiveX/RxJava,Behavior subject time gap fix 2,"Based on discussions in #1181, I've unified the behavior among the Subjects.

BehaviorSubject doesn't seem to exhibit issue #658 and #1184.

A second pair of eyes would be great to confirm the correctness and check if the removal of the CountDownLatch was the correct approach.
",2014-05-09 22:40:00,2014-05-20 05:11:18,https://api.github.com/repos/ReactiveX/RxJava/issues/1185,[],546,558,ReactiveX_RxJava_pull_1185.diff
ReactiveX/RxJava,NotificationLite.accept performance improvements,"This is a proposal for speeding up the `accept()` method (i.e., reducing its latency).

Benchmark comparison:

direct onNext: 488 MOps/s
master accept: 378 MOps/s
this accept: 477 MOps/s

(i7 4770K, JDK 1.8u5 x64)
",2014-05-09 16:53:00,2014-05-09 16:57:21,https://api.github.com/repos/ReactiveX/RxJava/issues/1183,[],14,9,ReactiveX_RxJava_pull_1183.diff
ReactiveX/RxJava,Add facilities for creating Observables from JavaFX events and ObservableValues,"Heavily inspired by the swing contrib.

Provides:
- a Scheduler implementation ensuring execution in the JavaFX UI thread
- a Subscription implementation ensuring that un-subscription happens in JavaFX UI thread
- an Observable factory method for observing UI events on JavaFX nodes
- an Observable factory method for observing value changes of a JavaFX ObservableValue

Also the rxjava-javafx is added to the gradle build.
",2014-05-09 16:19:27,2014-05-09 23:39:22,https://api.github.com/repos/ReactiveX/RxJava/issues/1182,[],603,0,ReactiveX_RxJava_pull_1182.diff
ReactiveX/RxJava,Behavior subject time gap fix,"This fix should make sure subscribing between two event emissions won't create a gap in the received events. I had to implement my own subscription management to ensure the required coordination behavior. 

Performance comparison for simple pass-through behavior:
PublishSubject (master) ~86 MOps/s
BehaviorSubject (master) ~47 MOps/s
BehaviorSubject (this) ~46 MOps/s

The relative slowness compared to PS is due the volatile write on each element and the additional ~1MOps/s is due to the subscription coordination.
",2014-05-09 15:51:40,2014-05-09 22:40:50,https://api.github.com/repos/ReactiveX/RxJava/issues/1181,[],341,77,ReactiveX_RxJava_pull_1181.diff
ReactiveX/RxJava,Add facilities for creating Observables from JavaFX events and Observabl...,"...eValues.

Provides:
- a Scheduler implementation ensuring execution in the JavaFX UI thread
- a Subscription implementation ensuring that un-subscription happens in JavaFX UI thread
- an Observable factory method for observing UI events on JavaFX nodes
- an Observable factory method for observing value changes of a JavaFX ObservableValue

Also the rxjava-javafx is added to the gradle build.
",2014-05-09 15:35:01,2014-05-09 16:15:48,https://api.github.com/repos/ReactiveX/RxJava/issues/1179,[],515,0,ReactiveX_RxJava_pull_1179.diff
ReactiveX/RxJava,Fix issue #1173,"In `Subscriber.apply(rx.Subscriber)`, `asJavaObserver` and `asJavaSubscription` will be set to `null` because the parent class will be initialized with `asJavaSubscriber==null`. #1173.

This PR did the initialization again in the subclass.
",2014-05-09 09:27:58,2014-05-19 17:38:40,https://api.github.com/repos/ReactiveX/RxJava/issues/1178,[],138,41,ReactiveX_RxJava_pull_1178.diff
ReactiveX/RxJava,GroupByUntil to use BufferUntilSubscriber,"Matches `groupBy` behavior. (I still think throwing an error for non-first subscribers is too harsh.)
",2014-05-09 06:39:30,2014-05-09 17:52:08,https://api.github.com/repos/ReactiveX/RxJava/issues/1177,[],82,10,ReactiveX_RxJava_pull_1177.diff
ReactiveX/RxJava,Fixed synchronous ConnectableObservable.connect problem,"ConnectableObservable.connect returns a Subscription and thus cannot be unsubscribed synchronously, similar how take didn't work before the Subscriber changes. This PR modifies the `ConnectableObservable` and its current implementation `OperatorMulticast` to extract the connection Subscription token before it is connected to the source. Cancelling this extracted token makes sure the synchronous connection is unsubscribed.

(The Rx.NET version of the test case seemingly doesn't exhibit the problem. I suspect it is the interplay of `IDisposable`s.)
",2014-05-08 21:42:54,2014-05-16 04:04:44,https://api.github.com/repos/ReactiveX/RxJava/issues/1175,[],95,24,ReactiveX_RxJava_pull_1175.diff
ReactiveX/RxJava,ObserveOn: Change to batch dequeue.,"Using the same batch technique as in `SerializedObserver` to dequeue and play values. I had to switch to synchronized because `ConcurrentLinkedQueue` doesn't support drain.

I run the scheduler perf test with it:

```
Result : 1913,582 ±(99.9%) 29,210 ns/op
  Statistics: (min, avg, max) = (1905,303, 1913,582, 1922,427), stdev = 7,586
  Confidence interval (99.9%): [1884,373, 1942,792]

Result : 64.277,546 ±(99.9%) 734,360 ns/op
  Statistics: (min, avg, max) = (64034,953, 64277,546, 64519,884), stdev = 190,711
  Confidence interval (99.9%): [63543,186, 65011,906]

Result : 67.999.392,293 ±(99.9%) 4715885,625 ns/op
  Statistics: (min, avg, max) = (66777535,133, 67999392,293, 69525773,000), stdev = 1224700,521
  Confidence interval (99.9%): [63283506,668, 72715277,918]
```

Master for me was 1863,423 / 119.030,536 / 127.738.858,250 

Appears to be a 2x speedup on 1024 and 1M items.
",2014-05-08 14:54:00,2014-05-16 04:06:51,https://api.github.com/repos/ReactiveX/RxJava/issues/1172,[],47,8,ReactiveX_RxJava_pull_1172.diff
ReactiveX/RxJava,fix to allow schedulePeriodic to work after 2262,"Thinking further I realized that the schedulePeriodically in #1162 would begin to fail at `Fri Apr 11 16:47:16 PDT 2262`

If this is deemed too soon to fail, then the solution in this commit will still be working in 292million years.
",2014-05-08 04:28:23,2014-05-20 04:25:35,https://api.github.com/repos/ReactiveX/RxJava/issues/1170,[],25,4,ReactiveX_RxJava_pull_1170.diff
ReactiveX/RxJava,Scheduler Improvements 507,"NewThread/EventLoop scheduler improvements proposal.

**NewThreadScheduler**

There is no need to have an `innerSubscription` there as the underlying Executor knows what tasks are in its queue and a `shutdown` will cancel them anyway. In the original version, I made a small mistake by leaving out an `innerSubscription.add(s)` which was one of the main contribution to the speed improvements (did not affect correctness).

**EventLoopScheduler**

An EventLoopScheduler needs to track its tasks so it can selectively cancel them in the NewThreadScheduler. Since an ELS worker is single threaded, the addition and removal of the completed tasks are more like queue operations; adding a last item and removing a first item in CompositeSubscription can be expensive even if the size is small due to the copying and state machine overhead. 

**SubscriptionQueue**

Therefore, I've built a special array-based (ringbuffer) queue called `SubscriptionQueue` which can resize itself as needed, similar to ArrayDeque, but behaves like a composite and queued items can be unsubscribed at once and provides the usual cancellation policy. When benchmarked with a simple loop of add/remove pair, it gives ~ 532 Mops/s whereas `CompositeSubscription` gives 16 Mops/s. It uses `synchronized` as generally one needs to synchronize the producer(s) of tasks with the completion of the tasks on the worker thread, where the producer count is likely small. The initial queue capacity is 8 which favors fast tasks and the array fits nicely into a typical 64 byte cache line. One unique property is that it dequeues based on object identity and not the head of the queue. The reason for this is that when there are multiple producers, queueing their subscriptions might happen in different order than their tasks are scheduled (i.e., the head of the queue points to s1 while t2 gets scheduled first).

**Perf tests**

I did some perf testing with `ComputationSchedulerPerf` but I ran into some trouble: the initial 512M memory for the benchmark doesn't seem to be enough, especially on a 4/8 core machine. Both the master and this PR goes really slow or fails with GC errors because the internal queues of the Executors get flooded with tasks. Each task is about 650 byte and having tens of thousands queued up consumes lot of memory. I run the perftests with 1300M which was enough although still pounding on the GC. (Btw, I don't understand the perf code: does the subscribeOn test do 1M one-time subscription, or subscribes to a stream of 1M elements? If the latter, what are the tasks that hammer the executor?)

_Master_ (https://gist.github.com/akarnokd/1fe0fb74f896c48c61a8)

```
Benchmark                                   (size)   Mode   Samples         Mean   Mean error    Units
r.s.ComputationSchedulerPerf.observeOn           1   avgt         5     1944,238       64,954    ns/op
r.s.ComputationSchedulerPerf.observeOn        1024   avgt         5   119353,236     1968,424    ns/op
r.s.ComputationSchedulerPerf.observeOn     1048576   avgt         5 129596502,875 11464347,421    ns/op
r.s.ComputationSchedulerPerf.subscribeOn         1   avgt         5     1659,862      462,385    ns/op
r.s.ComputationSchedulerPerf.subscribeOn      1024   avgt         5  4643038,650 39587231,914    ns/op
r.s.ComputationSchedulerPerf.subscribeOn   1048576   avgt         5   317353,904   566003,080    ns/op
```

**This proposal** (https://gist.github.com/akarnokd/6d9ba66761c5bdb8ecd7)

```
Benchmark                                   (size)   Mode   Samples         Mean   Mean error    Units
r.s.ComputationSchedulerPerf.observeOn           1   avgt         5     1858,486       73,600    ns/op
r.s.ComputationSchedulerPerf.observeOn        1024   avgt         5   117680,475     2305,467    ns/op
r.s.ComputationSchedulerPerf.observeOn     1048576   avgt         5 129298288,453 14093401,564    ns/op
r.s.ComputationSchedulerPerf.subscribeOn         1   avgt         5      839,078      293,626    ns/op
r.s.ComputationSchedulerPerf.subscribeOn      1024   avgt         5    51253,754   150446,345    ns/op
r.s.ComputationSchedulerPerf.subscribeOn   1048576   avgt         5   371325,179   692740,819    ns/op
```

The ObserveOn test benefits minimally from the changes.  For the 1 onSubscribe, it drops to 840ns. For the other sizes, I suspect hectic GC overhead so I can't declare a winner.

(Generally, since we use a lot of AtomicXYZ classes, they add 24 bytes to the memory footprint every time a Subscription is present. In order to get rid of them, one would need to replace it with volatile fields and `Unsafe` calls to get the CAS functionality back.)

Benchmarked on an i7 920 @ 2.66GHz, 4/8 hyperthreaded cores, 6GB total RAM, Windows 7 x64, Java 7u55 x64.
",2014-05-07 15:12:21,2014-05-12 06:55:01,https://api.github.com/repos/ReactiveX/RxJava/issues/1166,[],463,66,ReactiveX_RxJava_pull_1166.diff
ReactiveX/RxJava,Update according to review in issue #1159,"/cc @samuelgruetter
",2014-05-07 08:22:56,2014-05-08 05:06:53,https://api.github.com/repos/ReactiveX/RxJava/issues/1165,[],26,72,ReactiveX_RxJava_pull_1165.diff
ReactiveX/RxJava,JMH Perf Tests for Schedulers.computation,,2014-05-06 18:22:13,2014-05-06 18:22:16,https://api.github.com/repos/ReactiveX/RxJava/issues/1164,[],120,65,ReactiveX_RxJava_pull_1164.diff
ReactiveX/RxJava,Fix defer for Java 8 type-inference,"Fixes https://github.com/Netflix/RxJava/issues/1157
",2014-05-06 16:58:19,2014-05-06 16:58:22,https://api.github.com/repos/ReactiveX/RxJava/issues/1163,[],1,1,ReactiveX_RxJava_pull_1163.diff
ReactiveX/RxJava,fix to remove drift from schedulePeriodic,"When implementing the 'worker' scheduler pattern in rxcpp I implemented schedulePeriodic differently because I predicted that the RxJava version would drift. Once the changes were working, I verified my prediction in rxcpp. 

I decided to test the same in RxJava and contribute my approach.

This was my test:

``` java
import java.util.concurrent.TimeUnit;

import rx.Scheduler;
import rx.schedulers.Schedulers;
import rx.functions.Action0;

public class periodic {

    public static void main(String[] args) {

        final Scheduler scheduler = Schedulers.immediate();
        final Scheduler.Worker w = scheduler.createWorker();

        final long initial = TimeUnit.SECONDS.toMillis(2);
        final long period = TimeUnit.SECONDS.toMillis(1);
        final long start = scheduler.now() + initial;

        w.schedulePeriodically(new Action0() {
            long count = 0;
            @Override
            public void call() {
                long tick = scheduler.now();
                System.out.println(String.format(""expected -> %dms, actual -> %dms, drift -> %dms"", count*period, tick - start, tick - (start + (count*period))));
                ++count;
            }
        }, initial, period, TimeUnit.MILLISECONDS);
    }

}
```

The existing impl causes this output:

```
$ java -cp rxjava-core/build/libs/rxjava-core-0.18.3-SNAPSHOT.jar:./ periodic
expected -> 0ms, actual -> 1ms, drift -> 1ms
expected -> 1000ms, actual -> 1002ms, drift -> 2ms
expected -> 2000ms, actual -> 2003ms, drift -> 3ms
expected -> 3000ms, actual -> 3004ms, drift -> 4ms
expected -> 4000ms, actual -> 4005ms, drift -> 5ms
expected -> 5000ms, actual -> 5006ms, drift -> 6ms
expected -> 6000ms, actual -> 6007ms, drift -> 7ms
expected -> 7000ms, actual -> 7008ms, drift -> 8ms
expected -> 8000ms, actual -> 8009ms, drift -> 9ms
expected -> 9000ms, actual -> 9010ms, drift -> 10ms
expected -> 10000ms, actual -> 10011ms, drift -> 11ms
expected -> 11000ms, actual -> 11012ms, drift -> 12ms
expected -> 12000ms, actual -> 12013ms, drift -> 13ms
expected -> 13000ms, actual -> 13014ms, drift -> 14ms
expected -> 14000ms, actual -> 14016ms, drift -> 16ms
expected -> 15000ms, actual -> 15017ms, drift -> 17ms
expected -> 16000ms, actual -> 16018ms, drift -> 18ms
expected -> 17000ms, actual -> 17019ms, drift -> 19ms
expected -> 18000ms, actual -> 18020ms, drift -> 20ms
expected -> 19000ms, actual -> 19021ms, drift -> 21ms
expected -> 20000ms, actual -> 20022ms, drift -> 22ms
expected -> 21000ms, actual -> 21023ms, drift -> 23ms
expected -> 22000ms, actual -> 22023ms, drift -> 23ms
expected -> 23000ms, actual -> 23024ms, drift -> 24ms
```

With this commit the test outputs:

```
$ java -cp ./:./rxjava-core/build/libs/rxjava-core-0.18.3-SNAPSHOT.jar periodic
expected -> 0ms, actual -> 3ms, drift -> 3ms
expected -> 1000ms, actual -> 1001ms, drift -> 1ms
expected -> 2000ms, actual -> 2001ms, drift -> 1ms
expected -> 3000ms, actual -> 3000ms, drift -> 0ms
expected -> 4000ms, actual -> 4001ms, drift -> 1ms
expected -> 5000ms, actual -> 5000ms, drift -> 0ms
expected -> 6000ms, actual -> 6000ms, drift -> 0ms
expected -> 7000ms, actual -> 7000ms, drift -> 0ms
expected -> 8000ms, actual -> 8001ms, drift -> 1ms
expected -> 9000ms, actual -> 9001ms, drift -> 1ms
expected -> 10000ms, actual -> 10001ms, drift -> 1ms
expected -> 11000ms, actual -> 11001ms, drift -> 1ms
expected -> 12000ms, actual -> 12001ms, drift -> 1ms
expected -> 13000ms, actual -> 13001ms, drift -> 1ms
expected -> 14000ms, actual -> 14001ms, drift -> 1ms
expected -> 15000ms, actual -> 15001ms, drift -> 1ms
expected -> 16000ms, actual -> 16001ms, drift -> 1ms
expected -> 17000ms, actual -> 17000ms, drift -> 0ms
expected -> 18000ms, actual -> 18000ms, drift -> 0ms
expected -> 19000ms, actual -> 19000ms, drift -> 0ms
expected -> 20000ms, actual -> 20000ms, drift -> 0ms
expected -> 21000ms, actual -> 21002ms, drift -> 2ms
expected -> 22000ms, actual -> 22000ms, drift -> 0ms
expected -> 23000ms, actual -> 23001ms, drift -> 1ms
expected -> 24000ms, actual -> 24001ms, drift -> 1ms
```
",2014-05-06 15:10:25,2014-05-06 17:11:12,https://api.github.com/repos/ReactiveX/RxJava/issues/1162,[],4,3,ReactiveX_RxJava_pull_1162.diff
ReactiveX/RxJava,"Removed use of deprecated API from tests & operators, fixed year in head...","...ers, added and removed suppressions, fixed line endings, replaced tabs with spaces

I haven't deleted `OnSubscribeFunc` because I was not sure when the general cleanup of deprecated stuff will happen; I just made sure Java tests don't use it anymore.
",2014-05-06 13:21:50,2014-05-06 17:04:26,https://api.github.com/repos/ReactiveX/RxJava/issues/1161,[],1051,1358,ReactiveX_RxJava_pull_1161.diff
ReactiveX/RxJava,Add `replay` and `multicast` variants to RxScala,"This PR has some breaking changes:
- Change `def multicast[R >: T](subject: rx.lang.scala.Subject[R]): (() => Subscription, Observable[R])` to `def multicast[R >: T](subject: rx.lang.scala.Subject[R]): ConnectableObservable[R]`
- Change `def replay: (() => Subscription, Observable[T])` to `def replay: ConnectableObservable[T]`
- Remove `Observable.apply(Int)`

So it's better to merge it at the next major release.
#1152, #1153.

/cc @headinthebox @samuelgruetter
",2014-05-06 12:47:53,2014-05-20 16:31:05,https://api.github.com/repos/ReactiveX/RxJava/issues/1160,[],363,33,ReactiveX_RxJava_pull_1160.diff
ReactiveX/RxJava,Rxscala improvement,"Add `dropUntil`, `contains`, `repeat`, `doOnTerminate`, `startWith`, `publish` variants to RxScala. #1151, #1153.

/cc @headinthebox @samuelgruetter
",2014-05-06 12:42:38,2014-05-06 17:11:38,https://api.github.com/repos/ReactiveX/RxJava/issues/1159,[],332,3,ReactiveX_RxJava_pull_1159.diff
ReactiveX/RxJava,Scheduler correctness improvements.,"Second round on the scheduler correctness issue.

Sure it looks more heavy as `ScheduledAction` now has its own inner `CompositeSubscription` and a shared reference to the parent `innerSubscription`.

I've tried to benchmark it with `SchedulerPerformanceTests` but that test is flawed:
- Multiple threads pound on the same long sum value, so naturally additions get lost.
- The LongObserver gets unsubscribed after the first loop so `from` will not actually call `onNext` but `isUnsubscribed` a lot.
- Does not wait for the computations to finish and basically measures how fast 5M tasks can be added to the NewThreadScheduler's innerSubscription.

The flawed test gives ~ 11M ops/sec on my machine. If I fix the test and run against the master, 5M takes extremely long to finish due to the inherent slowness of add/remove in CompositeSubscription if large. On my 4 core hyperthread enabled machine, I get 50k-150k ops/second for baseline with a 100k loop.

The proposed changes run with the flawed test gives ~10.8M ops/sec. With the test fixed and with the proposed changes, I get ~1.2M ops/sec.
",2014-05-06 08:37:41,2014-05-06 18:31:39,https://api.github.com/repos/ReactiveX/RxJava/issues/1158,[],150,122,ReactiveX_RxJava_pull_1158.diff
ReactiveX/RxJava,Fix ReplaySubject Terminal State Race Condition,"Fixes https://github.com/Netflix/RxJava/issues/1147#issuecomment-42232464 with change from @akarnokd
",2014-05-05 20:37:45,2014-05-05 20:41:28,https://api.github.com/repos/ReactiveX/RxJava/issues/1150,[],46,18,ReactiveX_RxJava_pull_1150.diff
ReactiveX/RxJava,Manual Merge of Delay PR,,2014-05-05 19:25:50,2014-05-05 19:25:55,https://api.github.com/repos/ReactiveX/RxJava/issues/1148,[],400,320,ReactiveX_RxJava_pull_1148.diff
ReactiveX/RxJava,Scheduler fixes505,"This PR contains some changes to the NewThreadScheduler and EventLoopScheduler, which makes them work more correctly and gives some flexibility to them.

Note that this conflicts with PR #1143.

Notable changes:
- Changed `NewThreadScheduler` to use a `ScheduledExecutorService` as I don't see any particular reason why not.
- Added proper logic for tracking and unsubscribing scheduled actions.
- Renamed inner classes to better express their purpose (got lost in all of those inner EventLoopScheduler workers).
- Added the ability to specify the number of cores and the worker selection policy to `EventLoopScheduler`. Two policies are available: round robin and least-recent (default). A new `Schedulers.fixed()` method is added which lets the caller specify the pool size. Since the EventLoopScheduler is package private, I wasn't sure how to expose the worker selection policy. In addition, EventLoopScheduler implements Subscription so the Scheduler returned by `fixed()` can be terminated. I made sure the `computation()` scheduler can't be terminated this way.
- Fixed `EventLoopScheduler` to track the submitted actions properly.
- Note that the potential Subscription leak due to `innerSubscription.remove()` happening before `innerSubscription.add()` in `EventLoopWorker` is not handled. It can't happen with `NewThreadScheduler` though, although it would benefit from a `CompositeSubscription.delete()` method which doesn't unsubscribe the removed item and thus not interrupting the executor unnecessarily.
",2014-05-05 14:08:54,2014-05-06 07:54:15,https://api.github.com/repos/ReactiveX/RxJava/issues/1146,[],262,96,ReactiveX_RxJava_pull_1146.diff
ReactiveX/RxJava,Large CompositeSubscription performance improvements,"This is a proposition to improve the addition/removal speed of the `CompositeSubscription` in case of thousands of items in it. 

In some operators, especially when using Schedulers and/or observeOn, thousands of items may be present in the composite and since adding/removing a new item is O(n), it takes more and more time to add and remove items once the composite gets large.

My proposal is to change the composite state implementation to switch to a HashSet representation above a certain threshold (and switch back below some). The following diagram shows some benchmarking results. (Configuration: i7 920 @ 2.4GHz, 32K L1 Data, 256K L2, 8M L3, 6GB DDR3 1333MHz RAM, Windows 7 x64, Java 8u05 x64.)

![image](https://cloud.githubusercontent.com/assets/1269832/2877095/4779ac40-d443-11e3-9c0a-908ea49c6219.png)

This benchmark how the CompositeSubscription behaves when there are some items already in it and a new unique item is added and removed immediately (all single threaded). The blue line indicates the current master implementation; the red, green and purple show the new implementation with thresholds set to 8, 16 and 24 respectively. Once the internal array size reaches the cache-line size, it is generally better to use HashSet instead.

The second benchmark compares how fast can the CompositeSubscription be filled with subscribers to a various capacity, and how the target size affects the fill speed.

![image](https://cloud.githubusercontent.com/assets/1269832/2877162/afcb76a6-d444-11e3-8c4c-c3ba85e6c1d3.png)

When the composite is filled in, the one-by-one array resize performs better until a larger capacity is reached, but then again, using a HashSet to append further items is faster. Unfortunately, what seems to be an optimal threshold for the first case performs worse in this case.

There are some drawbacks of this hybrid approach:
- The optimal threshold value depends on the use case and the target system. How can we enable to tune this parameter. Parameter tuning could be handy in other places in RxJava; how can we enable it?
- I'm not 100% certain if I've correctly implemented the switchover from atomic states to mutable state and back.
",2014-05-05 11:10:03,2014-05-30 06:28:18,https://api.github.com/repos/ReactiveX/RxJava/issues/1145,[],79,13,ReactiveX_RxJava_pull_1145.diff
ReactiveX/RxJava,Operator Delay rebase & fixes,"Operator Delay

Issue #1060
",2014-05-05 05:53:10,2014-05-05 19:25:55,https://api.github.com/repos/ReactiveX/RxJava/issues/1144,[],7950,7870,ReactiveX_RxJava_pull_1144.diff
ReactiveX/RxJava,CachedThreadScheduler for use as default IO Scheduler,"Here is an implementation of the CachedThreadScheduler discussed in #1140.

I've been testing this against my own web service using load tests and it holds up fairly well. There seems to be a bit more retention of expired event loops during high load than I like. So I would appreciate a code review to make sure I haven't missed any part of the scheduler/subscription life cycle. Or if there's any unintentional reference keeping event loops or scheduler Worker instances from being garbage collected.
",2014-05-04 10:16:11,2014-05-20 10:35:14,https://api.github.com/repos/ReactiveX/RxJava/issues/1143,[],246,44,ReactiveX_RxJava_pull_1143.diff
ReactiveX/RxJava,Update 'contains' signature to 'contains(Object)',"The original `contains` signature can not support the following codes:

``` java
    public void test() {
        ArrayList<String> l = new ArrayList<String>();
        l.add(""test"");
        Observable<ArrayList<String>> o = Observable.<ArrayList<String>>from(l);
        o.contains(Arrays.asList(""test""));
    }
```

This PR changes the signature from `contains(T)` to `contains(Object)`. It's also consistent with `equals(Object)`.

This change should not break the old codes.
",2014-05-03 08:30:30,2014-05-05 19:18:25,https://api.github.com/repos/ReactiveX/RxJava/issues/1142,[],1,1,ReactiveX_RxJava_pull_1142.diff
ReactiveX/RxJava,Operator Window and other changes,"Operator Window with no-first-loss functionality.

Issue #1060

(I had to leave my computer so the detailed description will come within a few hours.)
",2014-04-30 13:17:45,2014-05-05 19:17:50,https://api.github.com/repos/ReactiveX/RxJava/issues/1138,[],1256,1305,ReactiveX_RxJava_pull_1138.diff
ReactiveX/RxJava,Fixes to the operators.,"Fixes for issue #1136
- `OperatorMulticast` is straightforward from concurrency perspective. The only consideration is that if the current subscription gets unsubscribed before the `connect` reaches the `unsafeSubscribe`, it really depends on the source what it will do with an unsubscribed client. It is possible to put extra effort to make sure a newly established connection won't get unsubscribed before it is actually connected or if it gets unsubscribed immediately, no subscription is attempted at all.
- `OperatorSampleWithTime`: didn't want to push too many PRs so I just included it here. There was a missing unsubscribe in the `onCompleted()` that makes sure the worker is stopped.
- `Subscribers.empty()` was implemented by returning the same Subscriber to everyone, which Subscriber is stateful so if someone unsubscribes it, it will appear everywhere as unsubscribed and can have unwanted effects. There is no such problem with `Observers.empty()` as it is stateless. The change just uses `Subscribers.from()` to wrap `Observers.empty()` and every caller gets its own independent instance.
- `OperatorRefCount` was a bit more tricky. Since it has a connection counter, one has to serialize subscriptions with unsubscriptions. However, it is possible a subscription gets unsubscribed before code reaches the connect check which may disrupt the connection counter. The solution is to keep track of the unsubscriptions that happen before the connection attempts and not change the counter in case of out-of-order behavior. The final aim was to avoid leaking the connection statuses if the `unsafeSubscribe` throws concurrently with a client unsubscribing by using weak tokens (integers wouldn't have worked as the first 0-127 are cached in the JVM and would never GC).
",2014-04-30 11:26:53,2014-05-05 19:15:17,https://api.github.com/repos/ReactiveX/RxJava/issues/1137,[],220,35,ReactiveX_RxJava_pull_1137.diff
ReactiveX/RxJava,OperatorTakeUntil,"Operator `TakeUntil`

Issue #1060
",2014-04-30 04:31:18,2014-05-05 19:12:09,https://api.github.com/repos/ReactiveX/RxJava/issues/1135,[],118,142,ReactiveX_RxJava_pull_1135.diff
ReactiveX/RxJava,OperatorTakeLast,"Operator `TakeLast`.

There are two changes comparing with the original implementations:
- Throw IndexOutOfBoundsException at once when calling `takeLast` with `count < 0`.
- Replace IllegalArgumentException with IndexOutOfBoundsException  when `count < 0` in `TakeLastWithTimed`.

Issue #1060
",2014-04-30 04:16:56,2014-05-05 19:11:08,https://api.github.com/repos/ReactiveX/RxJava/issues/1134,[],305,343,ReactiveX_RxJava_pull_1134.diff
ReactiveX/RxJava,collapse imports,"attempt to reduce merge conflicts as it's always the import statements that are conflicting
",2014-04-30 00:12:59,2014-04-30 00:13:02,https://api.github.com/repos/ReactiveX/RxJava/issues/1133,[],10,128,ReactiveX_RxJava_pull_1133.diff
ReactiveX/RxJava,Manual Merge of Several PRs,"Merging many PRs that were conflicting.

Heroic work by @akarnokd and @zsxwing on #1060 

All unit tests are passing on my machine. Going to let this bake a while before a release. Other PRs on still on their way ... 
",2014-04-30 00:11:17,2014-04-30 00:11:23,https://api.github.com/repos/ReactiveX/RxJava/issues/1132,[],4521,5598,ReactiveX_RxJava_pull_1132.diff
ReactiveX/RxJava,Operator TakeTimed,"Operator Take with time

Issue #1060
",2014-04-29 16:13:24,2014-04-30 00:11:26,https://api.github.com/repos/ReactiveX/RxJava/issues/1131,[],87,292,ReactiveX_RxJava_pull_1131.diff
ReactiveX/RxJava,Operator Switch,"Operator Switch

Issue #1060
",2014-04-29 13:26:50,2014-04-30 00:11:26,https://api.github.com/repos/ReactiveX/RxJava/issues/1130,[],252,193,ReactiveX_RxJava_pull_1130.diff
ReactiveX/RxJava,Conditional statements contribution to Operator,"Operators rewritten in contrib-computation-expressions.

Issue #1060
",2014-04-29 12:08:53,2014-04-30 00:11:26,https://api.github.com/repos/ReactiveX/RxJava/issues/1129,[],243,336,ReactiveX_RxJava_pull_1129.diff
ReactiveX/RxJava,Fix for SerializedObserverTest,"Fixed the SerializedObserverTest's problematic assertions:
- `testMultiThreadedWithNPEinMiddle` might schedule all non-null values before the exception might reach the serialized observer. In addition, waiting after the serialization doesn't help because the cheap value emissions get queued up before that, again, possibly before the exception. The new code adds some delays to the non-null elements allowing the exception to get into the queue. I've looped it 10.000 times without failure, but there is still a non-zero chance the `new NullPointerException()` thread is significantly delayed and ends up as the last event.
- `testNotificationDelay` might fail due to thread scheduling of the two `OnNextThread` delayed too much in respect to each other before the main thread allows the pass-through. The fix is to let bot instances' Thread reach the run method and then let the main thread pass through them. Again, a loop of 10.000 succeeded locally.
- Both tests are run 10 times to be more sure.
",2014-04-29 11:32:19,2014-04-30 00:11:26,https://api.github.com/repos/ReactiveX/RxJava/issues/1128,[],107,95,ReactiveX_RxJava_pull_1128.diff
ReactiveX/RxJava,Operator When,"Operator When in contrib-joins

Issue #1060
",2014-04-29 09:01:59,2014-04-30 00:11:26,https://api.github.com/repos/ReactiveX/RxJava/issues/1126,[],25,25,ReactiveX_RxJava_pull_1126.diff
ReactiveX/RxJava,Operator contrib math,"Operators of contrib-math

Issue #1060

I only changed the average code to operators, left the sum and min/max as they were. Renamed files to operator.
",2014-04-29 08:32:39,2014-04-30 00:11:26,https://api.github.com/repos/ReactiveX/RxJava/issues/1125,[],397,389,ReactiveX_RxJava_pull_1125.diff
ReactiveX/RxJava,Add lift to rxscala,"This PR added `lift` to RxScala and also added a `Subscriber.apply` method to support to chain `Subscriber`s.

/cc @samuelgruetter
",2014-04-28 15:59:02,2014-05-05 19:09:43,https://api.github.com/repos/ReactiveX/RxJava/issues/1124,[],154,12,ReactiveX_RxJava_pull_1124.diff
ReactiveX/RxJava,Operator Window,"Operator Window

Issue #1060

Significant changes have been implemented in the new Window operator's behavior:
- The original sized, timed and start-end observable versions waited until a window has finished and emitted the buffered values as a single `Observable.from`. This is not how the Rx.NET version behaves where once a window is open, values are delivered as they appear from source. This has the same effects as `groupBy` where Observable windows not subscribed immediately will not deliver all values. Probably this is why Clojure test `test-partition-all` fails, but I don't know how to fix it there.
- The callback boundary-observable version, similar to the buffer variant before, constantly created a new observable for each value. This new version, consistent with the new buffer, uses one boundary source per subscribing client.
- The exact variants (such as size == skip, timespan == timeshift and observable boundary) make extra effort to ensure all events are delivered into one of the windows, i.e., no event will fall between the closing and opening of a window gap when it concurrently appears from the source.

This rewrite needs more meticulous review due to the changes and their concurrency effects.
",2014-04-28 15:07:50,2014-04-30 16:09:25,https://api.github.com/repos/ReactiveX/RxJava/issues/1123,[],1224,1240,ReactiveX_RxJava_pull_1123.diff
ReactiveX/RxJava,OperatorSkipUntil,"Operator SkipUntil
#1060
",2014-04-28 09:10:50,2014-04-30 00:11:25,https://api.github.com/repos/ReactiveX/RxJava/issues/1122,[],93,138,ReactiveX_RxJava_pull_1122.diff
ReactiveX/RxJava,OperatorSkipTimed,"Operator SkipTimed
#1060

There was an unexpected dependency in `OperationTakeTimedTest` and is surely to cause conflict when `TakeTimed` is rewritten. Once all operators have been merged, I suggest we create a primary `TestException` and rewrite tests to use it instead of all those custom exception classes everywhere.
",2014-04-28 08:52:34,2014-04-30 00:11:25,https://api.github.com/repos/ReactiveX/RxJava/issues/1121,[],89,130,ReactiveX_RxJava_pull_1121.diff
ReactiveX/RxJava,OperatorSequenceEqual,"Operator SequenceEqual
#1060

Lightened the operator, but note that NotificationLite escaping an operator may cause undesired effects in other operators relying on NotificationLite as well.
",2014-04-28 08:22:03,2014-04-30 00:11:25,https://api.github.com/repos/ReactiveX/RxJava/issues/1120,[],27,29,ReactiveX_RxJava_pull_1120.diff
ReactiveX/RxJava,OperatorRefCount,"Operator RefCount
#1060
",2014-04-28 07:47:53,2014-04-30 00:11:25,https://api.github.com/repos/ReactiveX/RxJava/issues/1119,[],66,69,ReactiveX_RxJava_pull_1119.diff
ReactiveX/RxJava,Operator ParallelMerge,"Operator ParallelMerge, just renamed

Issue #1060
",2014-04-28 07:21:16,2014-04-30 00:11:25,https://api.github.com/repos/ReactiveX/RxJava/issues/1118,[],10,9,ReactiveX_RxJava_pull_1118.diff
ReactiveX/RxJava,Operator OnExceptionResumeNextViaObservable,"Operator OnExceptionResumeNextViaObservable

Issue #1060
",2014-04-28 07:06:55,2014-04-30 00:11:25,https://api.github.com/repos/ReactiveX/RxJava/issues/1117,[],94,131,ReactiveX_RxJava_pull_1117.diff
ReactiveX/RxJava,OperatorTakeWhile,"Operator `TakeWhile`

Issue #1060
",2014-04-27 15:27:23,2014-04-30 00:11:25,https://api.github.com/repos/ReactiveX/RxJava/issues/1115,[],103,168,ReactiveX_RxJava_pull_1115.diff
ReactiveX/RxJava,testing push to remote fork repository,"testing pull request to a fork???
",2014-04-27 05:53:20,2014-04-27 05:53:39,https://api.github.com/repos/ReactiveX/RxJava/issues/1114,[],0,0,ReactiveX_RxJava_pull_1114.diff
ReactiveX/RxJava,testing push to remote fork repository,"testing pull request to a fork???
",2014-04-27 05:52:01,2014-04-27 05:52:49,https://api.github.com/repos/ReactiveX/RxJava/issues/1113,[],0,0,ReactiveX_RxJava_pull_1113.diff
ReactiveX/RxJava,OperatorThrottleFirst,"Operator `ThrottleFirst` and moved tests in `ThrottleFirstTests` to `OperatorThrottleFirstTest`.

Issue #1060
",2014-04-27 03:34:57,2014-04-30 00:11:25,https://api.github.com/repos/ReactiveX/RxJava/issues/1112,[],108,166,ReactiveX_RxJava_pull_1112.diff
ReactiveX/RxJava,OperatorTimeInterval,"Operator `TimeInterval`

Issue #1060
",2014-04-27 02:22:06,2014-04-30 00:11:25,https://api.github.com/repos/ReactiveX/RxJava/issues/1111,[],64,88,ReactiveX_RxJava_pull_1111.diff
ReactiveX/RxJava,OperatorOnErrorReturn,"Operator OnErrorReturn

Issue #1060
",2014-04-25 22:44:09,2014-04-30 00:11:25,https://api.github.com/repos/ReactiveX/RxJava/issues/1110,[],91,137,ReactiveX_RxJava_pull_1110.diff
ReactiveX/RxJava,OperatorOnErrorResumeNextViaObservable,"Operator OnErrorResumeNextViaObservable

Issue #1060
",2014-04-25 22:25:47,2014-04-30 00:11:25,https://api.github.com/repos/ReactiveX/RxJava/issues/1109,[],83,121,ReactiveX_RxJava_pull_1109.diff
ReactiveX/RxJava,OperatorMulticastAndReplay,"Operator Multicast and Replay, because Replay is effectively a multicasted subject.

Issue #1060
",2014-04-25 21:44:58,2014-04-30 00:11:25,https://api.github.com/repos/ReactiveX/RxJava/issues/1108,[],259,254,ReactiveX_RxJava_pull_1108.diff
ReactiveX/RxJava,Fix ReplaySubject's double termination problem.,"Fix for issue #1105
",2014-04-25 20:21:51,2014-04-30 00:11:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1107,[],44,4,ReactiveX_RxJava_pull_1107.diff
ReactiveX/RxJava,OperatorMergeMaxConcurrent,"Operator MergeMaxConcurrent

Issue #1060
",2014-04-25 19:26:35,2014-04-30 00:11:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1106,[],161,222,ReactiveX_RxJava_pull_1106.diff
ReactiveX/RxJava,Operator merge delay error,"Operator MergeDelayError

Issue #1060
",2014-04-25 18:12:14,2014-04-30 00:11:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1104,[],217,391,ReactiveX_RxJava_pull_1104.diff
ReactiveX/RxJava,OperatorJoin,"Operator Join

Issue #1060

Remark: now that the client.onNext is called outside the synchronization block, joint results may appear in arbitrary order in case both left and right observables emit values concurrently. I suppose the strict ordering is not really expected here, but someone who uses this operator can tell (@duncani perhaps?) .
",2014-04-25 17:01:10,2014-04-30 00:11:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1103,[],329,311,ReactiveX_RxJava_pull_1103.diff
ReactiveX/RxJava,rxjava-android Poposal: Call action immediately in HandlerThreadScheduler if thread is the same,"By avoiding unnecessary Runnable creation, and posting it to handler we can decrease overhead when scheduling is made from the same thread.

Current Activity.runOnUIThread is implemented in the same way:

``` java
    public final void runOnUiThread(Runnable action) {
        if (Thread.currentThread() != mUiThread) {
            mHandler.post(action);
        } else {
            action.run();
        }
    }
```
",2014-04-25 15:35:08,2014-05-17 15:30:08,https://api.github.com/repos/ReactiveX/RxJava/issues/1102,[],49,10,ReactiveX_RxJava_pull_1102.diff
ReactiveX/RxJava,Operator async,"`contrib-async-util` mostly renames, deprecated api removed, file comment fixed

Sidenote: for me, NetBeans 8.0 editor shows errors in all the files, unable to find rxjava-core classes. Using build command from the menu works. This is true for the other contrib packages as well. Any tips on why?
",2014-04-25 14:56:32,2014-04-30 00:11:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1101,[],59,192,ReactiveX_RxJava_pull_1101.diff
ReactiveX/RxJava,OperatorUsing,"Operator `Using`

Issue #1060
",2014-04-25 14:48:21,2014-04-30 00:11:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1100,[],62,75,ReactiveX_RxJava_pull_1100.diff
ReactiveX/RxJava,OperatorToMap,"Operator `ToMap`

Issue #1060
",2014-04-25 14:20:53,2014-04-30 00:11:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1099,[],115,182,ReactiveX_RxJava_pull_1099.diff
ReactiveX/RxJava,OperatorTimerAndSample,"Operator Timer and Sample

Because there was a dependency in Sample towards the now removed Interval, I had to reimplement Sample in this PR as well.

Note that the new `OperatorSampleWithTime` schedules its first sample call before any upstream code is executed. Given the TestScheduler, a sample with 1sec and a timer with 1sec as well won't sample any value. The reason is that in the internal queue of TestScheduler, the sampler's action to take the sample is followed by the action to emit the timer's value.
",2014-04-25 13:55:09,2014-04-30 00:11:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1098,[],454,513,ReactiveX_RxJava_pull_1098.diff
ReactiveX/RxJava,OperatorToMultimap,"Operator `ToMultimap`

Issue #1060
",2014-04-25 13:44:29,2014-04-30 00:11:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1097,[],157,239,ReactiveX_RxJava_pull_1097.diff
ReactiveX/RxJava,OperatorGroupJoin,"Operator GroupJoin

for Issue #1060

Maybe this could be moved to the new joins.
",2014-04-25 09:59:30,2014-04-30 00:11:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1096,[],147,121,ReactiveX_RxJava_pull_1096.diff
ReactiveX/RxJava,OperatorGroupByUntil,"Operator GroupByUntil

For Issue #1060

While rewriting, I've noticed a common pitfall with the observation of the duration: many other operators react to onNext or onCompleted, but one should only ""expire"" once. I'll review my recent operators and post a separate PR if any.
",2014-04-25 08:53:29,2014-04-30 00:11:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1095,[],242,249,ReactiveX_RxJava_pull_1095.diff
ReactiveX/RxJava,Operator debounce2,"Operator Debounce again with improvements as discusssed in #1075

For Issue #1060
",2014-04-25 08:04:35,2014-04-30 00:11:24,https://api.github.com/repos/ReactiveX/RxJava/issues/1094,[],336,329,ReactiveX_RxJava_pull_1094.diff
ReactiveX/RxJava,OperatorDelay,"Operator Delay rewritten and improved as discussed in #1082

For Issue #1060
",2014-04-25 07:27:39,2014-05-05 05:51:41,https://api.github.com/repos/ReactiveX/RxJava/issues/1093,[],358,321,ReactiveX_RxJava_pull_1093.diff
ReactiveX/RxJava,Restore ObservableExecutionHook.onCreate,,2014-04-25 02:58:02,2014-04-25 03:01:00,https://api.github.com/repos/ReactiveX/RxJava/issues/1092,[],2,2,ReactiveX_RxJava_pull_1092.diff
ReactiveX/RxJava,Handle Thrown Errors with UnsafeSubscribe,"... oxymoronic commit here ... adding some safety to unsafeSubscribe.
... fixes https://github.com/Netflix/RxJava/issues/1090
",2014-04-25 02:57:30,2014-04-25 02:57:34,https://api.github.com/repos/ReactiveX/RxJava/issues/1091,[],57,1,ReactiveX_RxJava_pull_1091.diff
ReactiveX/RxJava,Manual Merge of Several PRs,"This was a manual merge since each of these was conflicting due to the changing import statements at the top. I really wish Github allowed easily handling these ... 
",2014-04-24 21:17:05,2014-04-24 21:21:37,https://api.github.com/repos/ReactiveX/RxJava/issues/1089,[],1884,2133,ReactiveX_RxJava_pull_1089.diff
ReactiveX/RxJava,OperatorToObservableFuture,"Also make the Observable be able to unsubscribe.

Issue #1060
",2014-04-24 15:28:29,2014-04-24 21:21:38,https://api.github.com/repos/ReactiveX/RxJava/issues/1088,[],38,34,ReactiveX_RxJava_pull_1088.diff
ReactiveX/RxJava,OperatorMergeMap,"Operator MergeMap, namely the paired and the one which turns all event kinds into Observables to merge.

Issue #1060
",2014-04-24 15:14:05,2014-04-24 21:21:38,https://api.github.com/repos/ReactiveX/RxJava/issues/1087,[],258,400,ReactiveX_RxJava_pull_1087.diff
ReactiveX/RxJava,OperatorFinallyDo,"Operator FinallyDo

Issue #1060
",2014-04-24 14:26:09,2014-04-24 21:21:38,https://api.github.com/repos/ReactiveX/RxJava/issues/1086,[],72,111,ReactiveX_RxJava_pull_1086.diff
ReactiveX/RxJava,OperatorDistinctUntilChanged,"Operator DistinctUntilChanged

Issue #1060

Again, I haven't ported the custom comparator version.
",2014-04-24 14:13:05,2014-04-24 21:21:38,https://api.github.com/repos/ReactiveX/RxJava/issues/1085,[],78,219,ReactiveX_RxJava_pull_1085.diff
ReactiveX/RxJava,OperatorDistinct,"Operator Distinct

Issue #1060

I didn't port the variant with the custom key comparator because it has been decided to rely on `Object.equals` and there were not exposed anyway.
",2014-04-24 13:51:15,2014-04-24 21:21:38,https://api.github.com/repos/ReactiveX/RxJava/issues/1084,[],74,262,ReactiveX_RxJava_pull_1084.diff
ReactiveX/RxJava,OperatorDematerialize,"Operator Dematerialize

Issue #1060

Two notes:
- Since the dematerialize() is an instance method, there is no correct type parametrization for the operator. Therefore, I just used a raw version in the call.
- The original dematerialize could send out two onCompleted or an onError followed by an onCompleted because the materialize() always adds an onCompleted after the raw events. This affected operators due to unsafeSubscribe. This new version ensures this doesn't happen.
",2014-04-24 13:19:13,2014-04-24 21:21:38,https://api.github.com/repos/ReactiveX/RxJava/issues/1083,[],112,93,ReactiveX_RxJava_pull_1083.diff
ReactiveX/RxJava,OperatorDelay,"Operator Delay

Issue #1060

I've applied the same item-delaying logic found in the timed delay to the selector-based delay. It looks elegant but adds a few extra layers layers and thus increases the per item delivery overhead.
",2014-04-24 12:46:31,2014-04-25 06:42:32,https://api.github.com/repos/ReactiveX/RxJava/issues/1082,[],274,320,ReactiveX_RxJava_pull_1082.diff
ReactiveX/RxJava,OperatorDefer,"Operator Defer

Issue #1060
",2014-04-24 11:14:24,2014-04-24 21:21:37,https://api.github.com/repos/ReactiveX/RxJava/issues/1081,[],40,23,ReactiveX_RxJava_pull_1081.diff
ReactiveX/RxJava,OperatorDefaultIfEmpty,"Operator DefaultIfEmpty

Issue #1060
",2014-04-24 10:57:30,2014-04-24 21:21:37,https://api.github.com/repos/ReactiveX/RxJava/issues/1080,[],149,159,ReactiveX_RxJava_pull_1080.diff
ReactiveX/RxJava,OperatorCombineLatest,"Operator CombineLatest

Issue #1060

Remarks:
- Added an overload to Observable which accepts any number of sources. Not sure why it wasn't exposed before? Perhaps removed?
- Relying on just the SO's onNext is not enough as leaving the synchronized block allows reordering of onNext calls. Therefore, the combinator uses the trick from SerializedObserver to make sure the combination order is consistent with whe winning of the synchronization ""race"". 
",2014-04-24 09:56:17,2014-04-24 21:21:37,https://api.github.com/repos/ReactiveX/RxJava/issues/1079,[],1054,815,ReactiveX_RxJava_pull_1079.diff
ReactiveX/RxJava,OperatorDebounce,"Operator Debounce

Issue #1060

Two notes:
- The behavior of the timed debounce has changed. In the original, if an onCompleted event arrived after an onNext event, that last value was lost. This new version emits the last value if it can then completes. This is consistent with the selector-based debounce operator from before and now.
- In both overloads, when the emission is run in parallel with the onCompleted of the main, the last event might or might not reach the client subscriber: one of the threads will grab the last value, but the call to the client.onCompleted might prevent the value delivery in the emission thread. This couldn't happen in the original as the event emissions where performed under the lock as well. We need to decide if we want to handle this corner case.
",2014-04-23 15:04:12,2014-04-25 07:53:40,https://api.github.com/repos/ReactiveX/RxJava/issues/1075,[],311,328,ReactiveX_RxJava_pull_1075.diff
ReactiveX/RxJava,OperatorConcat,"Operator Concat

Issue #1060
",2014-04-23 13:09:55,2014-04-24 18:59:12,https://api.github.com/repos/ReactiveX/RxJava/issues/1074,[],207,204,ReactiveX_RxJava_pull_1074.diff
ReactiveX/RxJava,OperatorBuffer,"Operator Buffer, split into 4 variants.

Issue #1060.

There are some important behavioral changes compared to the original versions:
- When an onError event appears from anywhere, the currently accumulated chunk(s) are _NOT_ emitted before the error is propagated. This conforms with Rx Design Guideline 6.6.
- The Observable returned by the Func0 inside the `buffer(Func0<Observable<B>>)` now is used as long as possible and whenever it fires an event, a new buffer chunk is started. The Func0 is called only once per subscriber. The original called it and subscribed to it all the time, causing all-increasing resubscriptions.
",2014-04-23 09:32:36,2014-04-24 18:56:52,https://api.github.com/repos/ReactiveX/RxJava/issues/1073,[],1143,596,ReactiveX_RxJava_pull_1073.diff
ReactiveX/RxJava,Scheduler.Inner -> Scheduler.Worker,"As per decision at https://github.com/Netflix/RxJava/issues/997#issuecomment-40998613
",2014-04-23 04:32:57,2014-04-23 04:33:06,https://api.github.com/repos/ReactiveX/RxJava/issues/1072,[],158,156,ReactiveX_RxJava_pull_1072.diff
ReactiveX/RxJava,Manual Merge of AsObservable,,2014-04-23 04:15:19,2014-04-23 04:15:39,https://api.github.com/repos/ReactiveX/RxJava/issues/1071,[],73,15,ReactiveX_RxJava_pull_1071.diff
ReactiveX/RxJava,Manual Merge of OperatorAny,,2014-04-23 04:09:33,2014-04-23 04:10:05,https://api.github.com/repos/ReactiveX/RxJava/issues/1070,[],94,149,ReactiveX_RxJava_pull_1070.diff
ReactiveX/RxJava,Manual Merge of OperatorAll,,2014-04-23 04:01:08,2014-04-23 04:01:15,https://api.github.com/repos/ReactiveX/RxJava/issues/1069,[],77,102,ReactiveX_RxJava_pull_1069.diff
ReactiveX/RxJava,add synchronous test of resubscribe after error,"I've added a simple synchronous test of resubscription after error. Retry has had a chequered history of late and I think might benefit from extra tests. The scenario is perhaps covered by the recent additions with #1027 but the test additions for that were async and more complex. This simple scenario broke for versions to 0.16.1 to 0.17.4, hung with 0.17.5 and passes in 0.17.6.
",2014-04-23 03:57:02,2014-04-23 04:20:14,https://api.github.com/repos/ReactiveX/RxJava/issues/1068,[],47,0,ReactiveX_RxJava_pull_1068.diff
ReactiveX/RxJava,CompositeSubscription fix,"A bug in the remove() method caused ArrayIndexOutOfBoundsException if the composite is not empty and trying to remove a subscription that is not in the composite at all.
",2014-04-22 16:07:33,2014-04-23 04:19:32,https://api.github.com/repos/ReactiveX/RxJava/issues/1066,[],14,1,ReactiveX_RxJava_pull_1066.diff
ReactiveX/RxJava,Optimize OperatorSkipLastTimed,"Changed OperatorSkipLastTimed to only cache the latest items in the specified time window.
",2014-04-22 13:09:43,2014-04-24 18:54:49,https://api.github.com/repos/ReactiveX/RxJava/issues/1065,[],25,28,ReactiveX_RxJava_pull_1065.diff
ReactiveX/RxJava,Operator AsObservable,"Rewritten AsObservable.

Issue #1060
",2014-04-22 10:40:30,2014-04-23 04:15:39,https://api.github.com/repos/ReactiveX/RxJava/issues/1064,[],73,15,ReactiveX_RxJava_pull_1064.diff
ReactiveX/RxJava,Fix bugs in equals and hashCode of Timestamped,"`equals` and `hashCode` of `Timestamped` are not correct. I just used eclipse to generate a new one.
",2014-04-22 09:50:36,2014-04-23 04:10:32,https://api.github.com/repos/ReactiveX/RxJava/issues/1063,[],4,1,ReactiveX_RxJava_pull_1063.diff
ReactiveX/RxJava,OperatorAny,"Reimplemented `Any`, aka `IsEmpty` and `Exists`.

Issue #1060
",2014-04-22 09:36:57,2014-04-23 04:10:05,https://api.github.com/repos/ReactiveX/RxJava/issues/1062,[],94,147,ReactiveX_RxJava_pull_1062.diff
ReactiveX/RxJava,OperatorAll,"Reimplemented `All`.

Issue #1060
",2014-04-22 08:59:00,2014-04-23 04:01:16,https://api.github.com/repos/ReactiveX/RxJava/issues/1061,[],84,102,ReactiveX_RxJava_pull_1061.diff
ReactiveX/RxJava,Typo in javadoc,,2014-04-21 19:51:09,2014-04-21 19:55:23,https://api.github.com/repos/ReactiveX/RxJava/issues/1058,[],1,1,ReactiveX_RxJava_pull_1058.diff
ReactiveX/RxJava,Fix issue #1044,"This PR eliminated the ambiguities described in #1044.
",2014-04-20 14:52:21,2014-04-21 16:48:04,https://api.github.com/repos/ReactiveX/RxJava/issues/1057,[],13,2,ReactiveX_RxJava_pull_1057.diff
ReactiveX/RxJava,Add drop(skip) and dropRight(skipLast) to rxscala,,2014-04-20 13:18:21,2014-04-21 16:48:23,https://api.github.com/repos/ReactiveX/RxJava/issues/1056,[],112,1,ReactiveX_RxJava_pull_1056.diff
ReactiveX/RxJava,close #1054,,2014-04-20 12:18:09,2014-04-21 16:46:26,https://api.github.com/repos/ReactiveX/RxJava/issues/1055,[],3,0,ReactiveX_RxJava_pull_1055.diff
ReactiveX/RxJava,Deprecation Cleanup,"The time has come to delete the deprecated methods/classes.

A few still remain to be done before 1.0 but can't be done until all operators are migrated:
- `Observable.OnSubscribeFunc`
- `Observable.create(OnSubscribeFunc)`
- `SafeObservableSubscription`
- `SafeObserver`
",2014-04-20 05:27:08,2014-04-20 05:28:06,https://api.github.com/repos/ReactiveX/RxJava/issues/1053,[],141,5919,ReactiveX_RxJava_pull_1053.diff
ReactiveX/RxJava,Scheduler Cleanup,"ComputationScheduler -> EventLoopsScheduler
Restoring parallel() to using Schedulers.computation()
",2014-04-20 04:12:12,2014-04-20 04:12:17,https://api.github.com/repos/ReactiveX/RxJava/issues/1052,[],3,5,ReactiveX_RxJava_pull_1052.diff
ReactiveX/RxJava,Manual Merge #967,"Manually merge #967
",2014-04-20 03:34:14,2014-04-20 03:34:21,https://api.github.com/repos/ReactiveX/RxJava/issues/1051,[],275,186,ReactiveX_RxJava_pull_1051.diff
ReactiveX/RxJava,Reimplement the 'SkipLast' operator,"This PR did the following work:
- Reimplemented the `SkipLast` operator to two different classes: `OperatorSkipLast` and `OperatorSkipLastWithTimed`.
- Fixed a bug in `OperatorSkipLastWithTimed` that when all elements are valid, `onCompleted` will not be called. The unit test is `testSkipLastTimedWhenAllElementsAreValid`.
",2014-04-19 14:57:27,2014-04-20 03:57:28,https://api.github.com/repos/ReactiveX/RxJava/issues/1050,[],421,422,ReactiveX_RxJava_pull_1050.diff
ReactiveX/RxJava,Move rx.joins to rxjava-joins module,"Migrating rx.joins into a separate contrib module as part of roadmap to 1.0: https://github.com/Netflix/RxJava/issues/1001#issuecomment-40390984
This is being done until the rx.joins API has further time to mature as it is likely to change and we can't make breaking changes any further once we hit 1.0.
",2014-04-19 04:36:07,2014-04-19 04:42:06,https://api.github.com/repos/ReactiveX/RxJava/issues/1049,[],368,325,ReactiveX_RxJava_pull_1049.diff
ReactiveX/RxJava,Remove ExecutorScheduler - New ComputationScheduler,"Removing `ExecutorScheduler` as it does not comply with the contract of sequential execution. A Scheduler needs to guarantee sequential execution, but putting work on a multi-threaded thread pool allows concurrent execution. 

See https://github.com/Netflix/RxJava/issues/711 and https://github.com/Netflix/RxJava/issues/713
",2014-04-19 04:02:48,2014-04-19 04:03:28,https://api.github.com/repos/ReactiveX/RxJava/issues/1048,[],199,449,ReactiveX_RxJava_pull_1048.diff
ReactiveX/RxJava,Scheduler Simplification,"API redesign (simplification) as per discussion at https://github.com/Netflix/RxJava/issues/997

The `Scheduler` API in this pull request is:

``` java
class Scheduler {
    public abstract Inner Inner(); 
    public int degreeOfParallelism();
    public long now();

    public abstract static class Inner implements Subscription {
        public abstract Subscription schedule(Action0 action, long delayTime, TimeUnit unit);
        public abstract Subscription schedule(Action0 action);
        public final void schedulePeriodically(Action0 action, long initialDelay, long period, TimeUnit unit);
        public long now();
    }
}
```

While migrating to this I found a 4th use case in addition to the previously discussed 3 that required the `schedule` methods inside `Inner` to also return `Subscription` for canceling the individual tasks as opposed to the entire `Inner`.

Here are the use cases:
#### 1) Single Action

``` java
final Inner is = scheduler.inner();
is.schedule(new Action0() {

    @Override
    public void call() {
        // do work here
    }
})

is.unsubscribe()
```

with lambda

``` java
final Inner is = scheduler.inner);
is.schedule(() -> {
        // do work here
})

is.unsubscribe()
```
#### 2) Inner Recursion

``` java
final Inner is = scheduler.inner();
is.schedule(new Action0() {

    @Override
    public void call() {
        // do work here then recursively reschedule
    is.schedule(this); // this will NOT work with lambdas, only anonymous inner classes
    }
})

is.unsubscribe()
```
#### 3) Outer Recursion

``` java
final Inner is = scheduler.inner();

public void onNext(T t) {
    is.schedule(new Action0() {

        @Override
        public void call() {
            // do work here
        }
    })
}

is.unsubscribe()
```
#### 4) Outer Recursion with Task Cancellation

This is used for things like `debounce` and `throttleLast` where tasks are being scheduled and cancelled as `onNext` notifications are received.

``` java
final Inner is = scheduler.inner();
SerialSubscription serial = new SerialSubscription();

public void onNext(T t) {
    // schedule a new task and cancel previous if not yet executed
    serial.set(is.schedule(new Action0() {

        @Override
        public void call() {
            // do work here
        }
    }));
}

is.unsubscribe()
```
",2014-04-18 05:29:35,2014-04-19 02:13:21,https://api.github.com/repos/ReactiveX/RxJava/issues/1047,[],1591,2052,ReactiveX_RxJava_pull_1047.diff
ReactiveX/RxJava,Reduce the scope of locking to increase parallelism.,"In my rxmon project https://github.com/vigdorchik/rxmon I make heavy use of combineLatest. This change that reduces the scope of locking should help increase combineLatest throughput. I wish I could report the speedup numbers, but I couldn't find how to publish RxJava to maven locally to try it out.
",2014-04-16 13:10:36,2014-04-17 07:52:30,https://api.github.com/repos/ReactiveX/RxJava/issues/1043,[],46,54,ReactiveX_RxJava_pull_1043.diff
ReactiveX/RxJava,Kotlin M7 and full compatibility with 0.17.0,,2014-04-16 01:51:48,2014-04-16 16:01:33,https://api.github.com/repos/ReactiveX/RxJava/issues/1042,[],64,57,ReactiveX_RxJava_pull_1042.diff
ReactiveX/RxJava,Merge and Cleanup of #972,"@akarnokd I have manually merged your changes (https://github.com/Netflix/RxJava/pull/972) and migrated from `Action1` to `Action0` as we discussed. 

Can you review what I did on top of your changes to make sure it's correct. It seems correct to me but there is some nuanced concurrency here (obviously, hence your fixes) and I would appreciate your validation. 
",2014-04-15 22:54:28,2014-04-16 16:00:39,https://api.github.com/repos/ReactiveX/RxJava/issues/1040,[],324,239,ReactiveX_RxJava_pull_1040.diff
ReactiveX/RxJava,rxjava-android: parameterize OperatorViewClick by concrete view type,"Parameterize OperatorViewClick observable to actual View type.
So actual view with it native type can be used.

So instead of 

```
Observable<View> imageClicks = ViewObservable.clicks(imageView, false);
        //...
        imageClicks.subscribe(new Action1<View>() {
            @Override
            public void call(View view) {
                ImageView imageView = (ImageView) view;
                imageView.setImageBitmap(bitmap);
            }
        });
```

you can use

```
        Observable<ImageView> imageClicks = ViewObservable.clicks(imageView, false);
        //...
        imageClicks.subscribe(new Action1<ImageView>() {
            @Override
            public void call(ImageView view) {
                view.setImageBitmap(bitmap);
            }
        });
```
",2014-04-15 21:07:09,2014-04-16 16:02:40,https://api.github.com/repos/ReactiveX/RxJava/issues/1038,[],5,5,ReactiveX_RxJava_pull_1038.diff
ReactiveX/RxJava,replaced FRP with RP in README title,"Mentioning ""Functional Reactive Programming"" causes confusion and misconception.
I think it's better to simply stick with ""Reactive Programming"".
",2014-04-14 11:53:14,2014-04-15 21:53:50,https://api.github.com/repos/ReactiveX/RxJava/issues/1036,[],1,1,ReactiveX_RxJava_pull_1036.diff
ReactiveX/RxJava,Scala cleanup,"Review by @headinthebox and @samuelgruetter.
",2014-04-14 10:08:20,2014-04-16 16:01:44,https://api.github.com/repos/ReactiveX/RxJava/issues/1035,[],8,10,ReactiveX_RxJava_pull_1035.diff
ReactiveX/RxJava,Manual Merge #1027,"While reviewing #1027 I added another unit test to understand the issue. Fix by @petermd is good.
",2014-04-12 00:06:04,2014-04-12 00:09:14,https://api.github.com/repos/ReactiveX/RxJava/issues/1033,[],191,100,ReactiveX_RxJava_pull_1033.diff
ReactiveX/RxJava,Scheduler with Schedulable/EventLoop,"API changes as per https://github.com/Netflix/RxJava/issues/997
",2014-04-11 20:04:49,2014-04-15 21:55:54,https://api.github.com/repos/ReactiveX/RxJava/issues/1032,[],666,663,ReactiveX_RxJava_pull_1032.diff
ReactiveX/RxJava,Fix NPE in SubjectSubscriptionManager,"If unsubscribed it should just return, not continue forward. If it does, the `newState` is null and it throws an NPE. 
",2014-04-11 19:54:00,2014-04-11 19:54:03,https://api.github.com/repos/ReactiveX/RxJava/issues/1031,[],1,1,ReactiveX_RxJava_pull_1031.diff
ReactiveX/RxJava,Benchmarking: Add JMH benchmark for ReplaySubject.,"Adds some benches for the replay subject.

I.E.

```
Benchmark                                     (nextRuns)   Mode   Samples         Mean   Mean error    Units
r.s.ReplaySubjectPerf.subscribeAfterEvents             1  thrpt         5  1898239.827    57634.047    ops/s
r.s.ReplaySubjectPerf.subscribeAfterEvents          1024  thrpt         5    35680.927      470.929    ops/s
r.s.ReplaySubjectPerf.subscribeAfterEvents       1048576  thrpt         5       32.427        1.462    ops/s
r.s.ReplaySubjectPerf.subscribeBeforeEvents            1  thrpt         5  1427820.733    19194.452    ops/s
r.s.ReplaySubjectPerf.subscribeBeforeEvents         1024  thrpt         5    36835.800      264.748    ops/s
r.s.ReplaySubjectPerf.subscribeBeforeEvents      1048576  thrpt         5       35.520        1.145    ops/s
```
",2014-04-11 18:05:52,2014-04-11 19:54:53,https://api.github.com/repos/ReactiveX/RxJava/issues/1030,[],143,0,ReactiveX_RxJava_pull_1030.diff
ReactiveX/RxJava,"isolate subscriber used for retries, cleanup tests","potential fix for #1024

there is an outstanding question (see commit comments) about whether its appropriate for the operator to use `unsafeSubscribe` given that it does not completely isolate the `Subscriber` from a badly behaved `Observable`.
",2014-04-09 10:07:43,2014-04-12 00:09:15,https://api.github.com/repos/ReactiveX/RxJava/issues/1027,[],146,88,ReactiveX_RxJava_pull_1027.diff
ReactiveX/RxJava,Adding a unit test to demo a concurrency issue with Observer catchup on a ReplaySubject.,"For issue #1025
",2014-04-09 00:32:47,2014-04-09 20:25:11,https://api.github.com/repos/ReactiveX/RxJava/issues/1026,[],29,3,ReactiveX_RxJava_pull_1026.diff
ReactiveX/RxJava,OperatorWeakBinding to not use WeakReferences anymore,"related issues:
https://github.com/Netflix/RxJava/pull/1008
https://github.com/Netflix/RxJava/issues/1006
https://github.com/Netflix/RxJava/issues/979

I changed the samples to actually use `bindActivity` and `bindFragment`
",2014-04-06 09:43:05,2014-04-15 21:52:27,https://api.github.com/repos/ReactiveX/RxJava/issues/1021,[],320,225,ReactiveX_RxJava_pull_1021.diff
ReactiveX/RxJava,Upgrade Gradle wrapper for Android samples to Gradle 1.11,"Android Studio 0.5.4 refuses to build with 1.10.
",2014-04-05 15:30:24,2014-04-16 16:02:28,https://api.github.com/repos/ReactiveX/RxJava/issues/1020,[],2,2,ReactiveX_RxJava_pull_1020.diff
ReactiveX/RxJava,Fix: retry() never unsubscribes from source until operator completes,"This fixes https://github.com/Netflix/RxJava/issues/1018

Thank you @petermd
",2014-04-04 17:15:05,2014-04-04 17:16:23,https://api.github.com/repos/ReactiveX/RxJava/issues/1019,[],107,9,ReactiveX_RxJava_pull_1019.diff
ReactiveX/RxJava,Remove Redundant protectivelyWrap Method,,2014-04-03 16:50:25,2014-04-03 16:50:29,https://api.github.com/repos/ReactiveX/RxJava/issues/1015,[],12,40,ReactiveX_RxJava_pull_1015.diff
ReactiveX/RxJava,Scheduler with Recurse/Inner,"API changes as per https://github.com/Netflix/RxJava/issues/997

Usage looks like this:

``` java
import java.util.concurrent.TimeUnit;

import rx.Scheduler.Inner;
import rx.Scheduler.Recurse;
import rx.functions.Action1;
import rx.schedulers.Schedulers;

public class Test {

    public static void main(String args[]) {

        Schedulers.newThread().schedule(new Action1<Recurse>() {

            @Override
            public void call(Recurse inner) {
                System.out.println(""do stuff"");
                // recurse
                inner.schedule(this);
            }

        });

        Schedulers.newThread().schedule(recurse -> {
            System.out.println(""do stuff"");
            recurse.schedule();
        });

        Schedulers.newThread().schedule(recurse -> {
            System.out.println(""do stuff"");
            recurse.schedule(1000, TimeUnit.MILLISECONDS);
        });

        Schedulers.newThread().schedule(recurse -> {
            recurse.schedule(re -> {
                System.out.println(""do more stuff"");
            });
        });

        Inner inner = Schedulers.newThread().createInner();
        inner.schedule(re -> {
            System.out.println(""do stuff"");
            re.schedule(r -> {
                System.out.println(""do more stuff"");
            });
        });

    }
}
```

Code outline:

![screen shot 2014-04-02 at 11 08 31 pm](https://cloud.githubusercontent.com/assets/813492/2600101/6c680404-baf6-11e3-916e-c41a817bc328.png)
",2014-04-03 06:09:18,2014-04-11 20:01:41,https://api.github.com/repos/ReactiveX/RxJava/issues/1014,[],637,623,ReactiveX_RxJava_pull_1014.diff
ReactiveX/RxJava,Removed window between the two synchronized blocks.,"In the original version, there was a window between finding a null queue and setting emitting false due to being in different synchronized block. If another thread came in this window, it created a new queue with its event which was not emitted until another onXXX method was called, causing unnecessary event delivery delay.

While running the tests, the `SerializedObserverTest.testNotificationDelay` failed from time to time due to thread timing. I haven't fixed this test.
",2014-04-02 07:48:01,2014-04-02 19:36:00,https://api.github.com/repos/ReactiveX/RxJava/issues/1012,[],19,13,ReactiveX_RxJava_pull_1012.diff
ReactiveX/RxJava,UnsafeSubscribe,"Migrate from reflection to unsafeSubscribe as per discussion at https://github.com/Netflix/RxJava/issues/676

All operators are migrated to using `unsafeSubscribe` instead of relying on their package to avoid `SafeSubscriber` wrapping.
",2014-04-02 06:04:38,2014-04-03 04:41:49,https://api.github.com/repos/ReactiveX/RxJava/issues/1010,[],604,687,ReactiveX_RxJava_pull_1010.diff
ReactiveX/RxJava,Android - Adding a new RetainedFragment example,"I wanted to augment the current `RetainedFragment` example class to address some scenarios I have run into using the patterns defined in the current example.  

I was hoping to get some feedback on a more complete scenario I have been working on which is the following.

On a typical login screen when the user taps a button we want to fire off our network request in an observable. We want to show a progress dialog and then show either success or an error dialog when it fails. We want to gracefully handle rotation and app switching in case a user does something else after firing off the login call. When the user returns we should be able to tell them there was an error or continue forward. 

I tried to address this scenario above but specifically I wanted to try and complete the following.
- Get all the benefits from the current example - i.e. rotation support
- Make sure the callbacks are not triggered while the app is not in focus
- Make the example be triggered by a user action - i.e. a user tapping a button

Hoping to get some feedback on the example and see if there are any issues with the sample implementation. 

Any issues you see here @mttkay or other android RX users?

Thanks
",2014-04-01 21:03:39,2014-04-16 16:01:51,https://api.github.com/repos/ReactiveX/RxJava/issues/1009,[],193,1,ReactiveX_RxJava_pull_1009.diff
ReactiveX/RxJava,Fix premature garbage collection of subscriber,"Keeping a weak binding onto the subscriber makes it possible to prematurely get the subscriber garbage collected if there are no other references to it.

Here, we chose to pass around the component to which the subscriber is tied in form of a pair (`BoundPayload`). This allows the subscribers to get a reference on the (guaranteed non-collected) target without keeping it in the closure.

This introduces an interface change, but the current implementation is wrong and should never be used (see issues #979 and #1006).

An example usage can be seen at https://github.com/samueltardieu/cgeo/blob/bound-payload/main/src/cgeo/geocaching/PocketQueryList.java#L50 where `selectFromPocketQueries` references the target activity through `pocketQueryLists.target` in the subscriber.

cc @mttkay
",2014-04-01 11:36:32,2014-04-05 16:57:42,https://api.github.com/repos/ReactiveX/RxJava/issues/1008,[],129,103,ReactiveX_RxJava_pull_1008.diff
ReactiveX/RxJava,add toMap from Java Observable,"Added three overloads of toMap to Scala Observable
",2014-03-31 18:17:31,2014-04-15 22:07:47,https://api.github.com/repos/ReactiveX/RxJava/issues/1005,[],90,1,ReactiveX_RxJava_pull_1005.diff
ReactiveX/RxJava,Func0 can transparently implement java.util.concurrent.Callable.,"This change doesn't change the API at all for users of `Func0`, but it makes all `Func0` objects immediately reusable with any JDK API that accepts `Callables`. For example, a `Func0` can now be submitted directly to an `ExecutorService` for asynchronous execution. It also allows the elimination of a small amount of redundant code within RxJava itself.
",2014-03-31 01:25:29,2014-03-31 16:30:35,https://api.github.com/repos/ReactiveX/RxJava/issues/1003,[],43,37,ReactiveX_RxJava_pull_1003.diff
ReactiveX/RxJava,New Implementation of SerializedObserver,"Rewrite of `SerializedObserver` by @akarnokd discussed at  https://github.com/Netflix/RxJava/pull/962#discussion_r10601839 from this Gist: https://gist.github.com/akarnokd/9545150
#### JMH Benchmarks

0.17.3

```
Benchmark                                                          (size)   Mode   Samples         Mean   Mean error    Units
r.operators.OperatorSerializePerf.noSerializationSingleThreaded      1024   avgt         5       45.504        1.710    ns/op
r.operators.OperatorSerializePerf.noSerializationSingleThreaded   1048576   avgt         5       58.600        5.647    ns/op
r.operators.OperatorSerializePerf.serializedSingleStream             1024   avgt         5       68.610        4.596    ns/op
r.operators.OperatorSerializePerf.serializedSingleStream          1048576   avgt         5       71.313        2.318    ns/op
r.operators.OperatorSerializePerf.synchronizedSingleStream           1024   avgt         5       73.322        3.666    ns/op
r.operators.OperatorSerializePerf.synchronizedSingleStream        1048576   avgt         5       76.518        1.355    ns/op
```

0.17.2

```
Benchmark                                                          (size)   Mode   Samples         Mean   Mean error    Units
r.operators.OperatorSerializePerf.noSerializationSingleThreaded      1024   avgt         5       45.790        1.184    ns/op
r.operators.OperatorSerializePerf.noSerializationSingleThreaded   1048576   avgt         5       58.518        3.788    ns/op
r.operators.OperatorSerializePerf.serializedSingleStream             1024   avgt         5       72.665        7.851    ns/op
r.operators.OperatorSerializePerf.serializedSingleStream          1048576   avgt         5       74.788        2.946    ns/op
r.operators.OperatorSerializePerf.synchronizedSingleStream           1024   avgt         5       73.661        3.499    ns/op
r.operators.OperatorSerializePerf.synchronizedSingleStream        1048576   avgt         5       78.386        5.036    ns/op
```
#### Manual Benchmarks

``` java
/**
 * 0.17.3:
 *
 * Run: 10 - 9,746,505 ops/sec
 * Run: 11 - 9,956,019 ops/sec
 * Run: 12 - 10,053,770 ops/sec
 * Run: 13 - 10,076,958 ops/sec
 * Run: 14 - 9,983,319 ops/sec
 *
 * 0.17.2:
 *
 * Run: 10 - 9,851,999 ops/sec
 * Run: 11 - 9,726,975 ops/sec
 * Run: 12 - 9,719,762 ops/sec
 * Run: 13 - 9,668,141 ops/sec
 * Run: 14 - 9,799,700 ops/sec
 *
 * @param input
 */
public void serializedSingleStream(Input input) {
    for (int i = 0; i < reps; i++) {
        input.observable.serialize().subscribe(input.subscriber);
    }
}
```
",2014-03-28 17:43:52,2014-04-01 21:00:12,https://api.github.com/repos/ReactiveX/RxJava/issues/999,[],403,95,ReactiveX_RxJava_pull_999.diff
ReactiveX/RxJava,Perfshadowjar,,2014-03-28 00:15:57,2014-03-28 02:42:26,https://api.github.com/repos/ReactiveX/RxJava/issues/996,[],73,49,ReactiveX_RxJava_pull_996.diff
ReactiveX/RxJava,Support Custom JMH Args,"Support executions of benchmarks such as:

```
../gradlew benchmarks '-Pjmh=-f 1 -tu ns -bm avgt -wi 5 -i 5 -r 1 .*OperatorSerializePerf.*'
```

By default it will run all benchmarks if no args are passed.
",2014-03-27 21:56:17,2014-03-27 21:56:20,https://api.github.com/repos/ReactiveX/RxJava/issues/995,[],37,21,ReactiveX_RxJava_pull_995.diff
ReactiveX/RxJava,Use @SafeVarargs for From and Merge,"A proposed change if we can demonstrate it works with Android.

See https://github.com/Netflix/RxJava/issues/992 for discussion.
Intended to eliminate overloads as defined in https://github.com/Netflix/RxJava/issues/686
",2014-03-27 06:06:33,2014-03-28 17:41:45,https://api.github.com/repos/ReactiveX/RxJava/issues/994,[],6,500,ReactiveX_RxJava_pull_994.diff
ReactiveX/RxJava,JMH Perf Tests,"1) Migrate all previous tests into `rx.archive` until we have matured with JMH
2) JMH config in gradle
3) Start of benchmarking with JMH for `baseline`, `map` and `serialize`

**To Run**

Inside ./rxjava-core/ invoke `../gradlew benchmarks`

Or from base invoke `./gradlew benchmarks` and it will scan each sub-module for benchmarks and then only find them in rxjava-core.

**Output**

```
Result : 72.204 ±(99.9%) 7.524 ns/op
  Statistics: (min, avg, max) = (69.221, 72.204, 74.048), stdev = 1.954
  Confidence interval (99.9%): [64.680, 79.729]


Benchmark                                                          (size)   Mode   Samples         Mean   Mean error    Units
r.jmh.Baseline.forLoopInvokingFunction                               1024   avgt         5     3230.689      486.080    ns/op
r.jmh.Baseline.forLoopInvokingFunction                            1048576   avgt         5  3394679.521   148858.373    ns/op
r.operators.OperatorMapPerf.mapIdentityFunction                         1   avgt         5       91.338        8.504    ns/op
r.operators.OperatorMapPerf.mapIdentityFunction                      1024   avgt         5     5626.727     1209.108    ns/op
r.operators.OperatorMapPerf.mapIdentityFunction                   1048576   avgt         5  6268747.085   258008.983    ns/op
r.operators.OperatorSerializePerf.noSerializationSingleThreaded      1024   avgt         5       42.198        0.791    ns/op
r.operators.OperatorSerializePerf.noSerializationSingleThreaded   1048576   avgt         5       45.935        0.911    ns/op
r.operators.OperatorSerializePerf.serializedSingleStream             1024   avgt         5       69.410       10.499    ns/op
r.operators.OperatorSerializePerf.serializedSingleStream          1048576   avgt         5       72.305       11.450    ns/op
r.operators.OperatorSerializePerf.synchronizedSingleStream           1024   avgt         5       72.238        7.233    ns/op
r.operators.OperatorSerializePerf.synchronizedSingleStream        1048576   avgt         5       72.204        7.524    ns/op


```
",2014-03-27 05:43:20,2014-03-27 05:49:30,https://api.github.com/repos/ReactiveX/RxJava/issues/993,[],314,169,ReactiveX_RxJava_pull_993.diff
ReactiveX/RxJava,JMH Benchmark Build Config,"Fixes the Gradle config for JMH so it works from command-line and projects import into Eclipse correctly. 

See https://github.com/Netflix/RxJava/pull/963

Thanks @quidryan !
",2014-03-26 22:35:35,2014-03-26 23:01:58,https://api.github.com/repos/ReactiveX/RxJava/issues/991,[],14,36,ReactiveX_RxJava_pull_991.diff
ReactiveX/RxJava,Quasar integration contrib module,"This module integrates RxJava with [Quasar](https://github.com/puniverse/quasar) in several ways. It provides:
- A fiber-based scheduler
- A fiber-blocking version of BlockingObservables
- Viewing Quasar channels as Observables and transforming Observables into channels (Quasar channels are a CSP mechanism very similar to channels in the Go programming language).
",2014-03-26 22:27:11,2014-04-02 06:36:43,https://api.github.com/repos/ReactiveX/RxJava/issues/990,[],1837,1,ReactiveX_RxJava_pull_990.diff
ReactiveX/RxJava,OnErrorFailedException,"Re-throw when onError throws an Exception.
This fixes https://github.com/Netflix/RxJava/issues/969
",2014-03-25 21:56:12,2014-03-25 22:02:48,https://api.github.com/repos/ReactiveX/RxJava/issues/988,[],87,5,ReactiveX_RxJava_pull_988.diff
ReactiveX/RxJava,Fix Non-Deterministic Pivot Test,"This fixes a test that failed on build servers (small, slow, single or dual-core machines).
",2014-03-25 21:38:01,2014-03-25 21:38:04,https://api.github.com/repos/ReactiveX/RxJava/issues/987,[],4,2,ReactiveX_RxJava_pull_987.diff
ReactiveX/RxJava,Fix SynchronizedObserver.runConcurrencyTest,"It wasn't waiting on all threads before emitting onCompleted.
",2014-03-25 21:32:13,2014-03-25 21:32:16,https://api.github.com/repos/ReactiveX/RxJava/issues/986,[],2,2,ReactiveX_RxJava_pull_986.diff
ReactiveX/RxJava,Tests and Javadoc for Pivot,,2014-03-25 18:17:55,2014-03-25 18:36:00,https://api.github.com/repos/ReactiveX/RxJava/issues/984,[],154,2,ReactiveX_RxJava_pull_984.diff
ReactiveX/RxJava,add OperationToOperator and unit tests and overload for lift method,"I found myself using this method a lot to easily create an Operator so that I can use the lift method. For example:

Suppose I want to use lift to perform a concat on a sequence of observables followed by count:

``` java
private static <T> Func1<Observable<Observable<T>>, Observable<Integer>> concatCount() {
    return new Func1<Observable<Observable<T>>, Observable<Integer>>() {
        @Override
        public Observable<Integer> call(Observable<Observable<T>> source) {
            return Observable.concat(source).count();
        }
    };
}
```

I can then use the suggested lift overload with the function above:

``` java
source.lift(MyClass.<Integer> concatCount());
```

or I could have made an Operator form of it (especially if its component operations don't have readily available Operator forms to chain together):

``` java
private static <T> Operator<Integer, Observable<T>> concatCountOperator() {
    return OperationToOperator.toOperator(MyClass.<T> concatCount());
}
```
",2014-03-25 12:26:41,2014-07-08 20:12:26,https://api.github.com/repos/ReactiveX/RxJava/issues/983,[],379,0,ReactiveX_RxJava_pull_983.diff
ReactiveX/RxJava,Pivot Operator,,2014-03-25 06:10:23,2014-03-25 16:34:26,https://api.github.com/repos/ReactiveX/RxJava/issues/982,[],736,8,ReactiveX_RxJava_pull_982.diff
ReactiveX/RxJava,Dematerialize - handle non-materialized terminal events,"This is used for a use case such as:

``` java
observable.flatMap(t -> {
if(x) {
  return Observable.from(Notification.create(t));
} else {
  return Observable.error(e);
}).dematerialize();
```
",2014-03-20 21:35:54,2014-03-20 21:35:58,https://api.github.com/repos/ReactiveX/RxJava/issues/977,[],40,3,ReactiveX_RxJava_pull_977.diff
ReactiveX/RxJava,parallel-merge unit test assertions,"Using serialize for merge allows less threads to be used under contention instead of blocking and using them all.
This changes the assertion to be <= 3 instead of == 3 because of that.
",2014-03-20 18:32:14,2014-03-20 18:32:18,https://api.github.com/repos/ReactiveX/RxJava/issues/976,[],5,4,ReactiveX_RxJava_pull_976.diff
ReactiveX/RxJava,GroupBy & Time Gap Fixes,"I ran head-on into the ""time gap"" (https://github.com/Netflix/RxJava/issues/844) issue while working on a stream processing use case (and new 'pivot' operator I'm writing).
This is a solution. It's still not ideal as the Javadocs of BufferUntilSubscriber mention, but this is working better than nothing and does not require blocking threads.
A better solution will come as part of the back pressure work where BufferUntilSubscriber will evolve to have a bounded buffer.
",2014-03-20 17:47:31,2014-03-20 17:47:37,https://api.github.com/repos/ReactiveX/RxJava/issues/975,[],211,681,ReactiveX_RxJava_pull_975.diff
ReactiveX/RxJava,"TestSubject, TestObserver and TestScheduler Improvements",,2014-03-20 17:39:49,2014-03-20 17:39:52,https://api.github.com/repos/ReactiveX/RxJava/issues/974,[],191,5,ReactiveX_RxJava_pull_974.diff
ReactiveX/RxJava,Merge - Handle Bad Observables,"- concurrency unit tests
- handle Observable that emits onComplete multiple times

See https://github.com/Netflix/RxJava/pull/962#issuecomment-38191868
",2014-03-20 16:54:40,2014-03-20 16:55:08,https://api.github.com/repos/ReactiveX/RxJava/issues/973,[],127,6,ReactiveX_RxJava_pull_973.diff
ReactiveX/RxJava,Fixed deadlock in Subjects + OperatorCache.,"Fix for Issue #971.
- I had to rewrite OperatorCache to allow testing for deadlocks in all Subject types.
- The terminationLatch was unnecessarily waiting for existing subscribers to deliver their termination events, which caused deadlock with repeat().
- Treating subjects as internal implementations was not necessary to fix the problem.
",2014-03-20 13:13:49,2014-04-16 16:00:40,https://api.github.com/repos/ReactiveX/RxJava/issues/972,[],262,151,ReactiveX_RxJava_pull_972.diff
ReactiveX/RxJava,Notifications for the allocation averse.,"I've seen and used the sentinel pattern in a couple of places in the implementation of operators.  I figured I'd formalize the hacks into one place where bugs can coalesce.  As a bonus the code that uses it looks a bit cleaner now.
",2014-03-20 07:09:34,2014-03-20 16:25:16,https://api.github.com/repos/ReactiveX/RxJava/issues/970,[],226,163,ReactiveX_RxJava_pull_970.diff
ReactiveX/RxJava,Reimplement the 'single' operator,"This PR did the following work:
- Reimplement the `single` operator
- Add `first`, `last`, `single` to rxjava-scala
- When the `Observable` is empty, `first`, `last`, `single` will throw `NoSuchElementException` instead of `IllegalArgumentException`. It's more consistent with the Java Collection API, e.g., [Deque.getFirst()](http://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#getFirst%28%29), [Deque.getLast()](http://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#getLast%28%29). This will break the current APIs.
",2014-03-17 14:19:22,2014-04-20 03:34:21,https://api.github.com/repos/ReactiveX/RxJava/issues/967,[],274,178,ReactiveX_RxJava_pull_967.diff
ReactiveX/RxJava,Reimplement the ElementAt operator and add it to rxjava-scala,,2014-03-15 16:42:47,2014-03-25 21:05:10,https://api.github.com/repos/ReactiveX/RxJava/issues/966,[],213,267,ReactiveX_RxJava_pull_966.diff
ReactiveX/RxJava,BugFix: Chain Subscription in TimeoutSubscriber and SerializedSubscriber,"This PR chains Subscription in TimeoutSubscriber  and SerializedSubscriber. Found by @rbramw #951. Thanks for your unit tests, @rbramw
",2014-03-15 14:13:32,2014-03-25 21:06:11,https://api.github.com/repos/ReactiveX/RxJava/issues/965,[],88,0,ReactiveX_RxJava_pull_965.diff
ReactiveX/RxJava,SubjectSubscriptionManager fix.,"Fix for #961

If an already unsubscribed Subscriber is added, the subscription function ends up in an infinite loop as the inner unsubscription logic changes the state to another object before the outer state machine continues.
- The outer state machine loop now exits if unsubscription happened and doesn't attempt to modify the state.
- The removeObserver method is changed so that if the subscription to be removed is not in the array, it returns this instead of an unnecessary copy. In addition, copyOf calls have been replaced by arraycopy to avoid reflective array creation.
",2014-03-13 22:11:58,2014-03-13 22:48:03,https://api.github.com/repos/ReactiveX/RxJava/issues/964,[],147,9,ReactiveX_RxJava_pull_964.diff
ReactiveX/RxJava,A more robust JMH benchmarking set-up,"Usage:

```
$ gradle benchmarks
$ java -jar rxjava-core/build/distributions/rxjava-core-0.17.2-SNAPSHOT-benchmarks.jar [...]
```

For example:

```
$ java -jar rxjava-core/build/distributions/rxjava-core-0.17.2-SNAPSHOT-benchmarks.jar -f 1 -wi 10 -i 10 -tu us -bm avgt

Benchmark                                  (size)   Mode   Samples         Mean   Mean error    Units
r.o.ObservableBenchmark.measureBaseline         1   avgt        10        0.003        0.000    us/op
r.o.ObservableBenchmark.measureBaseline      1024   avgt        10        2.764        0.051    us/op
r.o.ObservableBenchmark.measureBaseline   1048576   avgt        10     3104.088       49.586    us/op
r.o.ObservableBenchmark.measureMap              1   avgt        10        0.100        0.003    us/op
r.o.ObservableBenchmark.measureMap           1024   avgt        10        5.036        0.059    us/op
r.o.ObservableBenchmark.measureMap        1048576   avgt        10     6693.271      277.604    us/op
```

See https://github.com/Netflix/RxJava/issues/776 for more details.
",2014-03-13 20:31:52,2014-03-13 20:36:51,https://api.github.com/repos/ReactiveX/RxJava/issues/963,[],114,125,ReactiveX_RxJava_pull_963.diff
ReactiveX/RxJava,Migrate from SynchronizedObserver to SerializedObserver,"This pull request replaces use of `SynchronizedObserver` with `SerializedObserver`. 
### Why?
#### 1) Deadlocks

Holding a lock while emitting notifications (`onNext`, `onCompleted`, `onError`) allows for deadlocks if the event results in a cycle back to the parent. 

While testing RxJava 0.17.0 in Netflix production we ran into one of these. The vulnerability has existed all along but we finally hit it.

This issue has also been reported before such as: http://twistedoakstudios.com/blog/Post8424_deadlocks-in-practice-dont-hold-locks-while-notifying
#### 2) Blocking Threads

The use of `synchronized` can block threads. If it's used in areas such as modifying a data structure this can be okay. When emitting a notification however it is a problem as the result of an `onNext` can take a non-deterministically long time to complete. This means any other thread trying to emit will be blocked.

If the source threads are event loops (such as Vert.x or Netty) this will block the event loops. 

For example, if two network calls off two Netty event loops are being merged (such as via `flatMap`) and one of them does further slow processing that causes `onNext` to be slow, it will block the other `onNext` which blocks the event loop and prevents any further IO on that thread. This is a significant problem for system scale and breaks the promise of Rx being a non-blocking, reactive library.
### Solution

The `synchronize`, `SynchronizedObserver` and `SynchronizedSubscriber` operator and classes have been deprecated. They are replaced by `serialize`, `SerializedObserver` and `SerializedSubscriber`.

The `SerializedObserver` still ensures only a single thread can emit `onNext`, `onCompleted`, or `onError` at a time but does not hold a lock while doing so. Instead of blocking threads it will accept the incoming events into a buffer. Thus, it becomes an asynchronous operator.

The `merge` operator (which impacts `flatMap`) now uses `SerializedObserver`, along with any other place in RxJava that needed synchronization.
### Implementation

3 implementatations were written and tested:
- [queue and counter](https://github.com/benjchristensen/RxJava/blob/serialize-implementations/rxjava-core/src/main/java/rx/observers/SerializedObserverViaQueueAndCounter.java)
- [queue and lock](https://github.com/benjchristensen/RxJava/blob/serialize-implementations/rxjava-core/src/main/java/rx/observers/SerializedObserverViaQueueAndLock.java)
- [atomic state machine](https://github.com/benjchristensen/RxJava/blob/serialize-implementations/rxjava-core/src/main/java/rx/observers/SerializedObserverViaStateMachine.java)

Performance testing [revealed](https://github.com/benjchristensen/RxJava/blob/serialize-implementations/rxjava-core/src/perf/java/rx/operators/OperatorSerializePerformance.java):

``` java
    /**
     * 1 streams emitting in a tight loop. Testing for single-threaded overhead.
     * 
     * -> blocking synchronization (SynchronizedObserver)
     * 
     * Run: 10 - 58,186,310 ops/sec
     * Run: 11 - 60,592,037 ops/sec
     * Run: 12 - 58,099,263 ops/sec
     * Run: 13 - 59,034,765 ops/sec
     * Run: 14 - 58,231,548 ops/sec
     * 
     * -> state machine technique (SerializedObserverViaStateMachine)
     * 
     * Run: 10 - 34,668,810 ops/sec
     * Run: 11 - 32,874,312 ops/sec
     * Run: 12 - 33,389,339 ops/sec
     * Run: 13 - 35,269,946 ops/sec
     * Run: 14 - 34,165,013 ops/sec
     * 
     * -> using queue and counter technique (SerializedObserverViaQueueAndCounter)
     * 
     * Run: 10 - 19,548,387 ops/sec
     * Run: 11 - 19,471,069 ops/sec
     * Run: 12 - 19,480,112 ops/sec
     * Run: 13 - 18,720,550 ops/sec
     * Run: 14 - 19,070,383 ops/sec
     * 
     * -> using queue and lock technique (SerializedObserverViaQueueAndLock)
     * 
     * Run: 10 - 51,295,152 ops/sec
     * Run: 11 - 50,317,937 ops/sec
     * Run: 12 - 51,126,331 ops/sec
     * Run: 13 - 52,418,291 ops/sec
     * Run: 14 - 51,694,710 ops/sec
     */

    /**
     * 2 streams emitting in tight loops so very high contention.
     * 
     * -> blocking synchronization (SynchronizedObserver)
     * 
     * Run: 10 - 8,361,252 ops/sec
     * Run: 11 - 7,184,728 ops/sec
     * Run: 12 - 8,249,685 ops/sec
     * Run: 13 - 6,831,595 ops/sec
     * Run: 14 - 8,003,358 ops/sec
     * 
     * (faster because it allows each thread to be ""single threaded"" while blocking the other)
     * 
     * -> state machine technique (SerializedObserverViaStateMachine)
     * 
     * Run: 10 - 4,060,062 ops/sec
     * Run: 11 - 3,561,131 ops/sec
     * Run: 12 - 3,721,387 ops/sec
     * Run: 13 - 3,693,909 ops/sec
     * Run: 14 - 3,516,324 ops/sec
     * 
     * -> using queue and counter technique (SerializedObserverViaQueueAndCounter)
     * 
     * Run: 10 - 4,300,229 ops/sec
     * Run: 11 - 4,395,995 ops/sec
     * Run: 12 - 4,551,550 ops/sec
     * Run: 13 - 4,443,235 ops/sec
     * Run: 14 - 4,158,475 ops/sec
     * 
     * -> using queue and lock technique (SerializedObserverViaQueueAndLock)
     * 
     * Run: 10 - 6,369,781 ops/sec
     * Run: 11 - 6,933,872 ops/sec
     * Run: 12 - 5,652,535 ops/sec
     * Run: 13 - 5,503,716 ops/sec
     * Run: 14 - 6,219,264 ops/sec
     */

    /**
     * 2 streams emitting once a millisecond. Slow emission so little to no contention.
     * 
     * -> blocking synchronization (SynchronizedObserver)
     * 
     * Run: 10 - 1,996 ops/sec
     * Run: 11 - 1,996 ops/sec
     * Run: 12 - 1,995 ops/sec
     * Run: 13 - 1,997 ops/sec
     * Run: 14 - 1,996 ops/sec
     * 
     * -> state machine technique (SerializedObserverViaStateMachine)
     * 
     * Run: 10 - 1,996 ops/sec
     * Run: 11 - 1,996 ops/sec
     * Run: 12 - 1,996 ops/sec
     * Run: 13 - 1,996 ops/sec
     * Run: 14 - 1,996 ops/sec
     * 
     * -> using queue and counter technique (SerializedObserverViaQueueAndCounter)
     * 
     * Run: 10 - 1,996 ops/sec
     * Run: 11 - 1,996 ops/sec
     * Run: 12 - 1,996 ops/sec
     * Run: 13 - 1,996 ops/sec
     * Run: 14 - 1,995 ops/sec
     * 
     * -> using queue and lock technique (SerializedObserverViaQueueAndLock)
     * 
     * Run: 10 - 1,996 ops/sec
     * Run: 11 - 1,996 ops/sec
     * Run: 12 - 1,997 ops/sec
     * Run: 13 - 1,996 ops/sec
     * Run: 14 - 1,995 ops/sec
     */
```

The state machine solution was tested in production but caused performance problems, most likely due to the immense object allocation it needs to do. 

The elegant ""queue and counter"" solution does not perform well enough in the non-contended case.

The ""queue and lock"" model performs well in the non-contended case and under contention, despite not being a very elegant solution and requiring the use of mutex locks for the state changes (but it does not hold the locks during notification).
### Considerations

This does allow unbounded buffer growth, the same as `observeOn` and `zip` instead of blocking the producer threads. 
### Conclusion

The implementation in this pull request can and likely will be improved over time. The other implementations are purposefully being shown to allow others to provide further insight on how to do this better. 

This change is important to ensure RxJava is non-blocking and our canary testing of this change in the Netflix production environment suggests this change is both performant and functional.
",2014-03-13 18:01:05,2014-03-13 18:34:38,https://api.github.com/repos/ReactiveX/RxJava/issues/962,[],2896,150,ReactiveX_RxJava_pull_962.diff
ReactiveX/RxJava,Retry Unit Test from #879,"From https://github.com/Netflix/RxJava/issues/879
",2014-03-13 16:37:29,2014-03-13 16:37:33,https://api.github.com/repos/ReactiveX/RxJava/issues/960,[],38,4,ReactiveX_RxJava_pull_960.diff
ReactiveX/RxJava,OperationToFuture must throw CancellationException on get() if cancelled,"The JDK documentation for Future.get() and its overload requires these methods to throw CancellationException if the Future was cancelled before the task completed. The Futures returned by OperationToFuture.toFuture() did not respect this contract. Now they do.
",2014-03-12 16:28:49,2014-03-13 16:16:37,https://api.github.com/repos/ReactiveX/RxJava/issues/959,[],39,2,ReactiveX_RxJava_pull_959.diff
ReactiveX/RxJava,OperatorSkipWhile,"Reimplemented OperatorSkipWhile (the OperationSkipWhile has a state-sharing bug with `skipping` and `index`).

+1 test for many subscribers.
",2014-03-12 14:08:35,2014-03-13 16:15:55,https://api.github.com/repos/ReactiveX/RxJava/issues/958,[],106,109,ReactiveX_RxJava_pull_958.diff
ReactiveX/RxJava,Fixed byLine test to use line.separator system property instead of \n.,"`byLine()` uses the `line.separator` but the test used `\n`.
",2014-03-11 13:43:26,2014-03-13 16:15:31,https://api.github.com/repos/ReactiveX/RxJava/issues/956,[],3,1,ReactiveX_RxJava_pull_956.diff
ReactiveX/RxJava,Fixed ReplaySubject leak,"Fix for issue #939.
",2014-03-11 13:39:54,2014-03-13 16:15:15,https://api.github.com/repos/ReactiveX/RxJava/issues/955,[],36,7,ReactiveX_RxJava_pull_955.diff
ReactiveX/RxJava,Make ObserveOnTest.testNonBlockingOuterWhileBlockingOnNext deterministic,"reported at https://twitter.com/jaceklaskowski/status/443153927069249536
",2014-03-10 23:43:03,2014-03-10 23:43:13,https://api.github.com/repos/ReactiveX/RxJava/issues/953,[],16,8,ReactiveX_RxJava_pull_953.diff
ReactiveX/RxJava,rxjava-scala improvements and reimplemented the `amb` operator,"This PR did the following improvements: 
- Added `amb`, `delay`, `delaySubscription` in rxjava-scala. 
- Reimplemented the `amb` operator.
",2014-03-10 14:41:52,2014-03-13 16:11:47,https://api.github.com/repos/ReactiveX/RxJava/issues/952,[],179,74,ReactiveX_RxJava_pull_952.diff
ReactiveX/RxJava,OperatorTimeoutBase unsubscribe from source,"If no other observable is supplied to the OperatorTimeout:

public final Observable<T> timeout(long timeout, java.util.concurrent.TimeUnit timeUnit)

then, it does not unsubscribe from the source in the event of a timeout.
",2014-03-09 17:56:58,2014-03-14 16:53:55,https://api.github.com/repos/ReactiveX/RxJava/issues/951,[],1,0,ReactiveX_RxJava_pull_951.diff
ReactiveX/RxJava,Add support for Eclipse PDE,"Add support for Eclipse PDE handling OSGi fragments.
http://help.eclipse.org/kepler/index.jsp?topic=%2Forg.eclipse.platform.doc.isv%2Freference%2Fmisc%2Fbundle_manifest.html

see also #849
",2014-03-09 10:06:36,2014-03-10 16:19:12,https://api.github.com/repos/ReactiveX/RxJava/issues/950,[],1,0,ReactiveX_RxJava_pull_950.diff
ReactiveX/RxJava,HandlerThreadScheduler fix,"It's a best practice in android to check the current thread before using `Handler.post` and `Handler.postDelayed` because it can help to avoid unwanted UI blinks.
",2014-03-09 07:29:19,2014-03-12 03:33:11,https://api.github.com/repos/ReactiveX/RxJava/issues/949,[],21,28,ReactiveX_RxJava_pull_949.diff
ReactiveX/RxJava,OperationAll to OperatorAll,"Replaced the `OperationAll` to an `OperatorAll`.

Caveat: I am a newbie here, hoping to learn, so please do not spare me.
I saw a remark on performancetests, but noticed they were not applied everywhere, so I left them out.
I saw no issue yet asking for this work, this is on invitation from Erik Meijer at QCON yesterday.
If you want me to I can tackle some other operations as well.
",2014-03-08 21:36:11,2014-04-23 04:01:16,https://api.github.com/repos/ReactiveX/RxJava/issues/948,[],79,205,ReactiveX_RxJava_pull_948.diff
ReactiveX/RxJava,Experimenting with Schedulers.currentScheduler(),"Experimenting based on conversation at https://github.com/Netflix/RxJava/issues/941#issuecomment-36827374
",2014-03-06 06:39:18,2014-03-13 16:28:15,https://api.github.com/repos/ReactiveX/RxJava/issues/946,[],100,0,ReactiveX_RxJava_pull_946.diff
ReactiveX/RxJava,Manual Merge 940,"Fixes https://github.com/Netflix/RxJava/pull/940 via manual merge.
",2014-03-06 05:59:39,2014-03-06 05:59:46,https://api.github.com/repos/ReactiveX/RxJava/issues/945,[],641,227,ReactiveX_RxJava_pull_945.diff
ReactiveX/RxJava,OperationRetry -> OperatorRetry,"Updated to use ""lift"" and Subscriber.
Fixes https://github.com/Netflix/RxJava/issues/943 Observable.retry() does not unsubscribe from source
",2014-03-06 05:54:26,2014-03-06 05:54:29,https://api.github.com/repos/ReactiveX/RxJava/issues/944,[],135,111,ReactiveX_RxJava_pull_944.diff
ReactiveX/RxJava,MathObservable,"Moving the average/sum/min/max functionality to the MathObservable similar to StringObservable.

Similar to the rxjava-string module this is seeking to achieve the goal of keeping rxjava-core focused on core functionality.
",2014-03-05 06:31:38,2014-03-06 05:45:40,https://api.github.com/repos/ReactiveX/RxJava/issues/942,[],2057,1,ReactiveX_RxJava_pull_942.diff
ReactiveX/RxJava,refactor the debug hooks before they become a breaking change.,"The number of call backs started at one and grew to four and managing them all separately was cumbersome.  This will bring some sanity back to the debug hook API.

I've made one to tiny change to `OnSubscribeFromIterable`. It now checks if the subscriber is unsubscribed before calling `onCompleted()`.
",2014-03-03 18:44:41,2014-03-06 05:59:46,https://api.github.com/repos/ReactiveX/RxJava/issues/940,[],557,224,ReactiveX_RxJava_pull_940.diff
ReactiveX/RxJava,OperatorWeakBinding (deprecates OperatorObserveFromAndroidComponent),"Android UI operator that weakly binds to a fragment or activity. (see discussion in https://github.com/Netflix/RxJava/issues/899)
",2014-03-02 12:13:56,2014-03-13 16:09:32,https://api.github.com/repos/ReactiveX/RxJava/issues/938,[],283,6,ReactiveX_RxJava_pull_938.diff
ReactiveX/RxJava,Skip fixed,"Fixed state capture bug.
Added unit tests.
",2014-02-27 19:35:46,2014-03-04 20:05:53,https://api.github.com/repos/ReactiveX/RxJava/issues/936,[],180,188,ReactiveX_RxJava_pull_936.diff
ReactiveX/RxJava,add Observable.startWith(Observable) method and unit test,"add Observable.startWith(Observable) method and unit test. 

I would like to avoid breaking method chaining when want to startWith an Observable rather than just an Iterator or specific values. This is a very minor change as under the covers startWith uses concat anyway but it is significant in terms of code readability and is a natural completion of the startWith api. 
",2014-02-27 04:22:41,2014-03-06 06:01:14,https://api.github.com/repos/ReactiveX/RxJava/issues/934,[],29,0,ReactiveX_RxJava_pull_934.diff
ReactiveX/RxJava,Implemented Skip using Lift in Observable and OperatorSkip,"Deleted non-time part from OperationSkip
Moved tests to OperatorSkipTest
",2014-02-27 02:54:36,2014-02-27 19:37:38,https://api.github.com/repos/ReactiveX/RxJava/issues/933,[],92,188,ReactiveX_RxJava_pull_933.diff
ReactiveX/RxJava,A number of improvements to OperatorObserveFromAndroidComponent,"Could I get some eyes on this? @tehmou @zsxwing @benjchristensen
- move the UI thread assert out of the operator and into the helpers; this way, we don't fail the observer anymore with an exception, but the caller.
- do not loop unsubscribe through the main thread anymore. This unnecessarily defers releasing the references, and might in fact be processed only after Android creates the component after a rotation change. I had to make the references volatile for this to work.
- immediately unsubscribe in case we detect the componentRef has become invalid. This solves the problem that dangling observers would continue to listen to notifications with no observer alive anymore.

refs:
https://github.com/Netflix/RxJava/issues/754
https://github.com/Netflix/RxJava/issues/899
",2014-02-26 17:42:25,2014-03-06 18:21:50,https://api.github.com/repos/ReactiveX/RxJava/issues/931,[],75,49,ReactiveX_RxJava_pull_931.diff
ReactiveX/RxJava,Initial commit of the Android samples module,"refs https://github.com/soundcloud/RxJava/issues/3

I made it so that the samples project will automatically be pulled in as soon as it detects an Android SDK on the build machine; otherwise it's ignored. It also runs in a sub-gradle so should not be affected by changes to the main project. It does, however, automatically pull in and compile against the current project version.

Let me know what you think. I kept the actual samples minimal for now, I see this more as a tracer bullet for how the samples could fit into the current build setup.
",2014-02-26 17:40:22,2014-03-12 16:13:46,https://api.github.com/repos/ReactiveX/RxJava/issues/930,[],828,0,ReactiveX_RxJava_pull_930.diff
ReactiveX/RxJava,correct link to maven search,"Fixes the link for the maven search, now pointing to artifact id `rxjava-android`.
",2014-02-26 16:23:06,2014-03-06 06:04:28,https://api.github.com/repos/ReactiveX/RxJava/issues/929,[],1,1,ReactiveX_RxJava_pull_929.diff
ReactiveX/RxJava,Fix deadlock in SubscribeOnBounded,"Swap the subscription and the scheduling of pass-through to allow progress of a bounded synchronous source.
",2014-02-26 07:33:36,2014-03-13 16:32:56,https://api.github.com/repos/ReactiveX/RxJava/issues/928,[],15,3,ReactiveX_RxJava_pull_928.diff
ReactiveX/RxJava,TestSubscriber lastSeenThread,,2014-02-25 22:52:08,2014-02-25 22:52:11,https://api.github.com/repos/ReactiveX/RxJava/issues/927,[],2,0,ReactiveX_RxJava_pull_927.diff
ReactiveX/RxJava,TestSubscriber: Default onError and Terminal Latch Behavior,,2014-02-25 22:12:21,2014-02-25 22:12:25,https://api.github.com/repos/ReactiveX/RxJava/issues/926,[],28,5,ReactiveX_RxJava_pull_926.diff
ReactiveX/RxJava,Rxjava clojure bindings final,"Clojure bindings for RxJava. Rebased and cleaned up version of https://github.com/Netflix/RxJava/pull/908 ready for merge. Didn't really get any external feedback, so I'm assuming that means it's perfect :)
",2014-02-25 06:56:05,2014-02-25 22:09:50,https://api.github.com/repos/ReactiveX/RxJava/issues/925,[],2767,32,ReactiveX_RxJava_pull_925.diff
ReactiveX/RxJava,Localized Operator Error Handling,"Do error handling in the `lift` function rather than try/catch in `subscribe` since this catches at the operator level rather than for an entire sequence. This then allows `onErrorResumeNext` and siblings to handle the error instead of it only being emitted to the final `Subscriber`.

I derived this fix while working on Hystrix 1.4.
",2014-02-25 05:44:01,2014-02-25 06:44:00,https://api.github.com/repos/ReactiveX/RxJava/issues/924,[],111,5,ReactiveX_RxJava_pull_924.diff
ReactiveX/RxJava,Observable creation from Subscriber[T]=>Unit for Scala,"This PR adds the `Subscriber` type, and `Observable.apply[T](Subscriber[T] => Unit)`.

Additionally, I made some tweaks in `RxScalaDemo`, and I could remove all comments of the kind `TODO something behaves weirdly here`, because now the weird behavior was gone. Seems like there was some progress in RxJava core :-)

Sorry that this PR mixes several topics, let me know if you want me to split it by topic.

/cc @headinthebox @vjovanov
",2014-02-24 20:37:55,2014-03-06 06:04:55,https://api.github.com/repos/ReactiveX/RxJava/issues/923,[],233,62,ReactiveX_RxJava_pull_923.diff
ReactiveX/RxJava,Changes made while integrating it with our internal system,"Added complete and error hooks to make the duration of events evident.
Changed the debug notification to:
removed the start nano and thread id to leave that up to the hook writer to decide if they want that.
added the source observerable to make linking operators together.
",2014-02-24 19:00:36,2014-02-24 19:11:17,https://api.github.com/repos/ReactiveX/RxJava/issues/922,[],211,100,ReactiveX_RxJava_pull_922.diff
ReactiveX/RxJava,Delete Deprecated onSubscribeStart That Doesn't Work,"- It's messy to make this work so deleting it instead.
- Better to move forward in the 0.17 release than try and make this work for the very small percentage (probably only Netflix) that uses it.
",2014-02-21 22:48:36,2014-02-21 22:48:43,https://api.github.com/repos/ReactiveX/RxJava/issues/920,[],0,6,ReactiveX_RxJava_pull_920.diff
ReactiveX/RxJava,BugFix: Zip Never Completes When Zero Observables,"Fixes https://github.com/Netflix/RxJava/pull/868 and https://github.com/Netflix/RxJava/pull/917
",2014-02-21 22:31:27,2014-02-21 22:39:25,https://api.github.com/repos/ReactiveX/RxJava/issues/919,[],110,2,ReactiveX_RxJava_pull_919.diff
ReactiveX/RxJava,Operator: doOnTerminate,"Like finallyDo but before emitting the terminal state instead of after.
",2014-02-21 22:10:08,2014-02-21 22:10:11,https://api.github.com/repos/ReactiveX/RxJava/issues/918,[],36,3,ReactiveX_RxJava_pull_918.diff
ReactiveX/RxJava,Zip Bug UnitTest: Never Completes When Zero Observables,"Duplicate of #868.  Accidentally submitted the PR from master, not from a test branch.
",2014-02-21 21:36:18,2014-02-21 22:39:41,https://api.github.com/repos/ReactiveX/RxJava/issues/917,[],30,0,ReactiveX_RxJava_pull_917.diff
ReactiveX/RxJava,Merge pull request #1 from Netflix/master,"Merge with Netflix
",2014-02-21 16:20:17,2014-02-21 16:20:45,https://api.github.com/repos/ReactiveX/RxJava/issues/916,[],0,0,ReactiveX_RxJava_pull_916.diff
ReactiveX/RxJava,Merge pull request #1 from Netflix/master,"Merge with Netflix
",2014-02-21 16:16:17,2014-02-21 16:16:57,https://api.github.com/repos/ReactiveX/RxJava/issues/915,[],0,0,ReactiveX_RxJava_pull_915.diff
ReactiveX/RxJava,Remove groupBy with selector.,"I think we can use `groupBy(keySelector).map(elementSelector)` instead. Is there any reason to keep this signature?

Related to https://github.com/Netflix/RxJava/commit/02ccc4d727a9297f14219549208757c6e0efce2a#commitcomment-5430646
",2014-02-20 17:19:00,2014-02-20 17:26:45,https://api.github.com/repos/ReactiveX/RxJava/issues/910,[],0,24,ReactiveX_RxJava_pull_910.diff
ReactiveX/RxJava,Scheduler Plugin Refactor,"1) Deprecate Direct Access to Scheduler Implementations

This enforces the convention of using `Schedulers.*` and then makes the RxJavaDefaultSchedulers plugin more reliable.

2) Scheduler instances should be or behave like singletons

Remove the Func0 factory signature for Scheduler creation.
",2014-02-20 17:17:43,2014-02-20 17:25:57,https://api.github.com/repos/ReactiveX/RxJava/issues/909,[],70,55,ReactiveX_RxJava_pull_909.diff
ReactiveX/RxJava,Rxjava clojure bindings,"_PLEASE DON'T MERGE THIS - FOR REVIEW ONLY_

Here's a pull request for Clojure bindings to give people a place to provide feedback.
",2014-02-19 23:42:38,2014-02-25 06:56:25,https://api.github.com/repos/ReactiveX/RxJava/issues/908,[],2767,32,ReactiveX_RxJava_pull_908.diff
ReactiveX/RxJava,Deprecate Direct Access to Scheduler Implementations,"This enforces the convention of using `Schedulers.*` and then makes the RxJavaDefaultSchedulers plugin more reliable.
",2014-02-19 21:44:56,2014-02-20 17:16:49,https://api.github.com/repos/ReactiveX/RxJava/issues/907,[],41,6,ReactiveX_RxJava_pull_907.diff
ReactiveX/RxJava,Deprecate Direct Access to Scheduler Implementations,"This enforces the convention of using `Schedulers.*` and then makes the RxJavaDefaultSchedulers plugin more reliable.
",2014-02-19 21:43:50,2014-02-19 21:44:16,https://api.github.com/repos/ReactiveX/RxJava/issues/906,[],41,6,ReactiveX_RxJava_pull_906.diff
ReactiveX/RxJava,RxJavaSchedulers Plugin,"Allow setting different default schedulers for use by system.
",2014-02-19 20:07:23,2014-02-19 21:33:46,https://api.github.com/repos/ReactiveX/RxJava/issues/905,[],189,8,ReactiveX_RxJava_pull_905.diff
ReactiveX/RxJava,Merge: Unsubscribe Completed Inner Observables,"Fixing bug report from https://github.com/Netflix/RxJava/issues/897
",2014-02-19 18:03:12,2014-02-19 20:48:18,https://api.github.com/repos/ReactiveX/RxJava/issues/904,[],121,2,ReactiveX_RxJava_pull_904.diff
ReactiveX/RxJava,Scheduler.Recurse fields should be private,,2014-02-19 17:33:14,2014-02-19 20:48:07,https://api.github.com/repos/ReactiveX/RxJava/issues/903,[],2,2,ReactiveX_RxJava_pull_903.diff
ReactiveX/RxJava,Fixed NullPointerException that may happen on timeout,"An unhandled NullPointerException is thrown in the releaseResources method in rx.apache.http.consumers.ResponseConsumerDelegate if a timeout occur. If a timeout occur then onResponseReceived is never called and thus consumer is null.
",2014-02-19 13:23:37,2014-02-19 14:59:42,https://api.github.com/repos/ReactiveX/RxJava/issues/902,[],3,1,ReactiveX_RxJava_pull_902.diff
ReactiveX/RxJava,GroupBy Unit Test from #900,"https://github.com/Netflix/RxJava/issues/900
",2014-02-19 04:24:43,2014-02-19 04:50:29,https://api.github.com/repos/ReactiveX/RxJava/issues/901,[],34,0,ReactiveX_RxJava_pull_901.diff
ReactiveX/RxJava,Handle illegal errors thrown from plugin,,2014-02-18 16:12:13,2014-02-18 16:12:16,https://api.github.com/repos/ReactiveX/RxJava/issues/898,[],34,4,ReactiveX_RxJava_pull_898.diff
ReactiveX/RxJava,removing java 7 dep,,2014-02-18 06:18:22,2014-02-18 06:39:18,https://api.github.com/repos/ReactiveX/RxJava/issues/896,[],11,3,ReactiveX_RxJava_pull_896.diff
ReactiveX/RxJava,Rewrite OperationObserveFromAndroidComponent to OperatorObserveFromAndro...,"This PR did the following things:
- Rewrite `OperationObserveFromAndroidComponent` to `OperatorObserveAndroidComponent`.
- Call `unsubscribe` at once if the current thread is the UI thread.
- Remove `itUnsubscribesFromTheSourceSequence` since it's meaningless in the new design.
",2014-02-18 04:05:29,2014-02-18 07:42:46,https://api.github.com/repos/ReactiveX/RxJava/issues/895,[],112,118,ReactiveX_RxJava_pull_895.diff
ReactiveX/RxJava,Synchronized Operator Check for isTerminated,"As per https://github.com/Netflix/RxJava/issues/872 make Synchronized reject events after terminal state.
This class should not unsubscribe though. That is only for SafeSubscriber at the end.
",2014-02-18 00:41:50,2014-02-18 00:41:53,https://api.github.com/repos/ReactiveX/RxJava/issues/894,[],13,4,ReactiveX_RxJava_pull_894.diff
ReactiveX/RxJava,Change Parallel to use Long instead of Int,,2014-02-18 00:00:39,2014-02-18 00:00:42,https://api.github.com/repos/ReactiveX/RxJava/issues/893,[],77,9,ReactiveX_RxJava_pull_893.diff
ReactiveX/RxJava,onErrorFlatMap + OnErrorThrowable,"I am working on solving a production error handling use case that needs the ability to handle errors on an `Observable` acting like a message-bus. This requires it to ignore errors if they occur.

With @headinthebox the idea of `onErrorFlatMap` evolved, but we now have a decision to make about the implementation.

It's pretty easy to solve the first half and allow `onErrorFlatMap` to return `Observables` that are injected into the output `Observable` but don't `onComplete` and thus allow the stream to continue.

However, we're looking at whether we can also capture the `T value` that caused the exception to be thrown so we can achieve use cases like this:

``` java
    @Test
    public void spliceAndContinueEmitting() {
        TestSubscriber<String> ts = new TestSubscriber<String>();
        Observable.from(1, 2, 3, 4, 5, 6).map(new Func1<Integer, String>() {

            @Override
            public String call(Integer v) {
                if (v < 2 || v > 5) {
                    return ""Value="" + v;
                }
                throw new RuntimeException(""error in map function: "" + v);
            }

        }).onErrorFlatMap(new Func1<OnErrorThrowable, Observable<String>>() {

            @Override
            public Observable<String> call(OnErrorThrowable t) {
                return Observable.from(""Error="" + t.getValue());
            }

        }).subscribe(ts);

        ts.assertTerminalEvent();
        System.out.println(ts.getOnErrorEvents());
        assertEquals(0, ts.getOnErrorEvents().size());
        System.out.println(ts.getOnNextEvents());
        ts.assertReceivedOnNext(Arrays.asList(""Value=1"", ""Error=2"", ""Error=3"", ""Error=4"", ""Error=5"", ""Value=6""));
    }
```

This outputs:

```
[Value=1, Error=2, Error=3, Error=4, Error=5, Value=6]
```

To accomplish this however we must capture the `value` and wrap the `Throwable` in all operators that execute user-provided functions. This results in code like this:

``` java
            @Override
            public void onNext(T t) {
                try {
                    o.onNext(transformer.call(t));
                } catch (Throwable e) {
                    onError(new OnErrorThrowable(e, t));
                }
            }
```

instead of this:

``` java
            @Override
            public void onNext(T t) {
                try {
                    o.onNext(transformer.call(t));
                } catch (Throwable e) {
                    onError(e);
                }
            }
```

The drawback to this is that `onError` will now receive an `OnErrorThrowable` if the error comes from a user-provided function. The benefit is that the value associated with the failure is now accessible for debugging, reporting, feedback loops etc.

Operators affected by this are `cast`, `doOnEach`, `filter`, `groupBy`, `map`, `scan`, `zip` (and surely others) as these all take user-provided functions.

Are there reasons we should not wrap these errors inside an `OnErrorThrowable`?
",2014-02-17 23:32:46,2014-02-18 15:58:41,https://api.github.com/repos/ReactiveX/RxJava/issues/892,[],430,144,ReactiveX_RxJava_pull_892.diff
ReactiveX/RxJava,Eliminate rx.util.* dumping grounds,"Move all classes into proper homes rather than having `rx.util` as the miscellaneous dumping grounds.

I have attempted to make rx.util.functions.\* have deprecated proxies to ease the migration. I'm doing this in 0.17 instead of waiting since 0.17 already has breaking changes. 
",2014-02-17 21:36:36,2014-02-17 21:36:40,https://api.github.com/repos/ReactiveX/RxJava/issues/891,[],2150,738,ReactiveX_RxJava_pull_891.diff
ReactiveX/RxJava,Split SubscribeOn into SubscribeOn/UnsubscribeOn,"Working with @headinthebox based on discussions at https://github.com/Netflix/RxJava/pull/869 and https://github.com/Netflix/RxJava/pull/880#issuecomment-35163539 we determined that there are times when `unsubscribeOn` behavior is needed.

The `subscribeOn` operator can not mix `subscribe` and `unsubscribe` scheduling behavior without breaking the `lift`/`Subscriber` behavior that allows unsubscribing synchronous sources. The newly added `unsubscribeOn` operator will not work with synchronous unsubscribes, but it will work for the targeted use cases such as UI event handlers.
",2014-02-17 20:33:25,2014-02-17 20:33:29,https://api.github.com/repos/ReactiveX/RxJava/issues/890,[],814,336,ReactiveX_RxJava_pull_890.diff
ReactiveX/RxJava,Revert Bounded ObserveOn,"Reverting to only having unbounded `observeOn` in public API as per comment at https://github.com/Netflix/RxJava/pull/835#issuecomment-35299824

Leaving the bounded implementation as an internal operator implementation for now to be discussed further in v0.18 dev cycle.
",2014-02-17 18:57:17,2014-02-17 19:02:33,https://api.github.com/repos/ReactiveX/RxJava/issues/888,[],853,331,ReactiveX_RxJava_pull_888.diff
ReactiveX/RxJava,Remove Bad Filter Logic,"This code was accidentally committed during exploration of groupBy/subscribeOn.
",2014-02-17 18:25:26,2014-02-17 18:25:34,https://api.github.com/repos/ReactiveX/RxJava/issues/887,[],0,14,ReactiveX_RxJava_pull_887.diff
ReactiveX/RxJava,Fixed an issue with the from(Reader) added a bunch of unit tests.,"fixed a problem @fommil noticed in #840
",2014-02-17 09:04:42,2014-02-18 00:43:57,https://api.github.com/repos/ReactiveX/RxJava/issues/885,[],128,4,ReactiveX_RxJava_pull_885.diff
ReactiveX/RxJava,OperatorRetry,"Rewritten retry operator for 0.17+ and changed the per-source retry counter to per-subscriber retry counter so each subscriber can retry independently.
",2014-02-17 08:24:18,2014-03-13 16:31:50,https://api.github.com/repos/ReactiveX/RxJava/issues/884,[],113,113,ReactiveX_RxJava_pull_884.diff
ReactiveX/RxJava,Make Subscriptions of SwingObservable thread-safe,"Updated rxjava-swing according to the discussion in #869. Is it necessary to move the unit tests to src/test/java folder?
",2014-02-17 04:48:45,2014-02-18 07:42:10,https://api.github.com/repos/ReactiveX/RxJava/issues/883,[],375,196,ReactiveX_RxJava_pull_883.diff
ReactiveX/RxJava,rewrite OperationRetry and add unit test to address issue #879,"I rewrote the OperationRetry class from first principles if you like. Pretty clear to my eyes and doesn't use a single CompositeSubscription (method add()) for the lifetime of the retry which was the cause of bug #879 in the first place. Unit tests pass though I'll be glad of some peer review. 
Cheers. Dave
",2014-02-17 00:58:36,2014-03-13 16:38:00,https://api.github.com/repos/ReactiveX/RxJava/issues/882,[],53,16,ReactiveX_RxJava_pull_882.diff
ReactiveX/RxJava,Lift Performance,"Using `f.lift()` directly instead of `subscribe` improves ops/second on the included test from 5,907,721 ops/sec to 10,145,486 ops/sec
",2014-02-15 18:27:22,2014-02-17 21:39:09,https://api.github.com/repos/ReactiveX/RxJava/issues/881,[],74,3,ReactiveX_RxJava_pull_881.diff
ReactiveX/RxJava,Force ViewObservable be subscribed and unsubscribed in the UI thread,"According to #869 , `unsubscribe` can run in any thread. However, that will cause some concurrent issues in rxjava-android.

This PR schedules the `unsubscribe` action to run in the UI thread to solve the problem.
",2014-02-15 14:47:43,2014-02-15 18:28:48,https://api.github.com/repos/ReactiveX/RxJava/issues/880,[],56,5,ReactiveX_RxJava_pull_880.diff
ReactiveX/RxJava,Scheduler.scheduleRecursive,"Make recursive scheduling a first-class citizen without needing to refer to ""this"" which doesn't work inside lambdas (Java8/Scala/etc).

``` java
        Schedulers.newThread().scheduleRecursive(new Action1<Recurse>() {
            @Override
            public void call(Recurse r) {
                System.out.println(""do stuff on thread: "" + Thread.currentThread() + "" Time: "" + System.nanoTime());
                r.schedule(100, TimeUnit.MILLISECONDS);
            }
        });
```
",2014-02-14 20:41:23,2014-02-14 20:45:55,https://api.github.com/repos/ReactiveX/RxJava/issues/878,[],51,0,ReactiveX_RxJava_pull_878.diff
ReactiveX/RxJava,Correct synchronization guard in groupByUntil,"Can't see how `synchronized (key) { ... }` could have been correct here; `key` will hardly ever be the same instance for different invocations of `keySelector`, and the comment on line 73 clearly states `gate` to be the guard for `map`.
",2014-02-14 20:22:26,2014-02-14 20:46:23,https://api.github.com/repos/ReactiveX/RxJava/issues/877,[],1,1,ReactiveX_RxJava_pull_877.diff
ReactiveX/RxJava,Manual Merge of #750,"Manual merge of https://github.com/Netflix/RxJava/pull/751
",2014-02-14 20:10:07,2014-02-14 20:40:27,https://api.github.com/repos/ReactiveX/RxJava/issues/876,[],31,0,ReactiveX_RxJava_pull_876.diff
ReactiveX/RxJava,Bounded replay subject proposal,"Proposal for #865. (Not really for merging.)

Subscription and unsubscription is serialized with the regular events so this implementation should solve #658 as well. A property of this implementation due to queue/drain approach is that a new subscriber's thread might steal the processing loop. To mitigate this, scheduler overloads are provided to capture the processing loop.

Unfortunately, the performance is 2-3 times worse in unbounded mode compared against current ReplaySubject implementation when run with a simple 1M onNext calls. The replay after completion is about 10% slower.

I would guess the enqueue/dequeue operation adds quite a substantial overhead.
",2014-02-14 18:50:31,2014-03-13 16:31:09,https://api.github.com/repos/ReactiveX/RxJava/issues/875,[],782,0,ReactiveX_RxJava_pull_875.diff
ReactiveX/RxJava,Update CompositeSubscriptionTest.java,"Fix apparent typo, unsubscription of s2 was not checked and should have been.
",2014-02-14 11:34:47,2014-02-14 18:31:00,https://api.github.com/repos/ReactiveX/RxJava/issues/874,[],1,1,ReactiveX_RxJava_pull_874.diff
ReactiveX/RxJava,Blocking zip operator,"Proposed solution to #867
- Added overloads to zip many and zip 2 only. If my approach is favorable, other overloads can be added.
  - Javadoc might need some rephrasing.
- Contains fix for #868 but no test.
- Overloads take a bufferSize > 0 indicating the queue size, bufferSize <= 0 behaves as the original zip.
  - Due to the internals of zip, a bufferSize of 0 does not work (i.e., everyone blocks on add and noone can call tick). For that, zip would need different internals with CyclicBarrier and other magic. ~~**Should I work on this case as well?**~~
- Source completion is blocking as well right now; for example, an empty producer with a slow partner will complete only if the slow partner fires its first event. ~~**Should it terminate as soon as possible?**~~

Update:
- Added 0-length buffering mode, bufferSize < 0 now indicates unlimited buffering.
- Changed buffered mode to finish as soon as possible
",2014-02-13 14:43:16,2014-03-04 17:15:38,https://api.github.com/repos/ReactiveX/RxJava/issues/871,[],717,62,ReactiveX_RxJava_pull_871.diff
ReactiveX/RxJava,Add the selector variants of timeout in RxScala,"This PR added the selector variants of the `timeout` operator in the Scala and also added two examples.
",2014-02-13 13:13:05,2014-02-13 17:16:41,https://api.github.com/repos/ReactiveX/RxJava/issues/870,[],121,4,ReactiveX_RxJava_pull_870.diff
ReactiveX/RxJava,subscribeOn + groupBy,"Some changes on top of https://github.com/Netflix/RxJava/pull/864 as part of work on https://github.com/Netflix/RxJava/issues/844.

Primarily I did two things here:
- get unsubscribe working again via `subscribeOn` for synchronous `Observable`s
- leverage new `subscribeOn` behavior to make the `groupBy` unit tests work
",2014-02-13 05:22:51,2014-02-14 20:01:40,https://api.github.com/repos/ReactiveX/RxJava/issues/869,[],581,84,ReactiveX_RxJava_pull_869.diff
ReactiveX/RxJava,Zip Bug UnitTest: Never Completes When Zero Observables (Obsolete),"Hey guys,
  I discovered this issue today in Rx.  I'm not sure if it's a bug, or as designed.  I've added the test.  Can you let me know if it is in fact a bug, then I'll correct the issue?
",2014-02-13 03:34:40,2014-02-21 21:37:26,https://api.github.com/repos/ReactiveX/RxJava/issues/868,[],0,0,ReactiveX_RxJava_pull_868.diff
ReactiveX/RxJava,Update OperationScan to OperatorScan,"Migrate to use updated conventions of Operator\* classes that implement rx.Observable.Operator
",2014-02-12 21:21:27,2014-02-12 21:21:31,https://api.github.com/repos/ReactiveX/RxJava/issues/866,[],130,153,ReactiveX_RxJava_pull_866.diff
ReactiveX/RxJava,Blocking buffer until experiment,"This is a solution to the time gap problem for #844.

I've added an subscribeOn overload where the user can explicitly request a buffering behavior. In addition, SubscribeOn checks the type of the Observable and enters buffering mode for GroupedObservable and PublishSubject. I think these code options should be mutually exclusive:
1. either we only check for Observable type, but then new kinds of observables or hidden observables won't work,
2. or ask the programmer in the documentation/tutorial to explicitly request buffering in certain operator compositions.

I personally favor option 2).

A drawback is that this blocking subscribeOn deadlocks on pools with a single thread. We can, of course, check for Trampoline, Test and Immediate schedulers, but not schedulers created via `Schedulers.executor`, or the computation scheduler on a single-core machine.
",2014-02-12 13:22:46,2014-02-14 03:35:28,https://api.github.com/repos/ReactiveX/RxJava/issues/864,[],532,38,ReactiveX_RxJava_pull_864.diff
ReactiveX/RxJava,Optimize SwingMouseEventSource.fromRelativeMouseMotion,"do it more functional way
see the trick here:
http://www.introtorx.com/Content/v1.0.10621.0/12_CombiningSequences.html#Zip
",2014-02-12 12:53:06,2014-02-12 17:28:08,https://api.github.com/repos/ReactiveX/RxJava/issues/863,[],5,28,ReactiveX_RxJava_pull_863.diff
ReactiveX/RxJava,Update the timeout docs,"Updated the timeout docs.
",2014-02-12 11:52:21,2014-02-12 17:28:23,https://api.github.com/repos/ReactiveX/RxJava/issues/862,[],28,7,ReactiveX_RxJava_pull_862.diff
ReactiveX/RxJava,"Proposed solution to the time gap, using unbounded buffering.","This is a solution to the time gap problem for #844.
- Currently, it uses an unbounded buffer. I'll think about a bounded approach later on.
- I've added an subscribeOn overload where the user can explicitly request a buffering behavior. In addition, SubscribeOn checks the type of the Observable and enters buffering mode for GroupedObservable and PublishSubject. I think these code options should be mutually exclusive: 
  1. either we only check for Observable type, but then new kinds of observables or hidden observables won't work,
  2. or ask the programmer in the documentation/tutorial to explicitly request buffering in certain operator compositions.

I personally favor option 2).
",2014-02-12 10:27:57,2014-02-12 13:20:34,https://api.github.com/repos/ReactiveX/RxJava/issues/861,[],441,37,ReactiveX_RxJava_pull_861.diff
ReactiveX/RxJava,Fixing the generics for merge and lift,"I've tracked down to two problems #858 

The first is that lift wasn't quite right. I changed the lift argument from `Operator<R, T>` to `Operator<? extends R, ? super T>`.  Unfortunately Java won't let us hide that away in the `Operator` class so we have to redeclare that everywhere in the debug hooks but it's still better than the alternative of having to use the full `Func1<? extends Subscriber<? super R>, ? super Subscriber<? super T>>` everywhere.

The second problem was in the return type of merge `Observable<T>`.  Because of operators like `merge(Observable<? extends T> t1, Observable<? extends T> t2)` the only thing that can be said for the return type is that it is also `Observable<? extends T>` but at the moment it is returning `Observable<T>`.

This pull request changes all of them and leads to some silly return values like

```
Observable<String> a, b;
Observable<? extends String> x = merge(a, b);
```
",2014-02-12 10:04:54,2014-02-12 17:27:17,https://api.github.com/repos/ReactiveX/RxJava/issues/860,[],39,143,ReactiveX_RxJava_pull_860.diff
ReactiveX/RxJava,Add 'Fragment-Host' to rxjava-contrib/debug module for OSGi,"see #849
",2014-02-12 03:38:16,2014-02-12 03:41:52,https://api.github.com/repos/ReactiveX/RxJava/issues/859,[],1,0,ReactiveX_RxJava_pull_859.diff
ReactiveX/RxJava,Change Lift to use rx.Observable.Operator,"The generics insanity has to stop.

This pull request is a result of @abersnaze and I continuing to fail to make generics work with this signature:

``` java
Func1<Subscriber<? super R>, Subscriber<? super T>>
```

It all fell apart while trying to do things that needed the equivalent of:

``` java
Func1<Subscriber<? super R>, Subscriber<? super ? super T>>
```

... and other such variants.

With this change I can also finally get the `OperatorMerge` generics to work. 

Thus, the `Operator` type exists inside `Observable` just like `OnSubscribe` like this:

``` java
    /**
     * Operator function for lifting into an Observable.
     */
    public interface Operator<R, T> extends Func1<Subscriber<? super R>, Subscriber<? super T>> {
        // cover for generics insanity
    }
```

This gives us imports like this:

``` java
import rx.Observable;
import rx.Observable.OnSubscribe;
import rx.Observable.Operator;
```

I know it's not as pure as having `lift(Func1)` but this is far more usable.

``` java
public <R> Observable<R> lift(final Operator<R, T> bind)
```

If anyone has a different suggestion that still solves the generics issue please let me know.
",2014-02-12 00:37:45,2014-02-12 01:05:26,https://api.github.com/repos/ReactiveX/RxJava/issues/857,[],51,72,ReactiveX_RxJava_pull_857.diff
ReactiveX/RxJava,SchedulePeriodically Signature,"This pull requests adds `TimeUnit delayUnit` to the signature:

``` java
public Subscription schedulePeriodically(final Action1<Scheduler.Inner> action, long initialDelay, TimeUnit delayUnit, long period, TimeUnit periodUnit)
```

This was derived from feedback from @headinthebox while writing the Scala APIs.

Reason for ... 
- it better matches languages that have a single object that represent both together such as Scala.
- Java 8 adds `Duration`: http://download.java.net/jdk8/docs/api/java/time/Duration.html 

Reason against ... 
- Java 7 and earlier doesn't do it this way on their Executor.
- Java 8 despite adding `Duration` still doesn't use it on their `ScheduledExecutorService`

Thoughts, concerns, opinions?
",2014-02-11 23:19:18,2014-02-12 17:56:34,https://api.github.com/repos/ReactiveX/RxJava/issues/856,[],20,17,ReactiveX_RxJava_pull_856.diff
ReactiveX/RxJava,Move InterruptibleBlockingQueue Inside ObserveOn,"I decided I'm not ready to commit to this in the public API so am leaving it an implementation detail of ObserveOn.
While working on groupBy, parallel and subscribeOn this queue was not the right solution.
",2014-02-11 22:59:25,2014-02-11 22:59:28,https://api.github.com/repos/ReactiveX/RxJava/issues/855,[],108,113,ReactiveX_RxJava_pull_855.diff
ReactiveX/RxJava,The onCreate hook disappeared,"I think in the merging this hook disappeared from the original pull request for the debug hooks.
",2014-02-11 22:58:33,2014-02-11 22:59:42,https://api.github.com/repos/ReactiveX/RxJava/issues/854,[],1,1,ReactiveX_RxJava_pull_854.diff
ReactiveX/RxJava,StringObservable Update,"Manual merge of https://github.com/Netflix/RxJava/pull/843
",2014-02-11 20:33:03,2014-02-11 20:33:13,https://api.github.com/repos/ReactiveX/RxJava/issues/853,[],167,83,ReactiveX_RxJava_pull_853.diff
ReactiveX/RxJava,rxjava-debug,"Manual merge of https://github.com/Netflix/RxJava/pull/836
",2014-02-11 20:30:59,2014-02-11 20:31:07,https://api.github.com/repos/ReactiveX/RxJava/issues/852,[],641,5,ReactiveX_RxJava_pull_852.diff
ReactiveX/RxJava,Reimplement the timeout operator and fix timeout bugs,"This PR reimplemented the `timeout` operator. I also fixed the following bugs of `timeout`:
- The `timeout` can not work on a synchronized Observable. Unit test:
  https://github.com/zsxwing/RxJava/commit/356a6902a6e96e4d1a131d71521b62d26596fd6c#diff-f181dce6b07869d0daacb404a292ce0cR231
- The selector variant of Timeout should throw `TimeoutException` when a timeout event happens without an other Observable. Unit test: https://github.com/zsxwing/RxJava/commit/356a6902a6e96e4d1a131d71521b62d26596fd6c#diff-836fc7028db94329e793dcc6075a258dR259
  and
  https://github.com/zsxwing/RxJava/commit/356a6902a6e96e4d1a131d71521b62d26596fd6c#diff-836fc7028db94329e793dcc6075a258dR289
- The selector variant of Timeout has a race condition between `onNext` and `timeout` methods. Unit test: https://github.com/zsxwing/RxJava/commit/356a6902a6e96e4d1a131d71521b62d26596fd6c#diff-836fc7028db94329e793dcc6075a258dR321
- The method signatures of some selector variants of Timeout are wrong.
",2014-02-11 13:43:21,2014-02-11 20:24:47,https://api.github.com/repos/ReactiveX/RxJava/issues/851,[],572,351,ReactiveX_RxJava_pull_851.diff
ReactiveX/RxJava,Subscribe on gap,"Changed @benjchristensen code a bit to allow cancelling a delayed async subscription. Fixed up the `testNewSubscriberDoesntBlockExisting` test: the original deadlocked due the synchronous changes to the subscription model.

In order to let the async subscription work non-disruptively, I had to add a `delete` method to `CompositeSubscription` which removes a subscription without unsubscribing it. This is necessary to not cancel an inner scheduler.

Unfortunately, some Async tests fail due to deadlock now.

This PR is not really meant for merge but only for demonstration purposes.
",2014-02-11 12:14:36,2014-02-11 23:07:47,https://api.github.com/repos/ReactiveX/RxJava/issues/850,[],499,118,ReactiveX_RxJava_pull_850.diff
ReactiveX/RxJava,Add 'Fragment-Host' to rxjava-contrib modules for OSGi,"avoid split packages
http://wiki.osgi.org/wiki/Split_Packages

see also discussion #154
",2014-02-11 11:39:50,2014-02-11 20:19:06,https://api.github.com/repos/ReactiveX/RxJava/issues/849,[],6,0,ReactiveX_RxJava_pull_849.diff
ReactiveX/RxJava,"Attempt at SubscribeOn ""Time Gap"" Issue [Preview]","This is an attempt at solving the `subscribeOn` ""time gap"" issue that I found to be affecting unit tests and use cases such as `parallel`. 

More information and discussion is at https://github.com/Netflix/RxJava/issues/844

Currently I have made this work by having a trigger on `Subscriber.onSubscribe()` that I'm not thrilled with but want to show this for discussion.
",2014-02-11 07:52:11,2014-02-11 22:26:02,https://api.github.com/repos/ReactiveX/RxJava/issues/848,[],499,118,ReactiveX_RxJava_pull_848.diff
ReactiveX/RxJava,Various Changes While Fixing GroupBy,,2014-02-11 07:49:57,2014-02-11 08:07:46,https://api.github.com/repos/ReactiveX/RxJava/issues/847,[],1061,430,ReactiveX_RxJava_pull_847.diff
ReactiveX/RxJava,Added overloaded createRequest method that takes an HttpContext instance,"An HttpContext is needed when doing for example preemptive digest authentication with HTTP Client.
",2014-02-11 06:01:34,2014-02-11 20:25:45,https://api.github.com/repos/ReactiveX/RxJava/issues/846,[],39,1,ReactiveX_RxJava_pull_846.diff
ReactiveX/RxJava,Fix problem with Subscription,"- Fix problem with anonymous implementation of Subscription
- Enable Kotlin module 
",2014-02-10 22:49:37,2014-02-10 23:20:34,https://api.github.com/repos/ReactiveX/RxJava/issues/845,[],4,4,ReactiveX_RxJava_pull_845.diff
ReactiveX/RxJava,Updating StringObservable,"Updating StringObservable to use lift
And added from(InputStream) and from(Reader)
",2014-02-10 22:09:36,2014-02-11 20:33:14,https://api.github.com/repos/ReactiveX/RxJava/issues/843,[],808,88,ReactiveX_RxJava_pull_843.diff
ReactiveX/RxJava,Test Unsubscribe,"- also cleaned up some stuff I remembered after merging last commits
",2014-02-09 03:32:39,2014-02-09 03:32:42,https://api.github.com/repos/ReactiveX/RxJava/issues/842,[],34,6,ReactiveX_RxJava_pull_842.diff
ReactiveX/RxJava,Range OnSubscribe,"Reimplemented as a simple loop instead of Iterable. 

Simpler code gives a performance bump:

```
     * -- 0.17
     * 
     * Run: 10 - 271,147,198 ops/sec
     * Run: 11 - 274,821,481 ops/sec
     * Run: 12 - 271,632,295 ops/sec
     * Run: 13 - 277,876,014 ops/sec
     * Run: 14 - 274,821,763 ops/sec
     * 
     * -- 0.16.1
     * 
     * Run: 10 - 222,104,280 ops/sec
     * Run: 11 - 224,311,761 ops/sec
     * Run: 12 - 222,999,339 ops/sec
     * Run: 13 - 222,344,174 ops/sec
     * Run: 14 - 225,247,983 ops/sec
```
",2014-02-09 03:24:59,2014-02-09 03:25:04,https://api.github.com/repos/ReactiveX/RxJava/issues/841,[],163,152,ReactiveX_RxJava_pull_841.diff
ReactiveX/RxJava,Error Handling: OnErrorNotImplemented and java.lang.Error,"Special Handling of java.lang.Error and OnErrorNotImplemented
- https://github.com/Netflix/RxJava/issues/748#issuecomment-32471495
- https://github.com/Netflix/RxJava/issues/771
- https://github.com/Netflix/RxJava/issues/789
",2014-02-08 00:25:50,2014-02-08 06:45:40,https://api.github.com/repos/ReactiveX/RxJava/issues/839,[],250,639,ReactiveX_RxJava_pull_839.diff
ReactiveX/RxJava,Make Scala OnCompleted Notification an object,"This should solve issue https://github.com/Netflix/RxJava/issues/662 and https://github.com/Netflix/RxJava/pull/584 .
",2014-02-07 23:52:58,2014-02-09 00:27:25,https://api.github.com/repos/ReactiveX/RxJava/issues/838,[],19,28,ReactiveX_RxJava_pull_838.diff
ReactiveX/RxJava,Perf with JMH,"#776 This is a small change on top of perf with Caliper to performance benchmarking with JMH.
",2014-02-07 09:02:48,2014-02-09 00:29:34,https://api.github.com/repos/ReactiveX/RxJava/issues/837,[],145,2,ReactiveX_RxJava_pull_837.diff
ReactiveX/RxJava,Setting up the new subproject for debugging observable chains.,"By creating and registering this plugin you get a complete log of all the events (subscribe, onNext, onError, onCompleted and unsubscribe) that happen in all observables, observers and subscribers. The debug hook also takes a Func1 for transforming data before they are sent to actual onNext functions.

This pull request is for the raw data.  There isn't any persistence or visualization of the data generated yet.

Here is an example of a simple observable chain

```
from(1, 3).flatMap({ it -> from(it, it + 1) }).take(3).subscribe()
```

And the stream of notifications sent.

```
{ ""nano"": 1391761208271225000, ""thread"": 1, ""observer"": ""rx.Observable$27@3290a11e"", ""type"": ""Subscribe"", ""source"": ""rx.Observable$2@3541d281""}
{ ""nano"": 1391761208272832000, ""thread"": 1, ""observer"": ""rx.operators.OperatorTake$1@f81c4a1"", ""type"": ""Subscribe"", ""source"": ""rx.Observable$2@10942dfb"", ""to"": ""rx.operators.OperatorTake@7056c23d""}
{ ""nano"": 1391761208275469000, ""thread"": 1, ""observer"": ""rx.operators.OperatorMerge$1@49c5146e"", ""type"": ""Subscribe"", ""source"": ""rx.Observable$2@29c06798"", ""to"": ""rx.operators.OperatorMerge@16d14192""}
{ ""nano"": 1391761208275644000, ""thread"": 1, ""observer"": ""rx.operators.OperatorMap$1@427e3f2"", ""type"": ""Subscribe"", ""source"": ""rx.operators.OperatorFromIterable@56e626ff"", ""to"": ""rx.operators.OperatorMap@200a5beb""}
{ ""nano"": 1391761208276707000, ""thread"": 1, ""observer"": ""rx.operators.OperatorMap$1@427e3f2"", ""type"": ""OnNext"", ""value"": ""1"", ""to"": ""rx.operators.OperatorMap@200a5beb""}
{ ""nano"": 1391761208276839000, ""thread"": 1, ""observer"": ""rx.operators.OperatorMerge$1@49c5146e"", ""type"": ""OnNext"", ""value"": ""rx.Observable@299b78d4"", ""from"": ""rx.operators.OperatorMap@200a5beb"", ""to"": ""rx.operators.OperatorMerge@16d14192""}
{ ""nano"": 1391761208277012000, ""thread"": 1, ""observer"": ""rx.operators.OperatorMerge$1$InnerObserver@2b6dd9c5"", ""type"": ""Subscribe"", ""source"": ""rx.operators.OperatorFromIterable@38f42ac9""}
{ ""nano"": 1391761208277075000, ""thread"": 1, ""observer"": ""rx.operators.OperatorMerge$1$InnerObserver@2b6dd9c5"", ""type"": ""OnNext"", ""value"": ""1""}
{ ""nano"": 1391761208277166000, ""thread"": 1, ""observer"": ""rx.operators.OperatorTake$1@f81c4a1"", ""type"": ""OnNext"", ""value"": ""1"", ""from"": ""rx.operators.OperatorMerge@16d14192"", ""to"": ""rx.operators.OperatorTake@7056c23d""}
{ ""nano"": 1391761208277243000, ""thread"": 1, ""observer"": ""rx.Observable$27@3290a11e"", ""type"": ""OnNext"", ""value"": ""1"", ""from"": ""rx.operators.OperatorTake@7056c23d""}
{ ""nano"": 1391761208277338000, ""thread"": 1, ""observer"": ""rx.operators.OperatorMerge$1$InnerObserver@2b6dd9c5"", ""type"": ""OnNext"", ""value"": ""2""}
{ ""nano"": 1391761208277397000, ""thread"": 1, ""observer"": ""rx.operators.OperatorTake$1@f81c4a1"", ""type"": ""OnNext"", ""value"": ""2"", ""from"": ""rx.operators.OperatorMerge@16d14192"", ""to"": ""rx.operators.OperatorTake@7056c23d""}
{ ""nano"": 1391761208277471000, ""thread"": 1, ""observer"": ""rx.Observable$27@3290a11e"", ""type"": ""OnNext"", ""value"": ""2"", ""from"": ""rx.operators.OperatorTake@7056c23d""}
{ ""nano"": 1391761208277557000, ""thread"": 1, ""observer"": ""rx.operators.OperatorMerge$1$InnerObserver@2b6dd9c5"", ""type"": ""OnCompleted""}
{ ""nano"": 1391761208279076000, ""thread"": 1, ""observer"": ""rx.operators.OperatorMap$1@427e3f2"", ""type"": ""OnNext"", ""value"": ""3"", ""to"": ""rx.operators.OperatorMap@200a5beb""}
{ ""nano"": 1391761208279154000, ""thread"": 1, ""observer"": ""rx.operators.OperatorMerge$1@49c5146e"", ""type"": ""OnNext"", ""value"": ""rx.Observable@24d8116d"", ""from"": ""rx.operators.OperatorMap@200a5beb"", ""to"": ""rx.operators.OperatorMerge@16d14192""}
{ ""nano"": 1391761208279252000, ""thread"": 1, ""observer"": ""rx.operators.OperatorMerge$1$InnerObserver@65601e00"", ""type"": ""Subscribe"", ""source"": ""rx.operators.OperatorFromIterable@951c5ff""}
{ ""nano"": 1391761208279322000, ""thread"": 1, ""observer"": ""rx.operators.OperatorMerge$1$InnerObserver@65601e00"", ""type"": ""OnNext"", ""value"": ""3""}
{ ""nano"": 1391761208279409000, ""thread"": 1, ""observer"": ""rx.operators.OperatorTake$1@f81c4a1"", ""type"": ""OnNext"", ""value"": ""3"", ""from"": ""rx.operators.OperatorMerge@16d14192"", ""to"": ""rx.operators.OperatorTake@7056c23d""}
{ ""nano"": 1391761208279483000, ""thread"": 1, ""observer"": ""rx.Observable$27@3290a11e"", ""type"": ""OnNext"", ""value"": ""3"", ""from"": ""rx.operators.OperatorTake@7056c23d""}
{ ""nano"": 1391761208279562000, ""thread"": 1, ""observer"": ""rx.Observable$27@3290a11e"", ""type"": ""OnCompleted"", ""from"": ""rx.operators.OperatorTake@7056c23d""}
{ ""nano"": 1391761208279692000, ""thread"": 1, ""observer"": ""rx.Observable$27@3290a11e"", ""type"": ""Unsubscribe"", ""from"": ""rx.operators.OperatorTake@7056c23d""}
{ ""nano"": 1391761208279756000, ""thread"": 1, ""observer"": ""rx.operators.OperatorTake$1@f81c4a1"", ""type"": ""Unsubscribe"", ""from"": ""rx.operators.OperatorMerge@16d14192"", ""to"": ""rx.operators.OperatorTake@7056c23d""}
{ ""nano"": 1391761208279830000, ""thread"": 1, ""observer"": ""rx.operators.OperatorMerge$1@49c5146e"", ""type"": ""Unsubscribe"", ""from"": ""rx.operators.OperatorMap@200a5beb"", ""to"": ""rx.operators.OperatorMerge@16d14192""}
{ ""nano"": 1391761208279880000, ""thread"": 1, ""observer"": ""rx.operators.OperatorMap$1@427e3f2"", ""type"": ""Unsubscribe"", ""to"": ""rx.operators.OperatorMap@200a5beb""}
{ ""nano"": 1391761208279946000, ""thread"": 1, ""observer"": ""rx.operators.OperatorMerge$1$InnerObserver@2b6dd9c5"", ""type"": ""Unsubscribe""}
{ ""nano"": 1391761208280018000, ""thread"": 1, ""observer"": ""rx.operators.OperatorMerge$1$InnerObserver@65601e00"", ""type"": ""Unsubscribe""}
{ ""nano"": 1391761208280085000, ""thread"": 1, ""observer"": ""rx.operators.OperatorMap$1@427e3f2"", ""type"": ""OnCompleted"", ""to"": ""rx.operators.OperatorMap@200a5beb""}
{ ""nano"": 1391761208280150000, ""thread"": 1, ""observer"": ""rx.operators.OperatorMerge$1@49c5146e"", ""type"": ""OnCompleted"", ""from"": ""rx.operators.OperatorMap@200a5beb"", ""to"": ""rx.operators.OperatorMerge@16d14192""}
```
",2014-02-07 08:30:23,2014-02-11 20:31:08,https://api.github.com/repos/ReactiveX/RxJava/issues/836,[],641,5,ReactiveX_RxJava_pull_836.diff
ReactiveX/RxJava,ObserveOn Operator with Backpressure,"This is a re-implementation of ObserveOn done for 3 purposes:

1) Migrate to new `lift` style so the `Subscription` flows through correctly
2) Eliminate the wasted first schedule step (reported by @mttkay  https://github.com/Netflix/RxJava/pull/797#issuecomment-34044956)
3) Eliminate buffering so it naturally provides back pressure 

Unit tests are passing on my machine for a full build, but I'm interested in user experience, particularly from Android users where `observeOn` behavior is mission critical.

This WILL change behavior and possibly cause problems if `observeOn` was being used to make something async (which is not the purpose of `observeOn`. The `subscribeOn` operator is the one to use for making something ~~async~~ concurrent. [Update: Per discussions below we may want another operator or `observeOn` overload to allow async behavior to use a queue and decouple producer/consumer. The `observeOn` operator however should by default only do what it says - switch threads.]

This is a complete re-write so I may very well have created nasty bugs that we don't yet have unit tests for so I'd appreciate a thorough review and testing.

One possible concern is performance. In the case of a synchronous firehose (not the normal use case, but a use case nonetheless), this is far slower because now each `onNext` is sent one-at-a-time across thread boundaries whereas before it would put everything into a queue on one side then read it all from the queue on the other side. 

Thus, for this code that synchronously firehoses 100000 values it is about 7 times faster on the current code without back-pressure:

``` java
long last = Observable.range(0, 100000).observeOn(Schedulers.newThread()).toBlockingObservable().last();
```

However, this code is the same performance:

``` java
long last = Observable.interval(1, TimeUnit.MILLISECONDS).take(1000).observeOn(Schedulers.newThread()).toBlockingObservable().last();
```

The difference being that we're not just filling up the queue in the second one as it has latency.

I believe this is okay as the intent of `observeOn` is moving across thread boundaries, such as for UI events, and eliminating the bad behavior of buffer-bloat is the right thing. 

I'm sure we can find some performance improvements in this code, but it's worth pointing out how the change in behavior can affect it.
",2014-02-07 07:48:32,2014-02-09 00:26:20,https://api.github.com/repos/ReactiveX/RxJava/issues/835,[],646,234,ReactiveX_RxJava_pull_835.diff
ReactiveX/RxJava,Update clojure for 0.17,"Updated interop for `OnSubscribe` interface. Updated readme and examples.
",2014-02-07 06:02:26,2014-02-07 06:32:43,https://api.github.com/repos/ReactiveX/RxJava/issues/834,[],151,96,ReactiveX_RxJava_pull_834.diff
ReactiveX/RxJava,Take operator was breaking the unsubscribe chain,"Fixes issue https://github.com/Netflix/RxJava/issues/830
",2014-02-07 03:51:53,2014-02-07 03:51:58,https://api.github.com/repos/ReactiveX/RxJava/issues/833,[],39,7,ReactiveX_RxJava_pull_833.diff
ReactiveX/RxJava,[Issue #831] Fix for OperationJoin race condition,"This is to fix the race condition outlined in issue #831 .
The join now grabs a copy of the other side's id in the first critical section then won't go higher than that in the iteration of the other side's values (now using entrySet()).
",2014-02-07 00:12:48,2014-02-07 04:09:48,https://api.github.com/repos/ReactiveX/RxJava/issues/832,[],29,20,ReactiveX_RxJava_pull_832.diff
ReactiveX/RxJava,"adding marble diagrams, see-also links to javadocs of new repeat() variants",,2014-02-06 21:26:12,2014-02-07 03:56:05,https://api.github.com/repos/ReactiveX/RxJava/issues/829,[],14,6,ReactiveX_RxJava_pull_829.diff
ReactiveX/RxJava,Repeat Operator,"Based on code and discussion in https://github.com/Netflix/RxJava/pull/807/files
",2014-02-06 20:22:23,2014-02-06 20:22:28,https://api.github.com/repos/ReactiveX/RxJava/issues/828,[],347,196,ReactiveX_RxJava_pull_828.diff
ReactiveX/RxJava,Fixed cut & paster error in io scheduler,"Thanks @samuelgruetter for pointing this out. 
",2014-02-06 20:16:37,2014-02-06 20:28:03,https://api.github.com/repos/ReactiveX/RxJava/issues/827,[],2,5,ReactiveX_RxJava_pull_827.diff
ReactiveX/RxJava,Return wrapped Subscription,"- make sure the SafeSubscriber is included in what is returned
- then return as Subscription not Subscriber so it can't be cast back to a Subscriber
",2014-02-06 19:45:23,2014-02-06 19:45:27,https://api.github.com/repos/ReactiveX/RxJava/issues/826,[],13,2,ReactiveX_RxJava_pull_826.diff
ReactiveX/RxJava,Issue #799 - Commenting out the call to attachCallingThreadStack when co...,"...nstructing a CompositeException
",2014-02-06 17:25:38,2014-02-06 19:46:12,https://api.github.com/repos/ReactiveX/RxJava/issues/825,[],52,28,ReactiveX_RxJava_pull_825.diff
ReactiveX/RxJava,Set setDaemon on NewThreadScheduler,"First noticed by @zsxwing.
",2014-02-06 13:21:39,2014-02-06 19:47:09,https://api.github.com/repos/ReactiveX/RxJava/issues/824,[],3,1,ReactiveX_RxJava_pull_824.diff
ReactiveX/RxJava,Reimplement 'subscribeOn' using 'lift',"hi, this PR reimplemented the `subscribeOn` using `lift`. However, both the original and current implementation can not guarantee that `unsubscribe` is always called in the `scheduler`. An extreme example is:

``` java
    public static void main(String[] args) throws InterruptedException {
        Observable.create(new OnSubscribe<Integer>() {

            @Override
            public void call(final Subscriber<? super Integer> t1) {
                final Subscription s = Subscriptions.create(new Action0() {

                    @Override
                    public void call() {
                        System.out.println(Thread.currentThread().getName());
                    }
                });
                t1.add(s);
                new Thread(new Runnable() {

                    @Override
                    public void run() {
                        t1.unsubscribe();
                    }

                }, ""test"").start();
                try {
                    Thread.sleep(10000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                t1.onCompleted();
            }
        }).subscribeOn(Schedulers.newThread()).subscribe();
        Thread.sleep(10000);
    }
```

will output ""test"".
",2014-02-06 07:36:02,2014-02-07 04:04:39,https://api.github.com/repos/ReactiveX/RxJava/issues/822,[],250,153,ReactiveX_RxJava_pull_822.diff
ReactiveX/RxJava,Update to use Subscriber/Subscriptions.create,"Master had changed since the pull request.
",2014-02-06 00:38:13,2014-02-06 00:38:16,https://api.github.com/repos/ReactiveX/RxJava/issues/821,[],33,26,ReactiveX_RxJava_pull_821.diff
ReactiveX/RxJava,Git keeps modifying this file so committing it how it wants it.,,2014-02-06 00:10:54,2014-02-06 00:11:01,https://api.github.com/repos/ReactiveX/RxJava/issues/820,[],50,50,ReactiveX_RxJava_pull_820.diff
ReactiveX/RxJava,CompositeSubscription performance increase,"- Optimized the case when the composite holds only a single element.
- Replaced Arrays.copyOf with regular arraycopy to avoid the cost of reflective array creation
- Included perf test where I got 32% increase on my i7 4770K
",2014-02-05 22:18:31,2014-02-05 22:26:02,https://api.github.com/repos/ReactiveX/RxJava/issues/819,[],75,5,ReactiveX_RxJava_pull_819.diff
ReactiveX/RxJava,CompositeSubscription memory reduction,"Since CompositeSubscription is now used everywhere with Subscriber, I looked at the code again and tried to reduce memory consumption. I've added CLEAR_STATE_UNSUBSCRIBED singleton to transition into when unsubscribed. Note that the previous version kept the subscription array after the unsubscription, keeping references to other subscriptions alive (although unsubscribed); I'm not certain why unsubscription didn't simply discard the array before.

I've played with changing the `add` and `remove` methods (not included in this PR) to do more direct array manipulation with about 10-40% speed increase for tests like add directly followed by remove. The speed increase comes from:
- using arraycopy to avoid dynamic array creation in copyOf,
- handling case where CS contains a single item to be removed and transitions into CLEAR_STATE instead of creating a new empty state.

Similar memory reduction could be implemented in MAS and SAS.
",2014-02-05 20:50:35,2014-02-05 21:45:09,https://api.github.com/repos/ReactiveX/RxJava/issues/818,[],12,4,ReactiveX_RxJava_pull_818.diff
ReactiveX/RxJava,Scala Scheduler Bindings Fix,"- Updated schedulers to reflect 0.17 changes.
- Add timer bindings
",2014-02-05 19:37:16,2014-02-05 21:45:19,https://api.github.com/repos/ReactiveX/RxJava/issues/817,[],161,269,ReactiveX_RxJava_pull_817.diff
ReactiveX/RxJava,One global onCompleted object,"issue https://github.com/Netflix/RxJava/issues/662
",2014-02-05 16:44:59,2014-02-05 18:16:46,https://api.github.com/repos/ReactiveX/RxJava/issues/816,[],6,2,ReactiveX_RxJava_pull_816.diff
ReactiveX/RxJava,RunAsync method for outputting multiple values,"Added `runAsync` method to allow producing multiple values while running an action on a scheduler.

The drawback is that the action is run immediately and observers might not get any or all of the produced values. An overload lets the client specify a subject (such as ReplaySubject) to reliably capture all values and replay them to Observers. Otherwise, it just acts as a cold observable with the additional option to cancel the schedule and/or the action.
",2014-02-05 15:53:04,2014-02-05 17:43:47,https://api.github.com/repos/ReactiveX/RxJava/issues/814,[],142,1,ReactiveX_RxJava_pull_814.diff
ReactiveX/RxJava,Fixed OperationSubscribeOn so OperationConditionalsTest works again.,"Commenting out the inner makes the `OperationConditionalsTest` pass.

Unfortunately, I'm not sure whether this change affects non-Trampolined schedulers in any way or why was there a need to unsubscribe an inner scheduler. It is possible the actual bug is in TrampolineScheduler.
",2014-02-05 14:41:46,2014-02-05 17:50:34,https://api.github.com/repos/ReactiveX/RxJava/issues/812,[],1,1,ReactiveX_RxJava_pull_812.diff
ReactiveX/RxJava,Operator Repeat and other operator fixes,"Reimplemented repeat() which exposed some other problems.
- Added `QueueDrain` based on [this](http://twistedoakstudios.com/blog/Post8424_deadlocks-in-practice-dont-hold-locks-while-notifying).
- Added overload of repeat(long n) to repeat a source n times (which is not the same as repeat().take(n) generally). Note that Ben's prototype was not working correctly because it run the re-subscription code in a loop: if subscribeOn was used, it was constantly resubscribing before the old even finished.
- For some reason, observeOn+take didn't work as expected, causing repeat tests to fail as well. I couldn't determine the cause. I've noticed that `take` was unable to unsubscribe the upstream as there was nothing in its `cs`. 
- To fix the problem above, I've reimplemented observeOn as well. It does not use recursive scheduling but the QueueDrain. 
- This exposed another problem with GroupBy: in some cases, childObserver.onCompleted was sent out twice, breaking merge/flatMap. I've added a once check, but I'm not 100% certain there isn't anything else wrong with the GroupBy's staggered behavior.
- Unfortunately, `OperationParallelMergeTest` is broken with this PR. I don't quite understand why it doesn't work nor have a clue how to fix it or the new `observeOn`. Maybe the parallel tests relied on thread timing and not expiring too fast so they could continue one them.

Performance

from+repeat: 3.8MOps/s
from+repeat+observeOn: 1.5MOps/s
range: 31.8MOps/s
from+observeOn+repeat: 15 kOps/s
",2014-02-05 09:17:48,2014-02-06 20:46:15,https://api.github.com/repos/ReactiveX/RxJava/issues/807,[],386,225,ReactiveX_RxJava_pull_807.diff
ReactiveX/RxJava,Operator repeat,"I've reimplemented repeat() with the new lift/subscriber semantics, but run into a few problems:
- The previous `observeOn` implementation didn't work for some reason with some of the repeat tests. Haven't really looked into them, but instead reimplemented observeOn with the new semantics and with queue/drain method, which brought up some further issues.
- Changed the TestScheduler a bit as I've run into cases where the internal queue's order was not of the order of the schedule (typically when using 0 as delay) which caused tests to get rearranged events. Adding a monotonic id helps distinguish between tasks scheduled for the same time.
- GroupBy had some problem where it duplicated `childObserver.onCompleted` when run with staggered groups. It broke merge. I've added a once-check to it to make it work. Might need to utilize the same completeInner() logic than the groups.
- Broke `OperationParallelMergeTest`. I'm not sure why they don't work. Maybe it gets 3 parallelism but the thread Ids keep changing underneath. I never understood the expectations in those tests.
",2014-02-04 17:42:36,2014-02-04 17:44:57,https://api.github.com/repos/ReactiveX/RxJava/issues/806,[],1762,2172,ReactiveX_RxJava_pull_806.diff
ReactiveX/RxJava,Fix CompositeException,"This fixes possible issues where infinite loops could be created if the right combination of Exceptions and causal chains were composed together.
",2014-02-04 17:31:18,2014-02-04 17:31:26,https://api.github.com/repos/ReactiveX/RxJava/issues/805,[],105,3,ReactiveX_RxJava_pull_805.diff
ReactiveX/RxJava,Operator repeat,"I've reimplemented repeat() with the new lift/subscriber semantics, but run into a few problems:
- The previous `observeOn` implementation didn't work for some reason with some of the repeat tests. Haven't really looked into them, but instead reimplemented observeOn with the new semantics and with queue/drain method, which brought up some further issues.
- Changed the TestScheduler a bit as I've run into cases where the internal queue's order was not of the order of the schedule (typically when using 0 as delay) which caused tests to get rearranged events. Adding a monotonic id helps distinguish between tasks scheduled for the same time.
- GroupBy had some problem where it duplicated `childObserver.onCompleted` when run with staggered groups. It broke merge. I've added a once-check to it to make it work. Might need to utilize the same completeInner() logic than the groups.
- Broke `OperationParallelMergeTest`. I'm not sure why they don't work. Maybe it gets 3 parallelism but the thread Ids keep changing underneath. I never understood the expectations in those tests.
",2014-02-04 17:23:52,2014-02-04 17:27:12,https://api.github.com/repos/ReactiveX/RxJava/issues/804,[],451,290,ReactiveX_RxJava_pull_804.diff
ReactiveX/RxJava,Add testMultipleWithSameCause UnitTest,"Also make tests capable of failing with timeouts. Before the constructor would immediately go into an infinite loop and hang the tests.
",2014-02-04 05:54:13,2014-02-04 05:54:18,https://api.github.com/repos/ReactiveX/RxJava/issues/803,[],25,12,ReactiveX_RxJava_pull_803.diff
ReactiveX/RxJava,Added more possible failure cases to CompositeExceptionTest,,2014-02-04 04:47:40,2014-02-04 04:47:55,https://api.github.com/repos/ReactiveX/RxJava/issues/801,[],9,0,ReactiveX_RxJava_pull_801.diff
ReactiveX/RxJava,issue-799,"This PR is targeted at the 0.16.1 tag, but can be applied cleanly to master as well.  I wanted to have the ability to launch a bugfix 0.16.2 release that's not gated on the large number of changes in master.

Fixes #799
",2014-02-03 23:29:17,2014-03-13 16:29:53,https://api.github.com/repos/ReactiveX/RxJava/issues/800,[],157,31,ReactiveX_RxJava_pull_800.diff
ReactiveX/RxJava,Scheduler Outer/Inner [Preview],"Following are proposed changes to the `Scheduler` signature based on discussions between @headinthebox and I intended to simplify scheduling and make it easier to do the right thing.

This originates from three findings:

1) It was very easy to cause memory leaks or inadvertent parallel execution since the distinction between outer and inner scheduling was not obvious.

To solve this the new design explicitly has the outer `Scheduler` and then `Scheduler.Inner` for recursion.

2) The passing of state is not useful since scheduling over network boundaries with this model does not work.

In this new design all state passing signatures have been removed. This was determined while implementing a `RemoteScheduler` that attempted to use `observeOn` to transition execution from one machine to another. This does not work because of the requirement for serializing/deserializing the state of the entire execution stack. Migration of work over the network has been bound to be better suited to explicit boundaries established by Subjects. Thus, the complications within the Schedulers are unnecessary.

3) The number of overloads with different ways of doing the same things were confusing.

This new design removes all but the essential and simplest methods.

This is the new signature for `Scheduler`:

``` java
public abstract class Scheduler {

     // the primary entry point, it immediately schedulers work on a new thread and executes it
     // the return subscription will shut down the Inner scheduler when unsubscribed
     public abstract <T> Subscription schedule(Action1<Scheduler.Inner> action);
     public <T> Subscription schedule(final Action1<Scheduler.Inner> action, final long delayTime, final TimeUnit unit);
     public int degreeOfParallelism();
     public long now();

     public abstract class Inner implements Subscription {

         public abstract void schedule(Action1<Scheduler.Inner> action);
         public abstract void schedule(Action1<Scheduler.Inner> action, long delayTime, TimeUnit unit);
         public void schedulePeriodically(final Action1<Scheduler.Inner> action, long initialDelay, long period, TimeUnit unit);
            // I question having schedulePeriodically here, since recursion allow the same behavior, and with conditional logic
         public void schedule(Action1<Scheduler.Inner> action, Date dueTime);
      }
}
```

The simplest execution of a single task is:

``` java
Schedulers.newThread().schedule(new Action1<Inner>() {

    @Override
    public void call(Inner inner) {
        doWork();
    }

});
```

Recursion is easily invoked:

``` java
Schedulers.newThread().schedule(new Action1<Inner>() {

    @Override
    public void call(Inner inner) {
        doWork();
        // recurse until unsubscribed (the schedule will do nothing if unsubscribed)
        inner.schedule(this);
    }

});
```

The use of `Action1<Inner>` on both the outer and inner levels makes it so recursion that refer to `this` and it works easily. 

Similar to the new `lift`/`create` pattern with `Subscriber` the `Inner` is also a `Subscription` so it allows efficient loops with `unsubscribe` support:

``` java
Schedulers.newThread().schedule(new Action1<Inner>() {

    @Override
    public void call(Inner inner) {
        while(!inner.isUnsubscribed()) {
            doWork();
        }
    }

});
```

An action can now `unsubscribe` the `Scheduler.Inner`:

``` java
Schedulers.newThread().schedule(new Action1<Inner>() {

    @Override
    public void call(Inner inner) {
        while(!inner.isUnsubscribed()) {
            int i = doOtherWork();
            if(i > 100) {
                // an Action can cause the Scheduler to unsubscribe and stop
                inner.unsubscribe();
            }
        }
    }

});
```

Typically just stopping is sufficient:

``` java
Schedulers.newThread().schedule(new Action1<Inner>() {

    @Override
    public void call(Inner inner) {
        int i = doOtherWork();
        if (i < 10) {
            // recurse until done 10
            inner.schedule(this);
        }
    }

});
```

but if other work in other tasks is being done and you want to unsubscribe conditionally you could:

``` java
Schedulers.newThread().schedule(new Action1<Inner>() {

    @Override
    public void call(Inner inner) {
        int i = doOtherWork();
        if (i < 10) {
            // recurse until done 10
            inner.schedule(this);
        } else {
            inner.unsubscribe();
        }
    }

});
```

and the recursion can be delayed:

``` java
Schedulers.newThread().schedule(new Action1<Inner>() {

    @Override
    public void call(Inner inner) {
        doWork();
        // recurse until unsubscribed ... but delay the recursion
        inner.schedule(this, 500, TimeUnit.MILLISECONDS);
    }

});
```

The methods on the `Inner` never return a `Subscription` because they are always a single thread/event-loop/actor/etc and controlled by the `Subscription` returned by the initial `Scheduler.schedule` method. This is part of clarifying the contract.

Thus an `unsubscribe` controlled from the outside would be done like this:

``` java
Subscription s = Schedulers.newThread().schedule(new Action1<Inner>() {

    @Override
    public void call(Inner inner) {
        while(!inner.isUnsubscribed()) {
            doWork();
        }
    }

});

// unsubscribe from outside
s.unsubscribe();
```

I'd appreciate feedback on this design direction.

---

NOTE: This pull request is not yet complete. I have not modified the language adaptors or other modules, and there are 3 unit tests in core failing (related to `buffer` and `window`).
",2014-02-02 05:40:27,2014-02-04 17:19:18,https://api.github.com/repos/ReactiveX/RxJava/issues/797,[],1260,1824,ReactiveX_RxJava_pull_797.diff
ReactiveX/RxJava,Add Subscription.isUnsubscribed(),"With the new model of injecting `Subscription` into functions for synchronous loops to check `isUnsubscribed()` it now makes sense for this to be on the interface of all `Subscription` implementations.
",2014-02-01 00:48:18,2014-02-01 00:56:52,https://api.github.com/repos/ReactiveX/RxJava/issues/796,[],255,183,ReactiveX_RxJava_pull_796.diff
ReactiveX/RxJava,Observer + Subscriber,"As per discussion in https://github.com/Netflix/RxJava/issues/792 the `abstract class Observer` has been returned to `interface Observer` and there is now `abstract class Subscriber implements Observer<T>, Subscription` to fill that role.

Signatures are now:

``` java
// Observable.create
public final static <T> Observable<T> create(OnSubscribe<T> f)

// Observable.OnSubscribe typed function interface
public static interface OnSubscribe<T> extends Action1<Subscriber<? super T>>

// Observable.subscribe
public final Subscription subscribe(Subscriber<? super T> subscriber)
public final Subscription subscribe(Observer<? super T> observer)

// lift function
public <R> Observable<R> lift(final Func1<Subscriber<? super R>, Subscriber<? super T>> bind)

// Observer
public interface Observer<T> {
     public abstract void onNext(T t);
     public abstract void onError(Throwable e);
     public abstract void onCompleted();
}

// Subscriber
public abstract class Subscriber<T> implements Observer<T>, Subscription {
     public final void add(Subscription s)
     public final void unsubscribe()
     public final boolean isUnsubscribed()
}

// Subject 
public abstract class Subject<T, R> extends Observable<R> implements Observer<T>
```
",2014-01-31 06:50:05,2014-01-31 06:58:33,https://api.github.com/repos/ReactiveX/RxJava/issues/793,[],1842,1379,ReactiveX_RxJava_pull_793.diff
ReactiveX/RxJava,improve switchOnNext description in javadocs,"also: repair anchors in links to RxJava wiki in javadocs
",2014-01-29 21:04:20,2014-01-30 06:12:32,https://api.github.com/repos/ReactiveX/RxJava/issues/791,[],334,316,ReactiveX_RxJava_pull_791.diff
ReactiveX/RxJava,Convert to scan to use lift,"I switched the scan to an operator and cleaned up what looked like a lot of unnecessary code from the summing operations.
",2014-01-28 20:14:55,2014-02-12 20:37:07,https://api.github.com/repos/ReactiveX/RxJava/issues/790,[],132,385,ReactiveX_RxJava_pull_790.diff
ReactiveX/RxJava,Performance benchmark with caliper,"Minimal changes to get a `./gradlew time` task to accurately benchmark performance changes for #776.

I'm still looking into JHM but I'm not sure how well it will integrate with Rx's gradle build.
",2014-01-27 18:41:24,2014-02-09 00:29:37,https://api.github.com/repos/ReactiveX/RxJava/issues/788,[],143,2,ReactiveX_RxJava_pull_788.diff
ReactiveX/RxJava,Fix problem with Observable.create(),"- Fix problem with Obserable.create()
- Avoid the use of deprecated methods 
",2014-01-27 11:15:50,2014-01-27 18:05:55,https://api.github.com/repos/ReactiveX/RxJava/issues/787,[],113,90,ReactiveX_RxJava_pull_787.diff
ReactiveX/RxJava,"Careful With That Global Search And Replace, Eugene.","restoring the working URLs of RxJava wiki pages and marble diagrams in the javadocs
http://www.youtube.com/watch?v=AYMyxTFwuz8
",2014-01-26 20:19:50,2014-01-27 18:05:20,https://api.github.com/repos/ReactiveX/RxJava/issues/786,[],466,466,ReactiveX_RxJava_pull_786.diff
ReactiveX/RxJava,Reimplement Zip Operator Using Lift [Preview],"A preview of a re-implementation of the `zip` operator.

This re-implements the `zip` operator but not yet the `zipIterable` so those unit tests are still failing. I'm submitting early to get a code review and will finish the `zipIterable` sometime early next week.

I have already had the concurrency model reviewed by two others and all unit tests are passing but further review is justified and welcome.

The performance of this implementation (without doing any profiling) has risen from 1.42m ops/second on v0.16 to 1.67m ops/second as measured on my machine for the simple test `Observable.zip(from(1), from(1), {a, b -> a+b})` and 31k ops/second to 63k ops/second for `Observable.zip(range(0, 100), range(100, 200), {a, b -> a+b})`.
",2014-01-26 06:23:10,2014-02-05 03:53:18,https://api.github.com/repos/ReactiveX/RxJava/issues/785,[],1080,294,ReactiveX_RxJava_pull_785.diff
ReactiveX/RxJava,Lift and Observer+Subscription,"Make `Observer` implement `Subscription` and rename `bind` to `lift` as per decisions in https://github.com/Netflix/RxJava/issues/775

Signatures are now:

``` java
// Observable.create
public final static <T> Observable<T> create(OnSubscribe<T> f)

// Observable.OnSubscribe typed function interface
public static interface OnSubscribe<T> extends Action1<Observer<? super T>>

// lift function
public <R> Observable<R> lift(final Func1<Observer<? super R>, Observer<? super T>> bind)

// Observer
public abstract class Observer<T> implements Subscription {
     public abstract void onNext(T t);
     public abstract void onError(Throwable e);
     public abstract void onCompleted();
     public final void add(Subscription s)
     public final void unsubscribe()
     public final boolean isUnsubscribed()
}

// Subject
public abstract class Subject<T, R> extends Observer<T> {
    public abstract Observable<R> toObservable();
}
```

This is a major set of changes to the internals, particularly the unit tests because Mockito has issues with abstract classes as opposed to `Observer` being an interface.

There are still some unit tests failing that I haven't yet figured out:
- OperationJoinsTest.whenComplicated in rxjava-core
- OperationConditionalsTest.testDoWhileManyTimes in rxjava-computation-expressions
- OperationConditionalsTest.testWhileDoManyTimes in rxjava-computation-expressions

I intend on merging this sooner rather than later so everyone can be working off the same codebase, even though I do not consider this code ready for release, even once those unit tests are fixed.

Interestingly, these performance tests on my machine are much better:

``` java
// OperatorFromIterablePerformance.timeTenLongs()
v0.16
     * Run: 10 - 8,096,667 ops/sec
     * Run: 11 - 8,382,131 ops/sec
     * Run: 12 - 8,256,288 ops/sec
     * Run: 13 - 8,139,703 ops/sec
     * Run: 14 - 8,011,023 ops/sec

... after v0.17 work:

     * Run: 10 - 31,296,553 ops/sec
     * Run: 11 - 30,080,435 ops/sec
     * Run: 12 - 31,886,941 ops/sec
     * Run: 13 - 32,281,807 ops/sec
     * Run: 14 - 33,519,028 ops/sec


// OperatorMapPerformance.timeMapPlusOne();

v0.16

     * Run: 10 - 11,375,632 ops/sec
     * Run: 11 - 11,390,325 ops/sec
     * Run: 12 - 11,655,527 ops/sec
     * Run: 13 - 11,528,440 ops/sec
     * Run: 14 - 11,321,181 ops/sec

... after v0.17 work:

     * Run: 10 - 17,674,464 ops/sec
     * Run: 11 - 17,890,239 ops/sec
     * Run: 12 - 17,919,155 ops/sec
     * Run: 13 - 16,356,974 ops/sec
     * Run: 14 - 16,723,414 ops/sec

// OperatorMergePerformance.timeRepetitionsEmissionSynchronous()

v0.16

     * Run: 10 - 32,609,617 ops/sec
     * Run: 11 - 33,511,839 ops/sec
     * Run: 12 - 34,768,096 ops/sec
     * Run: 13 - 32,376,499 ops/sec
     * Run: 14 - 33,166,835 ops/sec

... after v0.17 work:

     * Run: 10 - 45,945,747 ops/sec
     * Run: 11 - 46,342,209 ops/sec
     * Run: 12 - 44,493,090 ops/sec
     * Run: 13 - 44,999,640 ops/sec
     * Run: 14 - 47,389,771 ops/sec

```
",2014-01-25 00:48:33,2014-01-26 05:17:48,https://api.github.com/repos/ReactiveX/RxJava/issues/784,[],3334,2889,ReactiveX_RxJava_pull_784.diff
ReactiveX/RxJava,Implement some Android UI related operators,"1. OperatorViewClick
2. OperatorEditTextInput
3. OperatorCompoundButtonInput
",2014-01-24 17:17:15,2014-02-06 00:33:59,https://api.github.com/repos/ReactiveX/RxJava/issues/783,[],738,1,ReactiveX_RxJava_pull_783.diff
ReactiveX/RxJava,"Fixed buglet in join binding, simplified types","Txs to @samuelgruetter for pointing out a small bug involving implicit conversions.

Simplified some of the types of empty, buffer, window, groupBy until to leverage Scala's top and bottom type (we could not do this in C#).
",2014-01-23 21:11:50,2014-02-06 00:33:06,https://api.github.com/repos/ReactiveX/RxJava/issues/781,[],72,30,ReactiveX_RxJava_pull_781.diff
ReactiveX/RxJava,Added join,"Added support for join in the Scala bindings
",2014-01-23 16:41:23,2014-01-23 19:39:53,https://api.github.com/repos/ReactiveX/RxJava/issues/780,[],42,0,ReactiveX_RxJava_pull_780.diff
ReactiveX/RxJava,Make operator writing a little less error prone.,,2014-01-23 00:33:06,2014-01-26 05:38:27,https://api.github.com/repos/ReactiveX/RxJava/issues/779,[],20,16,ReactiveX_RxJava_pull_779.diff
ReactiveX/RxJava,Fix zip race condition,"The ItemObserver collection logic needs to run in both the OnNext and OnCompleted handlers. 

Otherwise, you might have values waiting to be emitted and without seeing an OnCompleted. I couldn't think of an easy unit test for this, it actually took a while to narrow down the example.

The only way I could reproduce it on my machine was to use Hystrix and it happens somewhat sporadically (10-50 iterations).

``` java
public class Test {

  public static class DummyCommand extends HystrixCommand<Integer> {

    protected DummyCommand() {
      super(HystrixCommandGroupKey.Factory.asKey(""Dummy""));
    }

    @Override
    protected Integer run() throws Exception {
      Thread.sleep(1);
      return 1;
    }
  }

  public static void main(String[] args) throws InterruptedException {

    while (true) {
      Observable.zip(tap(new DummyCommand().observe()), tap(new DummyCommand().observe()), new Func2<Integer, Integer, Integer>() {
        @Override
        public Integer call(Integer a, Integer b) {
          return a + b;
        }
      }).toBlockingObservable().single();
      System.out.println(""\n\n\n"");
      Thread.sleep(5);
    }

  }

  public static Observable<Integer> tap(Observable<Integer> observable) {
    return observable.doOnEach(new Action1<Notification<? super Integer>>() {
      @Override
      public void call(Notification<? super Integer> notification) {
        System.out.println(""notification = "" + notification);
      }
    });
  }

}
```
",2014-01-22 18:51:19,2014-01-22 22:32:07,https://api.github.com/repos/ReactiveX/RxJava/issues/778,[],40,61,ReactiveX_RxJava_pull_778.diff
ReactiveX/RxJava,Fixed testSingleSourceManyIterators,"Converted to a single-threaded test.
",2014-01-22 08:17:44,2014-02-11 20:26:06,https://api.github.com/repos/ReactiveX/RxJava/issues/777,[],19,9,ReactiveX_RxJava_pull_777.diff
ReactiveX/RxJava,Bind pre release,"Fixed scala issue (map with index was removed)
",2014-01-21 21:59:10,2014-01-21 23:29:06,https://api.github.com/repos/ReactiveX/RxJava/issues/774,[],2511,2163,ReactiveX_RxJava_pull_774.diff
ReactiveX/RxJava,Various buildscript cleanup.,"There's a lot of changes here, but I tried to keep them small and incremental.

Let me know if there's anything you're unhappy with and I'll recraft this.
",2014-01-21 13:54:59,2014-02-11 20:41:54,https://api.github.com/repos/ReactiveX/RxJava/issues/772,[],685,860,ReactiveX_RxJava_pull_772.diff
ReactiveX/RxJava,Bind Operator,"Implementation of `bind` operator along with new `create` and `subscribe` methods and several reimplemented operators: `fromIterable`, `toList`, `toSortedList`, `map`, `cast`, `timestamp`, `merge`, `flatMap`, `mergeMap`, `groupBy`, `parallel`.

The `bind` signature is:

``` java
public <R> Observable<R> bind(final Func1<Operator<? super R>, Operator<? super T>> bind)
```

The new `Operator` class signature is:

``` java
public abstract class Operator<T> implements Observer<T>, Subscription
```

The `create` method now looks like:

``` java
public final static <T> Observable<T> create(final Action1<Operator<? super T>> f)
```

A new `subscribe` signature is:

``` java
public final void subscribe(Operator<? super T> o)
```

The use of these three new methods allows for chaining operators together and supporting unsubscription on both synchronous and asynchronous sources.
##### Status and Plan
- I have temporarily disabled Scala and Kotlin builds until they are fixed. 
- The Groovy module has been retrofitted with an extension module to intercept and disambiguate the new `create` method from the deprecated one.
- I have not yet tested Clojure or JRuby
- I am pretty certain I have the generics wrong on `OperatorMerge` so am using it in non-typesafe manner right now

This design has been reviewed with several people on Github and in person. Besides resolving the items listed above, my intention is as follows:
- invite feedback and review on this pull request in the next 12-24 hours
- merge into trunk if nothing major comes up
- work towards resolving issues with the language adaptors and polishing any rough edges of the new changes
- finalize `bind` signatures
- consider deprecating or eliminating `CurrentThreadScheduler` (if it needs to exist at all, perhaps rename to `TrampolineScheduler` to remove confusion between `Immediate` and `CurrentThread`)
- release as 0.17.0 (along with some unrelated `Scheduler` changes)
- continue working in the future migrating operators to this new design

See https://github.com/Netflix/RxJava/issues/746 for background on the proposal, reasons and design discussion.
",2014-01-21 05:21:19,2014-01-22 04:13:41,https://api.github.com/repos/ReactiveX/RxJava/issues/770,[],2511,2163,ReactiveX_RxJava_pull_770.diff
ReactiveX/RxJava,Zip fix for multiple onCompleted and moved unsubscribe outside the lock.,"Also added the test case from the issue.

Instead of #766
",2014-01-20 06:52:28,2014-01-21 05:29:16,https://api.github.com/repos/ReactiveX/RxJava/issues/767,[],71,17,ReactiveX_RxJava_pull_767.diff
ReactiveX/RxJava,Fixed the issue that 'zip' calls 'onCompleted' twice,"Fixed the issue reported by Vadim Spivak at https://groups.google.com/forum/#!topic/rxjava/79cWTv3TFp0

The original `zip` implementation may call `onCompleted` more than once but does not wrap the observer with a `SafeObserver`. When the observer is an internal observer, `zip` will break the Rx contract.

This PR wraps the internal observer with a `SafeObserver`.
",2014-01-19 09:09:06,2014-01-21 05:29:32,https://api.github.com/repos/ReactiveX/RxJava/issues/766,[],63,4,ReactiveX_RxJava_pull_766.diff
ReactiveX/RxJava,A variety of improvements to the javadoc text.,,2014-01-18 18:24:49,2014-01-21 05:28:31,https://api.github.com/repos/ReactiveX/RxJava/issues/765,[],2507,2815,ReactiveX_RxJava_pull_765.diff
ReactiveX/RxJava,Added support for custom functions in combineLatest.,,2014-01-17 04:35:41,2014-02-11 20:42:31,https://api.github.com/repos/ReactiveX/RxJava/issues/763,[],25,0,ReactiveX_RxJava_pull_763.diff
ReactiveX/RxJava,"adding javadoc marble diagram for the mergeMap(next,completed,error) variety",,2014-01-16 23:51:57,2014-01-17 03:23:55,https://api.github.com/repos/ReactiveX/RxJava/issues/762,[],5,3,ReactiveX_RxJava_pull_762.diff
ReactiveX/RxJava,additional buffer tests,"see Issue #756
",2014-01-16 21:30:01,2014-02-11 20:41:22,https://api.github.com/repos/ReactiveX/RxJava/issues/761,[],143,0,ReactiveX_RxJava_pull_761.diff
ReactiveX/RxJava,Performance Tests Source Folder,"- Create /src/perf for placing performance tests
- Start some operator tests and move existing perf tests into this folder.
- Probably want to explore using https://code.google.com/p/caliper/
",2014-01-16 19:51:39,2014-01-16 19:51:43,https://api.github.com/repos/ReactiveX/RxJava/issues/760,[],415,3,ReactiveX_RxJava_pull_760.diff
ReactiveX/RxJava,Add marble diagrams to new operators & variants.,"Add javadoc ""@deprecated use..."" where appropriate.
Some javadoc comment reformatting (e.g. overlong lines).
",2014-01-15 19:47:45,2014-01-15 22:16:08,https://api.github.com/repos/ReactiveX/RxJava/issues/755,[],176,109,ReactiveX_RxJava_pull_755.diff
ReactiveX/RxJava,modify ReplaySubject (with specified capacity) to comply with original reactive extensions behaviour,"modify ReplaySubject (with specified capacity) to comply with original reactive extensions behaviour

the capacity of ReplaySubject specifies maximum element count of the replay buffer

code:
https://rx.codeplex.com/SourceControl/latest#Rx.NET/Source/System.Reactive.Linq/Reactive/Subjects/ReplaySubject.cs
test:
https://rx.codeplex.com/SourceControl/latest#Rx.NET/Source/Tests.System.Reactive/Tests/Linq/Subjects/ReplaySubjectTest.cs
",2014-01-15 07:56:05,2014-03-13 16:29:45,https://api.github.com/repos/ReactiveX/RxJava/issues/753,[],138,41,ReactiveX_RxJava_pull_753.diff
ReactiveX/RxJava,"Organize, Format, Alphabetize and Finalize","Code cleanup after the many new operators that have come in over the past 2 months.

1) Organized imports
2) Formatted all code for standard whitespace, code formatting etc
3) Sorted methods in `Observable.java` alphabetically
4) Updated all license headers
5) Made `Observable` methods final as they are not intended to be overridden in the rare cases when inheritance makes sense for `Observable`. This better communicates the inheritance intent of the class and prevents against accidental misuse (such as overriding `subscribe` which breaks it).
",2014-01-15 07:42:56,2014-01-15 07:50:35,https://api.github.com/repos/ReactiveX/RxJava/issues/752,[],10015,8550,ReactiveX_RxJava_pull_752.diff
ReactiveX/RxJava,Provide Observable.timestamp(Scheduler) to be used in the tests.,"The test could've used toBlockingObservable, but this hangs, even though timestamped observable is completed.
",2014-01-14 15:05:50,2014-02-14 20:40:27,https://api.github.com/repos/ReactiveX/RxJava/issues/751,[],31,0,ReactiveX_RxJava_pull_751.diff
ReactiveX/RxJava,Separated Android test code from source.,"Moved the nested test classes in the android contrib code into a separate test folder.  The unit-test dependencies were making ProGuard sad, causing it to complain about missing libraries.
",2014-01-14 08:10:29,2014-01-14 08:20:39,https://api.github.com/repos/ReactiveX/RxJava/issues/749,[],379,275,ReactiveX_RxJava_pull_749.diff
ReactiveX/RxJava,"Organize, Format, Alphabetize and Finalize","Code cleanup after the many new operators that have come in over the past 2 months.

1) Organized imports
2) Formatted all code for standard whitespace, code formatting etc
3) Sorted methods in `Observable.java` alphabetically
4) Updated all license headers
5) Made `Observable` methods final as they are not intended to be overridden in the rare cases when inheritance makes sense for `Observable`. This better communicates the inheritance intent of the class and prevents against accidental misuse (such as overriding `subscribe` which breaks it).

Anyone have issues with any of these changes (I figure (5) will be the most controversial)?
",2014-01-14 05:09:26,2014-01-15 07:42:31,https://api.github.com/repos/ReactiveX/RxJava/issues/747,[],9854,8427,ReactiveX_RxJava_pull_747.diff
ReactiveX/RxJava,Fixed issue #737,"Fixed issue #737. Moved the `onCompleted` logic under the condition `latest == id`.
",2014-01-13 09:31:32,2014-01-14 03:51:00,https://api.github.com/repos/ReactiveX/RxJava/issues/745,[],72,16,ReactiveX_RxJava_pull_745.diff
ReactiveX/RxJava,Observable interface,"The core purposes of the Observable type—visitation of elements, detection of completion, and detection of errors—are currently tangled with a set of fluent utility methods. This tangling makes the core contract of observability harder to understand, and it makes sub-typing less straightforward and less flexible.

To resolve this situation, I have refactored an interface out of Observable, which I have tentatively dubbed IObservable. (Ideally, the interface itself would be called Observable, and the class FluentObservable. See Guava's FluentIterable alongside the JDK's Iterable for another example of this pattern. However, I did not want to break backward compatibility.) All public methods now accept IObservable instead of Observable in their argument lists, while those that returned Observable continue to do so. This pattern gives the best of both worlds: any IObservable implementation can be used anywhere Observable and its subclasses can, and we don't lose the convenience of the fluent API. In particular, any IObservable can be converted into an Observable via the new method Observable.from(IObservable).

This change should be 100% backwards-compatible at compile time, though the changed signatures mean that it is not backwards-compatible at the binary level. I have observed a number of breaking API changes on master over the last few weeks, so hopefully that is not a deal breaker. If it is, we can always restore overloads that accept Observable in addition to IObservable, but that seemed like a pretty large amount of duplication and complexity for a small benefit, so I have not done it so far.
",2014-01-13 01:41:59,2014-03-13 16:24:04,https://api.github.com/repos/ReactiveX/RxJava/issues/744,[],2648,2247,ReactiveX_RxJava_pull_744.diff
ReactiveX/RxJava,Replaces AtomicReference with a length 1 array,"This patch replaces the usage of an AtomicReference in BlockingObservable::forEach to hold
an exception set from within a closure with an array of length 1, thus avoiding the cost of
the memory barriers issued when the AtomicReference's internal volatile field is accessed.
",2014-01-12 13:24:01,2014-02-11 20:36:02,https://api.github.com/repos/ReactiveX/RxJava/issues/743,[],6,7,ReactiveX_RxJava_pull_743.diff
ReactiveX/RxJava,Build with Gradle 1.10.,"Required that the IDE plugins also be applied to the root, because of the improved Scala support with the IDEA plugin.
",2014-01-11 13:54:28,2014-01-12 00:16:50,https://api.github.com/repos/ReactiveX/RxJava/issues/742,[],3,4,ReactiveX_RxJava_pull_742.diff
ReactiveX/RxJava,"Zip with iterable, removed old aggregator version and updated tests","Listed in #653.
",2014-01-11 12:22:27,2014-01-14 08:18:51,https://api.github.com/repos/ReactiveX/RxJava/issues/741,[],524,393,ReactiveX_RxJava_pull_741.diff
ReactiveX/RxJava,Timeout with selector overloads,"Listed in #653.
",2014-01-11 10:58:14,2014-01-14 03:46:02,https://api.github.com/repos/ReactiveX/RxJava/issues/740,[],474,0,ReactiveX_RxJava_pull_740.diff
ReactiveX/RxJava,Debounce with selector,"Listed in #653
",2014-01-11 09:40:43,2014-01-14 03:45:11,https://api.github.com/repos/ReactiveX/RxJava/issues/739,[],260,1,ReactiveX_RxJava_pull_739.diff
ReactiveX/RxJava,Publish and PublishLast overloads,"Listed in #653

These operators use the existing multicast and subject infrastructure so I omitted any direct tests.
",2014-01-11 08:32:05,2014-01-14 03:43:32,https://api.github.com/repos/ReactiveX/RxJava/issues/738,[],78,1,ReactiveX_RxJava_pull_738.diff
ReactiveX/RxJava,MergeMap with Iterable and resultSelector overloads,"Listed in #653.
",2014-01-10 14:44:42,2014-01-14 03:41:12,https://api.github.com/repos/ReactiveX/RxJava/issues/736,[],727,0,ReactiveX_RxJava_pull_736.diff
ReactiveX/RxJava,Window with Observable boundary.,"Listed in issue #653.
",2014-01-10 13:34:37,2014-01-14 03:36:06,https://api.github.com/repos/ReactiveX/RxJava/issues/735,[],380,0,ReactiveX_RxJava_pull_735.diff
ReactiveX/RxJava,Delay with subscription and item delaying observables.,"Listed in #653

Note: onError and onCompleted events of the source are immediately propagated and will prevent emitting any pending values.
",2014-01-10 12:24:47,2014-01-14 03:35:27,https://api.github.com/repos/ReactiveX/RxJava/issues/734,[],555,0,ReactiveX_RxJava_pull_734.diff
ReactiveX/RxJava,Buffer with Observable boundary.,"Mentined in Issue #653.
- 1 overload where the user can specify the capacity of the internal buffer.
",2014-01-10 10:44:26,2014-01-14 03:32:10,https://api.github.com/repos/ReactiveX/RxJava/issues/733,[],296,2,ReactiveX_RxJava_pull_733.diff
ReactiveX/RxJava,Ported groupByUntil function to scala-adapter,"Ported the groupByUntil function to scala-adapter. This is my first time contributing, please let me know if anything is off.
",2014-01-09 21:12:48,2014-01-14 18:51:37,https://api.github.com/repos/ReactiveX/RxJava/issues/732,[],42,7,ReactiveX_RxJava_pull_732.diff
ReactiveX/RxJava,Replaced 'Thread.sleep' with 'CountDownLatch' to fix the flaky test failures,"Fixed the test failures in https://github.com/Netflix/RxJava/issues/383#issuecomment-30081304 and #581
",2014-01-09 13:30:37,2014-01-09 17:45:03,https://api.github.com/repos/ReactiveX/RxJava/issues/731,[],17,20,ReactiveX_RxJava_pull_731.diff
ReactiveX/RxJava,Improve Error Handling and Stacktraces When Unsubscribe Fails,"The stacktraces were a mess when onError failed or was not implemented and unsubscribe also failed.
That is a far edge case and means code is broken and breaking the Rx contracts … but that’s just when we need clear stacktraces.
The CompositeException and SafeObserver class now do a dance and wire together a causal chain to provide a stacktrace that can identity all the points of error.
Also standardized and simplified the RxJavaPlugin.onErrorHandler while working in the vicinity.

This came about after I was asked to help debug a problem and couldn’t do it by looking at the thrown exception, I had to use a debugger and step through.
",2014-01-09 06:32:56,2014-01-09 06:51:04,https://api.github.com/repos/ReactiveX/RxJava/issues/730,[],433,57,ReactiveX_RxJava_pull_730.diff
ReactiveX/RxJava,ImmediateScheduler optimization for toObservableIterable,"- the ImmediateScheduler no longer schedules itself but uses a loop
- 10-20x faster to use a loop rather than schedule itself recursively
",2014-01-07 02:07:06,2014-01-07 02:20:14,https://api.github.com/repos/ReactiveX/RxJava/issues/727,[],179,152,ReactiveX_RxJava_pull_727.diff
ReactiveX/RxJava,The test has to wait on each action independently.,"Reduced the size of the iterable because I think it was blowing through the stack.
",2014-01-06 23:06:45,2014-01-09 17:43:26,https://api.github.com/repos/ReactiveX/RxJava/issues/726,[],20,5,ReactiveX_RxJava_pull_726.diff
ReactiveX/RxJava,Simpler computation/io naming for Schedulers,"- simpler (no one remembers the current names when talking about them)
- does not tie naming to a particular implementation involving thread pools versus a pool of event loops or something similar (as we likely will change the implementation, see https://github.com/Netflix/RxJava/issues/713)
",2014-01-06 21:29:05,2014-01-06 22:05:31,https://api.github.com/repos/ReactiveX/RxJava/issues/725,[],34,2,ReactiveX_RxJava_pull_725.diff
ReactiveX/RxJava,Revert use of CurrentThreadScheduler for Observable.from,"Use ImmediateScheduler as performance is 4x faster and CurrentThreadScheduler currently offers no benefit (it doesn’t solve the unsubscribe problem).

Performance numbers:

```
 * Observable.from(Arrays.asList(1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L), scheduler);
 *
 * --- Schedulers.immediate() ---
 *
 * Run: 0 - 1,849,947 ops/sec
 * Run: 1 - 2,076,067 ops/sec
 * Run: 2 - 2,114,688 ops/sec
 * Run: 3 - 2,114,301 ops/sec
 * Run: 4 - 2,102,543 ops/sec
 *
 * --- Schedulers.currentThread() ---
 *
 * Run: 0 - 548,862 ops/sec
 * Run: 1 - 559,955 ops/sec
 * Run: 2 - 581,412 ops/sec
 * Run: 3 - 562,187 ops/sec
 * Run: 4 - 565,723 ops/sec

 * Observable.from(Arrays.asList(1L), scheduler);
 *
 * --- Schedulers.immediate() ---
 *
 * Run: 10 - 4,113,672 ops/sec
 * Run: 11 - 4,068,351 ops/sec
 * Run: 12 - 4,070,318 ops/sec
 * Run: 13 - 4,161,793 ops/sec
 * Run: 14 - 4,156,725 ops/sec
 *
 * --- Schedulers.currentThread() ---
 *
 * Run: 10 - 1,692,286 ops/sec
 * Run: 11 - 1,765,054 ops/sec
 * Run: 12 - 1,763,100 ops/sec
 * Run: 13 - 1,770,907 ops/sec
 * Run: 14 - 1,732,291 ops/sec
```
",2014-01-06 21:28:54,2014-01-06 22:05:07,https://api.github.com/repos/ReactiveX/RxJava/issues/724,[],177,2,ReactiveX_RxJava_pull_724.diff
ReactiveX/RxJava,Deprecate multiple arity ‘from’,"- added @Deprecated annotations where it was only part of the Javadoc
- deprecated ‘where’ which is a duplicate of `filter` kept from early days matching Rx.Net

See https://github.com/Netflix/RxJava/issues/686
",2014-01-06 20:56:05,2014-01-06 21:06:02,https://api.github.com/repos/ReactiveX/RxJava/issues/723,[],27,0,ReactiveX_RxJava_pull_723.diff
ReactiveX/RxJava,Added `Observable.timeout` wrappers to scala adapter,"Added the four timeout methods on Observable in the Scala adaptor. Note
for the java/scala type interop:
http://stackoverflow.com/q/20912151
",2014-01-04 17:17:48,2014-01-09 17:44:38,https://api.github.com/repos/ReactiveX/RxJava/issues/720,[],79,4,ReactiveX_RxJava_pull_720.diff
ReactiveX/RxJava,Implemented the Merge overloads,"Hi, this PR implemented the overloads of `merge` in #62. Please take a look.
",2014-01-03 16:36:43,2014-01-14 03:29:04,https://api.github.com/repos/ReactiveX/RxJava/issues/718,[],322,163,ReactiveX_RxJava_pull_718.diff
ReactiveX/RxJava,Added ConnectableObservable,"Fixed test
Added overload for scan
Added trivial test for scan
",2014-01-03 05:32:34,2014-01-03 16:41:12,https://api.github.com/repos/ReactiveX/RxJava/issues/717,[],83,13,ReactiveX_RxJava_pull_717.diff
ReactiveX/RxJava,Add missing type hint to clojure example,"#623
",2014-01-02 23:25:09,2014-01-03 00:23:47,https://api.github.com/repos/ReactiveX/RxJava/issues/715,[],3,1,ReactiveX_RxJava_pull_715.diff
ReactiveX/RxJava,rxjava-computation-expressions,"The conditional operators are going in this contrib module.

See https://github.com/Netflix/RxJava/issues/683
",2014-01-02 22:39:49,2014-01-02 22:49:25,https://api.github.com/repos/ReactiveX/RxJava/issues/714,[],418,293,ReactiveX_RxJava_pull_714.diff
ReactiveX/RxJava,Fix Scheduler Memory Leaks,"The `NewThreadScheduler`, `CurrentThreadScheduler` and `ExecutorScheduler` all had memory leaks when doing recursion with the `Func2` method signature. This pull request fixes that along with improving the unit test coverage.

The fix involved treating ""outer"" and ""inner"" schedulers differently, with ""inner"" being the place where recursion happens.

The memory behavior can be tested using `TestRecursionMemoryUsage`.

This fixes the problems reported in https://github.com/Netflix/RxJava/pull/643 and  https://github.com/Netflix/RxJava/pull/648 but does not change the `Scheduler` or `Subscription` interfaces or public implementation details.
",2013-12-31 19:07:20,2014-01-02 05:12:31,https://api.github.com/repos/ReactiveX/RxJava/issues/712,[],1591,905,ReactiveX_RxJava_pull_712.diff
ReactiveX/RxJava,Created new wiki page for the operators in the Async class,"...adjusted javadoc links accordingly
...added new sections for previously un-wiki-documented operators in Async
...added links to those in javadocs
",2013-12-31 00:49:53,2013-12-31 00:57:28,https://api.github.com/repos/ReactiveX/RxJava/issues/710,[],68,46,ReactiveX_RxJava_pull_710.diff
ReactiveX/RxJava,Lotsa javadoc improvements,"- diagrams for previously-undiagram'd methods
- links to wiki docs where available
- standardizing format & nomenclature
",2013-12-30 22:23:32,2013-12-30 22:38:11,https://api.github.com/repos/ReactiveX/RxJava/issues/709,[],452,443,ReactiveX_RxJava_pull_709.diff
ReactiveX/RxJava,Combine latest fix,"Manual merge of https://github.com/Netflix/RxJava/pull/616

I would like to get a version of this that doesn't use a lock in the `onNext` method but have chosen to merge this for now to get the functionality correct and then followup later with a refactor or rewrite when I or someone else has time.
",2013-12-30 18:18:55,2013-12-30 18:19:01,https://api.github.com/repos/ReactiveX/RxJava/issues/708,[],328,522,ReactiveX_RxJava_pull_708.diff
ReactiveX/RxJava,Merge of rxjava-async-util,"Manual merge of https://github.com/Netflix/RxJava/pull/704
",2013-12-30 17:59:27,2013-12-30 18:06:49,https://api.github.com/repos/ReactiveX/RxJava/issues/707,[],3426,1197,ReactiveX_RxJava_pull_707.diff
ReactiveX/RxJava,Clean merge of rxjava-async-util,"Manual merge of https://github.com/Netflix/RxJava/pull/704 by cherry picking relevant changes.
",2013-12-30 17:14:47,2013-12-30 17:28:12,https://api.github.com/repos/ReactiveX/RxJava/issues/706,[],2190,507,ReactiveX_RxJava_pull_706.diff
ReactiveX/RxJava,adjust javadocs for new sumFoo()/averageFoo() method names,,2013-12-29 03:03:51,2013-12-29 03:18:21,https://api.github.com/repos/ReactiveX/RxJava/issues/705,[],16,16,ReactiveX_RxJava_pull_705.diff
ReactiveX/RxJava,New contrib module: rxjava-async-util,"- Added startFuture, deferFuture, forEachFuture operators.
- Left out the CancellationToken resembling overloads as I was in doubt they can be meaningfully used. If a task is cancelled, it is enough to check the Thread.currentThread().isInterrupted() flag.
",2013-12-28 01:02:05,2013-12-30 17:14:58,https://api.github.com/repos/ReactiveX/RxJava/issues/704,[],3426,1198,ReactiveX_RxJava_pull_704.diff
ReactiveX/RxJava,Small Tweaks,"Some small changes while reviewing code.
",2013-12-27 23:00:03,2013-12-27 23:00:08,https://api.github.com/repos/ReactiveX/RxJava/issues/703,[],19,8,ReactiveX_RxJava_pull_703.diff
ReactiveX/RxJava,Collect Operator,"Added with @headinthebox while reviewing Java 8 Streams https://github.com/Netflix/RxJava/issues/678
",2013-12-27 21:57:57,2013-12-27 21:58:02,https://api.github.com/repos/ReactiveX/RxJava/issues/701,[],58,0,ReactiveX_RxJava_pull_701.diff
ReactiveX/RxJava,various javadoc improvements,"- diagrams for skip(t), single(), take(t), skipLast(t)
- adding diagrams, improving javadocs for sumFoo/averageFoo operators
- adding diagram to repeat()
",2013-12-27 21:49:23,2013-12-27 23:02:21,https://api.github.com/repos/ReactiveX/RxJava/issues/700,[],190,99,ReactiveX_RxJava_pull_700.diff
ReactiveX/RxJava,Repeat Operator,"- merge and slight modification of https://github.com/Netflix/RxJava/pull/518 done with @headinthebox 
",2013-12-27 21:33:44,2013-12-27 21:33:49,https://api.github.com/repos/ReactiveX/RxJava/issues/699,[],158,2,ReactiveX_RxJava_pull_699.diff
ReactiveX/RxJava,Merge of Pull 657: Average and Sum,,2013-12-27 21:13:26,2013-12-27 21:13:31,https://api.github.com/repos/ReactiveX/RxJava/issues/698,[],1078,3,ReactiveX_RxJava_pull_698.diff
ReactiveX/RxJava,Manual Merge of Pull #667,"Manual merge of https://github.com/Netflix/RxJava/pull/667
",2013-12-27 20:22:41,2013-12-27 20:22:47,https://api.github.com/repos/ReactiveX/RxJava/issues/697,[],700,13,ReactiveX_RxJava_pull_697.diff
ReactiveX/RxJava,New contrib module: rxjava-async-util,"Home for async utility functions with juc.Future, Actions, Functions etc that don’t need to be in rxjava-core.

As per discussions at:
- https://github.com/Netflix/RxJava/pull/646#issuecomment-31147005
- https://github.com/Netflix/RxJava/pull/645#issuecomment-31146492
- https://github.com/Netflix/RxJava/pull/622#issuecomment-31144128

/cc @akarnokd
",2013-12-27 18:56:30,2013-12-27 21:43:19,https://api.github.com/repos/ReactiveX/RxJava/issues/696,[],708,508,ReactiveX_RxJava_pull_696.diff
ReactiveX/RxJava,"Change page from ""Mathematical Operators"" to ""Mathematical and Aggregate Operators""","- move toList, reduce, concat, toSortedList, toMap, and toMultiMap to that page
- deprecate aggregate in favor of reduce

[should I move takeLast, last, and takeLastBuffer to the Aggregate operators page? they don't operate on the aggregate, exactly, but they do wait until the source completes before emitting anything]
",2013-12-26 19:31:11,2013-12-27 16:28:40,https://api.github.com/repos/ReactiveX/RxJava/issues/694,[],257,185,ReactiveX_RxJava_pull_694.diff
ReactiveX/RxJava,Kotlin M6.2,"Version updated for Kotlin M6.2
",2013-12-26 14:40:19,2013-12-26 16:15:48,https://api.github.com/repos/ReactiveX/RxJava/issues/693,[],2,2,ReactiveX_RxJava_pull_693.diff
ReactiveX/RxJava,javadoc improvements:,"- diagrams for switchLatest, mergeMap, concatMap, switchMap, mapWithIndex, doOnNext
- change text to note deprecation of aggregate
- standardized formatting
- force image size in ReplaySubject javadoc
",2013-12-24 20:11:15,2013-12-24 20:37:05,https://api.github.com/repos/ReactiveX/RxJava/issues/691,[],21,19,ReactiveX_RxJava_pull_691.diff
ReactiveX/RxJava,Fixed Scala bindings,,2013-12-24 18:36:05,2013-12-24 18:43:03,https://api.github.com/repos/ReactiveX/RxJava/issues/690,[],53,26,ReactiveX_RxJava_pull_690.diff
ReactiveX/RxJava,Removed ObserverBase,"For issue #674

Removed ObserverBase and adapted JoinObserver1.
",2013-12-24 15:32:45,2013-12-27 16:31:10,https://api.github.com/repos/ReactiveX/RxJava/issues/689,[],41,93,ReactiveX_RxJava_pull_689.diff
ReactiveX/RxJava,Fix SafeObserver handling of onComplete errors,"Fixes https://github.com/Netflix/RxJava/issues/630
",2013-12-24 06:56:22,2013-12-24 06:56:27,https://api.github.com/repos/ReactiveX/RxJava/issues/688,[],247,32,ReactiveX_RxJava_pull_688.diff
ReactiveX/RxJava,API Design Tweaks,"Some changes resulting from review with @headinthebox and @jhusain

General principles pursued are to simplify the mental model and surface area of the API.
",2013-12-24 05:13:23,2013-12-24 06:25:26,https://api.github.com/repos/ReactiveX/RxJava/issues/670,[],118,97,ReactiveX_RxJava_pull_670.diff
ReactiveX/RxJava,Javadoc improvements:,"- diagrams for switchCase, doWhile, whileDo, ifThen, delaySubscription, single, singleOrDefault, takeFirst, takeLast (and variant forms of these)
- standardizing javadoc comment formatting
- standardizing nomenclature
",2013-12-24 01:14:47,2013-12-24 05:14:09,https://api.github.com/repos/ReactiveX/RxJava/issues/669,[],296,209,ReactiveX_RxJava_pull_669.diff
ReactiveX/RxJava,Operator forIterable 2,"Split from #636

This operator behaves differently than `concat(Iterable)`. It allows projecting a potentially infinite sequence onto Observables concatenated one after each other. The input Iterable sequence is not traversed upfront like concat(Iterable) and concat(Observable) would do.
",2013-12-24 00:26:48,2013-12-27 20:07:37,https://api.github.com/repos/ReactiveX/RxJava/issues/668,[],359,0,ReactiveX_RxJava_pull_668.diff
ReactiveX/RxJava,"Operators Skip, SkipLast, Take with time","Rebased version, without the drain scheduler variant.
- Fixes issue mentioned in #666 as well.
",2013-12-23 23:52:07,2013-12-27 20:22:48,https://api.github.com/repos/ReactiveX/RxJava/issues/667,[],686,6,ReactiveX_RxJava_pull_667.diff
ReactiveX/RxJava,GroupByUntil with maxGroups,"Split from #641

Purpose: limit the active groups to a certain number. If new group is opened, the oldest group is closed.
",2013-12-23 22:36:24,2013-12-27 21:34:56,https://api.github.com/repos/ReactiveX/RxJava/issues/665,[],189,21,ReactiveX_RxJava_pull_665.diff
ReactiveX/RxJava,Operation AsObservable,"Split from PR #641
",2013-12-23 22:21:10,2013-12-27 16:31:56,https://api.github.com/repos/ReactiveX/RxJava/issues/664,[],46,0,ReactiveX_RxJava_pull_664.diff
ReactiveX/RxJava,BO.collect and BO.chunkify,"Refactored BO.collect and BO.chunkify out of PR #636

Mentioned in issue #634
",2013-12-23 21:47:54,2014-02-11 20:34:17,https://api.github.com/repos/ReactiveX/RxJava/issues/663,[],500,0,ReactiveX_RxJava_pull_663.diff
ReactiveX/RxJava,Subscriptions Rewrite,"Refactor rewrite of Subscriptions by @headinthebox and myself after reviewing the various different implementations.
- We removed `SingleAssignmentSubscription` while trying to reduce surface area and simplify code.
- Moved to a non-blocking state-machine model that does not lock or busy spin during ""mutation states""
",2013-12-23 20:38:33,2013-12-23 20:38:38,https://api.github.com/repos/ReactiveX/RxJava/issues/661,[],391,384,ReactiveX_RxJava_pull_661.diff
ReactiveX/RxJava,Hopefully fixed missing notifications if part of the subscription is del...,"...ayed.

Fix suggestion to issue #658.

Basically it is a ""spin-lock"" between onNext and the subscription. It has the additional effect of locking out concurrent subscriptions, but these would most likely clash on the state-swap anyway.
",2013-12-23 20:08:54,2013-12-27 21:33:57,https://api.github.com/repos/ReactiveX/RxJava/issues/660,[],207,6,ReactiveX_RxJava_pull_660.diff
ReactiveX/RxJava,Missing fixes from the subject rewrite,"Two small changes:
- Prevent overwriting the terminal notification in `BehaviorSubject` so new subscribers to a terminated subject can see the error/completion.
- Call `Thread.currentThread().interrupt()` if the `terminationLatch.await()` throws.
",2013-12-23 19:46:41,2013-12-23 22:47:12,https://api.github.com/repos/ReactiveX/RxJava/issues/659,[],58,6,ReactiveX_RxJava_pull_659.diff
ReactiveX/RxJava,"Operations Aggregate, Average and Sum with selector","Issue #653

Remarks:
- I know we can combine ops to get one of the new aggregate variant, but I think it might be worth having a direct version which avoids nesting several layers of Observables, Observers and Subscriptions.
- The `averageInteger` and `sumInteger` (and the other types) are handy if we want to use chained operation invocations (with less overhead):

``` java
Observable.from(""a"", ""bb"", ""ccc"").sumInteger(s -> s.length())
    .toBlockingObservable().single();
```

instead of

``` java
Observable.sumIntegers(Observable.from(""a"", ""bb"", ""ccc"").map(s -> s.length()))
    .toBlockingObservable().single();
```
",2013-12-23 18:18:25,2013-12-27 21:13:33,https://api.github.com/repos/ReactiveX/RxJava/issues/657,[],1304,1,ReactiveX_RxJava_pull_657.diff
ReactiveX/RxJava,"Skip, SkipLast, Take, TakeLast with time","Issue #653
",2013-12-23 01:03:20,2013-12-23 23:18:47,https://api.github.com/repos/ReactiveX/RxJava/issues/655,[],960,4,ReactiveX_RxJava_pull_655.diff
ReactiveX/RxJava,"Empty, Error and Never overloads with type witness","Witness variants for #653.
",2013-12-22 22:35:03,2013-12-23 22:22:13,https://api.github.com/repos/ReactiveX/RxJava/issues/654,[],89,1,ReactiveX_RxJava_pull_654.diff
ReactiveX/RxJava,Subjects fixes performance improvements,"Based on PR #651 

Improvements upon Ben's excellent work:
- (Original performance for me was 1.662.152 ops/sec on average.)
- Storing subscriptions and observers in arrays rather than in a Map inside `SubjectSubscriptionManager.`. This adds +2.340.000 ops/sec on average; total ~ 4.000.000 ops/sec so far.
- `SafeObserver` uses a volatile for the actual Observer which is swapped to a `nopObserver` if a terminal case occurs. This avoids an atomic get and if statement and adds a +100.000 ops/second on average; total ~4.100.000 ops/sec so far.
- I suggest adding a create option to set the initial buffer size (not done here) which would reduce the number of array-resizes. With 2048 as a sweet spot on my machine, this adds +1.100.000 ops/second; total 5.200.000 so far.

**Bounded version**
We have a boundable ReplaySubject in main named `CustomReplaySubject` and PR #649 to improve a bit upon its performance. It might benefit from the changes above as well. It would be more tricky implementation in terms of the replay operation, since the buffer would be in constant virtual index motion (including its start and end), so observers would need to atomically get a value from it whose index could get below the virtual start index of the buffer. Will think about this.
",2013-12-22 14:00:52,2013-12-23 18:36:33,https://api.github.com/repos/ReactiveX/RxJava/issues/652,[],1264,668,ReactiveX_RxJava_pull_652.diff
ReactiveX/RxJava,"Subjects Refactor - Non-Blocking, Common Abstraction, Performance","These changes evolved out of reviewing pull request https://github.com/Netflix/RxJava/pull/605 and code reviewing master branch with @headinthebox and validating functionality against .Net. I also spent some time to figure out a non-blocking design that I believe is working.

The results for `ReplaySubject` is that it performs faster than what is currently in master and does not block in almost all cases. I have not yet perf-tested the other 3 Subjects.
- Common logic composed inside SubjectSubscriptionManager used by all 4 Subjects
- ReplaySubject does not block while replaying to new subscribers
- Added unit tests and fixed behavior while reviewing with @headinthebox compared to Rx.Net
- Uses mostly non-blocking approach (I believe it’s all correct, unit and long running tests have been used to prove it. The tests found concurrency problems during development and became stable once I got the design correct. As with all concurrent code I may be missing something.)
  - The only place it blocks is if a new Observer subscribes, completes replay and `onComplete`/`onError` are in process. It will wait for those to complete before applying the terminal state on itself.

As for performance, for relative comparison my machine gets these numbers for the master branch:

```
     * ArrayList with raw values & synchronized access
     * 
     * Run: 10 - 11,993,341 ops/sec
     * Run: 11 - 11,719,523 ops/sec
     * Run: 12 - 11,965,214 ops/sec
     * Run: 13 - 11,814,730 ops/sec
     * Run: 14 - 11,947,459 ops/sec
```

This commit gets these numbers:

```
     * ArrayList with raw values & non-blocking (no synchronization)
     * 
     * Run: 10 - 16,069,678 ops/sec
     * Run: 11 - 15,954,688 ops/sec
     * Run: 12 - 16,158,874 ops/sec
     * Run: 13 - 16,209,504 ops/sec
     * Run: 14 - 16,151,174 ops/sec
```

I'm curious about adding bounded support and using a circular-array rather than ArrayList and seeing if it performs better.

The performance tests are inside `SubjectPerformanceTests` and inspired by tests done in the non-blocking code workshop with Martin Thompson. 

Some of the code is not as elegant as I'd like but was done for performance reasons. For example, I had a much more elegant version using a simple linked list but it had horrible performance. Another example is that using `Notification` to wrap every `onNext` so we have a single data structure is very inefficient so it maintains `T` without wrapping and then conditional logic to check for terminal state. These and other things have been determined while doing perf tests during development and I have consciously moved towards performance rather than the most elegant code.

I'd appreciate feedback on concurrency problems if any exist or ways of getting more performance out while achieving the same functional requirements.
",2013-12-22 07:10:35,2013-12-23 18:36:32,https://api.github.com/repos/ReactiveX/RxJava/issues/651,[],1246,660,ReactiveX_RxJava_pull_651.diff
ReactiveX/RxJava,"Refactored BoundedReplaySubject, concurrency enhancements.","Refactored the formerly `rx.operators.OperationReplay.CustomReplaySubject` into `rx.subjects.BoundedReplaySubject` with all sorts of `create` factory methods.

Also mentioned in the [forum](https://groups.google.com/forum/#!topic/rxjava/SqwS5kz-lRA).

Changed to the concurrency logic:

The former `Lock` is now split into a `ReadWriteLock`. In write phase, the buffer is updated; in read phase, the observers are notified. New subscribers will enter the read phase so replaying can be run in-parallel with the already subscribed observers.

However, the source side of the subject is still blocked while replaying. I can't imagine any non-convoluted way to make this less blocking or lock free.
",2013-12-20 23:02:16,2013-12-22 14:23:37,https://api.github.com/repos/ReactiveX/RxJava/issues/649,[],793,644,ReactiveX_RxJava_pull_649.diff
ReactiveX/RxJava,Reentrant scheduling2,"Revised version of PR #643.
- Added `scheduleRunnable()` overloads to `Scheduler` directly to avoid constant wrapping between `Runnable` and `Action0`.
- Removed the helper interface.
- Reworked `ReentrantScheduler` to work with a parent scheduler directly.
- Replaced `ForwardSubscription` with `IncrementalSubscription` as the first one didn't correctly managed the orderly nature of swapping subscriptions: an unfortunate thread scheduling could have swapped in an older subscription before a new subscription.

In my opinion, the `Scheduler` and its implementations should use `Runnable` as the internal unit of work instead of `Action0`. Since the `Executor`s require `Runnable` anyway, less wrapping means less memory and better performance. The `Scheduler` interface can retain the `Action0` overloads but no other implementation should need to deal with them.
",2013-12-20 20:34:03,2014-01-02 05:12:53,https://api.github.com/repos/ReactiveX/RxJava/issues/648,[],641,60,ReactiveX_RxJava_pull_648.diff
ReactiveX/RxJava,Operation Generate + Timed,"Issue #49

I hope the `Func1<TState, Long>, TimeUnit` will suffice.

I kept the absolute time variant in the `OperationGenerate` and in tests but haven't exposed them in `Observable`.
",2013-12-20 17:35:04,2014-01-02 20:36:04,https://api.github.com/repos/ReactiveX/RxJava/issues/647,[],860,0,ReactiveX_RxJava_pull_647.diff
ReactiveX/RxJava,Operator BO.forEachFuture,"Issue #634

I tried to find a random place in BO but it is likely this or the other PRs will not merge one after another.
",2013-12-20 13:45:13,2013-12-27 18:58:52,https://api.github.com/repos/ReactiveX/RxJava/issues/646,[],745,0,ReactiveX_RxJava_pull_646.diff
ReactiveX/RxJava,Operators: startFuture (StartAsync) and deferFuture (DeferAsync),"Issue #634

They are basically 1-2 layer deep indirections around Futures and Observables.
",2013-12-20 10:06:46,2013-12-27 18:58:47,https://api.github.com/repos/ReactiveX/RxJava/issues/645,[],1098,0,ReactiveX_RxJava_pull_645.diff
ReactiveX/RxJava,Throw the checked exception without declaring it.,"It uses the deprecated method Thread.stop(Throwable) to throw an exception without declaring it.
",2013-12-20 00:28:49,2014-01-02 20:01:58,https://api.github.com/repos/ReactiveX/RxJava/issues/644,[],28,16,ReactiveX_RxJava_pull_644.diff
ReactiveX/RxJava,Fixed OutOfMemoryError with CPU scheduler in recursive mode.,"Found an [issue in Rx.NET](https://rx.codeplex.com/discussions/431558) regarding an out-of-memory situation due to long chained subscriptions when using recursive scheduling.

The following test program crashes or just hangs indefinitely:

``` java
public class RunRecursiveScheduling {
    /**
     * Generates an observable sequence by iterating a state from an initial 
     * state until the condition returns false.
     */
    public static <TState, R> OnSubscribeFunc<R> generate(
            final TState initialState,
            final Func1<TState, Boolean> condition,
            final Func1<TState, TState> iterate,
            final Func1<TState, R> resultSelector,
            final Scheduler scheduler) {
        return new OnSubscribeFunc<R>() {
            @Override
            public Subscription onSubscribe(final Observer<? super R> observer) {
                return scheduler.schedule(initialState, new Func2<Scheduler, TState, Subscription>() {
                    @Override
                    public Subscription call(Scheduler s, TState state) {
                        boolean hasNext;
                        try {
                            hasNext = condition.call(state);
                        } catch (Throwable t) {
                            observer.onError(t);
                            return Subscriptions.empty();
                        }
                        if (hasNext) {
                            R result;
                            try {
                                result = resultSelector.call(state);
                            } catch (Throwable t) {
                                observer.onError(t);
                                return Subscriptions.empty();
                            }
                            observer.onNext(result);

                            TState nextState;
                            try {
                                nextState = iterate.call(state);
                            } catch (Throwable t) {
                                observer.onError(t);
                                return Subscriptions.empty();
                            }

                            return s.schedule(nextState, this);
                        }
                        observer.onCompleted();
                        return Subscriptions.empty();
                    }
                });
            }
        };
    }

    public static void main(String[] args) throws Exception {
        Observable<Integer> source = Observable.create(generate(
                0, a -> true, a -> a + 1, a -> a, Schedulers.threadPoolForComputation()));

        CountDownLatch latch = new CountDownLatch(1);
        Subscription s = source.subscribe(v -> { 
                    if (v % 100_000 == 0) {
                        System.out.println(v);
                    }
                    if (v >= 10_000_000) { 
                        latch.countDown(); 
                    } 
                }, 
                e -> { e.printStackTrace(); latch.countDown(); }, 
                latch::countDown);

        latch.await();

        System.out.println(""Wait done."");

        s.unsubscribe();

        System.out.println(""Unsubscribe done."");
    }
}
```

The issue lies in the fact that CPU scheduler (and perhaps the others) are not really reentrant, therefore, they create new composite subscriptions whenever a recursive scheduling happens. So instead of showing a simple subscription to the outside world, a chain of subscription is extended on every recursive schedule call.

A working solution is to have a different scheduler shown to the `Func2<Scheduler, T, Subscription>` than the actual CPU scheduler. This new scheduler, called `ReentrantScheduler`, maintains internal subscriptions which get replaced if a recursive scheduling is executed.

I found three issues with this new approach and the old tests:
- In `SchedulersTest.testRecursiveScheduler2`, the logic relied on the expectation that the call on L338 is executed at least once if the outer subscription is unsubscribed. The new logic stops the schedule chain instantly, so it is very unlikely the call on L338 gets executed after this.
- In `OperationObserveOn.Observation` tries to solve the underlying issue as well with its own subscription replacer logic. I haven't changed the operator as it might not work with non CPU scheduler after that.
- The `ReentrantSchehduler` maintains two subscriptions. One for the result of the schedule calls, and one for the the `DiscardableAction`s. The former subscriptions can be swapped out without unsubscribing the previous completed schedule, but I'm not sure about the `DiscardableAction`s; if I unsubscribe them, tests hang because it basically cancels itself and no further task is executed. This might be a conceptual error in `ReentrantScheduler`; perhaps it should not return the entire composite on each schedule call, but rather return the content of the `actionSub` only.
",2013-12-19 22:36:35,2013-12-20 20:34:39,https://api.github.com/repos/ReactiveX/RxJava/issues/643,[],661,61,ReactiveX_RxJava_pull_643.diff
ReactiveX/RxJava,TestScheduler infrastructure enhancements,"Enhanced TestScheduler.

Mentioned in issue #634, and in the forum [HistoricalScheduler](https://groups.google.com/forum/#!topic/rxjava/4vmsg5Rs5sU).

Notes:
- Inspired by Rx.NET.
- `HistoricalScheduler` appears to be just a variant of the `TestScheduler` where times are absolute `DateTimeOffset`s. Since we don't do `java.util.Date` overloads anywhere, I didn't implement this. If you need to work with real time (i.e., `System.currentTimeMillis()`) just advance the `TestScheduler` by ctm. before doing anything else.
- The `Recorded` class, the `TestScheduler.scheduleAbsolute` and `TestScheduler.scheduleRelative` methods use millisecond resolution time due to two reasons:
  - `TestScheduler.now()` is in milliseconds
  - No real need of higher resolution, as TestScheduler operates on virtual time and aimed for testing purposes only. Virtual time can be scaled up or down as neccessary.
- Added the package `rx.observers`. I guess we can move the `SafeObserver`, `ObserverBase` and `SynchronizedObserver` into these packages (not done in this PR). The package's JavaDoc visibility can be decided independently.
- I put the new `ColdObservable`, `HotObservable` and `TestableObservable` types into `rx.observables`. Do we have a main distribution and a test distribution of RxJava (i.e., if someone wants to use these types to test his/her own operators, does he/she need to download a different library)?
- Added some behavior to `Notification`. In addition, I suggested the deprecation of `new Notification()` to create an OnCompleted kind of notification, since virtually there is no way (or reason) to distinguish between one OnCompleted event from another, I've added a factory method instead which returns a single constant instance. I haven't changed any use place of the old constructor.
- See `TestSchedulerTest` for the use cases.
",2013-12-19 14:46:45,2014-02-11 20:35:06,https://api.github.com/repos/ReactiveX/RxJava/issues/642,[],1493,1,ReactiveX_RxJava_pull_642.diff
ReactiveX/RxJava,"Operators: AsObservable, GroupBy w/ maxGroups, GroupByUntil w/ maxGroups","Issue #634

Implemented both maxGroups variants on top of (my) `groupByUntil` so it won't conflict with any potentially rewritten `groupBy`.
",2013-12-19 09:37:03,2013-12-23 22:35:34,https://api.github.com/repos/ReactiveX/RxJava/issues/641,[],281,22,ReactiveX_RxJava_pull_641.diff
ReactiveX/RxJava,Moved the descriptions of some operators to a new wiki page.,"""Conditional and Boolean Operators""
adjusting the javadoc links accordingly
",2013-12-18 22:02:13,2013-12-19 17:54:17,https://api.github.com/repos/ReactiveX/RxJava/issues/639,[],21,21,ReactiveX_RxJava_pull_639.diff
ReactiveX/RxJava,"Operators DelaySubscription, TakeLast w/ time, TakeLastBuffer","Issue #634
",2013-12-18 21:49:54,2013-12-23 21:40:26,https://api.github.com/repos/ReactiveX/RxJava/issues/638,[],539,1,ReactiveX_RxJava_pull_638.diff
ReactiveX/RxJava,"Operators BO.chunkify, BO.collect, O.forIterable","Issue #634

Any suggestions for a name instead of `forIterable`?
",2013-12-18 20:06:49,2013-12-24 00:27:09,https://api.github.com/repos/ReactiveX/RxJava/issues/636,[],858,0,ReactiveX_RxJava_pull_636.diff
ReactiveX/RxJava,"Operators: switchCase (Case), ifThen (If), doWhile (DoWhile), WhileDo (W...","...hile)

Issue #634

No MSDN references available.
",2013-12-18 14:00:36,2013-12-23 21:19:03,https://api.github.com/repos/ReactiveX/RxJava/issues/635,[],818,0,ReactiveX_RxJava_pull_635.diff
ReactiveX/RxJava,Fixed issue #595 about null in toList operator,"just fixed the issue #595 about null values. I suppose that 'toList' does not need to handle the concurrent problem, so I use `ArrayList`.
",2013-12-18 02:40:23,2013-12-23 21:16:33,https://api.github.com/repos/ReactiveX/RxJava/issues/633,[],15,9,ReactiveX_RxJava_pull_633.diff
ReactiveX/RxJava,Make NewThreadScheduler create Daemon threads,"This matches the behavior of Schedulers.COMPUTATION_EXECUTOR and Schedulers.IO_EXECUTOR.

See https://groups.google.com/forum/#!topic/rxjava/Qe1qi0aHtnE and https://github.com/Netflix/RxJava/issues/431#issuecomment-30767610
",2013-12-17 17:31:46,2013-12-17 19:49:04,https://api.github.com/repos/ReactiveX/RxJava/issues/631,[],10,24,ReactiveX_RxJava_pull_631.diff
ReactiveX/RxJava,Properly wired up SynchronizedObserver within MergeDelayError operator,"Previous pull request for this issue (https://github.com/Netflix/RxJava/pull/615) missed the step of connecting SynchronizedObserver to ParentObserver
",2013-12-16 19:04:29,2013-12-16 20:28:06,https://api.github.com/repos/ReactiveX/RxJava/issues/628,[],1,1,ReactiveX_RxJava_pull_628.diff
ReactiveX/RxJava,"Added: BO.Latest, fixed: BO.next, BO.mostRecent, BO.toIterable","- Implemented Latest (Issue #59)
- Fixed Next and MostRecent to connect to the source observable only when the iterator is asked for.
- Fixed ToIterable.next() not properly handling the completed status (repeated calls to just the next() would simply block on the empty queue).
",2013-12-16 10:19:01,2013-12-23 21:15:51,https://api.github.com/repos/ReactiveX/RxJava/issues/626,[],422,23,ReactiveX_RxJava_pull_626.diff
ReactiveX/RxJava,"Operators: Observables from functionals (Action0, Func0, Runnable, Calla...","...ble)

I've created 4 operators that turn ordinary action/function calls into Observables, but unlike start and Async, the functions are called on each subscription instead of only once. They can be thought of a more generalized from(T value). Each method is named according to the accepted type to avoid overload issues with Java 8 & various dynamic languages.

The 4 additional overloads lets the user specify the scheduler where the function is called. By default, the functions are called on the threadPoolForComputation.

I don't know if there are Rx.NET equivalents of these (or they ever existed).
",2013-12-13 23:17:01,2013-12-27 18:58:37,https://api.github.com/repos/ReactiveX/RxJava/issues/622,[],482,1,ReactiveX_RxJava_pull_622.diff
ReactiveX/RxJava,SerialSubscription & From,"Update scala bindings for SerialSubscription since underlying type now implements isUnsubscribed.

Changed Observable.from to use currentThreadScheduler (principle of least surprise).
Used scheduler in create instead of observerOn.
Fixed blocking tests.
",2013-12-13 09:05:13,2013-12-23 21:03:32,https://api.github.com/repos/ReactiveX/RxJava/issues/621,[],94,72,ReactiveX_RxJava_pull_621.diff
ReactiveX/RxJava,Subscription overhaul2,"Renamed and changed things according to comments in #603
",2013-12-13 08:31:18,2013-12-23 20:39:13,https://api.github.com/repos/ReactiveX/RxJava/issues/620,[],1485,334,ReactiveX_RxJava_pull_620.diff
ReactiveX/RxJava,UnitTest to assert thread safety of Executor Scheduler,"- The Executor thread-pools hop threads when using observeOn so this tests that it is thread-safe when doing so.
- The test performs non-thread-safe mutations which should fail (or at least be non-deterministic) if memory visibility problems or concurrency is occurring.
",2013-12-13 07:41:28,2013-12-14 00:15:58,https://api.github.com/repos/ReactiveX/RxJava/issues/619,[],86,0,ReactiveX_RxJava_pull_619.diff
ReactiveX/RxJava,replay() and timer() javadocs: diagrams & wiki links,,2013-12-13 00:58:42,2013-12-13 00:59:23,https://api.github.com/repos/ReactiveX/RxJava/issues/617,[],180,120,ReactiveX_RxJava_pull_617.diff
ReactiveX/RxJava,Combine latest fix,"Fixes potential issues mentioned in #613

Question: it emits a ""row"" while holding a lock. This ensures a FIFO behavior towards the client observer. Do we want such strong guarantee?
",2013-12-12 23:05:11,2013-12-30 18:19:03,https://api.github.com/repos/ReactiveX/RxJava/issues/616,[],321,534,ReactiveX_RxJava_pull_616.diff
ReactiveX/RxJava,Copied the code from OperationMerge to fix synchronization,"for #614
",2013-12-12 21:44:47,2013-12-12 22:28:36,https://api.github.com/repos/ReactiveX/RxJava/issues/615,[],16,2,ReactiveX_RxJava_pull_615.diff
ReactiveX/RxJava,Replay additional overloads,"Issue #71
- Added several overloads of the `replay` operator: 
  - limited buffer, limited time window, buffer+time, 
  - scheduler overloads; 
  - versions which perform a projection before the replay
- Added missing `multicast` overload
",2013-12-12 20:08:15,2013-12-12 20:19:42,https://api.github.com/repos/ReactiveX/RxJava/issues/612,[],1591,0,ReactiveX_RxJava_pull_612.diff
ReactiveX/RxJava,Serial subscription fix,"Changed Scala bindings fro SerialSubscription to use underlying isUnsubscribed implementation
",2013-12-12 20:07:01,2013-12-12 20:11:35,https://api.github.com/repos/ReactiveX/RxJava/issues/611,[],154,59,ReactiveX_RxJava_pull_611.diff
ReactiveX/RxJava,Operation Timer 3.0,"Rebased.
",2013-12-12 07:48:38,2013-12-12 20:17:32,https://api.github.com/repos/ReactiveX/RxJava/issues/609,[],176,60,ReactiveX_RxJava_pull_609.diff
ReactiveX/RxJava,Javadoc improvements:,"- consistent nomenclature
- consistent/standard javadoc formatting
- more-precise descriptions
- timer() marble digram & wiki link
- delay() marble diagram & wiki link
",2013-12-11 22:38:37,2013-12-12 00:04:04,https://api.github.com/repos/ReactiveX/RxJava/issues/607,[],774,711,ReactiveX_RxJava_pull_607.diff
ReactiveX/RxJava,Operation Timer again,"Operation Timer readded.

Note that the master version has the timer operator with wrong return type compared to Rx.NET (Void vs Long). I've replaced the the methods and use places.
",2013-12-11 22:13:59,2013-12-12 00:06:59,https://api.github.com/repos/ReactiveX/RxJava/issues/606,[],190,72,ReactiveX_RxJava_pull_606.diff
ReactiveX/RxJava,Subjects reimplemented.,"Reimplemented all 4 kinds of subjects with the following properties:
- The `onNext`, `onError` and `onCompleted` are fully thread safe against subscription and unsubscription.
- A terminated subject won't accept any new events; `AsyncSubject`, `PublishSubject` and `BehaviorSubject` will re-emit just the very first exception when an observer subscribes to them.
- Emitting events to subscribed observers is done while holding the state lock. 
  - In Rx.NET when an event is received, the list of observers is retrieved while holding the lock, then outside the lock, the list is traversed and the events are propagated to the observers. Note however, if an observer unsubscribes right after the unlock and before the event propagation, it will still appear in the list and will receive the event. IMO, this is an undesired behavior.
  - The drawback of my solution is that it might be possible to deadlock the subjects, i.e., when an observer deliberately passes the source subject to another thread (which sends an event to the subject) and waits for its completion.
- Added the `Notification.acceptSafe` which will capture the exception of the `onNext` and propagate it through the `onError`. Its return value indicates if the observer can still be used after (i.e., no terminal event was delivered).
- Added the reusable state classes to `AbstractSubject`, although none of the subjects use this class any more.
- There is an `UnsubscribeTester` class, which seems to be out-of-place. Can this be moved into the test directory?
",2013-12-11 21:44:09,2013-12-23 20:58:17,https://api.github.com/repos/ReactiveX/RxJava/issues/605,[],639,214,ReactiveX_RxJava_pull_605.diff
ReactiveX/RxJava,Added op:join to concat objects with separator between elements.,"Straightforward. `""a"", 1, ""c""` with separator `"", ""` becomes `""a, 1, c""`
",2013-12-11 18:26:12,2013-12-12 00:05:19,https://api.github.com/repos/ReactiveX/RxJava/issues/604,[],142,2,ReactiveX_RxJava_pull_604.diff
ReactiveX/RxJava,Significant restructuring of subscriptions,"I've re-abstracted the subscriptions to be more uniform and maintenance friendly.
- Enhanced BooleanSubscription to support inheritance and single unsubscription action through `onUnsubscribe` (Issue #591).
- Added `BooleanSubscription.withAction` to allow wrapping a single-time unsubscription action.
- Created `AbstractAtomicSubscription` which manages the lock-free manipulations through callbacks.
- Rewritted `MultipleAssignmentSubscription` to have two extension points in its logic, which allows simpler subclass implementations of `SerialSubscription` and `SingleAssignmentSubscription`. `MultipleAssignmentSubscription` does not extend `AbstractAtomicSubscription` because it has a much simpler state-transition logic whereas the `AbstractAtomicSubscription` with its callbacks would be an overkill.
- Rewritten `CompositeSubscription` and `RefCountSubscription` to use `AbstractAtomicSubscription`.
- Modified `SafeObservableSubscription` to use `SingleAssignmentSubscription` instead of duplicating its behavior.
- Extended `Subscriptions` with an `unsubscribeAll` method to capture the exception collection behavior when unsubscribing from multiple subscriptions.
- Added `empty0()`, `empty1()` and `empty2()` convenience methods to Actions. Haven't checked if such no-op ActionX instances are created manually somewhere.
- BONUS: `ValuedCompositeSubscription<T>` class where a value can be associated with a `Subscription` key.
",2013-12-11 14:59:41,2013-12-13 08:31:35,https://api.github.com/repos/ReactiveX/RxJava/issues/603,[],1420,296,ReactiveX_RxJava_pull_603.diff
ReactiveX/RxJava,ObserveOn Fixes,"- refactor to remove imperative assignment of innerScheduler for clearer concurrency and data access
- fix subscription leak (Composite+MultipleAssignment instead of just Composite)
- remove confusing conditional logic for inner/outer scheduler
",2013-12-11 06:48:47,2013-12-13 07:32:32,https://api.github.com/repos/ReactiveX/RxJava/issues/602,[],174,66,ReactiveX_RxJava_pull_602.diff
ReactiveX/RxJava,BugFix: Replay Subject,,2013-12-11 01:51:01,2013-12-11 01:51:05,https://api.github.com/repos/ReactiveX/RxJava/issues/600,[],94,4,ReactiveX_RxJava_pull_600.diff
ReactiveX/RxJava,Refactor rx.concurrency to rx.schedulers,"To match the naming convention of rx.observables, rx.subjects and rx.subscriptions we have decided to rename rx.concurrency to rx.schedulers prior to the 1.0 release. These commits makes this change.

Since this is a non-trivial breaking change to anyone using Schedulers, this leaves the `rx.concurrency.*` classes in place and deprecates them to give time to migrate. These deprecated classes will be deleted prior to the 1.0 release.
",2013-12-10 23:57:39,2013-12-10 23:57:53,https://api.github.com/repos/ReactiveX/RxJava/issues/599,[],1606,895,ReactiveX_RxJava_pull_599.diff
ReactiveX/RxJava,New Scala Bindings,"(copied from release notes)
# RxScala Release Notes

This release of the RxScala bindings builds on the previous 0.15 release to make the Rx bindings for Scala
include all Rx types. In particular this release focuses on fleshing out the bindings for the `Subject` and `Scheduler`
types, as well as aligning the constructor functions for `Observable` with those in the RxJava.

Expect to see ongoing additions to make the Scala binding match the equivalent underlying Java API,
as well as minor changes in the existing API as we keep fine-tuning the experience on our way to a V1.0 release.
## Observer

In this release we have made the `asJavaObserver` property in `Observable[T]`as well the the factory method in the
companion object that takes an `rx.Observer` private to the Scala bindings package, thus properly hiding irrelevant
implementation details from the user-facing API. The `Observer[T]` trait now looks like a clean, native Scala type:

``` scala
trait Observer[-T] {
  def onNext(value: T): Unit
  def onError(error: Throwable): Unit
  def onCompleted(): Unit
}

object Observer {...}
```

To create an instance of a specific `Observer`, say  `Observer[SensorEvent]` in user code, you can create a new instance
of the `Observer` trait by implementing any of the methods that you care about:

``` scala
   val printObserver = new Observer[SensorEvent] {
      override def onNext(value: SensorEvent): Unit = {...value.toString...}
   }
```

 or you can use one of the overloads of the companion `Observer` object by passing in implementations of the `onNext`,
 `onError` or `onCompleted` methods.

Note that typically you do not need to create an `Observer` since all of the methods that accept an `Observer[T]`
(for instance `subscribe`) usually come with overloads that accept the individual methods
`onNext`, `onError`, and `onCompleted` and will automatically create an `Observer` for you under the covers.

While _technically_ it is a breaking change make the `asJavaObserver` property private, you should probably not have
touched `asJavaObserver` in the first place. If you really feel you need to access the underlying `rx.Observer`
call `toJava`.
## Observable

Just like for `Observer`, the `Observable` trait now also hides its `asJavaObservable` property and makes the constructor
function in the companion object that takes an `rx.Observable` private (but leaves the companion object itself public).
Again, while _technically_ this is a breaking change, this should not have any influence on user code.

``` scala
trait Observable[+T] {
    def subscribe(observer: Observer[T]): Subscription = {...}
    def apply(observer: Observer[T]): Subscription = {...}
    ...
}
object Observable {
   def create[T](func: Observer[T] => Subscription): Observable[T] = {...}
   ...
}
```

The major changes in `Observable` are wrt to the factory methods where too libral use of overloading of the `apply`
method hindered type inference and made Scala code look unnecessarily different than that in other language bindings.
All factory methods now have their own name corresponding to the Java and .NET operators
(plus overloads that take a `Scheduler`).
- `def from[T](future: Future[T]): Observable[T]`,
- `def from[T](iterable: Iterable[T]): Observable[T]`,
- `def error[T](exception: Throwable): Observable[T]`,
- `def empty[T]: Observable[T]`,
- `def items[T](items: T*): Observable[T],
- Extension method on `toObservable: Observable[T]` on `List[T]`.

In the _pre-release_ of this version, we expose both `apply` and `create` for the mother of all creation functions.
We would like to solicit feedback which of these two names is preferred
(or both, but there is a high probability that only one will be chosen).
- `def apply[T](subscribe: Observer[T]=>Subscription): Observable[T]`
- `def create[T](subscribe: Observer[T] => Subscription): Observable[T]`
## Subject

The `Subject` trait now also hides the underlying Java `asJavaSubject: rx.subjects.Subject[_ >: T, _<: T]`
and takes only a single _invariant_ type parameter `T`. all existing implementations of `Subject` are parametrized
by a single type, and this reflects that reality.

``` scala
trait Subject[T] extends Observable[T] with Observer[T] {}
object Subject {
   def apply(): Subject[T] = {...}
}
```

For each kind of subject, there is a class with a private constructor and a companion object that you should use
to create a new kind of subject. The subjects that are available are:
- `AsyncSubject[T]()`,
- `BehaviorSubject[T](value)`,
- `Subject[T]()`,
- `ReplaySubject[T]()`.

The latter is still missing various overloads http://msdn.microsoft.com/en-us/library/hh211810(v=vs.103).aspx which
you can expect to appear once they are added to the underlying RxJava implementation.

Compared with release 0.15.1, the breaking changes in `Subject` for this release are
making `asJavaSubject` private, and collapsing its type parameters, neither of these should cause trouble,
and renaming `PublishSubject` to `Subject`.
## Schedulers

The biggest breaking change compared to the 0.15.1 release is giving `Scheduler` the same structure as the other types.
The trait itself remains unchanged, except that we made the underlying Java representation hidden as above.
as part of this reshuffling, the scheduler package has been renamed from `rx.lang.scala.concurrency`
to `rx.lang.scala.schedulers`. There is a high probability that this package renaming will also happen in RxJava.

``` scala
trait Scheduler {...}
```

In the previous release, you created schedulers by selecting them from the `Schedulers` object,
as in `Schedulers.immediate` or `Schedulers.newThread` where each would return an instance of the `Scheduler` trait.
However, several of the scheduler implementations have additional methods, such as the `TestScheduler`,
which already deviated from the pattern.

In this release, we changed this to make scheduler more like `Subject` and provide a family of schedulers
that you create using their factory function:
- `CurrentThreadScheduler()`,
- `ExecutorScheduler(executor)`,
- `ImmediateScheduler()`,
- `NewThreadScheduler()`,
- `ScheduledExecutorServiceScheduler(scheduledExecutorService)`,
- `TestScheduler()`,
- `ThreadPoolForComputationScheduler()`,
- `ThreadPoolForIOScheduler()`.

In the future we expect that this list will grow further with new schedulers as they are imported from .NET
(http://msdn.microsoft.com/en-us/library/system.reactive.concurrency(v=vs.103).aspx).

To make your code compile in the new release you will have to change all occurrences of `Schedulers.xxx`
into `XxxScheduler()`, and import `rx.lang.scala.schedulers` instead of `rx.lang.scala.schedulers`.
## Subscriptions

The `Subscription` trait in Scala now has `isUnsubscribed` as a member, effectively collapsing the old `Subscription`
and `BooleanSubscription`, and the latter has been removed from the public surface. Pending a bug fix in RxJava,
`SerialSubscription` implements its own `isUnsubscribed`.

``` scala
trait Subscription {
  def unsubscribe(): Unit = { ... }
  def isUnsubscribed: Boolean = ...
}

object Subscription {...}
```

 To create a `Subscription` use one of the following factory methods:
- `Subscription{...}`, `Subscription()`,
- `CompositeSubscription(subscriptions)`,
- `MultipleAssignmentSubscription()`,
- `SerialSubscription()`.
  
  In case you do feel tempted to call `new Subscription{...}` directly make sure you wire up `isUnsubscribed`
  and `unsubscribe()` properly, but for all practical purposes you should just use one of the factory methods.
## Notifications

All underlying wrapped `Java` types in the `Notification` trait are made private like all previous types. The companion
objects of `Notification` now have both constructor (`apply`) and extractor (`unapply`) functions:

``` scala
object Notification {...}
trait Notification[+T] {
   override def equals(that: Any): Boolean = {...}
   override def hashCode(): Int = {...}
   def apply[R](onNext: T=>R, onError: Throwable=>R, onCompleted: ()=>R): R = {...}
}
```

The nested companion objects of `Notification` now have both constructor (`apply`) and extractor (`unapply`) functions:

``` scala
object Notification {
   object OnNext { def apply(...){}; def unapply(...){...} }
   object OnError { def apply(...){}; def unapply(...){...} }
   object OnCompleted { def apply(...){}; def unapply(...){...} }
}
```

To construct a `Notification`, you import `rx.lang.scala.Notification._` and use `OnNext(""hello"")`,
or `OnError(new Exception(""Oops!""))`, or `OnCompleted()`.

To pattern match on a notification you create a partial function like so: `case Notification.OnNext(v) => { ... v ... }`,
or you use the `apply` function to pass in functions for each possibility.

There are no breaking changes for notifications.
## Java Interop Helpers

Since the Scala traits _wrap_ the underlying Java types, yoo may occasionally will have to wrap an unwrap
between the two representations. The `JavaConversion` object provides helper functions of the form `toJavaXXX` and
`toScalaXXX` for this purpose, properly hiding how precisely the wrapped types are stored.
Note the (un)wrap conversions are defined as implicits in Scala, but in the unlikely event that you do need them
be kind to the reader of your code and call them explicitly.

``` scala
object JavaConversions {
  import language.implicitConversions

  implicit def toJavaNotification[T](s: Notification[T]): rx.Notification[_ <: T] = {...}
  implicit def toScalaNotification[T](s: rx.Notification[_ <: T]): Notification[T] = {...}
  implicit def toJavaSubscription(s: Subscription): rx.Subscription = {...}
  implicit def toScalaSubscription(s: rx.Subscription): Subscription = {...}
  implicit def scalaSchedulerToJavaScheduler(s: Scheduler): rx.Scheduler = {...}
  implicit def javaSchedulerToScalaScheduler(s: rx.Scheduler): Scheduler = {...}
  implicit def toJavaObserver[T](s: Observer[T]): rx.Observer[_ >: T] = {...}
  implicit def toScalaObserver[T](s: rx.Observer[_ >: T]): Observer[T] = {...}
  implicit def toJavaObservable[T](s: Observable[T]): rx.Observable[_ <: T] = {...}
  implicit def toScalaObservable[T](observable: rx.Observable[_ <: T]): Observable[T] = {...}
}
```
",2013-12-10 04:43:41,2013-12-10 04:51:00,https://api.github.com/repos/ReactiveX/RxJava/issues/598,[],1232,442,ReactiveX_RxJava_pull_598.diff
ReactiveX/RxJava,"Javadoc updates (longCount, sample(sampler))",,2013-12-09 21:05:41,2013-12-10 22:57:39,https://api.github.com/repos/ReactiveX/RxJava/issues/597,[],13,11,ReactiveX_RxJava_pull_597.diff
ReactiveX/RxJava,Fix for buffer not stopping when unsubscribed.,"Issue #559
",2013-12-09 18:25:14,2013-12-10 22:57:10,https://api.github.com/repos/ReactiveX/RxJava/issues/596,[],91,11,ReactiveX_RxJava_pull_596.diff
ReactiveX/RxJava,Implement the 'Start' operator,"Hi, this PR implemented the `Start` operator #81. Please take a look.
",2013-12-09 12:33:53,2013-12-11 06:08:04,https://api.github.com/repos/ReactiveX/RxJava/issues/594,[],165,1,ReactiveX_RxJava_pull_594.diff
ReactiveX/RxJava,Lock-free subscriptions,"- Uniform naming of inner components: Issue #592
- Lock-free approach to avoid deadlocks: Issue #577
- SerialSubscription.isUnsubscribe added: Issue #590

Remarks:
- IMO, an unsubscribed Single/Serial/Multiple subscription return Subscriptions.empty() instead of null. So unless the user put a null in there he/she shouldn't worry about null.
- There was a concurrency bug in @jloisel 's reimplementation of CompositeSubscription. It allowed multiple threads to enter the mutation part if the current state was already MUTATE. I've added the necessary checks to allow only NORMAL -> MUTATE transitions.
",2013-12-09 08:53:21,2013-12-10 23:03:28,https://api.github.com/repos/ReactiveX/RxJava/issues/593,[],369,120,ReactiveX_RxJava_pull_593.diff
ReactiveX/RxJava,Operation LongCount,"Issue #60

Straightforward version of the regular count(). 

(However, I would have implemented it differently so the constant boxing-unboxing could be avoided.)
",2013-12-08 15:29:58,2013-12-08 23:47:01,https://api.github.com/repos/ReactiveX/RxJava/issues/587,[],22,0,ReactiveX_RxJava_pull_587.diff
ReactiveX/RxJava,Fix Concat to allow multiple observers,"Issues #552 and #583
",2013-12-08 14:45:36,2013-12-08 23:48:23,https://api.github.com/repos/ReactiveX/RxJava/issues/586,[],66,8,ReactiveX_RxJava_pull_586.diff
ReactiveX/RxJava,Operation Timer,"Enhancement: #92

I've omitted the absolute time variants because of the earlier comments on Generate.

Related issue: #530 
",2013-12-08 14:10:35,2013-12-09 08:55:47,https://api.github.com/repos/ReactiveX/RxJava/issues/585,[],220,1,ReactiveX_RxJava_pull_585.diff
ReactiveX/RxJava,Fixes OnCompleted.unapply result type,"The Scala spec says that an extractor matches a pattern with zero
argument pattern if the result type of unapply is Boolean. The result
type of Option[T] means that the extractor has exactly one argument
pattern of type T.

The ""Option[Unit]"" result type does work, but it's probably a compiler
bug. Based on the result type, the pattern match ""case OnCompleted() =>""
should not compile and ""case OnCompleted(()) =>"" should be used instead.
Using the latter one crashes the compiler... Changing the result type of
unapply to Boolean does _not_ change any of this, so using the pattern
""case OnCompleted(()) =>"" still crashes the compiler, but at least the
pattern is not suggested by the unapply result type and the pattern
match results in one less object allocation.

The included test does _not_ check for this problem, it simply makes
sure that it still works correctly when using the correct pattern.
",2013-12-08 13:38:09,2013-12-23 20:56:54,https://api.github.com/repos/ReactiveX/RxJava/issues/584,[],21,3,ReactiveX_RxJava_pull_584.diff
ReactiveX/RxJava,Fix: Unsubscribe while not holding a lock.,"For Issue #577
",2013-12-08 12:50:07,2013-12-09 08:43:25,https://api.github.com/repos/ReactiveX/RxJava/issues/582,[],118,24,ReactiveX_RxJava_pull_582.diff
ReactiveX/RxJava,CRLF fixes,"Issue #579

In case the manual mode is chosen.
",2013-12-08 08:57:10,2013-12-08 23:58:58,https://api.github.com/repos/ReactiveX/RxJava/issues/580,[],4091,4091,ReactiveX_RxJava_pull_580.diff
ReactiveX/RxJava,A bug in apply(u:=>Unit) method of Subscription companion object fixed w...,"...hich may cause multiple invocations of u, in a multithreaded, multi-unsubscribe situation.

Threads may be pre-empted after evaluation of condition (!unsubscribed.get()) which may result in two or more threads executing the consequent block more than once. A code that relies on single evaluation of u will fail if that case happens.
",2013-12-07 16:23:22,2013-12-23 20:54:26,https://api.github.com/repos/ReactiveX/RxJava/issues/578,[],2,2,ReactiveX_RxJava_pull_578.diff
ReactiveX/RxJava,Timer and Delay,"As [pointed out](https://github.com/Netflix/RxJava/pull/384#issuecomment-26843865) by @headinthebox, it's possible to implement `delay` in terms of `timer`, `map` and `concat`. 

However, there were some tricky points:
-    In order to start the timers right after they're created (and not just when `concat` subscribes to them), I had to use `replay`.
-    There is bug https://github.com/Netflix/RxJava/issues/552 which also affects `delay`.

I hope that there aren't too many further tricky points that I missed, especially since https://github.com/Netflix/RxJava/issues/552 adds confusion. So this will need another review once https://github.com/Netflix/RxJava/issues/552 is fixed.

Thanks @jmhofer for your previous work on `delay`, I reused it where possible (see commit messages).
",2013-12-06 16:11:02,2013-12-10 22:59:02,https://api.github.com/repos/ReactiveX/RxJava/issues/576,[],355,0,ReactiveX_RxJava_pull_576.diff
ReactiveX/RxJava,Reimplement the 'SequenceEqual' operator,"Hi, this PR reimplemented the `SequenceEqual` operator #76 and should fix the issue #564.

The wiki page https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#sequenceequal still needs to be updated. @DavidMGross could you help update the marble diagram of `SequenceEqual`? Thanks!
",2013-12-06 15:08:09,2013-12-08 23:38:50,https://api.github.com/repos/ReactiveX/RxJava/issues/575,[],245,21,ReactiveX_RxJava_pull_575.diff
ReactiveX/RxJava,clarify documentation on cache(),"I lost some time because I didn't read the documentation of `cache()` carefully enough. To make it easier for others, I tried to make the documentation more explicit here.
",2013-12-06 13:50:15,2013-12-08 23:35:57,https://api.github.com/repos/ReactiveX/RxJava/issues/574,[],9,1,ReactiveX_RxJava_pull_574.diff
ReactiveX/RxJava,Removed Opening and Closing historical artifacts.,"Issue #540

The build fails due Scala compiler error I don't understand:

```
[ant:scalac] RxJava\language-adaptors\rxjava-scala\src\main\s
cala\rx\lang\scala\Observable.scala:531: error: type mismatch;
[ant:scalac]  found   : x2.type (with underlying type rx.Observable[_ <: T])
[ant:scalac]  required: T
[ant:scalac]       Observable[T](x2)
[ant:scalac]                     ^
[ant:scalac] one error found
```

``` scala
  def window[Closing](closings: () => Observable[Closing]): Observable[Observable[T]] = {
    val func : Func0[_ <: rx.Observable[_ <: Closing]] = closings().asJavaObservable
    val o1: rx.Observable[_ <: rx.Observable[_]] = asJavaObservable.window[Closing](func)
    val o2 = Observable[rx.Observable[_]](o1).map((x: rx.Observable[_]) => {
      val x2 = x.asInstanceOf[rx.Observable[_ <: T]]
      Observable[T](x2)
    })
    o2
  }
```

Could someone help me with this?
",2013-12-06 10:34:22,2013-12-08 23:35:03,https://api.github.com/repos/ReactiveX/RxJava/issues/573,[],106,269,ReactiveX_RxJava_pull_573.diff
ReactiveX/RxJava,ObserveOn fix for observing the same source on the same scheduler by two...,"... different observers.

Issue #551
- cleaned up
- added test cases
",2013-12-06 08:53:48,2013-12-08 23:33:31,https://api.github.com/repos/ReactiveX/RxJava/issues/572,[],119,52,ReactiveX_RxJava_pull_572.diff
ReactiveX/RxJava,Operation Sample with Observable v2,"Issue #74
- Sample will terminate if either the source or the sampler terminates or throws an error.
- The sampler now emits values only in its onNext() method. Therefore, if the sampler completes and there is a sampled value available (`valueTaken == false`), it won't emit the value before terminating.
",2013-12-06 08:31:38,2013-12-08 23:28:11,https://api.github.com/repos/ReactiveX/RxJava/issues/571,[],263,2,ReactiveX_RxJava_pull_571.diff
ReactiveX/RxJava,"javadoc improvements (groupJoin, groupByUntil, timestamp w/scheduler)","adding marble diagrams and links to the RxJava wiki, standardizing javadoc comment formatting
",2013-12-05 18:13:23,2013-12-06 00:53:08,https://api.github.com/repos/ReactiveX/RxJava/issues/569,[],41,20,ReactiveX_RxJava_pull_569.diff
ReactiveX/RxJava,Use lock free strategy for several Subscription implementations,"Reduce contention by using CAS (Compare And Swap) operations to replace
subscription in several subscription implementations.
",2013-12-05 14:42:04,2013-12-08 23:27:32,https://api.github.com/repos/ReactiveX/RxJava/issues/568,[],455,218,ReactiveX_RxJava_pull_568.diff
ReactiveX/RxJava,Operation Timestamp with Scheduler,"Issue #93
",2013-12-05 09:07:01,2013-12-05 11:35:34,https://api.github.com/repos/ReactiveX/RxJava/issues/567,[],111,0,ReactiveX_RxJava_pull_567.diff
ReactiveX/RxJava,Operation Sample with another Observable,"Issue #74

Added missing `Observable.sample(Observable<U> sampler)`.
",2013-12-05 08:42:23,2013-12-06 08:07:25,https://api.github.com/repos/ReactiveX/RxJava/issues/566,[],269,1,ReactiveX_RxJava_pull_566.diff
ReactiveX/RxJava,Operator GroupJoin v2,"Issue #53

Rebased.

Still: @headinthebox While writing the test for the operator, I've noticed that when both duration selectors are never(), Rx.NET never calls onCompleted on the group subjects, even though the left and right sources onComplete(). I haven't seen Rx.NET test for this scenario. This comes into play when I want to emulate join() with groupJoin(): the outer merge never onCompletes(). If I understand the behavior corretly, when both left and right sources get depleted, there is no way a new group or new group value would arrive, and all the open groups and the main observer can be onCompleted(). This is somewhat similar to join() and groupByUntil() behavior.
",2013-12-05 07:43:05,2013-12-05 11:33:21,https://api.github.com/repos/ReactiveX/RxJava/issues/565,[],800,0,ReactiveX_RxJava_pull_565.diff
ReactiveX/RxJava,Operation GroupByUntil,"Issue #52

Rebased.
",2013-12-04 22:46:19,2013-12-05 00:29:08,https://api.github.com/repos/ReactiveX/RxJava/issues/563,[],565,0,ReactiveX_RxJava_pull_563.diff
ReactiveX/RxJava,Scala Adaptor Improvements by Erik,"There are many important improvements by Erik on the branch https://github.com/Applied-Duality/RxJava/tree/RxJavaBugFixes , and I'd like to have them on Netflix:master, so that everyone works on the same code, and that we can avoid duplicate work, since some changes I'd like to do require changes that Erik has already made. @headinthebox hope you're ok with this.
",2013-12-04 18:56:10,2013-12-04 23:12:47,https://api.github.com/repos/ReactiveX/RxJava/issues/562,[],361,264,ReactiveX_RxJava_pull_562.diff
ReactiveX/RxJava,Creating Observables in Scala: Approach04,"This implements **approach04** from https://github.com/Netflix/RxJava/issues/549 .
I also moved the `toScalaXxx`/`toJavaXxx` methods into a separate file, so that one can import only these without importing the implicit function conversions. 
There's now also `Observable.from(Future)` and to test it, some tweaks in `Notification` were necessary.
Note that this is a breaking change.
",2013-12-04 16:48:23,2013-12-05 11:32:02,https://api.github.com/repos/ReactiveX/RxJava/issues/561,[],224,143,ReactiveX_RxJava_pull_561.diff
ReactiveX/RxJava,Add type variances for doOnEach actions.,"This fixes the use of contravariant actions (issue #532)
",2013-12-04 14:58:06,2013-12-04 21:09:52,https://api.github.com/repos/ReactiveX/RxJava/issues/560,[],3,3,ReactiveX_RxJava_pull_560.diff
ReactiveX/RxJava,ObserveOn: Moved queue into a per-observer instance.,"I don't fully understand why the original didn't work properly. My guess is either the shared queue between observers or a race condition on the recursiveScheduler field. My implementation seems to work correctly with the test case in #551

``` java
public class ObserveOnTest {
    static class PrintObserver<T> implements Observer<T> {
        private final String prefix;
        public PrintObserver(String prefix) {
            this.prefix = prefix;
        }
        void printPrefix() {
            System.out.print(prefix);
            System.out.print("": "");
        }
        @Override
        public void onNext(T args) {
            synchronized (PrintObserver.class) {
                printPrefix();
                System.out.println(args);
            }
        }

        @Override
        public void onError(Throwable e) {
            synchronized (PrintObserver.class) {
                printPrefix();
                System.out.println(e);
            }
        }

        @Override
        public void onCompleted() {
            synchronized (PrintObserver.class) {
                printPrefix();
                System.out.println(""done"");
            }
        }

    }
    public static void main(String[] args) throws Exception {
        Observable<Integer> o = Observable.from(1, 2, 3);
        Observable<Integer> o2 = o.observeOn(Schedulers.threadPoolForComputation());

        System.out.println(""Subscribe A"");
        o2.subscribe(new PrintObserver<>(""a""));
        System.out.println(""Subscribe B"");
        o2.subscribe(new PrintObserver<>(""b""));
        System.out.println(""Waiting"");
        Thread.sleep(1000);
        System.out.println(""Done"");
    }
}
```
",2013-12-04 10:54:18,2013-12-06 08:34:15,https://api.github.com/repos/ReactiveX/RxJava/issues/557,[],58,1,ReactiveX_RxJava_pull_557.diff
ReactiveX/RxJava,skipUntil() marble diagram and wiki link in javadoc,,2013-12-04 00:16:07,2013-12-04 00:26:49,https://api.github.com/repos/ReactiveX/RxJava/issues/555,[],3,0,ReactiveX_RxJava_pull_555.diff
ReactiveX/RxJava,Don't call plugin's handler if handler is given,"When an error handler is explicitly supplied, don't delegate to the
plugin's error handler.

This looks like a mistake, but I'm not certain.  I wasn't able to find documentation on the error handler plugin that describes when it's called.  My assumption here is that it's a default error handler, called when no onError() implementation is supplied.
",2013-12-03 17:31:43,2013-12-03 20:27:16,https://api.github.com/repos/ReactiveX/RxJava/issues/553,[],0,2,ReactiveX_RxJava_pull_553.diff
ReactiveX/RxJava,Changes to allow the initiating of work on an Observable to be done after the Subscription is available.,"See issue #547 for more details and discussion on this.
",2013-12-01 08:28:03,2013-12-27 21:41:25,https://api.github.com/repos/ReactiveX/RxJava/issues/548,[],707,530,ReactiveX_RxJava_pull_548.diff
ReactiveX/RxJava,Opening closing,"Issue #540

Removed Opening and Closing interfaces and updated method signatures accordingly.
Moved ObserverBase to rx.operators for now and added static methods to wrap or construct one. If usefull, it and other default implementations may be moved to a new public rx.observers package.
",2013-11-30 12:40:51,2013-12-06 08:56:06,https://api.github.com/repos/ReactiveX/RxJava/issues/546,[],327,201,ReactiveX_RxJava_pull_546.diff
ReactiveX/RxJava,Fixed Zip issue with infinite streams.,"Issue #539
",2013-11-30 11:46:38,2013-12-03 22:46:26,https://api.github.com/repos/ReactiveX/RxJava/issues/545,[],121,5,ReactiveX_RxJava_pull_545.diff
ReactiveX/RxJava,Support creating Observable from Android's Sensor.,"Very early PR to get some guidance over API, testing, style and error handling.
",2013-11-29 16:53:33,2013-12-27 21:42:11,https://api.github.com/repos/ReactiveX/RxJava/issues/543,[],37,0,ReactiveX_RxJava_pull_543.diff
ReactiveX/RxJava,Support creating Observable from Android's Sensor.,"Very early PR to get some guidance over API, style and error handling.
",2013-11-29 16:30:29,2013-11-29 16:49:19,https://api.github.com/repos/ReactiveX/RxJava/issues/542,[],0,0,ReactiveX_RxJava_pull_542.diff
ReactiveX/RxJava,Operation SkipUntil,"Issue #79
- Written from scratch
- Consulted Rx.NET sources to verify the behavior; there is one difference: I've implemented the OtherObserver such a way that if it is empty, it calls onCompleted() on the client observer and terminates the whole setup, in other words, the client observer won't be held up just to skip all elements of the source Observable (what if infinite stream is in play?!). 
",2013-11-29 08:57:26,2013-12-03 22:48:38,https://api.github.com/repos/ReactiveX/RxJava/issues/541,[],293,0,ReactiveX_RxJava_pull_541.diff
ReactiveX/RxJava,Zipping a finite and an infinite Observable,"Here are 4 tests testing that zipping a finite and an infinite Observable results in a finite Observable. The third of them fails...
",2013-11-28 10:14:13,2013-12-03 22:47:04,https://api.github.com/repos/ReactiveX/RxJava/issues/539,[],103,0,ReactiveX_RxJava_pull_539.diff
ReactiveX/RxJava,Operation GroupJoin,"Issue #53

Steps taken:
- Started out from scratch based on the join() operator's pattern
- Consulted with Rx.NET sources to match the data types of left&right maps; and behavior
- Added RefCountSubscription class and consulted Rx.NET on the unsubscription behavior
- Looked at WindowObservable and AddRef in the Rx.NET sources for their behavior.
- Took a test inspiration from http://rxwiki.wikidot.com/101samples#toc39

@headinthebox While writing the test for the operator, I've noticed that when both duration selectors are never(), Rx.NET never calls onCompleted on the group subjects, even though the left and right sources onComplete(). I haven't seen Rx.NET test for this scenario. This comes into play when I want to emulate join() with groupJoin(): the outer merge never onCompletes(). If I understand the behavior corretly, when both left and right sources get depleted, there is no way a new group or new group value would arrive, and all the open groups and the main observer can be onCompleted(). This is somewhat similar to join() and groupByUntil() behavior.
",2013-11-27 22:41:45,2013-12-05 07:33:39,https://api.github.com/repos/ReactiveX/RxJava/issues/538,[],801,1,ReactiveX_RxJava_pull_538.diff
ReactiveX/RxJava,Add scala adapters for doOnEach operator.,"This re-integrates support for doOnEach that was lost in the Scala refactor.
",2013-11-27 21:11:43,2013-12-04 21:06:45,https://api.github.com/repos/ReactiveX/RxJava/issues/537,[],59,0,ReactiveX_RxJava_pull_537.diff
ReactiveX/RxJava,Rebased version of jmhofer's delay() implementation,"This is in response to the request in #384, to rebase the delay() implementation on top of master.
",2013-11-27 18:12:23,2013-11-27 19:03:49,https://api.github.com/repos/ReactiveX/RxJava/issues/536,[],510,2,ReactiveX_RxJava_pull_536.diff
ReactiveX/RxJava,Fix compilation errors due to referencing the Android support library directly,"This is to prevent compilation failures in projects that do not link the support-v4 library. The only other option I saw to fix this would have been to split up the android module into one for native fragments and one for support fragments, which I found would come with unjustified overhead. Hence I settled for the cheap way, which is to sacrifice type safety here.

Refs https://github.com/soundcloud/RxJava/issues/2

/cc @gbenson-nflx 
",2013-11-27 12:06:28,2013-12-03 22:43:43,https://api.github.com/repos/ReactiveX/RxJava/issues/535,[],123,4,ReactiveX_RxJava_pull_535.diff
ReactiveX/RxJava,Async conversions,"Issue #95
- Moved to Async class and into the rx.util.functions
- Added variances to ""lambdas""
- Unfortunately, the code looks almost the same as Rx.Net.
",2013-11-27 08:14:45,2013-12-03 22:42:49,https://api.github.com/repos/ReactiveX/RxJava/issues/533,[],2061,0,ReactiveX_RxJava_pull_533.diff
ReactiveX/RxJava,"visually distinguish operators that use schedulers, etc.","visually distinguish operators that use schedulers; add distinct doOnEach diagrams
",2013-11-26 21:10:12,2013-12-03 22:41:43,https://api.github.com/repos/ReactiveX/RxJava/issues/531,[],25,19,ReactiveX_RxJava_pull_531.diff
ReactiveX/RxJava,Scala Tweaks,"Some cleanup from Erik, unit test fixes, adding license headers.
",2013-11-26 19:28:57,2013-11-26 19:29:07,https://api.github.com/repos/ReactiveX/RxJava/issues/529,[],335,13,ReactiveX_RxJava_pull_529.diff
ReactiveX/RxJava,Operation GroupByUntil,"Issue #52
- Added variance to ""lambda"" parameters
- Using PublishSubject as it now properly handles subscriptions after its terminal state

Can't do much about the scala tests failing.
",2013-11-26 19:11:00,2013-12-04 21:19:38,https://api.github.com/repos/ReactiveX/RxJava/issues/528,[],564,0,ReactiveX_RxJava_pull_528.diff
ReactiveX/RxJava,Docs,"Javadoc improvements, including diagrams & wiki links for new operators.
",2013-11-26 17:54:32,2013-11-26 19:30:06,https://api.github.com/repos/ReactiveX/RxJava/issues/527,[],944,151,ReactiveX_RxJava_pull_527.diff
ReactiveX/RxJava,Manual Merge of toMap/toMultiMap,"Manual merge of https://github.com/Netflix/RxJava/pull/513
",2013-11-26 06:04:38,2013-11-26 06:05:02,https://api.github.com/repos/ReactiveX/RxJava/issues/526,[],1095,0,ReactiveX_RxJava_pull_526.diff
ReactiveX/RxJava,BugFix: Handling of Terminal State for Behavior/Publish Subjects,"- They were not correctly emitting onCompleted when new Observers subscribed after the Subject was terminated.
- Added same logic that already existed on AsyncSubject
",2013-11-26 05:41:37,2013-11-26 05:41:42,https://api.github.com/repos/ReactiveX/RxJava/issues/525,[],357,320,ReactiveX_RxJava_pull_525.diff
ReactiveX/RxJava,Fixed the issue #521,"Hi, this PR fixed the issue #521. Please take a look. Thanks!
",2013-11-25 11:21:09,2013-11-26 00:27:26,https://api.github.com/repos/ReactiveX/RxJava/issues/522,[],5,6,ReactiveX_RxJava_pull_522.diff
ReactiveX/RxJava,Fixed the blocking/non-blocking first,"Hi, this PR fixed the last problem in #423.
- `Observable.first` in RxJava is same as `Observable.FirstAsync` in Rx.Net, which is a non-blocking operator. When the source sequence is empty, it will emit an `IllegalArgumentException`.
- `Observable.takeFirst` is an alias of `take(1)`. If the source sequence is empty, it will return an empty sequence.
- `BlockingObservable.first` in RxJava is same as `Observable.First` in Rx.Net, which is a blocking operator. When the source sequence is empty, it will emit an `IllegalArgumentException`.
- also added `BlockingObservable.firstOrDefault`.

Here I attached my test codes for Rx.Net.

``` c#
            Console.WriteLine(""===Test FirstAsync"");
            {
                IObservable<int> obs = Observable.Range(1, 4).FirstAsync();
                obs.Subscribe(
                    x => Console.WriteLine(""FirstAsync: "" + x),
                    e => Console.WriteLine(""FirstAsync: "" + e),
                    () => Console.WriteLine(""FirstAsync completed"")
                    );
            }
            {
                IObservable<int> obs = Observable.Empty<int>().FirstAsync();
                obs.Subscribe(
                    x => Console.WriteLine(""FirstAsync with empty: "" + x),
                    e => Console.WriteLine(""FirstAsync with empty: "" + e),
                    () => Console.WriteLine(""FirstAsync with empty completed"")
                    );
            }
            Console.WriteLine(""===Test Take(1)"");
            {
                IObservable<int> obs = Observable.Range(1, 4).Take(1);
                obs.Subscribe(
                    x => Console.WriteLine(""Take(1): "" + x),
                    e => Console.WriteLine(""Take(1): "" + e),
                    () => Console.WriteLine(""Take(1) completed"")
                    );
            }
            {
                IObservable<int> obs = Observable.Empty<int>().Take(1);
                obs.Subscribe(
                    x => Console.WriteLine(""Take(1) with empty: "" + x),
                    e => Console.WriteLine(""Take(1) with empty: "" + e),
                    () => Console.WriteLine(""Take(1) with empty completed"")
                    );
            }
            Console.WriteLine(""===Test First(1)"");
            {
                int value = Observable.Range(1, 4).First();
                Console.WriteLine(""First: "" + value);
            }
            {
                try
                {
                    int value = Observable.Empty<int>().First();
                }
                catch(Exception e) {
                    Console.WriteLine(""First with empty: "" + e);
                }
            }
```

The output is:

<pre>
===Test FirstAsync
FirstAsync: 1
FirstAsync completed
FirstAsync with empty: System.InvalidOperationException: Sequence contains no elements.
===Test Take(1)
Take(1): 1
Take(1) completed
Take(1) with empty completed
===Test First(1)
First: 1
First with empty: System.InvalidOperationException: Sequence contains no elements.
...
</pre>

",2013-11-25 03:28:23,2013-12-23 20:51:09,https://api.github.com/repos/ReactiveX/RxJava/issues/520,[],1101,291,ReactiveX_RxJava_pull_520.diff
ReactiveX/RxJava,Operator Generate again,"Issue #49
- Updated tests to use TestScheduler
- Removed class TimeSpan and the timeSelectors are expected to return a nanosecond-resolution value.
",2013-11-24 16:57:04,2013-11-26 06:25:55,https://api.github.com/repos/ReactiveX/RxJava/issues/519,[],751,0,ReactiveX_RxJava_pull_519.diff
ReactiveX/RxJava,Rx java repeat,"Implementation of repeat. 

There is an issue with toBlockingObservable when using currentThread(). 
",2013-11-23 21:26:21,2013-12-27 21:33:49,https://api.github.com/repos/ReactiveX/RxJava/issues/518,[],127,108,ReactiveX_RxJava_pull_518.diff
ReactiveX/RxJava,Adding utility functions for observables of strings useful for processing non blocking IO.,"I started developing this for use with the rxjava-apache-http contrib module to safely and scalable decode infinite observables of byte arrays into strings but thought it should live in core because it could be useful for non blocking disk IO.

I did not make this part of rx.Observable because these operators only work on observables of string. The drawback is that discoverability will be harder.
",2013-11-23 00:01:26,2013-12-03 22:25:50,https://api.github.com/repos/ReactiveX/RxJava/issues/516,[],569,1,ReactiveX_RxJava_pull_516.diff
ReactiveX/RxJava,Operation GroupByUntil again,"Issue #52
",2013-11-22 23:22:31,2013-11-26 07:12:07,https://api.github.com/repos/ReactiveX/RxJava/issues/515,[],590,0,ReactiveX_RxJava_pull_515.diff
ReactiveX/RxJava,Operation Join again,"Issue #56
",2013-11-22 22:44:11,2013-11-26 00:30:31,https://api.github.com/repos/ReactiveX/RxJava/issues/514,[],601,0,ReactiveX_RxJava_pull_514.diff
ReactiveX/RxJava,Operators toMap and toMultimap again,"Issue #96 and Issue #97

toMap: 3 overloads
toMultimap: 4 overloads
Added groovy test to verify overloading
",2013-11-22 22:31:31,2013-11-26 06:05:04,https://api.github.com/repos/ReactiveX/RxJava/issues/513,[],1094,0,ReactiveX_RxJava_pull_513.diff
ReactiveX/RxJava,Scala Adaptor Details,"With https://github.com/Netflix/RxJava/pull/503, some files were lost, so I added them again, and I also fixed many other details. There are no changes in functionality/inheritance, only ""cosmetics"". Except https://github.com/samuelgruetter/RxJava/commit/8567fcbaff20859c68ce4c30c7f347be34581fa4 : @headinthebox could you please confirm this one-line change?
",2013-11-22 21:55:15,2013-11-26 00:23:27,https://api.github.com/repos/ReactiveX/RxJava/issues/512,[],960,434,ReactiveX_RxJava_pull_512.diff
ReactiveX/RxJava,Operation GroupByUntil,"Issue #52

Note that Rx.NET's Subject<T> once onCompleted() or onError()'d, any subsequent subscriptions from observers will immediately receive onCompleted() or onError(). RxJava's PublishSubject however doesn't seem to do that, leaving future observers never do anything. Since the Rx.NET.GroupByUntil relied on the described behavior to handle escaped groups, the proposed implementation inside the GroupSubject will do this manually.
",2013-11-22 20:53:13,2013-11-22 21:34:08,https://api.github.com/repos/ReactiveX/RxJava/issues/511,[],590,0,ReactiveX_RxJava_pull_511.diff
ReactiveX/RxJava,BugFix: Zip,"This is a manual merge of https://github.com/Netflix/RxJava/pull/495 where I added some unit tests and suppressed warnings while reviewing the refactor done by @akarnokd

I believe this fixes issue https://github.com/Netflix/RxJava/issues/387
",2013-11-22 20:25:01,2013-11-22 20:25:23,https://api.github.com/repos/ReactiveX/RxJava/issues/510,[],411,131,ReactiveX_RxJava_pull_510.diff
ReactiveX/RxJava,Operator: Generate,"Operator Generate (6 variants) for Issue #49.
",2013-11-22 13:24:02,2013-11-26 06:26:35,https://api.github.com/repos/ReactiveX/RxJava/issues/509,[],841,1,ReactiveX_RxJava_pull_509.diff
ReactiveX/RxJava,Empty subscribe,,2013-11-21 22:21:15,2013-11-21 22:21:19,https://api.github.com/repos/ReactiveX/RxJava/issues/508,[],27,0,ReactiveX_RxJava_pull_508.diff
ReactiveX/RxJava,Operation join,"Issue #56
",2013-11-21 21:40:28,2013-11-22 21:30:56,https://api.github.com/repos/ReactiveX/RxJava/issues/507,[],601,1,ReactiveX_RxJava_pull_507.diff
ReactiveX/RxJava,"Operators: And, Then, When","Issue #23, Issue #88, Issue #100

Can be extended to Plan4..Plan9 and Pattern4..Pattern9 if Action4..Action9 is available. Not sure about the ActionN version.
",2013-11-21 14:24:48,2013-11-22 21:00:31,https://api.github.com/repos/ReactiveX/RxJava/issues/506,[],1714,1,ReactiveX_RxJava_pull_506.diff
ReactiveX/RxJava,ToAsync implemented: Issue #95,"Added 44 overloads of toAsync.
",2013-11-20 21:03:59,2013-11-27 10:28:49,https://api.github.com/repos/ReactiveX/RxJava/issues/505,[],2186,2,ReactiveX_RxJava_pull_505.diff
ReactiveX/RxJava,Operator: toMap (ToDictionary) and toMultimap (ToLookup),"Operators toMap and toMultimap.

I've tried my best to describe them in the Javadoc.
",2013-11-20 13:56:01,2013-11-22 21:01:40,https://api.github.com/repos/ReactiveX/RxJava/issues/504,[],1030,0,ReactiveX_RxJava_pull_504.diff
ReactiveX/RxJava,New Scala Bindings,"# Alternative Rx bindings for Scala

The previous RxScala binding attempt to optimize for seamless interop between Scala and Java.
The intended interop is illustrated by the following example where in Scala a class is defined that takes
an `Observable[Movie]` that is transformed using RxScala operators:

``` scala
class MovieLib(val moviesStream: Observable[Movie]) {
   val threshold = 1200
   def shortMovies: Observable[Movie] = ???
   def longMovies: Observable[Movie] = ???
}
```

which is then called in Java, passing a Java `Observable<Movie>` to the constructor

``` java
public void test() {
   MovieLib lib = new MovieLib(Observable.from(...));

   lib.longMovies().subscribe(moviePrinter);
}
```

The technique used to obtain this transparency is to use a value class with a private constructor that implements
the Rx operators in an idiomatic Scala way, and a companion object that is used to construct instances in Scala

``` scala
object Observable {
   def apply[T](asJava: rx.Observable[_ <: T]): Observable[T] = { new Observable[T](asJava) }
}

class Observable[+T] private[scala] (val asJava: rx.Observable[_ <: T])  extends AnyVal {
   // Idiomatic Scala friendly definitions of Rx operators
}
```

Since `rx.lang.scala.Observable[T] extends AnyVal`, the underlying representation of `rx.lang.scala.Observable[T]`
is the same as `rx.Observable<T>`. Because `rx.lang.scala.Observable[T]` is an opaque type in Scala,
the Scala programmer only sees the Scala-friendly operators.

However, in the current the illusion of interop is quickly lost when going beyond this simple example.
For example but type `Notification[T]` and `Scheduler[T]` are defined using wrappers,
and hence they are not compatible with `Notification<T>` respectively `Scheduler<T>`.
For instance, when materializing an `Observable[T]` in Scala to an `Observable[Notification[T]]`,
we lost the seamless interop with `Observable<Notification<T>>` on the Java side.

However, the real problems with seamless interop show up when we try to creating bindings for other Rx types.
In particular types that have inheritance or more structure.

For example, RxScala currently defines a type synonym `type Observer[-T] = rx.Observer[_ >: T]`,
but no further bindings for observers.
Similarly, for subjects RxScala defines `type Subject[-T, +R] = rx.subjects.Subject[_ >: T, _ <: R]`.
The problem with these definitions is that on the Java side, subjects are defined as:

``` scala
public abstract class Subject<T, R> extends Observable<R> implements Observer<T> { …}
```

without binding any of the Rx subjects.

The consequence is that `Subject[S,T]` in Scala is unrelated to `rx.lang.scala.Observable[T]` in Scala,
but shows up as a `rx.Observable[T]`. The problem however is that if we want to expose subjects in Scala
such that they derive from both `Observable[S]` and `Observer[T]` we cannot use the `extend AnyVal` trick
we used for `Observable[T]` and immediately lose transparent interop with Java.

The problem is even worse because `AsyncSubject<T>`, `BehaviorSubject<T>`, … all derive from `Subject<T,T>`,
so if we want them to derive from a common base `Subject[T,T]` type in Scala we lose transparency for those as well.
And again, if we expose the various subjects by extending `AnyVal`, they are useless in Scala because they do not inherit
from a common base type. To avoid implementing all methods of observable and observer on each specific subject
we might add implicit conversions to `Observable[T]` and `Observer[T]` but that still does not give Scala users
a native `Subject[S,T]` type.

``` scala
object AsyncSubject {
    def apply[T](): AsyncSubject[T] =
      new AsyncSubject[T](rx.subjects.AsyncSubject.create())
}

class AsyncSubject[T] private [scala] (val inner: rx.subjects.AsyncSubject[T])
    extends AnyVal
{ … }

implicit final def asObservable[T](subject: AsyncSubject[T]): Observable[T] =
  Observable(subject.inner)

implicit final def asObserver[T](subject: AsyncSubject[T]): Observer[T] =
  subject.inner
```

The inheritance problem is not just limited to subjects, but also surfaces for subscriptions.
Rx scala currently defines `type Subscription = rx.Subscription` using a type synonym as well,
and we run into exactly the same problems as with subjects when we try to bind the
various Rx subscriptions `BooleanSubscription`, `SerialSubscription`,  etc.

Since we cannot wrap Rx types in Scala such that they are both (a) transparently interoperable with Java,
and (b) feel native and idiomatic to Scala, we should decide in favor of optimizing RxScala for Scala
and consumption of Rx values from Java but not for Scala as a producer.

The new bindings feel like a completely native Scala library, without needing any complications of the Scala side.

``` scala
object Observer { …}
trait Observable[+T] {
   def asJavaObservable: rx.Observable[_ <: T]
}

object Observer {…}
trait Observer[-T] {
  def asJavaObserver: rx.Observer[_ >: T]
}

object Subject {…}
trait Subject[-T, +R] extends Observable[R] with Observer[T] {
  val asJavaSubject: rx.subjects.Subject[_ >: T, _<: R]
}

object Scheduler {…}
trait Scheduler {
   def asJavaScheduler: rx.Scheduler;
}

object Notification {…}
trait Notification[+T] {
  def asJavaNotification: rx.Notification[_ <: T]
}

object Subscription {…}
trait Subscription {
   def asJavaSubscription: rx.Subscription
}
```

You pay the price when crossing the Scala/Java interop boundary, which is where it should be.
The proper way is to put the burden of interop on the Scala side, in case you want to create
a reusable Rx-based library in Scala, or wrap and unwrap on the Java side.

``` java
public static void main(String[] args) {

   Observable<Movie> movies = Observable.from(new Movie(3000), new Movie(1000), new Movie(2000));
   MovieLib lib = new MovieLib(toScalaObservable(movies));
   lib.longMovies().asJavaObservable().subscribe(m ->
      System.out.println(""A movie of length "" + m.lengthInSeconds() + ""s"")
   );
}
```
## Delegation versus Inheritance

The obvious thought is that using delegation instead of inheritance (http://c2.com/cgi/wiki?DelegationIsInheritance)
will lead to excessive wrapping, since all Scala types wrap and delegate to an underlying RxJava implementation.
Note however, that the wrapping happens at query generation time and incurs no overhead when messages are flowing
through the pipeline. Say we have a query `xs.map(f).filter(p).subscribe(o)`. Even though the Scala types are wrappers,
the callback that is registered with xs is something like `x => { val y = f(x); if(p(y)){ o.asJavaObserver.onNext(y) }}`
and hence there is no additional runtime penalty.
",2013-11-20 01:19:27,2013-11-20 01:19:48,https://api.github.com/repos/ReactiveX/RxJava/issues/503,[],1606,1620,ReactiveX_RxJava_pull_503.diff
ReactiveX/RxJava,Fix ObserveOn and add ParallelMerge Scheduler overload,"- ObserveOn was not correctly recursing when the source was async. It would create a new scheduler (i.e. a new thread) each time.
- Also added unit tests to ParallelMerge
",2013-11-20 00:31:12,2013-11-20 00:31:38,https://api.github.com/repos/ReactiveX/RxJava/issues/502,[],139,11,ReactiveX_RxJava_pull_502.diff
ReactiveX/RxJava,ParallelMerge Operator,,2013-11-19 22:07:27,2013-11-19 22:07:30,https://api.github.com/repos/ReactiveX/RxJava/issues/501,[],118,0,ReactiveX_RxJava_pull_501.diff
ReactiveX/RxJava,"concat with iterable overload, merge with iterable overload",,2013-11-19 20:52:30,2013-11-20 07:26:46,https://api.github.com/repos/ReactiveX/RxJava/issues/500,[],35,0,ReactiveX_RxJava_pull_500.diff
ReactiveX/RxJava,ObserveOn Refactor,"Refactor and small fixes of ObserveOn with @headinthebox 
",2013-11-19 20:24:51,2013-11-19 20:24:55,https://api.github.com/repos/ReactiveX/RxJava/issues/499,[],130,148,ReactiveX_RxJava_pull_499.diff
ReactiveX/RxJava,Implement the 'Repeat' operator,"Hi, this PR implemented the `Repeat` operator #70. Please take a look. Thanks!
",2013-11-19 16:58:56,2013-12-27 21:34:07,https://api.github.com/repos/ReactiveX/RxJava/issues/498,[],379,0,ReactiveX_RxJava_pull_498.diff
ReactiveX/RxJava,Zip rewritten from scratch,"(I hope I managed a clean branch this time...)
",2013-11-19 09:02:25,2013-11-22 20:25:24,https://api.github.com/repos/ReactiveX/RxJava/issues/497,[],295,131,ReactiveX_RxJava_pull_497.diff
ReactiveX/RxJava,Add contravariant for min and max,"Hi, this PR added  contravariant for min and max mentioned in #494.
",2013-11-19 04:09:09,2013-11-19 04:37:45,https://api.github.com/repos/ReactiveX/RxJava/issues/496,[],20,20,ReactiveX_RxJava_pull_496.diff
ReactiveX/RxJava,"Zip many rewritten, Concat with iterable, Merge with Iterable.","I've rewritten the Zip method to terminate as soon as possible. In addition, the concat(Iterable<Observable<T>> and merge(Iterable<Observable<T>>) where missing from Observable.
",2013-11-18 22:36:15,2013-11-19 17:23:25,https://api.github.com/repos/ReactiveX/RxJava/issues/495,[],433,145,ReactiveX_RxJava_pull_495.diff
ReactiveX/RxJava,"Zip many from scratch, missing concat of iterable.",,2013-11-18 18:29:58,2013-11-18 20:16:54,https://api.github.com/repos/ReactiveX/RxJava/issues/493,[],461,196,ReactiveX_RxJava_pull_493.diff
ReactiveX/RxJava,"Implement the scheduler overloads for Range, From, StartWith","Hi, this PR implemented the scheduler overloads for Range #68, From #98 , StartWith #82. Please take a look. Thanks!
",2013-11-18 11:39:30,2013-11-19 17:22:22,https://api.github.com/repos/ReactiveX/RxJava/issues/492,[],124,0,ReactiveX_RxJava_pull_492.diff
ReactiveX/RxJava,Baseline checkin for Android sample app,"Began work on a sample Android app to help myself understand Rx as applied to a Java client.  Thought it would be useful for others to see, comment on, improve, and add to.

Have discussed with @mttkay, he has offered to review and possibly contribute as well.

-Greg
",2013-11-18 07:20:47,2013-11-22 20:28:26,https://api.github.com/repos/ReactiveX/RxJava/issues/491,[],700,0,ReactiveX_RxJava_pull_491.diff
ReactiveX/RxJava,"Scala Adaptor: Inheritance, subscriptions and subjects","I tried to add subscriptions and subjects using the value class trick, and came to the conclusion that it won't work. The problem is that inheritance and value classes don't work together, because value classes cannot be extended. We want Observable to be a value class, and at the same time, we want Subject to extend Observable, so that doesn't work.

This PR is very similar to [Erik's code](https://github.com/headinthebox/ScalaBindingsRecent), but I added a trait

``` scala
trait JavaWrapper[+W] {
  def asJava: W
}
```

which all classes extend. This allows us to have an `asJava` method everywhere (instead of `asJavaSubject` / `asJavaObserver` etc). The main challenge was to get the double inheritance Subject extends Observer and Observable working.
Now all wrappers are done the same way. For instance, Observable looks as follows:

``` scala
trait Observable[+T] extends JavaWrapper[rx.Observable[_ <: T]] { 
  ... 
}

object Observable {
  private[Observable] class ObservableWrapper[+T](val asJava: rx.Observable[_ <: T]) extends Observable[T] {}

  def apply[T](asJava: rx.Observable[_ <: T]): Observable[T] = {
    new ObservableWrapper[T](asJava)
  }

  ...
}
```

In Scala code, to convert from Scala types to Java types, there's the `asJava` method, and to convert from Java types to Scala types, there's an `apply` method in each companion object.

When we used value classes, such conversions were not necessary in Java, because Scala types appeared as Java types for the Java compiler. Now, they become necessary, but note that this PR does not yet contain such conversions, but that should be no big problem.
",2013-11-17 15:10:13,2013-11-19 05:47:01,https://api.github.com/repos/ReactiveX/RxJava/issues/490,[],407,169,ReactiveX_RxJava_pull_490.diff
ReactiveX/RxJava,Javadoc improvements,"Adding marble diagrams, making the javadocs more consistent in their terminology & formatting.
",2013-11-16 03:50:56,2013-11-20 16:49:06,https://api.github.com/repos/ReactiveX/RxJava/issues/487,[],4146,2582,ReactiveX_RxJava_pull_487.diff
ReactiveX/RxJava,BugFix: AsyncSubject,"- it was not emitting values to observers that subscribed after onCompleted/onError
",2013-11-16 02:55:30,2013-11-16 02:55:45,https://api.github.com/repos/ReactiveX/RxJava/issues/486,[],239,32,ReactiveX_RxJava_pull_486.diff
ReactiveX/RxJava,Added  aliases and objects for concrete subject types in Scala.,"-AsyncSubject[T]
-BehaviorSubject[T]
-PublishSubject[T]
-ReplaySubject[T]
",2013-11-15 22:38:07,2013-11-16 05:50:18,https://api.github.com/repos/ReactiveX/RxJava/issues/485,[],71,12,ReactiveX_RxJava_pull_485.diff
ReactiveX/RxJava,DoOn Tweaks,"- do not have 2 method overloads with similar method signatures, dynamic languages can not negotiate method dispatch using function arity
- add doOnCompleted and doOnError methods instead of different doOnEach overloads

This is a very slight breaking change by deleting a method added in the last release. I did not catch this when I did the code review.
",2013-11-13 23:35:34,2013-11-13 23:36:08,https://api.github.com/repos/ReactiveX/RxJava/issues/483,[],115,10,ReactiveX_RxJava_pull_483.diff
ReactiveX/RxJava,Implement the 'Using' operator,"Hi, this PR implemented the `Using` operator #99. Please take a look. Thanks! 
",2013-11-11 11:16:35,2013-11-12 23:16:12,https://api.github.com/repos/ReactiveX/RxJava/issues/481,[],294,0,ReactiveX_RxJava_pull_481.diff
ReactiveX/RxJava,BugFix: Emit an IllegalArgumentException instead of ArithmeticException if the observable is empty,"This PR fixed the `average` issue in #423. If an observable is empty, `average` will emit an `IllegalArgumentException` instead of `ArithmeticException`. Thanks!
",2013-11-08 05:47:20,2013-11-12 23:09:57,https://api.github.com/repos/ReactiveX/RxJava/issues/480,[],17,9,ReactiveX_RxJava_pull_480.diff
ReactiveX/RxJava,Adds doOnEach operator,"I thought this would be a good and simple way to start getting my feet wet with RxJava.  This implements #40.

Any feedback would be great.

Thanks,
Scott
",2013-11-08 03:26:26,2013-11-12 23:09:04,https://api.github.com/repos/ReactiveX/RxJava/issues/479,[],366,0,ReactiveX_RxJava_pull_479.diff
ReactiveX/RxJava,"Implemented the ""Operator: Min and MinBy"" and ""Operator: Max and MaxBy""","Hi, this PR implemented the `Operator: Min and MinBy` #63 and `Operator: Max and MaxBy` #61. Every operator has 2 variants, one for `Comparable`, another for `Comparator`. Please take a look. Thanks!
",2013-11-08 03:26:22,2013-11-12 23:05:37,https://api.github.com/repos/ReactiveX/RxJava/issues/478,[],628,0,ReactiveX_RxJava_pull_478.diff
ReactiveX/RxJava,CompositeSubscription bugfixes,"- remove now also unsubscribes the removed subscription
- added clear method
",2013-11-07 23:59:45,2013-11-07 23:59:50,https://api.github.com/repos/ReactiveX/RxJava/issues/477,[],94,4,ReactiveX_RxJava_pull_477.diff
ReactiveX/RxJava,Don't emit null onComplete when no onNext received in AsyncSubject,"Reported via email by @axel22 and @headinthebox 
",2013-11-07 23:45:13,2013-11-07 23:45:22,https://api.github.com/repos/ReactiveX/RxJava/issues/476,[],32,24,ReactiveX_RxJava_pull_476.diff
ReactiveX/RxJava,Additional unit test for reduce,,2013-11-07 23:32:01,2013-11-07 23:32:05,https://api.github.com/repos/ReactiveX/RxJava/issues/475,[],20,0,ReactiveX_RxJava_pull_475.diff
ReactiveX/RxJava,BugFix: Reduce an empty observable,"This fixes issue https://github.com/Netflix/RxJava/issues/423

The fix is based on this comment by @headinthebox: https://github.com/Netflix/RxJava/issues/423#issuecomment-27642532

Thank you @zsxwing  for your involvement on this.

If I have mis-interpreted the results of the discussion and this is still wrong ... please correct me.

Here is the unit test asserting the behavior:

``` java
    /**
     * A reduce should fail with an IllegalArgumentException if done on an empty Observable.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testReduceWithEmptyObservable() {
        Observable<Integer> observable = Observable.range(1, 0);
        observable.reduce(new Func2<Integer, Integer, Integer>() {

            @Override
            public Integer call(Integer t1, Integer t2) {
                return t1 + t2;
            }

        }).toBlockingObservable().forEach(new Action1<Integer>() {

            @Override
            public void call(Integer t1) {
                // do nothing ... we expect an exception instead
            }
        });

        fail(""Expected an exception to be thrown"");
    }
```
",2013-11-07 23:27:08,2013-11-07 23:27:15,https://api.github.com/repos/ReactiveX/RxJava/issues/474,[],34,1,ReactiveX_RxJava_pull_474.diff
ReactiveX/RxJava,Fix non-deterministic unit test,"- the latch was before onError is called
- use BlockingObservable and expect the IllegalArgumentException to be thrown
",2013-11-07 23:14:15,2013-11-07 23:14:19,https://api.github.com/repos/ReactiveX/RxJava/issues/473,[],4,12,ReactiveX_RxJava_pull_473.diff
ReactiveX/RxJava,BugFix: Issue 431 Unsubscribe with Schedulers.newThread,"Fix bug => Unsubscribing does not work when using subscribeOn(Schedulers.newThread())

I believe this fixes https://github.com/Netflix/RxJava/issues/431

The NewThreadScheduler was not using DiscardableAction that supports being unsubscribed.
",2013-11-07 04:49:28,2013-11-07 04:49:36,https://api.github.com/repos/ReactiveX/RxJava/issues/472,[],106,11,ReactiveX_RxJava_pull_472.diff
ReactiveX/RxJava,Unit Test Tweaks,,2013-11-07 04:12:42,2013-11-07 04:12:45,https://api.github.com/repos/ReactiveX/RxJava/issues/471,[],55,3,ReactiveX_RxJava_pull_471.diff
ReactiveX/RxJava,Operator: Last,"Adds `Observable.last` and fixes behavior of `BlockingObservable.last` based on email discussion with @headinthebox 
",2013-11-07 03:27:11,2013-11-07 03:27:28,https://api.github.com/repos/ReactiveX/RxJava/issues/470,[],146,9,ReactiveX_RxJava_pull_470.diff
ReactiveX/RxJava,Merge Amb Operator in PR https://github.com/Netflix/RxJava/pull/460,"Split unit tests out while merging.
",2013-11-05 04:17:28,2013-11-05 04:17:32,https://api.github.com/repos/ReactiveX/RxJava/issues/467,[],539,0,ReactiveX_RxJava_pull_467.diff
ReactiveX/RxJava,Refactor Unit Tests from Inner Classes to /src/test,"Manual merge of and additions to pull request https://github.com/Netflix/RxJava/pull/465 to refactor unit tests from inner classes to separate /src/test/ folder to accomplish issue https://github.com/Netflix/RxJava/issues/439  ""minimize library size"".

Great work by @pasviegas on this pull request!
",2013-11-05 04:10:32,2013-11-05 04:10:49,https://api.github.com/repos/ReactiveX/RxJava/issues/466,[],13855,11902,ReactiveX_RxJava_pull_466.diff
ReactiveX/RxJava,Moving unit tests to test source folders #439,,2013-11-04 06:47:50,2013-11-05 04:10:49,https://api.github.com/repos/ReactiveX/RxJava/issues/465,[],12322,12076,ReactiveX_RxJava_pull_465.diff
ReactiveX/RxJava,Added the rest overloads of Timeout operator,"Hi, this PR implemented the rest overloads of `Timeout` operator #91. Please take a look. Thanks.
",2013-11-03 10:13:04,2013-11-12 23:00:18,https://api.github.com/repos/ReactiveX/RxJava/issues/463,[],212,18,ReactiveX_RxJava_pull_463.diff
ReactiveX/RxJava,Added 'sleep' to avoid 'testMapWithErrorInFuncAndThreadPoolScheduler' fails,"Hi, due to my mistake, `testMapWithErrorInFuncAndThreadPoolScheduler` may fail in some situation. Sorry for that. I fixed it in this PR.
",2013-11-01 14:54:34,2013-11-08 03:17:45,https://api.github.com/repos/ReactiveX/RxJava/issues/461,[],44,9,ReactiveX_RxJava_pull_461.diff
ReactiveX/RxJava,Implemented the 'Amb' operator,"Hi, this PR implemented the `Amb` operator #22. I used varargs to support the array version and first-second version in one method. So in my PR, there are only two variants.
",2013-11-01 13:06:12,2013-11-05 04:17:33,https://api.github.com/repos/ReactiveX/RxJava/issues/460,[],514,0,ReactiveX_RxJava_pull_460.diff
ReactiveX/RxJava,Fixed issue #454,"Hi, I used SafeObservableSubscription to fix the issue #454.
",2013-10-29 13:24:06,2013-10-31 19:14:33,https://api.github.com/repos/ReactiveX/RxJava/issues/459,[],20,2,ReactiveX_RxJava_pull_459.diff
ReactiveX/RxJava,[rxjava-android] OperationObserveFromAndroidComponent,"This is in reference to https://github.com/soundcloud/RxJava/issues/1

Android applications can use this operator to safely observe a source sequence on the main user interface thread. As long as the subscription is unsubscribed from in `onDestroy` or `onDetach`, no resource leaks will occur.

I have also added an `AndroidObservable` class which acts as an entry point for instantiating Android specific observer instances.
",2013-10-29 10:39:39,2013-10-31 19:16:04,https://api.github.com/repos/ReactiveX/RxJava/issues/458,[],327,1,ReactiveX_RxJava_pull_458.diff
ReactiveX/RxJava,Adding utility functions for observables of strings useful for processing non blocking IO.,"I started developing this for use with the rxjava-apache-http contrib module to safely and scalable decode infinite observables of byte arrays into strings but thought it should live in core because it could be useful for non blocking disk IO.

I did not make this part of rx.Observable because these operators only work on observables of string.  The drawback is that discoverability will be harder.
",2013-10-29 08:26:47,2013-11-22 23:51:07,https://api.github.com/repos/ReactiveX/RxJava/issues/457,[],4680,1926,ReactiveX_RxJava_pull_457.diff
ReactiveX/RxJava,Scala Adaptor: TODO list and documentation,"More complete TODO list for Scala Adaptor and some documentation for [CompletenessTest](https://github.com/samuelgruetter/RxJava/blob/scalaadaptor/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala).
",2013-10-27 20:21:06,2013-10-31 19:16:26,https://api.github.com/repos/ReactiveX/RxJava/issues/455,[],76,31,ReactiveX_RxJava_pull_455.diff
ReactiveX/RxJava,Fixed issue #417,"``` java
public static void main(String[] args) {
    System.out.println(""started"");
    System.out.println(Observable.from(1).observeOn(Schedulers.threadPoolForComputation())
        .map(f).toBlockingObservable().single());
    System.out.println(""done"");
}
```

This issue in #417 is because current `map` implementation violates the design guild:

> 6.4. Protect calls to user code from within an operator

Now current `map` does not handle the error from the `func` param which may be user codes. When the thread pool scheduler is involved, the error from `func` will throw to the outside and be handled by `java.util.concurrent.FutureTask`. The error will be dropped so the observer will not see it.

This PR used `SafeObserver` to protect `map` from user codes.
",2013-10-25 11:32:25,2013-10-31 19:17:48,https://api.github.com/repos/ReactiveX/RxJava/issues/453,[],48,12,ReactiveX_RxJava_pull_453.diff
ReactiveX/RxJava,Implemented the scheduler version of the 'Return' operator,"Hi, this is the scheduler version of the 'Return' operator #73.
",2013-10-25 06:00:51,2013-10-31 20:26:19,https://api.github.com/repos/ReactiveX/RxJava/issues/452,[],17,0,ReactiveX_RxJava_pull_452.diff
ReactiveX/RxJava,Implemented the 'TimeInterval' operator,"Hi, this PR implemented the `TimeInterval` operator #90. Please take a look. Thanks.
",2013-10-24 06:24:02,2013-10-31 19:19:24,https://api.github.com/repos/ReactiveX/RxJava/issues/450,[],247,0,ReactiveX_RxJava_pull_450.diff
ReactiveX/RxJava,Removing println from OperationMerge,,2013-10-23 23:35:57,2013-10-23 23:36:09,https://api.github.com/repos/ReactiveX/RxJava/issues/449,[],0,1,ReactiveX_RxJava_pull_449.diff
ReactiveX/RxJava,Caching the result of 'isInternalImplementation',"Currently, reflective getPackage() call happens on every subscribe() invocation.  This PR sets up a Concurrent HashMap to cache the result of this call per-class.
",2013-10-22 19:52:20,2013-10-22 19:52:54,https://api.github.com/repos/ReactiveX/RxJava/issues/447,[],17,4,ReactiveX_RxJava_pull_447.diff
ReactiveX/RxJava,Implemented the 'Timeout' operator,"Hi, I used `SynchronizedObserver` to implement the `Timeout` operator #91. It may be simpler than #434. Considering DateTimeOffset and TimeSpan in C# have the same meaning, RxJava only needs 4 overrides. I have already implemented all of them.

Please take a look. Thanks.
",2013-10-22 07:26:46,2013-10-31 20:26:30,https://api.github.com/repos/ReactiveX/RxJava/issues/446,[],384,0,ReactiveX_RxJava_pull_446.diff
ReactiveX/RxJava,OperationSwitch notify onComplete() too early.,"OperationSwitch has to wait that both parent and child complete before complete itself.
",2013-10-21 19:22:18,2013-10-22 19:36:17,https://api.github.com/repos/ReactiveX/RxJava/issues/443,[],175,44,ReactiveX_RxJava_pull_443.diff
ReactiveX/RxJava,Fixed the issue that 'take' does not call 'onError',"I fixed one of the issues in #417: `System.out.println(Observable.from(1, 2, 3).take(1).map(f).toBlockingObservable().single());` is never terminated.

This issues is because `take` does not handle the exception throwing from `onNext` correctly.
",2013-10-19 17:44:21,2013-10-22 19:35:14,https://api.github.com/repos/ReactiveX/RxJava/issues/441,[],72,4,ReactiveX_RxJava_pull_441.diff
ReactiveX/RxJava,libGDX support,"This is the start of a new contrib project that lays the foundation for RxJava support for **[libGDX](http://libgdx.badlogicgames.com/)**.

This is still missing tests because it's very difficult to unit test this properly due to the nature of libGDX. However, I'll be using this a lot in my own Android projects.

I'm not sure whether this should be a contrib subproject of RxJava or maybe a separate repo. If you think this should be separate, just decline the PR.
",2013-10-19 09:52:36,2013-10-31 20:27:09,https://api.github.com/repos/ReactiveX/RxJava/issues/440,[],1028,1,ReactiveX_RxJava_pull_440.diff
ReactiveX/RxJava,Kotlin Language Adaptor,"Kotlin could be used with RxJava without language adaptors.

This language adaptor just provide a set of extension functions to enable a more idiomatic usage.  

There are two test classes:
- BasicKotlinTest is just plain Kotlin
- ExtensionTest is Kotlin with the extensions provided by this adaptor  
",2013-10-16 09:26:29,2013-10-17 02:20:27,https://api.github.com/repos/ReactiveX/RxJava/issues/438,[],837,0,ReactiveX_RxJava_pull_438.diff
ReactiveX/RxJava,Fixes: Scheduler and Merge,"1) Scheduler overload with recursive support

Fixed while working with @headinthebox 

2) unsubscribe was not propagating to parent Observable on merge(Observable<Observable<T>>)

Found and fixed while working with infinite streams. Merge was correctly unsubscribing from all children which means it was always working when doing something like `merge(a, b)`, but it wasn't correctly unsubscribing if given a single `Observable<Observable<T>>`
",2013-10-16 06:23:10,2013-10-16 06:23:16,https://api.github.com/repos/ReactiveX/RxJava/issues/437,[],158,26,ReactiveX_RxJava_pull_437.diff
ReactiveX/RxJava,Reimplemented the 'reduce' operator,"Hi,

I reimplemented the 'reduce' operator. The improvements are as follow:
- As I mentioned in #423, 'reduce' should throw an exception when applying on an empty sequence without an initial value.
- Now 'reduce' does not need a 'takeLast' operator, and should be more efficient.
",2013-10-16 05:27:32,2013-11-08 03:19:15,https://api.github.com/repos/ReactiveX/RxJava/issues/436,[],121,4,ReactiveX_RxJava_pull_436.diff
ReactiveX/RxJava,"rx-apache-http recognizes ""Transfer-Encoding: chunked"" as an HTTP stream","Uses the same infrastructure already in place for ""Content-Type: text/event-stream"" for HTTP response with chunked encoding.  Works with Twitter Streaming API
",2013-10-16 03:28:49,2013-10-16 05:59:28,https://api.github.com/repos/ReactiveX/RxJava/issues/435,[],16,3,ReactiveX_RxJava_pull_435.diff
ReactiveX/RxJava,Implemented SerialSubscription and Timeout operator,"Implemented Timeout operator and SerialSubscription upon which it is based.
",2013-10-15 10:39:01,2013-10-22 19:38:33,https://api.github.com/repos/ReactiveX/RxJava/issues/434,[],418,5,ReactiveX_RxJava_pull_434.diff
ReactiveX/RxJava,Fixed testOnErrorViaHasNext in issue #383,"Hi,

This PR fixed the issue that `testOnErrorViaHasNext` fails sometimes. It only tries to avoid the failure of unit tests.
However, there is still an issue in the `next` operator. The `hasNext` may return true, but the later `next` throws `IllegalStateException(""Observable is completed"")`. An example unit test throws `IllegalStateException`:

``` java
        @Test
        public void test() {
            Subject<String, String> obs = PublishSubject.create();
            Iterator<String> it = next(obs).iterator();
            assertTrue(it.hasNext());
            obs.onCompleted();
            it.next();
        }
```

I think @abersnaze is right. 

> hasNext should block until either the onNext or onComplete has been called.
",2013-10-15 06:32:14,2013-10-31 20:28:23,https://api.github.com/repos/ReactiveX/RxJava/issues/433,[],215,103,ReactiveX_RxJava_pull_433.diff
ReactiveX/RxJava,Fixed path to RxScalaDemo.scala,,2013-10-15 04:11:07,2013-10-16 05:21:46,https://api.github.com/repos/ReactiveX/RxJava/issues/432,[],1,1,ReactiveX_RxJava_pull_432.diff
ReactiveX/RxJava,Fixed issue #428,"I fixed the issue #428. This issus is because the wrong order of `unsubscribe` and `emitChunk`.

`unsubscribe` will cancel the Future, and the currrent thread's interrupt status will be set. If `unsubscribe` is called before `emitChunk`, the currrent thread's interrupt status has already set before `emitChunk`. It may confuse users when they have some codes depending on the interrupt status.

I put `emitChunk` before `unsubscribe` and added a unit test for it.
",2013-10-12 07:59:37,2013-10-16 05:29:43,https://api.github.com/repos/ReactiveX/RxJava/issues/430,[],42,1,ReactiveX_RxJava_pull_430.diff
ReactiveX/RxJava,[RFC] Initial implementation of OperationObserveInForeground (Android),"In reference to the discussion in [0] and our work with RxJava on Android, here is an initial attempt at providing an Rx operator which wraps the boilerplate required to observe sequences on Android UI components like Fragments and Activities (although I should mention that I haven't added support for the latter yet but focused on Fragments from the support-v4 library.)

Here's what I did:
- provide an operator which accepts a specialized observer type that is able to expose a Fragment reference. This is essential for us to decide whether it's safe to forward messages to that fragment, and we can only ask the fragment itself to make that decision
- schedule observer callbacks on the Android UI thread by default

There is some discussions to be had around this. I would really appreciate if everyone with and without Android experience could weigh in. Specific questions I think need discussing:
- I am terminating the sequence early if the caller does not subscribe using one of the specialized Observer types I provide (`FragmentObserver` or `SupportFragmentObserver` for native and back-compat fragments respectively). As mentioned above, I must force the caller to give me a reference to the fragment, since otherwise callbacks cannot be executed in a safe manner (safe w.r.t. not calling back in case Android decided to remove the fragment from the window; this is a life-cycle event in Android which cannot be intercepted other than asking the fragment whether it's still attached or not). I realize this has a smell to it, but I don't see another option.
- the specialized observer class keeps weak references to the source observer and the fragment (both can be the same object, but then again, could also not if e.g. you use inner classes as observers). In case the references got cleared, messages will be dropped
- Naming: observeInForeground is the best I could come up with, which doesn't mean much :-) Feel free to submit better naming suggestions

TODO:
- Implement native `FragmentObserver` in the same manner as `SupportFragmentObserver` (the latter is what we need so I built that one first)
- Add `ActivityObserver` in the same manner
- Think about auto-unsubscribing from the source sequence in case the references got cleared

[0] https://groups.google.com/forum/?fromgroups=#!topic/rxjava/7o_NJw36Enw
",2013-10-09 09:20:57,2013-10-09 20:49:36,https://api.github.com/repos/ReactiveX/RxJava/issues/427,[],337,1,ReactiveX_RxJava_pull_427.diff
ReactiveX/RxJava,PublishSubject ReSubscribe for publish().refCount() Behavior,"Allow `publish` + `refCount` to support re-subscribing to the origin after decrementing the count to 0 then adding new Observers which increment count to 1+.

The PublishSubject implementation was performing onError/onCompleted unsubscribe logic that was put in place long ago and I am now pretty sure it was wrong.

This was revealed while playing with `refCount` which intends on allowing a re-subscription to the source once new Observers arrive. PublishSubject was preventing that.

The one use case that I'm still wondering about though is if someone subscribes to a PublishSubject after it has emitted onCompleted and isn't ""restarted"". That Observer would wait forever if it is a ""single-shot"" PublishSubject use case. I'm not sure if that's just a bad use and fits into the ""don't do that"" scenario, or if it's a legit issue that has a solution.

Right now this code is ""thread-safe"" in the visibility sense, but it's not atomic and could have race conditions between adding/removing Observers and event notifications. I don't think that's an issue as if someone is concurrently adding/removing it's always a race, but am not 100% sure if there's a use case I'm missing. This also assumes (as it always did) that someone is not invoking onNext concurrently as that would break the Rx contract.
",2013-10-09 06:57:21,2013-10-09 20:52:53,https://api.github.com/repos/ReactiveX/RxJava/issues/426,[],184,242,ReactiveX_RxJava_pull_426.diff
ReactiveX/RxJava,Manual Merge of Pull Request #407,"Added a unit test to #407 while testing it. 
",2013-10-09 05:44:50,2013-10-09 05:45:14,https://api.github.com/repos/ReactiveX/RxJava/issues/425,[],279,1,ReactiveX_RxJava_pull_425.diff
ReactiveX/RxJava,Implemented the 'IgnoreElements' operator,"Hi,

I implemented the `IgnoreElements` operator #54. Please take a look. Thanks.
",2013-10-08 11:16:03,2013-10-09 20:11:05,https://api.github.com/repos/ReactiveX/RxJava/issues/424,[],34,0,ReactiveX_RxJava_pull_424.diff
ReactiveX/RxJava,JRuby function wrapping support,"This PR fixes #320 by implementing JRuby wrappers for RxJava-specific function interfaces. Given a set of method signatures for a Java method, JRuby will select the signature that best matches the Ruby arguments provided and wrap each argument in a proxy that implements the correct Java interface.

Occasionally JRuby will be unable to unambiguously select one method signature over another, and will either a) select the correct signature, but report that there was ambiguity in the method signatures or b) select the wrong signature and fail.

By explicitly wrapping `Proc` arguments into wrappers that implement the correct RxJava interface, JRuby will always select the correct method signature and will not need to wrap the argument in a proxy, increasing both correctness and performance.
",2013-10-07 01:09:14,2013-10-09 06:08:47,https://api.github.com/repos/ReactiveX/RxJava/issues/422,[],705,0,ReactiveX_RxJava_pull_422.diff
ReactiveX/RxJava,Adding collect method to Scala Observable,"I think it's a good idea to add a `collect` method analogous with the one in the Scala collection library. It was simplest to implement it using a combination of `filter` & `map`.

If you find any major disadvantages with this please chime in.
",2013-10-04 20:46:47,2013-10-31 20:30:51,https://api.github.com/repos/ReactiveX/RxJava/issues/421,[],16,0,ReactiveX_RxJava_pull_421.diff
ReactiveX/RxJava,Scala Adaptor,"Here are more improvements to the Scala adaptor, mostly changes in classes other than `rx.lang.scala.Observable` itself, as well as scaladoc for all classes. And the `MovieLib` example is now part of the `rxjava-scala` project instead of being a seperate project.
",2013-10-02 13:34:13,2013-10-09 06:00:36,https://api.github.com/repos/ReactiveX/RxJava/issues/420,[],1494,802,ReactiveX_RxJava_pull_420.diff
ReactiveX/RxJava,Implemented the 'Throw' operator with scheduler,"Hi,

I implemented the `Throw` operator #89 with scheduler. I found that RxJava had an `error` method. So I just implemented the scheduler overload.
",2013-09-30 05:57:00,2013-10-09 20:52:32,https://api.github.com/repos/ReactiveX/RxJava/issues/416,[],19,0,ReactiveX_RxJava_pull_416.diff
ReactiveX/RxJava,Implemented the 'Empty' operator with scheduler,"Hi,

I implemented the 'Empty' operator with scheduler #42. Please take a look. Thanks.
",2013-09-30 03:00:14,2013-10-09 05:55:29,https://api.github.com/repos/ReactiveX/RxJava/issues/415,[],19,0,ReactiveX_RxJava_pull_415.diff
ReactiveX/RxJava,Implemented the 'SkipLast' operator,"Hi,

I implemented the `skipLast` operator #78.  I used `ReentrantLock` and `LinkedList` to implement it rather than `LinkedBlockingDeque` like `takeLast` #85 #140 for two reasons.
- LinkedBlockingDeque requires that count is greater than 0 but `skipLast` can accept 0. 
- LinkedBlockingDeque requires the elements can not be null but an observable can emit a null value.

In summary, `LinkedBlockingDeque` will cause issues like #413.

Please take a look. Thanks.
",2013-09-29 07:33:03,2013-10-09 05:54:28,https://api.github.com/repos/ReactiveX/RxJava/issues/414,[],249,0,ReactiveX_RxJava_pull_414.diff
ReactiveX/RxJava,"Fixed the issues of takeLast(items, 0) and null values","Hi,

There are two issues about `takeLast` #85 #140. The essential cause is `LinkedBlockingDeque`.
1. count == 0
   `takeLast` in RxJava will throw an exception when count == 0, as `LinkedBlockingDeque` rejects count <= 0. However, in c#, TakeLast with 0 count is valid. The following codes is OK in C# (no exception and do nothing):

``` c#
            var source = Observable.Return(1).TakeLast(0);
            source.Subscribe(
                x => 
                    Console.WriteLine(""subscriber got "" + x)
            );
            Console.ReadLine();
```
1. null values
   LinkedBlockingDeque requires the elements can not be null but an observable can emit a null value.

I used `ReentrantLock` and `LinkedList` to replace `LinkedBlockingDeque`. Please take a look. Thanks.
",2013-09-29 02:37:12,2013-10-09 05:50:01,https://api.github.com/repos/ReactiveX/RxJava/issues/413,[],88,12,ReactiveX_RxJava_pull_413.diff
ReactiveX/RxJava,update counter before triggering latch,"as mentioned in #383

rx.concurrency.TestSchedulers.testSchedulingWithDueTime

is flaky because there is a race-condition where the test can assert the counter value before it is updated. fix is just to update the counter before releasing the latch.
",2013-09-26 13:55:59,2013-10-09 05:47:27,https://api.github.com/repos/ReactiveX/RxJava/issues/411,[],1,1,ReactiveX_RxJava_pull_411.diff
ReactiveX/RxJava,Implemented the 'Contains' operator,"Hi, I implemented the `Contains` operator #31. I saw the discussion about the `distinct` operator #395, so I did not implement the comparator override. Please take a look. Thanks!
",2013-09-26 08:31:15,2013-10-09 05:46:56,https://api.github.com/repos/ReactiveX/RxJava/issues/410,[],71,0,ReactiveX_RxJava_pull_410.diff
ReactiveX/RxJava,Implemented 'Synchronize' with 'lock',"Hi,

I implemented #84 to support that sending a lock to the `synchronize` operator.

I also found that there was a issue that `testMultiThreadedWithNPE` and `testMultiThreadedWithNPEinMiddle` might fail in some special situation. When `onError` is invoked before any `onNext`, the last statement `assertEquals(1, busyObserver.maxConcurrentThreads.get());` in these methods will fail. I also fixed this issue in the pull request.
",2013-09-25 03:48:17,2013-09-25 18:03:16,https://api.github.com/repos/ReactiveX/RxJava/issues/409,[],274,8,ReactiveX_RxJava_pull_409.diff
ReactiveX/RxJava,Do not run RxScalaDemo on each build,"On my last pull request, I forgot to uncomment the line which ignores `RxScalaDemo`, so currently it is executed on each build, even though it does no automatic testing. And since `RxScalaDemo` takes about 48 seconds, this significantly increases build time. Sorry for this...

After this change, the complete build took 3 mins 33.932 secs on my 3 years old laptop, so if cloudbees can't build it in 10 min, there might be something else not properly working...
",2013-09-24 18:22:01,2013-09-25 18:04:42,https://api.github.com/repos/ReactiveX/RxJava/issues/408,[],1,1,ReactiveX_RxJava_pull_408.diff
ReactiveX/RxJava,Implemented RefCount Operator,"Please note that I placed the unit tests under the test root rather than inline with the implementation as has been done for other operators.  This is due to a bug in IDEA that prohibits running unit tests in folders designated as source rather than test.  I can see that a bunch of other operators follow this convention so hopefully that's okay.
",2013-09-24 11:26:29,2013-10-09 05:45:15,https://api.github.com/repos/ReactiveX/RxJava/issues/407,[],176,1,ReactiveX_RxJava_pull_407.diff
ReactiveX/RxJava,Add fromChangeEvents methods to SwingObservable,"For swing components which fire `ChangeEvent`s, I added a method `SwingObservable.fromChangeEvents`, similar to the other methods of `SwingObservable`. 

Unfortunately, there is no common base interface for all components which fire `ChangeEvents`s, so I created one myself: `ChangeEventSource.ChangeEventComponentWrapper`.

Then, each component which fires `ChangeEvents`s needs its own overload in `SwingObservable`.

An other approach would be to use reflection, but then we loose typesafety.
",2013-09-23 16:23:40,2013-11-22 20:38:54,https://api.github.com/repos/ReactiveX/RxJava/issues/404,[],639,10,ReactiveX_RxJava_pull_404.diff
ReactiveX/RxJava,Implemented the 'cast' and 'ofType' operators,"Hi,

I used 'map' to implement the 'cast' operator #26. I also used 'cast' to implement the 'ofType' operator #67.
Please take a look. Thanks!
",2013-09-23 05:19:21,2013-09-25 18:28:55,https://api.github.com/repos/ReactiveX/RxJava/issues/403,[],140,0,ReactiveX_RxJava_pull_403.diff
ReactiveX/RxJava,Fixes to rxjava-apache-http,"- made Content-Type inspection more reliable
- other small improvments
",2013-09-22 04:27:22,2013-09-22 04:27:26,https://api.github.com/repos/ReactiveX/RxJava/issues/402,[],38,37,ReactiveX_RxJava_pull_402.diff
ReactiveX/RxJava,Implemented the 'DefaultIfEmpty' operator. See #34,"Hi,

This implements the `DefaultIfEmpty` operator from #34.

There are two variants. However, I can not get the element type in the source observable due to type erasure. So I only implemented the variant with a default value: http://msdn.microsoft.com/en-us/library/hh229624(v=vs.103).aspx

Please take a look. Thanks.
",2013-09-22 02:45:43,2013-09-25 18:24:32,https://api.github.com/repos/ReactiveX/RxJava/issues/401,[],138,0,ReactiveX_RxJava_pull_401.diff
ReactiveX/RxJava,Removing 'comparator` overloads of `distinct`,"Removing these fairly recently added overloads as they turn out to not be the best approach.

Discussion ongoing as to how to implement them at https://github.com/Netflix/RxJava/issues/395
",2013-09-21 21:10:58,2013-09-21 21:11:02,https://api.github.com/repos/ReactiveX/RxJava/issues/400,[],0,66,ReactiveX_RxJava_pull_400.diff
ReactiveX/RxJava,Merge Pull #390 - elementAt,"Merge pull https://github.com/Netflix/RxJava/pull/390
",2013-09-21 20:39:53,2013-09-21 20:39:59,https://api.github.com/repos/ReactiveX/RxJava/issues/399,[],302,1,ReactiveX_RxJava_pull_399.diff
ReactiveX/RxJava,Merge 'any' Pull Request,"Merges pull https://github.com/Netflix/RxJava/pull/385

I changed `any` to `isEmpty` and `exists` as I agree with @samuelgruetter comment at https://github.com/Netflix/RxJava/pull/385#issuecomment-24568332. These names feel more idiomatic to Java languages.
",2013-09-21 20:31:30,2013-09-21 20:31:36,https://api.github.com/repos/ReactiveX/RxJava/issues/398,[],316,4,ReactiveX_RxJava_pull_398.diff
ReactiveX/RxJava,Observable API for Apache HttpAsyncClient 4.0,"This is still experimental, I have not used it for any significant load or production traffic.
",2013-09-21 06:47:04,2013-09-21 21:05:36,https://api.github.com/repos/ReactiveX/RxJava/issues/397,[],776,1,ReactiveX_RxJava_pull_397.diff
ReactiveX/RxJava,Add missing methods to Scala Adaptor,"This pull request adds a method to the Scala Observable for each method in the Java Observable. Some were renamed, have a different signature, or were left out intentionally. A comparison can be found [here](https://github.com/samuelgruetter/rx-playground/wiki/Comparison-of-Scala-Observable-and-Java-Observable). 

The Scala Observable should now be complete, but there are still some [TODOs](https://github.com/samuelgruetter/RxJava/blob/a2ab731ce1a867e1a2902c27062bcea2923ef303/language-adaptors/rxjava-scala/TODO.md).

There should be no breaking changes, but only additions.

There's also an automatic completeness test (`rx.lang.scala.CompletenessTest`). If methods are missing, it still succeeds, but it prints the missing methods to stdout.
",2013-09-20 16:30:25,2013-09-21 07:05:18,https://api.github.com/repos/ReactiveX/RxJava/issues/396,[],1000,278,ReactiveX_RxJava_pull_396.diff
ReactiveX/RxJava,Change Interval and Sample default Scheduler,"Change to use built-in thread-pools rather than creating a new Executor on each invocation.
The built-in ones are shared across all operators, have threads ready, are marked as daemon threads so don't prevent system shutdown, and are named for clarity when looking at thread dumps and debuggers.

This fixes https://github.com/Netflix/RxJava/issues/388
",2013-09-19 05:07:47,2013-09-19 05:07:51,https://api.github.com/repos/ReactiveX/RxJava/issues/394,[],2,2,ReactiveX_RxJava_pull_394.diff
ReactiveX/RxJava,Parallel Operator & ObserveOn/ScheduledObserver Fixes,"#### Parallel Operator

This operator came out of discussions and work with @headinthebox to allow explicit and composable declaration of blocks of work that can be scheduled for parallel execution.

An Observable event stream will be sharded using groupBy using a value from Scheduler. degreeOfParallelism() (defaulting to number of CPU cores) and perform the defined work in parallel.

Instead of having various parallel operators like parallelMap, parallelFilter parallelScan etc this can work generically for any operators or sequence of operators.
#### Fix ObserveOn, NewThreadScheduler and ScheduledObserver bugs

@headinthebox and I were working on some code and found differences in behavior between Rx.Net and RxJava with observeOn. This commit should fix that.
",2013-09-19 04:53:10,2013-09-19 05:07:06,https://api.github.com/repos/ReactiveX/RxJava/issues/393,[],551,93,ReactiveX_RxJava_pull_393.diff
ReactiveX/RxJava,remove scalatest packages from OSGI imports,,2013-09-18 07:57:03,2013-09-19 04:54:33,https://api.github.com/repos/ReactiveX/RxJava/issues/391,[],1,1,ReactiveX_RxJava_pull_391.diff
ReactiveX/RxJava,Implemented the 'elementAt' and 'elementAtOrDefault' operators. see #41,"Hi,

This implements the `ElementAt` and `ElementAtOrDefault` operators from #41.

For `ElementAt`, if the index is less than 0, or greater than or equal to the number of elements in the source sequence, an IndexOutOfBoundsException will be threw.

For `ElementAtOrDefault`,  if the index is less than 0, an IndexOutOfBoundsException will be threw. What's more, I added a `defaultValue` parameter. I can not get the element type in the source observable due to type erasure. So I can not determine the default value automatically. That's why `ElementAtOrDefault` needs  a `defaultValue` parameter.
",2013-09-18 05:18:48,2013-09-21 20:40:00,https://api.github.com/repos/ReactiveX/RxJava/issues/390,[],279,0,ReactiveX_RxJava_pull_390.diff
ReactiveX/RxJava,Scala Adaptor Improvements,"Includes groupBy, scala README, examples, moving ImplicitFunctionConversions out of internal package, multicast, publish, replay, and methods for BlockingObservable.

Note that the commit https://github.com/samuelgruetter/RxJava/commit/ac26e42d1e85deac0b7bfa50c3ca3e5298493dd4 modifies core by making the Java `Subject<T, R>` used as contravariant in `T` and covariant in `R`, which allows me to write Scala's multicast without typecasting.
",2013-09-17 15:04:17,2013-09-18 05:27:48,https://api.github.com/repos/ReactiveX/RxJava/issues/389,[],469,275,ReactiveX_RxJava_pull_389.diff
ReactiveX/RxJava,Implemented the 'any' operator,"This implements the operator `Any` from #24 in all two variants.

However, I encountered two problems.

Updated: the online document http://msdn.microsoft.com/en-us/library/hh211993(v=vs.103).aspx is wrong. See my later discussion.

Another question is if I add the `any` method to `rx.Observable<T>`, some unit tests will fail as the method `any` in  `rx.Observable<T>` overrides the method `org.mockito.Matchers.any(java.lang.Class<T>)` in some unit tests (e.g., `rx.subjects.ReplaySubject<T>`). Do I need to use another method name, or just modify the unit tests? Now the `any` methods in `rx.Observable<T>` are commented out.

Thanks.
",2013-09-16 10:05:52,2013-09-21 20:31:37,https://api.github.com/repos/ReactiveX/RxJava/issues/385,[],272,13,ReactiveX_RxJava_pull_385.diff
ReactiveX/RxJava,Implemented the `delay` operator,"This implements the operator from #36 in all four variants.

The tests also found a bug in `interval` that I fixed.

Maybe this is a bug of `map` though - `map` throws exceptions in `onNext`, not sure if it should be allowed to do that - the `SafeObserver` that it relies on comes too late for scheduled actions. However, this can be discussed and fixed independently.
",2013-09-14 11:05:40,2013-12-11 06:09:11,https://api.github.com/repos/ReactiveX/RxJava/issues/384,[],532,7,ReactiveX_RxJava_pull_384.diff
ReactiveX/RxJava,Removing deprecated RxImplicits from rxjava-scala,"Now that @samuelgruetter's work on a value class implementation of Scala Observable has been merged, no need for the standalone `RxImplicits`
",2013-09-13 23:02:25,2013-09-18 05:31:32,https://api.github.com/repos/ReactiveX/RxJava/issues/382,[],0,606,ReactiveX_RxJava_pull_382.diff
ReactiveX/RxJava,Implemented `mapWithIndex`,"As requested by @samuelgruetter in #372.
",2013-09-13 12:02:32,2013-09-14 15:37:10,https://api.github.com/repos/ReactiveX/RxJava/issues/381,[],144,40,ReactiveX_RxJava_pull_381.diff
ReactiveX/RxJava,Implemented `distinct` and `distinctUntilChanged` variants using a comparator,"As @abersnaze and @benjchristensen both agreed (see the #374 discussion) that they'd like the comparator versions of these two operations, too, I implemented them here.
",2013-09-13 10:34:33,2013-09-13 16:44:09,https://api.github.com/repos/ReactiveX/RxJava/issues/380,[],330,31,ReactiveX_RxJava_pull_380.diff
ReactiveX/RxJava,Make `interval` work with multiple subscribers,"As per @samuelgruetter's comments in #55, I added some tests against `interval` together with multiple subscribers, and then proceeded to fix the behavior by wrapping it in another subscription function.

I hope it's ok now.
",2013-09-13 08:02:22,2013-09-13 16:39:10,https://api.github.com/repos/ReactiveX/RxJava/issues/379,[],132,3,ReactiveX_RxJava_pull_379.diff
ReactiveX/RxJava,UnitTests while working on EventStream use cases,,2013-09-13 03:41:57,2013-09-13 03:42:01,https://api.github.com/repos/ReactiveX/RxJava/issues/378,[],241,0,ReactiveX_RxJava_pull_378.diff
ReactiveX/RxJava,Distinct operator,"Merging https://github.com/Netflix/RxJava/pull/375
",2013-09-13 03:35:29,2013-09-13 03:35:34,https://api.github.com/repos/ReactiveX/RxJava/issues/377,[],237,0,ReactiveX_RxJava_pull_377.diff
ReactiveX/RxJava,Idiomatic Scala Adaptor,"This is a first pull request for https://github.com/Netflix/RxJava/issues/336 . The Scala Adaptor is still far from being finished (see TODOs in `language-adaptors/rxjava-scala/TODO.md`), but I think it's in a state where it can be merged in so that people can try it out and give feedback.
",2013-09-12 19:54:18,2013-09-13 03:19:17,https://api.github.com/repos/ReactiveX/RxJava/issues/376,[],2580,13,ReactiveX_RxJava_pull_376.diff
ReactiveX/RxJava,Implemented `distinct` operator,"This PR implements `distinct`, as speficied by #38. 

Again, I haven't implemented the .NET methods taking an `IEqualityComparator` (see #374).
",2013-09-12 13:17:07,2013-09-13 03:35:35,https://api.github.com/repos/ReactiveX/RxJava/issues/375,[],237,0,ReactiveX_RxJava_pull_375.diff
ReactiveX/RxJava,Implemented distinctUntilChanged operation,"This is the implementation for `distinctUntilChanged` as described in #39.

I haven't implemented the two methods from .NET that are using an `IEqualityComparator` because I don't think it would be idiomatic Java to define an interface like this and use that here. - Or does somebody want that?
",2013-09-12 10:58:39,2013-09-13 03:22:34,https://api.github.com/repos/ReactiveX/RxJava/issues/374,[],250,0,ReactiveX_RxJava_pull_374.diff
ReactiveX/RxJava,"a few warnings, javadoc, and one missing scheduler parameter","This is just a quick fix for #368 according to @samuelgruetter's comments.

I also removed a few unnecessary `@SuppressWarnings(""unchecked"")` and one unnecessary semicolon.
",2013-09-12 07:48:50,2013-09-13 03:20:09,https://api.github.com/repos/ReactiveX/RxJava/issues/373,[],24,66,ReactiveX_RxJava_pull_373.diff
ReactiveX/RxJava,Operator: Retry,"https://github.com/Netflix/RxJava/issues/72
",2013-09-11 06:09:55,2013-09-11 06:18:58,https://api.github.com/repos/ReactiveX/RxJava/issues/371,[],251,2,ReactiveX_RxJava_pull_371.diff
ReactiveX/RxJava,Change zip method signature from Collection to Iterable,"Fix javadoc typos.
",2013-09-11 04:52:18,2013-09-11 04:52:23,https://api.github.com/repos/ReactiveX/RxJava/issues/370,[],34,31,ReactiveX_RxJava_pull_370.diff
ReactiveX/RxJava,Remove covariance of scan/reduce,"Remove covariance of scan/reduce since consumer/producer are the same <T, T, T>

See https://github.com/Netflix/RxJava/issues/360#issuecomment-24203016
",2013-09-11 04:36:50,2013-09-11 16:52:56,https://api.github.com/repos/ReactiveX/RxJava/issues/369,[],65,31,ReactiveX_RxJava_pull_369.diff
ReactiveX/RxJava,Operators: Throttle and Debounce,"This adds `throttleFirst`, `throttleLast` (alias of `sample`) and `debounce` (aliased with `throttleWithTimeout`).

This merges pull request https://github.com/Netflix/RxJava/pull/258.

Unfortunately the Rx `throttle` operator behavior is actually `debounce`, not `throttle`. This pull request tries to address that.

Here is a good place to get a description of `throttle` versus `debounce`: http://drupalmotion.com/article/debounce-and-throttle-visual-explanation

> Debounce: Think of it as ""grouping multiple events in one"". Imagine that you go home, enter in the elevator, doors are closing... and suddenly your neighbor appears in the hall and tries to jump on the elevator. Be polite! and open the doors for him: you are debouncing the elevator departure. Consider that the same situation can happen again with a third person, and so on... probably delaying the departure several minutes.
> 
> Throttle: Think of it as a valve, it regulates the flow of the executions. We can determine the maximum number of times a function can be called in certain time. So in the elevator analogy.. you are polite enough to let people in for 10 secs, but once that delay passes, you must go!

Other links includes:
- http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
- http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/

I feel we need some kind of `throttle*` operator name as an alias to `debounce` to help people discover it, especially those coming from Rx.Net or RxJS. I'm not fond of `throttleWithTimeout` which is what I have it as right now. Perhaps `throttleViaDebounce` even though that doesn't actually make sense? 

I do not want to use `throttle` because it's not actually the definition of `throttle`. To confirm this I have asked over a dozen server-side engineers what their definition of `throttle` is and their expectations of an operator is. It never matches the Rx definition and they are always surprised by the `debounce` behavior.

I have included `throttleLast` as an alias to `sample` so that as people start typing `throttle...` it prompts them for the different options and discoverability will be improved instead of knowing to go look for `sample`.

The `throttleFirst` operator is included as an efficient approach to throttling tht does not involve ticking time, intervals or buffering in any way. It simply allows an `onNext` value through if the last `onNext` event was greater than X time units ago. All others are discarded. This matches server-side throttling expectations and is limited overhead.

Questions:

1) Is there a better name for `throttleWithTimeout` as an alias to `debounce`?
2) Does the documentation sufficiently explain the different strategies?
3) If ambitious in your review, does anyone see concurrency bugs?
",2013-09-10 20:03:56,2013-09-11 16:53:16,https://api.github.com/repos/ReactiveX/RxJava/issues/368,[],840,7,ReactiveX_RxJava_pull_368.diff
ReactiveX/RxJava,Operator: throttleFirst,"Another take on `throttle` … this delivers the first value in each window.
",2013-09-10 07:06:11,2013-09-10 20:04:21,https://api.github.com/repos/ReactiveX/RxJava/issues/367,[],282,5,ReactiveX_RxJava_pull_367.diff
ReactiveX/RxJava,Operator: throttleWithTimeout,"Another take on `throttle` … I believe this matches Rx.Net behavior.

This will wait until timeout value has passed without any further values before emitting the received value.
",2013-09-10 06:52:08,2013-09-10 20:04:38,https://api.github.com/repos/ReactiveX/RxJava/issues/366,[],352,5,ReactiveX_RxJava_pull_366.diff
ReactiveX/RxJava,Operation throttleLast,"Merge of https://github.com/Netflix/RxJava/pull/258
",2013-09-10 06:02:13,2013-09-10 20:04:30,https://api.github.com/repos/ReactiveX/RxJava/issues/365,[],287,5,ReactiveX_RxJava_pull_365.diff
ReactiveX/RxJava,additions to tests,,2013-09-10 02:39:21,2013-09-10 02:39:26,https://api.github.com/repos/ReactiveX/RxJava/issues/364,[],44,1,ReactiveX_RxJava_pull_364.diff
ReactiveX/RxJava,unit tests for covariance,"- refactoring so not everything for the entire Observable ends up in a single class
",2013-09-10 01:47:49,2013-09-10 01:47:55,https://api.github.com/repos/ReactiveX/RxJava/issues/363,[],328,188,ReactiveX_RxJava_pull_363.diff
ReactiveX/RxJava,Merge 'first' Operator,"Merge pull request https://github.com/Netflix/RxJava/pull/357 with `first` and `firstOrDefault` operators.
",2013-09-10 01:05:09,2013-09-10 01:05:58,https://api.github.com/repos/ReactiveX/RxJava/issues/362,[],373,0,ReactiveX_RxJava_pull_362.diff
ReactiveX/RxJava,Fix vararg issues reported in https://github.com/Netflix/RxJava/issues/359,"Branch working on https://github.com/Netflix/RxJava/issues/359

I'll continue committing to this until all the varargs are replaced.
",2013-09-09 22:52:12,2013-09-10 00:54:16,https://api.github.com/repos/ReactiveX/RxJava/issues/361,[],1556,131,ReactiveX_RxJava_pull_361.diff
ReactiveX/RxJava,"Implemented ""First"" and ""FirstOrDefault"" operations","This PR builds upon the `skipWhile`  PR (#355) which makes implementing the two `first` variants extremely easy.

I changed `firstOrDefault` slightly from what Rx.NET does by explicitly requiring a default value as parameter of the function call. I don't know what default value I should return otherwise, except `null` (and imho this would be pretty useless).

This PR addresses issue #44.
",2013-09-08 13:29:21,2013-09-10 01:06:10,https://api.github.com/repos/ReactiveX/RxJava/issues/357,[],564,0,ReactiveX_RxJava_pull_357.diff
ReactiveX/RxJava,"Added interval methods to Observable, where they were still missing","This was simply missing and forgotten in #55.
",2013-09-08 11:35:06,2013-09-09 16:53:56,https://api.github.com/repos/ReactiveX/RxJava/issues/356,[],30,0,ReactiveX_RxJava_pull_356.diff
ReactiveX/RxJava,implemented skipWhile and skipWhileWithIndex (#80),"The title says it all already.
",2013-09-07 20:11:09,2013-09-09 16:53:07,https://api.github.com/repos/ReactiveX/RxJava/issues/355,[],222,0,ReactiveX_RxJava_pull_355.diff
ReactiveX/RxJava,"Count, Sum, Average implementations","I implemented three easy  operations here simply using `reduce`.

Two things were tricky however:
1. How to name the various ""overloads"" (have to use different names due to identical erasure). I propose `sum`, `sumLongs`, `sumFloats`, `sumDoubles` here (and the same for the averages).
2. How to handle empty source observables when averaging. I propose throwing an `ArithmeticException` here.

Any other opinions?
",2013-09-07 19:11:15,2013-09-09 16:52:15,https://api.github.com/repos/ReactiveX/RxJava/issues/354,[],491,2,ReactiveX_RxJava_pull_354.diff
ReactiveX/RxJava,Take Operator Error Handling,"Unit test for https://github.com/Netflix/RxJava/issues/217
",2013-09-07 07:05:47,2013-09-07 07:05:51,https://api.github.com/repos/ReactiveX/RxJava/issues/353,[],34,0,ReactiveX_RxJava_pull_353.diff
ReactiveX/RxJava,Adding Func5-9 and N to the wrapper,"the zip(Collection, FuncN) isn't working in groovy because the function wrapper doesn't implement FuncN
",2013-09-06 18:51:06,2013-09-06 19:02:36,https://api.github.com/repos/ReactiveX/RxJava/issues/352,[],48,2,ReactiveX_RxJava_pull_352.diff
ReactiveX/RxJava,Fix Observable.window static/instance bug,"- reported at https://github.com/Netflix/RxJava/pull/349#issuecomment-23946707
",2013-09-06 16:29:27,2013-09-06 16:29:38,https://api.github.com/repos/ReactiveX/RxJava/issues/351,[],59,40,ReactiveX_RxJava_pull_351.diff
ReactiveX/RxJava,A little Swing wrap-up,"These are some old changes in the Swing contrib library that wrap up a few loose endings (javadoc warnings, slightly inconsistent behavior for `KEY_TYPED` events, an additional helper for computing relative mouse motion).

I updated this to work with the current master (and fixed a few warnings concerning unused imports and double semicolons). I also checked whether this needs some variance generalizations, but it seems that it doesn't.
",2013-09-06 13:28:15,2013-09-06 16:34:12,https://api.github.com/repos/ReactiveX/RxJava/issues/350,[],125,16,ReactiveX_RxJava_pull_350.diff
ReactiveX/RxJava,Window Operator,"Manual merge of https://github.com/Netflix/RxJava/pull/337

Since this pull request was submitted there were significant changes to the `create` operator and generics, so I manually merged into master. I have not actually reviewed for behavior, but unit tests are passing and code structure looked good.

This is for issue https://github.com/Netflix/RxJava/issues/102?source=c
",2013-09-05 06:21:41,2013-09-05 22:14:03,https://api.github.com/repos/ReactiveX/RxJava/issues/349,[],1647,679,ReactiveX_RxJava_pull_349.diff
ReactiveX/RxJava,switchDo to switchOnNext,"See https://github.com/Netflix/RxJava/issues/342 for original question.

Does anyone have an opinion on this?
",2013-09-05 01:36:00,2013-09-05 06:44:08,https://api.github.com/repos/ReactiveX/RxJava/issues/348,[],10,11,ReactiveX_RxJava_pull_348.diff
ReactiveX/RxJava,Fixing Scala unit tests after previous commits accidentally broke them,,2013-09-05 01:27:03,2013-09-05 01:27:08,https://api.github.com/repos/ReactiveX/RxJava/issues/347,[],473,482,ReactiveX_RxJava_pull_347.diff
ReactiveX/RxJava,BlockingObservable Refactor,"- No longer extends from Observable. If someone chooses to use BlockingObservable the intent is to leave the Observable so it shouldn't show the non-blocking operators.
- Remove duplicate static methods, similar to how done on Observable in earlier commit.
",2013-09-05 01:09:56,2013-09-05 01:10:01,https://api.github.com/repos/ReactiveX/RxJava/issues/346,[],56,285,ReactiveX_RxJava_pull_346.diff
ReactiveX/RxJava,Remove unnecessary Observable constructor,"- fixed unit tests that relied on it
",2013-09-04 23:14:38,2013-09-04 23:14:45,https://api.github.com/repos/ReactiveX/RxJava/issues/345,[],197,325,ReactiveX_RxJava_pull_345.diff
ReactiveX/RxJava,Update Clojure interop to support new OnSubscribeFunc with rx/fn.,,2013-09-04 23:14:18,2013-09-04 23:14:56,https://api.github.com/repos/ReactiveX/RxJava/issues/344,[],30,0,ReactiveX_RxJava_pull_344.diff
ReactiveX/RxJava,Covariant Support with super/extends and OnSubscribeFunc,"Merging and adding to work by @jmhofer in https://github.com/Netflix/RxJava/pull/331

In particular this adds the following change to the previous pull request:

``` java
public static <T> Observable<T> create(Func1<? super Observer<? super T>, ? extends Subscription> func)
```

to

``` java
public static <T> Observable<T> create(OnSubscribeFunc<T> func)
```
",2013-09-04 19:14:20,2013-09-04 22:43:29,https://api.github.com/repos/ReactiveX/RxJava/issues/343,[],1521,1029,ReactiveX_RxJava_pull_343.diff
ReactiveX/RxJava,Update gradle wrapper to latest,,2013-09-03 17:19:56,2013-09-03 20:51:23,https://api.github.com/repos/ReactiveX/RxJava/issues/341,[],131,105,ReactiveX_RxJava_pull_341.diff
ReactiveX/RxJava,Extremely rudimentary auto-generated Clojure wrapper. (DO NOT MERGE),"Proof(?)-of-concept for rxjava issue #334. Please do not merge.
",2013-09-03 03:48:39,2013-10-31 20:28:52,https://api.github.com/repos/ReactiveX/RxJava/issues/338,[],164,1,ReactiveX_RxJava_pull_338.diff
ReactiveX/RxJava,Added the window() operation.,"window() returns an Observable<Observable<T>> that will chunk the source observable
based on several criteria; counts, time etc.

This differs from buffer() in that the underlying observables will all onComplete()
independently from their upstream Observable.
",2013-09-02 04:24:28,2013-09-05 06:22:12,https://api.github.com/repos/ReactiveX/RxJava/issues/337,[],1572,616,ReactiveX_RxJava_pull_337.diff
ReactiveX/RxJava,Issue 329: Fix non-deterministic unit tests,"I'm sure there are others, but I've tried to fix the ones reported in https://github.com/Netflix/RxJava/issues/329
",2013-08-31 21:15:25,2013-08-31 21:15:47,https://api.github.com/repos/ReactiveX/RxJava/issues/332,[],32,52,ReactiveX_RxJava_pull_332.diff
ReactiveX/RxJava,Adding super/extends so that Observable is covariant,"Ok, so this pull request changes a _lot_ of lines. It's mostly generalizing all the `FuncX`s to be used like `FuncX[-T1, -T2, ..., -TX, +R]` (contravariant parameters, covariant return type) and all the `Observer`s to be used ""in a contravariant way"". A few of the `Observable` uses are covariant, now, too (mostly `zip`).

This is the pull request for #326.

This doesn't look very good in the code (thanks Java). Also, it doesn't seem to make Scala interop easier at all (at least not yet).

Please take a look. I'm not exactly happy with the result. - Maybe I'm doing something wrong here? - I've still got hope that there's an easier way...

The pull request compiles and tests ok for me (except for the Clojure module, but that's another story and not due to my changes).
",2013-08-31 20:15:36,2013-09-04 22:43:30,https://api.github.com/repos/ReactiveX/RxJava/issues/331,[],1383,932,ReactiveX_RxJava_pull_331.diff
ReactiveX/RxJava,Make DummyObservable visible to clojureTest classpath.,"RxJava issue #327. Moved DummyObservable into main so that it's
compiled and available when the clojureTest task executes. Perhaps
someone with stronger Gradle skills can figure out how to put this Java
class in src/test and get things to work out. Correctly. For the time
being, several clean/build cycles worked fine for me.
",2013-08-31 19:56:05,2013-08-31 20:28:40,https://api.github.com/repos/ReactiveX/RxJava/issues/330,[],2,3,ReactiveX_RxJava_pull_330.diff
ReactiveX/RxJava,Preserve metadata on fn and action macros,"Because they're macros, rx/fn and rx/action would lose metadata attached
to them, in particular type hints which are slightly important to
disambiguate overloaded Observable methods. Fixed.
",2013-08-31 05:28:11,2013-08-31 06:07:39,https://api.github.com/repos/ReactiveX/RxJava/issues/325,[],106,8,ReactiveX_RxJava_pull_325.diff
ReactiveX/RxJava,0.11 Cleanup,,2013-08-30 18:44:22,2013-08-30 22:27:59,https://api.github.com/repos/ReactiveX/RxJava/issues/324,[],301,50,ReactiveX_RxJava_pull_324.diff
ReactiveX/RxJava,Static core,"Another take on Issues #204, #208.  
- typesafe rxjava-core
- modular jars
- Scala support via implicits
- Groovy support via extension methods
- No Clojure support in this PR (eventually via macros)
- Eliminated JRuby support (for now)
",2013-08-29 18:12:26,2013-08-30 17:35:18,https://api.github.com/repos/ReactiveX/RxJava/issues/323,[],2453,5085,ReactiveX_RxJava_pull_323.diff
ReactiveX/RxJava,Update Android README.md,"Added sample usage of Android Handler schedulers.
",2013-08-24 16:38:21,2013-08-24 17:03:46,https://api.github.com/repos/ReactiveX/RxJava/issues/322,[],59,2,ReactiveX_RxJava_pull_322.diff
ReactiveX/RxJava,AtomicObservableSubscription to SafeObservableSubscription,,2013-08-24 04:00:54,2013-08-24 04:00:59,https://api.github.com/repos/ReactiveX/RxJava/issues/321,[],2,2,ReactiveX_RxJava_pull_321.diff
ReactiveX/RxJava,typesafe-core,"Here's another attempt at making rx-core typesafe and still supporting dynamic languages. The previous attempt was https://github.com/Netflix/RxJava/pull/304.  Enough changed (including the 0.10 release) since I submitted #304 that it made more sense to start fresh with this one.  All the comments from that PR still apply, and the 'subscribe on map' issue is now handled.

This will make RxJava completely static by removing all Object overloads (see https://github.com/Netflix/RxJava/issues/208 and https://github.com/Netflix/RxJava/issues/204).

---

Implementation notes originally posted at https://github.com/Netflix/RxJava/issues/204#issuecomment-20396621:

After implementing and throwing away a few different approaches we have landed on a solution we feel will balance the various competing priorities. 

Our goals are:
- support static typing for Java/Scala/Kotlin etc by removing the Object overloads
- support any JVM language, static or dynamically typed
- allow all languages to use the same `rx.Observable` class so that we don't divide libraries with helpers such as `GroovyObservable`, `ClojureObservable` etc that then need to be converted back and forth when doing interop
- do not require special classloaders or agents to enable runtime bytecode generation
- do not remove static operators to enable proxying
- small jars and limited or no dependencies

The solution we have arrived at will work as follows:
- The rxjava-core source code will delete all Object overload methods and be pure static java.
  - Any language that supports functional interfaces directly (such as Java 8 and XTend) can use the Java core version directly.
- Languages needing specific lambda/clojure type mapping to the Func_/Action_ types will have language specific Jars created via build-time bytecode generation.
  - Any method with a Func_/Action_ argument will be overloaded with a version supporting the language requirements.

For example:

The default Java version:

``` java
public static <T> Observable<T> filter(Observable<T> that, Func1<T, Boolean> predicate)
```

A Groovy version:

``` java
public static <T> Observable<T> filter(Observable<T> that, groovy.lang.Closure predicate)
```
- A jar per language will be created as follows:
  - rxjava-x.y.z.jar 
  - rxjava-groovy-x.y.z.jar 
  - rxjava-clojure-x.y.z.jar 
  - rxjava-scala-x.y.z.jar 
  - rxjava-jruby-x.y.z.jar 
  - rxjava-kotlin-x.y.z.jar 

A project will include just the jar that meets their language needs, there will no longer be a ""core"" jar plus the language adaptor.

The drawback of this is that mixing two of these in a classpath will result in non-deterministic loading (whichever is loaded last wins) and that is the version that will be used. This means if a library depends on rxjava.jar but is using Groovy and needs rxjava-groovy.jar it is up to the developer of that project to make sure they have only the rxjava-groovy.jar version. This is not ideal but is a one-time pain setting up a build and is better than the constant pain of missing static typing or converting to/from different Observable implementations for different languages.
- At this time we are optimizing for projects using a single language or Java + another language. If there are use cases where people are trying to mix multiple languages in a very polyglot manner we have two options:
  - include an rxjava-dynamic.jar version that re-adds the Object overloads
  - include build configs for common combinations of languages such as rxjava-groovy-clojure.jar
- Language adaptations (such as clojure which has preferred idioms that necessitate wrapping) will still be possible through the language-adaptor projects and be included in the appropriate language jars.

This should not break any code but will require a slight change to the build dependencies in your project when we release this. 

We hope that this enables the RxJava project to better achieve its goal of being polyglot and targeting the JVM in general and not any specific languages without sacrificing interop or idiomatic usage in each of the languages.
",2013-08-19 05:36:56,2013-08-29 19:17:52,https://api.github.com/repos/ReactiveX/RxJava/issues/319,[],3069,2250,ReactiveX_RxJava_pull_319.diff
ReactiveX/RxJava,Initial support for scheduling on Android Handler threads,"To add to the discussion in https://github.com/Netflix/RxJava/pull/317, this is pretty much what we're using in our production app since a few weeks now. It used to live in our app project, but since we've already started talking about adding to rxjava-contrib, I've pulled out the code in question and integrated it into RxJava under rxjava-android.

This comprises:
- [x] a `Scheduler` implementation which schedules work on Android's `Handler` threads, including the main UI thread.
- [x] an `AndroidSchedulers` class which provides factory methods to instantiate Handler schedulers, especially the main thread scheduler
- [x] unit test support via Robolectric
- [x] build integration

There is some discussion needed around both test support and build integration. @mustafasezgin will want to weigh in on this. In order to write Android unit tests, you're unfortunately required to take a few obstacles, so we had to add some cruft to the production code (an empty Android `R` class and a custom test runner.)
",2013-08-14 10:35:56,2013-08-23 05:56:26,https://api.github.com/repos/ReactiveX/RxJava/issues/318,[],210,1,ReactiveX_RxJava_pull_318.diff
ReactiveX/RxJava,AndroidScheduler.java,"Initial spike for AndroidScheduler.java.

Been using this for quite some time. But I don't like the concept using calling `observer.observeOn(AndroidScheduler.getInstance())` as it sort of puts Android specific stuffs. Should RxJava support some concept of `Schedulers.mainScheduler()`? We can then set the default main schedulers using `Schedulers.setMainScheduler(AndroidScheduler.getInstance())` when app starts.
",2013-08-13 23:20:08,2013-08-15 14:26:34,https://api.github.com/repos/ReactiveX/RxJava/issues/317,[],69,0,ReactiveX_RxJava_pull_317.diff
ReactiveX/RxJava,Remove thread.sleep from unit test to speed it up,".. and apparently formatting and imports changed a bunch ...
",2013-08-01 17:33:35,2013-08-01 17:33:40,https://api.github.com/repos/ReactiveX/RxJava/issues/316,[],183,188,ReactiveX_RxJava_pull_316.diff
ReactiveX/RxJava,Change onError(Exception) to onError(Throwable) - Issue #296,"This changes `Observer#onError(Exception e)` to `Observer#onError(Throwable e)`

See ""Observer#onError should use Throwable"" https://github.com/Netflix/RxJava/issues/296 for discussion that led to this change.

This is a breaking change and will result in a version bump from 0.9.x to 0.10.x. 
",2013-08-01 04:27:40,2013-08-01 17:25:08,https://api.github.com/repos/ReactiveX/RxJava/issues/315,[],848,633,ReactiveX_RxJava_pull_315.diff
ReactiveX/RxJava,Map Error Handling,"While reviewing pull request https://github.com/Netflix/RxJava/pull/312 I noticed that the behavior of Map didn't seem right in how it continued emitting values and necessitated the changes to onErrorResumeNext. 

Digging in it seems the onNext was manually doing error handling but in a non-comprehensive manner whereas now I am letting the `SafeObserver` (previously called `AtomicObserver`) handle it which does unsubscribes and ignores subsequent events if it doesn't unsubscribe correctly.

This is also related to https://github.com/Netflix/RxJava/issues/216.
",2013-07-31 22:37:26,2013-07-31 22:37:46,https://api.github.com/repos/ReactiveX/RxJava/issues/314,[],109,76,ReactiveX_RxJava_pull_314.diff
ReactiveX/RxJava,Fix for OperatorOnErrorResumeNextViaObservable and async Resume,"This patch is to ensure that OnErrorResumeNextViaObservable handles source Observables that emit invalid sequences of onNext/onError/onCompleted.

Please see #306 for a more detailed description of how this can occur (and what other fixes might be needed)

To re-create the issue the provided resume Observable itself must be async. Because it does not complete immediately there is a window where the source Observable can produce additional events which are then propogated into the output. 

The fix ensures the operator only propogates onNext/onCompleted as long as the original subscription is valid. It also prevents the resume subscription happening more than once even if multiple onError events being received.
",2013-07-27 01:31:14,2013-07-31 21:01:02,https://api.github.com/repos/ReactiveX/RxJava/issues/312,[],54,8,ReactiveX_RxJava_pull_312.diff
ReactiveX/RxJava,Various Javadoc improvements and corrections.,"I've been exploring the rxjava source code for the last week or two in my spare time and along the way I cleaned up and made minor corrections and improvements to the Javadocs. Here's the changes if they're of interest.
",2013-07-26 05:06:28,2013-07-31 20:53:46,https://api.github.com/repos/ReactiveX/RxJava/issues/311,[],598,531,ReactiveX_RxJava_pull_311.diff
ReactiveX/RxJava,A little typo in a comment in the Clojure examples,,2013-07-22 15:30:54,2013-07-22 16:33:11,https://api.github.com/repos/ReactiveX/RxJava/issues/309,[],1,1,ReactiveX_RxJava_pull_309.diff
ReactiveX/RxJava,Ensure now() is always updated in TestScheduler.advanceTo/By,"The TestScheduler advanceTimeTo() and advanceTimeBy() methods only update now() correctly if there is a scheduled event in the work queue after the target time. If the queue is empty, now() is not updated at all. If it has no items after the target time, then now() is updated to the time of the last event on the queue.

The pull request ensures now() is always updated to the target time. There is no check to make sure time always moves forwards, but then that check is not in the current implementation either.
",2013-07-21 10:13:57,2013-07-22 16:35:26,https://api.github.com/repos/ReactiveX/RxJava/issues/308,[],1,1,ReactiveX_RxJava_pull_308.diff
ReactiveX/RxJava,Getting rid of one of the Gradle 1.6 deprecation warnings,"This PR addresses one of Gradle's new deprecation warnings.

(The other warning is caused by the LicensePlugin, as far as I can see.)
",2013-07-08 14:10:35,2013-07-22 16:35:58,https://api.github.com/repos/ReactiveX/RxJava/issues/305,[],2,2,ReactiveX_RxJava_pull_305.diff
ReactiveX/RxJava,Version 0.10.0 - Static Language Support,"Manual merge of pull https://github.com/Netflix/RxJava/pull/300 from @mattrjacobs 

This will make RxJava completely static by removing all Object overloads (see https://github.com/Netflix/RxJava/issues/208 and https://github.com/Netflix/RxJava/issues/204).

I'm submitting this before it being 100% ready so people can review and provide feedback.

Open items to append to this pull request before merging:

**1) subscribe with map is not handled yet**

The following signature needs to be made static. Right now the lack of this combined with removal of Functions.from dynamic language functionality has broken this.

``` java
public Subscription subscribe(final Map<String, Object> callbacks)
```

**2) Core artifact naming convention**

Should rxjava-core-x.y.x.jar become rxjava-x.y.z.jar since the concept of core+language no longer applies?

I think I'd prefer this:
- rxjava-x.y.z.jar 
- rxjava-groovy-x.y.z.jar 
- rxjava-clojure-x.y.z.jar 
- rxjava-scala-x.y.z.jar 
- rxjava-jruby-x.y.z.jar 
- rxjava-kotlin-x.y.z.jar 
- rxjava-dynamic-x.y.z.jar (object overload for any language)
- rxjava-groovy-clojure-x.y.z.jar (multi-language jar)

Only one of those jars is needed hence the reason why I think the 'core' term is no longer needed as it communicated the fact it was always needed.

Any contrib modules would be: rxjava-contrib-module-name-x.y.x.jar

**3) Dependencies from languages to core still exist**

The build still will result in Maven Central POM files requires rxjava-core from the language version despite that not being the case. Need to eliminate this dependency in the artifact.

---

Implementation notes originally posted at https://github.com/Netflix/RxJava/issues/204#issuecomment-20396621:

After implementing and throwing away a few different approaches we have landed on a solution we feel will balance the various competing priorities. 

Our goals are:
- support static typing for Java/Scala/Kotlin etc by removing the Object overloads
- support any JVM language, static or dynamically typed
- allow all languages to use the same `rx.Observable` class so that we don't divide libraries with helpers such as `GroovyObservable`, `ClojureObservable` etc that then need to be converted back and forth when doing interop
- do not require special classloaders or agents to enable runtime bytecode generation
- do not remove static operators to enable proxying
- small jars and limited or no dependencies

The solution we have arrived at will work as follows:
- The rxjava-core source code will delete all Object overload methods and be pure static java.
  - Any language that supports functional interfaces directly (such as Java 8 and XTend) can use the Java core version directly.
- Languages needing specific lambda/clojure type mapping to the Func_/Action_ types will have language specific Jars created via build-time bytecode generation.
  - Any method with a Func_/Action_ argument will be overloaded with a version supporting the language requirements.

For example:

The default Java version:

``` java
public static <T> Observable<T> filter(Observable<T> that, Func1<T, Boolean> predicate)
```

A Groovy version:

``` java
public static <T> Observable<T> filter(Observable<T> that, groovy.lang.Closure predicate)
```
- A jar per language will be created as follows:
  - rxjava-x.y.z.jar 
  - rxjava-groovy-x.y.z.jar 
  - rxjava-clojure-x.y.z.jar 
  - rxjava-scala-x.y.z.jar 
  - rxjava-jruby-x.y.z.jar 
  - rxjava-kotlin-x.y.z.jar 

A project will include just the jar that meets their language needs, there will no longer be a ""core"" jar plus the language adaptor.

The drawback of this is that mixing two of these in a classpath will result in non-deterministic loading (whichever is loaded last wins) and that is the version that will be used. This means if a library depends on rxjava.jar but is using Groovy and needs rxjava-groovy.jar it is up to the developer of that project to make sure they have only the rxjava-groovy.jar version. This is not ideal but is a one-time pain setting up a build and is better than the constant pain of missing static typing or converting to/from different Observable implementations for different languages.
- At this time we are optimizing for projects using a single language or Java + another language. If there are use cases where people are trying to mix multiple languages in a very polyglot manner we have two options:
  - include an rxjava-dynamic.jar version that re-adds the Object overloads
  - include build configs for common combinations of languages such as rxjava-groovy-clojure.jar
- Language adaptations (such as clojure which has preferred idioms that necessitate wrapping) will still be possible through the language-adaptor projects and be included in the appropriate language jars.

This should not break any code but will require a slight change to the build dependencies in your project when we release this. 

We hope that this enables the RxJava project to better achieve its goal of being polyglot and targeting the JVM in general and not any specific languages without sacrificing interop or idiomatic usage in each of the languages.
",2013-07-05 23:42:14,2013-08-20 21:07:20,https://api.github.com/repos/ReactiveX/RxJava/issues/304,[],1907,2281,ReactiveX_RxJava_pull_304.diff
ReactiveX/RxJava,Pull 267 - Merge combineLatest,"Spent some time reviewing it and it seems good. Any bugs can be dealt with as people start playing with it instead of me holding this up as a pull request any longer since this exposes `combineLatest` in `Observable` for I believe the first time and is thus a low risk to breaking any existing users.
",2013-07-05 22:03:13,2013-07-05 22:03:20,https://api.github.com/repos/ReactiveX/RxJava/issues/303,[],125,96,ReactiveX_RxJava_pull_303.diff
ReactiveX/RxJava,"Update Observable.isInternalImplementation, get rid of NullPointerExcept...","...ion

NullPointerException has been encountered during my tests. It is because java.lang.Class.getPackage() may return null ""... if no package information is available from the archive or codebase"" (documented feature).
",2013-07-04 21:02:01,2013-07-05 21:15:35,https://api.github.com/repos/ReactiveX/RxJava/issues/302,[],2,1,ReactiveX_RxJava_pull_302.diff
ReactiveX/RxJava,"Type-safety in rxjava-core, dynamic language support via compile-time code generation, and Scala support via implicits","Implementation of ideas here: https://groups.google.com/forum/#!topic/rxjava/g6Z9KyMM8zs

This addresses #204 and #208 .
",2013-07-04 06:34:16,2013-07-05 23:43:43,https://api.github.com/repos/ReactiveX/RxJava/issues/300,[],1834,2048,ReactiveX_RxJava_pull_300.diff
ReactiveX/RxJava,"Make ScheduledSubscription public, expose scheduler field","As proposed in issue #293

This will make it easier to verify proper scheduling behavior of services implemented using rx.
",2013-06-17 17:32:22,2013-07-05 21:28:54,https://api.github.com/repos/ReactiveX/RxJava/issues/294,[],31,20,ReactiveX_RxJava_pull_294.diff
ReactiveX/RxJava,Kotlin Language Adaptor,"Langauge adaptor for kotlin
",2013-06-08 06:21:13,2013-09-03 22:11:10,https://api.github.com/repos/ReactiveX/RxJava/issues/292,[],508,0,ReactiveX_RxJava_pull_292.diff
ReactiveX/RxJava,Issue 103,"Adding the zip operator that works on collection of Observables and a FuncN.

https://github.com/Netflix/RxJava/issues/103
",2013-06-05 23:49:07,2013-07-05 21:30:02,https://api.github.com/repos/ReactiveX/RxJava/issues/290,[],142,0,ReactiveX_RxJava_pull_290.diff
ReactiveX/RxJava,Fixes on #284 (groupBy),"See my previous [comment](https://github.com/Netflix/RxJava/issues/282#issuecomment-19013992).
",2013-06-05 22:43:33,2013-12-06 01:03:16,https://api.github.com/repos/ReactiveX/RxJava/issues/289,[],224,64,ReactiveX_RxJava_pull_289.diff
ReactiveX/RxJava,Fix PublishSubject non-deterministic behavior on concurrent modification,"- changed to take snapshot of observers.values() before iterating in onNext/onError/onCompleted so that nested subscriptions that add to observers can't change the values() iteration
- single-threaded nested subscriptions are now deterministic
- multi-threaded subscriptions will no longer be allowed to race to get into an interating onNext/onError/onCompleted loop, they will always wait until the next
- also improved terminal state behavior when subscribing to a PublishSubject that has already received onError/onCompleted

https://github.com/Netflix/RxJava/issues/282
",2013-06-04 06:40:11,2013-06-05 04:30:43,https://api.github.com/repos/ReactiveX/RxJava/issues/288,[],208,9,ReactiveX_RxJava_pull_288.diff
ReactiveX/RxJava,Error handling and validation,"Refactoring related to arg validation and error handling.

https://github.com/Netflix/RxJava/issues/198 Throw if no onError handler specified
https://github.com/Netflix/RxJava/issues/278 Subscribe argument validation
",2013-06-03 22:54:42,2013-06-04 06:45:01,https://api.github.com/repos/ReactiveX/RxJava/issues/287,[],205,51,ReactiveX_RxJava_pull_287.diff
ReactiveX/RxJava,Several new or more-precise marble diagrams,"Add several new or more-specific marble diagrams, correct two bad image
links, correct some typos
",2013-06-03 18:43:19,2013-06-03 23:08:46,https://api.github.com/repos/ReactiveX/RxJava/issues/285,[],126,29,ReactiveX_RxJava_pull_285.diff
ReactiveX/RxJava,GroupBy fixes as reported in Issue 282,"Issue https://github.com/Netflix/RxJava/issues/282
- Refactored to maintain a single subscription that propagates events to the correct child GroupedObservables.
- make unsubscribe work correctly for parent/child sequences
- add language adaptor support
",2013-06-02 04:25:14,2013-06-05 04:37:50,https://api.github.com/repos/ReactiveX/RxJava/issues/284,[],509,62,ReactiveX_RxJava_pull_284.diff
ReactiveX/RxJava,GroupBy GroupedObservables should not re-subscribe to parent sequence,"https://github.com/Netflix/RxJava/issues/282

Refactored to maintain a single subscription that propagates events to the correct child GroupedObservables.
",2013-05-31 22:38:51,2013-06-02 04:25:27,https://api.github.com/repos/ReactiveX/RxJava/issues/283,[],438,62,ReactiveX_RxJava_pull_283.diff
ReactiveX/RxJava,Operation: buffer,"The buffer operation is an operation which allows you to buffer incoming events into one or more buffers. Depending on their purpose, these buffers can be emitted to an `Observer` when needed. In essence this means that events are collected and propagated to the `Observer` in batches. The [original issue](https://github.com/Netflix/RxJava/issues/16), which this pull request addresses, mentions a total of 10 variations on this operator. This pull request contains code which supports all of them.

![buffer](https://f.cloud.github.com/assets/4491168/731348/2f076cc8-e269-11e2-8fa8-e798f04f2f3c.png)

The 10 variations which exist in Rx .Net, can be subdivided into two categories: single and multi buffers. With single buffers, only one buffer at any time is actively collecting incoming events, whereas with multi buffers, multiple buffers are actively collecting incoming events. In the first case the `Observer` will receive every original event only once in one buffer, whereas in the latter case, the `Observer` will receive every original event zero or more times.
### Single buffers
##### buffer(bufferClosingSelector)

The bufferClosingSelector parameter is a `Func0<Observable<BufferClosing>>`. It uses to `Func0` object to construct an `Observable` which produces a `BufferClosing` object. Once this object has been produced by the `Observable` the currently active buffer will be closed and emitted to the `Observer`. At the same time a new buffer will be created which will start recording incoming events. 
##### buffer(count)

This operator closes and emits the current buffer after counting a certain amount of received events. At the same time it will create a new buffer which will start recording incoming events. One example would be `buffer(2)`, which with the following input: `[0, 1, 2, 3, 4, 5]` will output the following buffers: `[0, 1], [2, 3], [4, 5]`.
##### buffer(timespan)

This operator closes and emits the current buffer after a certain amount of time has elapsed. At the same time it will create a new buffer which will start recording incoming events.
##### buffer(timespan, scheduler)

Same as previous operator, but now with a custom scheduler.
##### buffer(timespan, count)

This operator closes and emits the current buffer after counting a certain amount of received events or after a certain amount of time has elapsed. At the same time it will create a new buffer which will start recording incoming events.
##### buffer(timespan, count, scheduler)

Same as previous operator, but now with a custom scheduler.
### Multiple buffers
##### buffer(count, skip)

This operator will create a new buffer after it has received 'skip' amount of events. Each buffer will be closed once it has reached a capacity of '[count'. One example would be `buffer(3, 1)`, which with the following input: `0, 1, 2, 3, 4, 5]`, will output the following buffers: `[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]`.
##### buffer(bufferOpenings, bufferClosingSelector)

This operator takes two parameters: an `Observable<BufferOpening>` and a `Func1<BufferOpening, Observable<BufferClosing>>`. The first parameter determines when buffers are created. The second parameter determines when the buffers are closed. Every time a `BufferOpening` object is received from the `Observable` a new buffer is created. The received `BufferOpening` object is fed into the second parameter which yields an `Observable<BufferClosing>` object. When this `Observable` produces a `BufferClosing` object, the associated buffer is closed and emitted.
##### buffer(timespan, timeshift)

This operator is very similar to `buffer(count, skip)`, but in stead of counting events, it's based on time. The `timeshift` period defines how often a new buffer will be created. The `timespan` period defines the period between buffer construction and buffer emission.
##### buffer(timespan, timeshift, scheduler)

Same as previous operator, but now with a custom scheduler.

As always, **feedback is welcome!**
",2013-05-29 22:02:30,2013-07-22 16:55:22,https://api.github.com/repos/ReactiveX/RxJava/issues/281,[],1614,0,ReactiveX_RxJava_pull_281.diff
ReactiveX/RxJava,Diagrams and some new javadoc content for Observable subclasses,"Some marble or marblish diagrams and a bit of new documentation for the
BlockingObservable and ConnectableObservable subclasses.
",2013-05-28 20:36:51,2013-05-28 20:40:58,https://api.github.com/repos/ReactiveX/RxJava/issues/280,[],52,0,ReactiveX_RxJava_pull_280.diff
ReactiveX/RxJava,Adding marble diagrams,"several new marble diagrams for previously undiagrammed methods
",2013-05-28 20:12:12,2013-05-28 20:15:44,https://api.github.com/repos/ReactiveX/RxJava/issues/279,[],92,2,ReactiveX_RxJava_pull_279.diff
ReactiveX/RxJava,Move forEach to BlockingObservable,"- was missed in previous refactoring
",2013-05-16 23:07:25,2013-05-16 23:07:31,https://api.github.com/repos/ReactiveX/RxJava/issues/275,[],157,141,ReactiveX_RxJava_pull_275.diff
ReactiveX/RxJava,0.9 cleanup,,2013-05-16 22:54:38,2013-05-16 22:54:43,https://api.github.com/repos/ReactiveX/RxJava/issues/274,[],142,77,ReactiveX_RxJava_pull_274.diff
ReactiveX/RxJava,Concat,"Add new unit test to cover non-blocking subscribe() for Concat operator.
",2013-05-15 23:36:53,2013-05-16 16:23:16,https://api.github.com/repos/ReactiveX/RxJava/issues/273,[],154,80,ReactiveX_RxJava_pull_273.diff
ReactiveX/RxJava,BlockingObservable,"Move all blocking operators to `BlockingObservable`. This has breaking changes for anything using blocking operators ... part of the pursuit of establishing a clean API on our path to 1.0.

This is something I've been wanting to do for a while but got the push over the ledge via discussion at https://github.com/Netflix/RxJava/issues/270.

This strays from ""match Rx.Net as closely as possible"" but feels justified for the following reasons:
- Rx is primarily intended for asynchronous event handling and composition
- mixing blocking and non-blocking operators is confusing and leads to poor usage patterns
- mixing blocking operators (like `take` and `takeLast` is non-obvious)
- Rx.Net intends on deprecating (or has already) blocking operators as per Erik Meijer @headinthebox in this discussion: https://github.com/Netflix/RxJava/issues/270#issuecomment-17882444 

I have removed all blocking operators from `Observable` and put them in `BlockingObservable`. I have left `Observable.toBlockingObservable` as a means of going from one to the other as it is an obvious communication of what is now being permitted. 

While doing this I also cleaned up some odd API artifacts such as `toObservable` vs `from` and moved implementation specific code from `rx.util` into the internal package `rx.operators` where all code reserves the right to change at any time.

I intend on releasing this as version 0.9.
",2013-05-14 21:09:00,2013-05-16 16:22:39,https://api.github.com/repos/ReactiveX/RxJava/issues/272,[],970,866,ReactiveX_RxJava_pull_272.diff
ReactiveX/RxJava,Rewrite concat operation to not block on subscribe,"Hi,
While trying to stop the subscribe function from blocking, I ended up rewriting the most of the concat operation. From related issue discussions it appears the desired behaviour is still under debate, so I hope you agree on the chosen approach. See the explanation below.
Because practically it implements two asynchronous observers that interact with eachother, there are quite a few possible race conditions and other possibilities to break the Rx grammar, but I hope I fixed all of them.
Regards,

Gerben

The concat operator previously blocked on calling subscribe until all the
sequences had finished. In quite some cases this results in unwanted (and
unexpected) behaviour, such as when prefixing an infinite Observable
with a fixed one, for example when using startWith (which calls concat):
`someInputStream.startWith(123).subscribe(x -> print(x));`
This statement will block indefinitely if the input stream is infinite. Also
on finite sequences it seems silly to have to wait for them to finish.

In this new approach the incoming observables are put into a queue, instead
of waiting for the whole sequence to finish. When the first observable
completes, the next one is taken from the queue and subscribed to, and so
on. The queue can be extended while processing the observables, and
onCompleted is only called when both the source of observables has completed
and all observables in the queue have been read.
",2013-05-14 20:53:36,2013-05-16 16:23:18,https://api.github.com/repos/ReactiveX/RxJava/issues/271,[],88,79,ReactiveX_RxJava_pull_271.diff
ReactiveX/RxJava,Fix concurrency bug in ScheduledObserver,"This is a followup to https://github.com/Netflix/RxJava/commit/1fa6ae3be23200c787cc1c25c0bb8cac99ae0d17 that fixed one issue (concurrency) and created another (broke Rx contract by allowing concurrent execution of onNext).

I have reverted back to the previous implementatio and then attempted to fix the concurrency issue again.

I think it ended up being a simple fix … just re-ordering the `enqueue` method to remove the race-condition between the logic protected by the AtomicInteger and adding to the queue.

It's not an atomic operation (adding then processing) so we need to just add to the queue and treat it as an async data structure and keep the AtomicInteger portion to only protecting the ""process or not process"" logic.

``` java
        // this must happen before 'counter' is used to provide synchronization between threads
        queue.offer(notification);
```

This may still have issues but it's now working in all of my concurrency tests (the ones that broken with the original and then my modified version). The tests are not easy to build unit tests out of as they require running for many seconds and non-deterministically causing a race condition so I have not yet spend the time to try and figure out a deterministic unit test hence them not being committed.
",2013-05-11 14:02:13,2013-05-11 14:10:25,https://api.github.com/repos/ReactiveX/RxJava/issues/269,[],43,26,ReactiveX_RxJava_pull_269.diff
ReactiveX/RxJava,Fix concurrency bug in ScheduledObserver,"- found a concurrency bug while working on https://github.com/Netflix/Hystrix/issues/123
- the following code would lock up occasionally due to onCompleted not being delivered:

``` java
public class RunTest {
    public static void main(String[] args) {
        System.out.println(""Starting test..."");

        final ArrayList<String> strings = new ArrayList<String>(200000);

        int num = 10000;
        while (true) {
            long start = System.currentTimeMillis();
            final AtomicInteger count = new AtomicInteger();
            for (int i = 0; i < num; i++) {
                new TestService1(2, 5).toObservable().forEach(new Action1<Integer>() {

                    @Override
                    public void call(Integer v) {
                        count.addAndGet(v);
                    }
                });

                new TestService2(""hello"").toObservable().forEach(new Action1<String>() {

                    @Override
                    public void call(String v) {
                        strings.add(v);
                    }

                });
            }
            long time = (System.currentTimeMillis() - start);
            long executions = num * 2;
            System.out.println(""Time: "" + time + ""ms for "" + executions + "" executions ("" + (time * 1000) / executions + "" microseconds)"");
            System.out.println(""   Count: "" + count);
            System.out.println(""   Strings: "" + strings.size());
            strings.clear();
        }
    }
}
```
- Also made OperationObserveOn not use ScheduledObserver if the `ImmediateScheduler` is chosen to allow an optimization. I believe this optimization is safe because ScheduledObserver does not require knowledge of a Scheduler (such as for now()) and all we do is emit data to the Observer on a scheduler and if we know it's Immediate we can go direct and skip the enqueuing step. This allows shaving off a noticable number of microseconds per execution in the loop above.
",2013-05-10 20:22:03,2013-05-10 20:22:17,https://api.github.com/repos/ReactiveX/RxJava/issues/268,[],37,45,ReactiveX_RxJava_pull_268.diff
ReactiveX/RxJava,CombineLatest without synchronization,"Finally, I managed to get rid of all the synchronization in `CombineLatest` (it all boils down to two atomics and one concurrent map). As concurrency is always hairy to get right: Can someone please check that it's okay like that?

I also added static methods to `Observable` for it, and fixed the handling of exceptions within the combining function.

Usage is (though non-asynchronous source observables don't make sense, I use these here in order to keep the example simple):

``` java
Observable<Integer> o1 = Observable.from(1, 2, 3);
Observable<Integer> o2 = Observable.from(4, 5, 6);
Observable<Integer> r = Observable.combineLatest(o1, o2, new Func2<Integer, Integer, Integer>() {
  @Override Integer call(Integer a, Integer b) {
    return a + b;
  }
});
```
",2013-05-09 15:04:29,2013-07-05 22:03:20,https://api.github.com/repos/ReactiveX/RxJava/issues/267,[],123,90,ReactiveX_RxJava_pull_267.diff
ReactiveX/RxJava,change from junit to junit-dep,"- removes Hamcrest dependencies (http://saltnlight5.blogspot.com/2012/10/whats-up-with-junit-and-hamcrest.html)
- solves conflicts on our CI server (blocking release to Maven Central)
",2013-05-07 22:06:07,2013-05-07 22:06:11,https://api.github.com/repos/ReactiveX/RxJava/issues/266,[],6,6,ReactiveX_RxJava_pull_266.diff
ReactiveX/RxJava,Swing - component event observables and minor cleanup,"Here's another small pull request concerning the Swing contrib. - With this, I think I'm very well equipped to start with my little Swing Pong demo...
",2013-05-07 20:58:32,2013-05-07 22:00:34,https://api.github.com/repos/ReactiveX/RxJava/issues/265,[],166,15,ReactiveX_RxJava_pull_265.diff
ReactiveX/RxJava,Merge BehaviorSubject from Pull 256,"Manual merge of https://github.com/Netflix/RxJava/pull/256 

Additionally removes SynchronizedObserver usage from Subject implementations.
- We don't need to add synchronization as the subjects can trust their source Observables to comply with the Rx contract.
- This optimization follows Rx Design Guidelines 6.8. Avoid serializing operators

This was discussed at https://github.com/Netflix/RxJava/pull/256
",2013-05-07 16:17:26,2013-05-07 16:19:11,https://api.github.com/repos/ReactiveX/RxJava/issues/264,[],266,9,ReactiveX_RxJava_pull_264.diff
ReactiveX/RxJava,"Publish, Replay and Cache Operators","(Redo of https://github.com/Netflix/RxJava/pull/260 after merging)

Added basic Publish (https://github.com/Netflix/RxJava/issues/15) and Replay (https://github.com/Netflix/RxJava/issues/71) operators to Observable. I have not done any of the overloads (particularly `Replay` which has 10+ in .Net.

I also added a new `Cache` operator as discussed by @johngmyers and I at https://github.com/Netflix/RxJava/pull/209.

Playing with `Replay` and `ConnectableObservable` it does not cater well to the typical use case of needing to just de-dupe calls (cache the responses) so this `Cache` operator can be thought of as an automatic version of `Replay`. It comes with the same risk as `toList` if used with infinite or very large sequences as you can not unsubscribe from it.
",2013-05-07 14:49:10,2013-05-07 14:53:54,https://api.github.com/repos/ReactiveX/RxJava/issues/263,[],390,25,ReactiveX_RxJava_pull_263.diff
ReactiveX/RxJava,A few basic Swing observables,"This adds a few observables for observing common button click, keyboard and mouse events.
",2013-05-07 14:09:41,2013-05-07 15:37:01,https://api.github.com/repos/ReactiveX/RxJava/issues/262,[],491,0,ReactiveX_RxJava_pull_262.diff
ReactiveX/RxJava,Multicast: `Observable.publish()`,"A very little API addition: publishing observables without requiring a `Subject`. See #65 (and http://northhorizon.net/2011/sharing-in-rx/).
",2013-05-07 13:56:59,2013-05-07 14:23:02,https://api.github.com/repos/ReactiveX/RxJava/issues/261,[],15,0,ReactiveX_RxJava_pull_261.diff
ReactiveX/RxJava,"Publish, Replay and Cache Operators","Added basic Publish (https://github.com/Netflix/RxJava/issues/15) and Replay (https://github.com/Netflix/RxJava/issues/71) operators to Observable. I have not done any of the overloads (particularly `Replay` which has 10+ in .Net.

I also added a new `Cache` operator as discussed by @johngmyers and I at https://github.com/Netflix/RxJava/pull/209.

Playing with `Replay` and `ConnectableObservable` it does not cater well to the typical use case of needing to just de-dupe calls (cache the responses) so this `Cache` operator can be thought of as an automatic version of `Replay`. It comes with the same risk as `toList` if used with infinite or very large sequences as you can not unsubscribe from it.
",2013-05-07 07:35:16,2013-05-07 14:54:24,https://api.github.com/repos/ReactiveX/RxJava/issues/260,[],390,16,ReactiveX_RxJava_pull_260.diff
ReactiveX/RxJava,Added the switch operator to Observable,"I've implemented the switch operator for `Observable` sequences (see issue #13). Because ""switch"" is a keyword in Java I have opted for switchDo. This matches to the finallyDo method which represents the finally operator and has the same naming problem. 

Please let me know if you have any feedback.
",2013-05-05 23:34:22,2013-05-16 19:16:25,https://api.github.com/repos/ReactiveX/RxJava/issues/259,[],422,0,ReactiveX_RxJava_pull_259.diff
ReactiveX/RxJava,Operation: throttle,"The throttle operation is a filtering operator which is meant to combat receiving bursts of events in short periods of time. The original Rx .Net implementation of this operator works as followed:

Upon receiving an event A, it waits a certain specified amount of time Z before propagating it to the `Observer`. If another event B is received within this period of time, the propagation of A is cancelled, and B will be propagated in stead as soon as a Z amount of time has passed since B was received.

As @benjchristensen already mentioned, the use of threads in this way is quite inefficient. To this end I proposed two additional variations on this scheme of throttling [here](https://github.com/Netflix/RxJava/pull/258#issuecomment-17880627). The question now is which schemes do we want (to support)?

Any thoughts on this is highly appreciated!
",2013-05-05 09:00:10,2013-09-11 16:53:17,https://api.github.com/repos/ReactiveX/RxJava/issues/258,[],357,5,ReactiveX_RxJava_pull_258.diff
ReactiveX/RxJava,"Improved scan, reduce, aggregate","`scan` is currently restricted to accumulators of type `Func2<T, T, T>` where `Func2<R, T, R>` would be possible for initial values of type `R`. This pull request tries to fix this by generalizing the `scan` implementation. I had to restructure the scan operator a bit for this to stay typesafe. Imho it's more readable now, though.

This indirectly leads to generalized `reduce`, too.

Also, `aggregate` is added as an alias for `reduce` (see #20).
",2013-05-04 13:35:41,2013-05-07 14:04:57,https://api.github.com/repos/ReactiveX/RxJava/issues/257,[],201,244,ReactiveX_RxJava_pull_257.diff
ReactiveX/RxJava,Created the initial implementation of BehaviorSubject,"I've been trying to implement the BehaviorSubject. Functionally it works as it should, but I'm not entirely happy with the static `createWithDefaultValue(T)` method. I can't create a static method `create(T)` because Subject extends Observable, which has a static `create(Object)` method. So to resolve that I had to give the static method in BehaviorSubject a different name.

Additionally I'm using an `AtomicReference<T>` in this static method to keep track of the last published value. I tried coming up with different solutions to push the last published value to the Observer when it's subscribing, but this seems to be the most clean solution.

If there's any feedback on either issue, please let me know.
",2013-05-03 23:19:49,2013-05-07 16:19:12,https://api.github.com/repos/ReactiveX/RxJava/issues/256,[],264,0,ReactiveX_RxJava_pull_256.diff
ReactiveX/RxJava,Cleaning up - fixing a lot of build warnings (mostly javadoc),"I'm not good at ignoring warnings... - there are lots of them in the build output, mostly due to invalid javadoc link syntax or missing `@return` descriptions.

This is my attempt at fixing them.
",2013-05-02 18:47:39,2013-05-06 20:14:13,https://api.github.com/repos/ReactiveX/RxJava/issues/255,[],83,74,ReactiveX_RxJava_pull_255.diff
ReactiveX/RxJava,Swing scheduler,"I've added a Swing-specific scheduler to RxJava. However, it probably doesn't belong to `rxjava-core` and therefore, I've created a subfolder named `extensions` with currently one single subproject `rxjava-swing` with currently one single class `SwingScheduler`.

I've tried to create a build for this, too, but I'm not very familiar with Gradle, so somebody should probably check that it's okay like this.

Also, I'm not very happy with the subfolder name (`extensions`). Maybe somebody has a better idea for a more specific name?
",2013-05-02 11:21:11,2013-05-06 20:12:50,https://api.github.com/repos/ReactiveX/RxJava/issues/254,[],318,1,ReactiveX_RxJava_pull_254.diff
ReactiveX/RxJava,Fix multiple subscription bug on operation filter,"A new subscription must be created on every subscribe call, otherwise any
subscribe call after the first directly fails.
",2013-05-01 20:16:53,2013-05-01 20:48:19,https://api.github.com/repos/ReactiveX/RxJava/issues/253,[],1,1,ReactiveX_RxJava_pull_253.diff
ReactiveX/RxJava,Observable.toFuture,,2013-05-01 04:49:45,2013-05-01 04:56:04,https://api.github.com/repos/ReactiveX/RxJava/issues/252,[],208,10,ReactiveX_RxJava_pull_252.diff
ReactiveX/RxJava,Initial implementation of AsyncSubject,"I've done some work on AsyncSubject<T>, including unit tests and I'm looking for feedback. 

I don't expect to get this pull request immediately accepted. But I hope to find out if this is the correct workflow for this repository, and if the code is up to your standards, before I start pouring in more hours into issue #17. If you guys are ok with the AsyncSubject<T> implementation I'll start working on the others.

Looking forward to some feedback!
",2013-04-28 20:15:22,2013-05-01 05:04:40,https://api.github.com/repos/ReactiveX/RxJava/issues/250,[],253,0,ReactiveX_RxJava_pull_250.diff
ReactiveX/RxJava,Timestamp operation,"Straightforward implementation of issue #93, based on `OperationMap` (without the scheduler version, as `map` doesn't take a scheduler yet either).
",2013-04-28 17:53:01,2013-05-01 20:51:44,https://api.github.com/repos/ReactiveX/RxJava/issues/249,[],156,0,ReactiveX_RxJava_pull_249.diff
ReactiveX/RxJava,Implemented Sample Operation,"Now that `OperationInterval` is in, `OperationSample` (see  #74) was kind of straightforward. I also added a unit test against sampling, and allowed for specifying a scheduler used by the sample operation.
",2013-04-27 20:06:54,2013-05-01 20:49:18,https://api.github.com/repos/ReactiveX/RxJava/issues/248,[],256,0,ReactiveX_RxJava_pull_248.diff
ReactiveX/RxJava,Add flatMap alias to mapMany,"This is to match with what Java 8 is adding to Stream so we support the duality of Iterable/Collection to Observable.

http://download.java.net/lambda/b86/docs/api/java/util/stream/Stream.html#flatMap(java.util.function.Function)
",2013-04-26 21:10:08,2013-05-01 04:50:14,https://api.github.com/repos/ReactiveX/RxJava/issues/247,[],123,10,ReactiveX_RxJava_pull_247.diff
ReactiveX/RxJava,Scheduling actions periodically,"As proposed earlier by @mairbek in https://github.com/Netflix/RxJava/pull/228#issuecomment-16254526, I extended the `Scheduler` by yet another method `schedulePeriodically`. This has a default implementation that works via recursion. I tried it out with all existing schedulers, and it seems to work fine. I also wrote a unit test for it using the `TestScheduler`.

I switched scheduled executor services to use their fixed rate scheduling instead of the recursive default implementation. And I also switched the `OperationInterval` implementation to use periodic scheduling.
",2013-04-26 13:50:08,2013-05-01 04:55:54,https://api.github.com/repos/ReactiveX/RxJava/issues/246,[],231,36,ReactiveX_RxJava_pull_246.diff
ReactiveX/RxJava,Moved state from Observable to Observer,,2013-04-23 11:34:46,2013-05-01 04:51:00,https://api.github.com/repos/ReactiveX/RxJava/issues/245,[],64,45,ReactiveX_RxJava_pull_245.diff
ReactiveX/RxJava,Pre 0.8.0 Release Changes,"Some cleanup before releasing.
",2013-04-19 15:58:02,2013-04-19 18:50:27,https://api.github.com/repos/ReactiveX/RxJava/issues/244,[],51,30,ReactiveX_RxJava_pull_244.diff
ReactiveX/RxJava,ReplaySubject - Manual Merge of Pull 218,"Manual merge of ReplaySubject from pull request https://github.com/Netflix/RxJava/pull/218
- merged DefaultSubject and PublishedSubject which were the same thing (lots more unit tests though from this pull request)
- still not sure what the right name is for DefaultSubject/PublishSubject
- renamed RepeatSubject to ReplaySubject to match .Net
- tweaked unit tests with InOrder while reviewing them to understand behavior
- moved UnsubscribeTester into a package private class as I'm still undecided on long-term placement of this and the OperatorTester class
",2013-04-18 20:20:47,2013-04-18 20:21:47,https://api.github.com/repos/ReactiveX/RxJava/issues/241,[],746,8,ReactiveX_RxJava_pull_241.diff
ReactiveX/RxJava,Update TestScheduler to match merged Scheduler changes,"- I accidentally merged this code before fixing it to match the changes to AbstractScheduler/Scheduler
",2013-04-18 19:41:34,2013-04-18 19:41:44,https://api.github.com/repos/ReactiveX/RxJava/issues/240,[],43,36,ReactiveX_RxJava_pull_240.diff
ReactiveX/RxJava,CurrentThreadScheduler Delayed Execution Fix,"Added unit tests for the delayed execution for `CurrentThreadScheduler`.
Re-implemented queueing in order to make those tests pass.
",2013-04-18 18:07:46,2013-04-18 19:06:20,https://api.github.com/repos/ReactiveX/RxJava/issues/239,[],106,27,ReactiveX_RxJava_pull_239.diff
ReactiveX/RxJava,ScheduledObserver/ObserveOn - Manual Merge of Pull 234,"Manual merge of https://github.com/Netflix/RxJava/pull/234 with some unit test tweaks and additions.
",2013-04-18 17:41:12,2013-04-18 17:47:01,https://api.github.com/repos/ReactiveX/RxJava/issues/238,[],223,21,ReactiveX_RxJava_pull_238.diff
ReactiveX/RxJava,Implement ConnectableObservable and Observable.publish,"Hi,
I hope you appreciate this implementation. Most of it is a quite straightforward mimic of the .NET version. Could you perhaps verify if I used the lock and the subscription wrapper correctly?

Following the behaviour of the .NET Rx implementation, a ConnectableObservable
consists of a Subject that can be connected to its source Observable by calling
the connect() method. The Observable.publish() method can be used to create a
new ConnectableObservable for the given Observable.

Greetings,
Gerben
",2013-04-18 16:55:21,2013-04-19 21:08:14,https://api.github.com/repos/ReactiveX/RxJava/issues/237,[],91,0,ReactiveX_RxJava_pull_237.diff
ReactiveX/RxJava,Fixed Sleeping Action,"Sleeping action wasn't working correctly.
",2013-04-17 10:30:23,2013-04-18 17:29:29,https://api.github.com/repos/ReactiveX/RxJava/issues/236,[],7,3,ReactiveX_RxJava_pull_236.diff
ReactiveX/RxJava,Schedulers Interface (Merging and Adding to Pull Request 229),"Merging and adding to pull request https://github.com/Netflix/RxJava/pull/229 from @jmhofer which adds functionality discussed in the Scheduler issue https://github.com/Netflix/RxJava/issues/19

Work done in https://github.com/Netflix/RxJava/pull/229 added the following methods to `Scheduler`:
- `Subscription schedule(T state, Func2<Scheduler, T, Subscription> action, long delayTime, TimeUnit unit)`
- `Subscription schedule(T state, Func2<Scheduler, T, Subscription> action)`

These are in fact the primary methods from RxNet (http://msdn.microsoft.com/en-us/library/hh211963(v=vs.103).aspx) and the others are just helper overloads.

It seems beneficial to use these 2 methods for actual implementation logic while all other methods are just decorating and forwarding from AbstractScheduler to these methods.

I propose these changes on top of pull request https://github.com/Netflix/RxJava/pull/229 to achieve this.

I also added unit tests that @mairbek created (https://github.com/Netflix/RxJava/pull/229#issuecomment-16115941).

All unit tests are passing … but we don't yet have enough unit test coverage so I won't be surprised if bugs are found.
",2013-04-17 05:44:35,2013-04-18 16:11:13,https://api.github.com/repos/ReactiveX/RxJava/issues/235,[],672,162,ReactiveX_RxJava_pull_235.diff
ReactiveX/RxJava,ScheduledObserver Ordering,"Fixing issue #233.
Blocking solution for now, thinking about non-blocking alternatives.
",2013-04-16 14:33:49,2013-04-18 17:47:04,https://api.github.com/repos/ReactiveX/RxJava/issues/234,[],72,20,ReactiveX_RxJava_pull_234.diff
ReactiveX/RxJava,Corrected naming,"Renamed `Operator` to `Operation` to be consistent.
",2013-04-14 19:29:47,2013-04-16 20:08:04,https://api.github.com/repos/ReactiveX/RxJava/issues/232,[],10,10,ReactiveX_RxJava_pull_232.diff
ReactiveX/RxJava,Multicast,"Implemented Multicast operation, working on issue #65.
",2013-04-12 14:40:31,2013-04-18 19:08:55,https://api.github.com/repos/ReactiveX/RxJava/issues/231,[],462,119,ReactiveX_RxJava_pull_231.diff
ReactiveX/RxJava,An unsubscribed AtomicObservableSubscription.wrap() unsubscribes its argument,"Fixes #210
",2013-04-10 03:02:20,2013-04-16 20:16:22,https://api.github.com/repos/ReactiveX/RxJava/issues/230,[],32,9,ReactiveX_RxJava_pull_230.diff
ReactiveX/RxJava,Trying to extend the Scheduler interface according to the comments at,"I've tried to extend the `Scheduler` interface according to the discussion at issue #19. If I understand this correctly, most of it can be done via the `AbstractScheduler`.

I hope this helps. Please have a look.
",2013-04-09 14:01:45,2013-04-18 16:11:16,https://api.github.com/repos/ReactiveX/RxJava/issues/229,[],103,0,ReactiveX_RxJava_pull_229.diff
ReactiveX/RxJava,Interval,"I have attempted to implement the ""Interval"" operator (#55) here. As far as I can see, it seems to work. This is based on the quite fresh work on schedulers.

It doesn't work with the `currentThread` or `newThread` schedulers, I guess due to the simple `SleepingAction`. It does work with a `ScheduledExecutorService`, though.

For testing this conveniently, I also wrote a test scheduler with adjustable time.

Looking forward to any review comments.
",2013-04-08 22:12:02,2013-04-18 19:11:04,https://api.github.com/repos/ReactiveX/RxJava/issues/228,[],234,0,ReactiveX_RxJava_pull_228.diff
ReactiveX/RxJava,Merge overload - possibility A,"A possible implementation of scheduler overloads on the merge operator.

Related to Schedulers pulled in https://github.com/Netflix/RxJava/pull/225 and issue https://github.com/Netflix/RxJava/issues/19
",2013-04-05 20:31:48,2013-04-16 20:16:44,https://api.github.com/repos/ReactiveX/RxJava/issues/227,[],196,3,ReactiveX_RxJava_pull_227.diff
ReactiveX/RxJava,Merge overload - possibility B,"A possible implementation of scheduler overloads on the merge operator.

Related to Schedulers pulled in https://github.com/Netflix/RxJava/pull/225 and issue https://github.com/Netflix/RxJava/issues/19
",2013-04-05 20:31:03,2013-04-16 20:16:49,https://api.github.com/repos/ReactiveX/RxJava/issues/226,[],183,4,ReactiveX_RxJava_pull_226.diff
ReactiveX/RxJava,Schedulers (merge of pull #199),"Manual merge of https://github.com/Netflix/RxJava/pull/199 by @mairbek plus the following changes:
- made some classes non-public so they don't become part of the published API (if we find they have value in the public API we can make them so but once published it's hard to remove them so I'd rather keep them implementation details until then)
- consolidated ExecutorScheduler and ScheduledExecutorScheduler
- made ExecutorScheduler use a system-wide ScheduledExecutorScheduler for handling delayed events when only an Executor is available
- made the IOThreadPool use a non-bounded cached thread-pool 

Next step from here is to review all operator implementations and add the Scheduler overloads.
",2013-04-05 04:32:48,2013-04-05 20:19:18,https://api.github.com/repos/ReactiveX/RxJava/issues/225,[],1448,4,ReactiveX_RxJava_pull_225.diff
ReactiveX/RxJava,RxJavaObservableExecutionHook,"Allow a plugin to intercept invocations of an Observable via its subscribe method.

Use cases:
- extra logging or metrics for start, return and error events when subscribing
- decorate (or replace) an 'onSubscribe' function with additional behavior
- decorate an Exception
- decorate a Subscription

This is modeled after Hystrix Plugins: http://netflix.github.com/Hystrix/javadoc/index.html?com/netflix/hystrix/strategy/executionhook/HystrixCommandExecutionHook.html

Javadocs will be at http://netflix.github.com/RxJava/javadoc/
",2013-04-04 22:16:37,2013-04-04 22:23:01,https://api.github.com/repos/ReactiveX/RxJava/issues/224,[],216,15,ReactiveX_RxJava_pull_224.diff
ReactiveX/RxJava,Concat merge,"1. Update javadoc on subscribe() blocking if observables are running on the same thread.
2. Add test case with infinity observable.
3. Add test case to unsubscribe() with all observables running in different thread (non-blocking).
",2013-04-04 00:23:56,2013-04-18 17:47:50,https://api.github.com/repos/ReactiveX/RxJava/issues/223,[],481,176,ReactiveX_RxJava_pull_223.diff
ReactiveX/RxJava,Pull issue 43 merge,"Manual merge of https://github.com/Netflix/RxJava/pull/196
",2013-04-03 18:14:15,2013-04-03 18:40:47,https://api.github.com/repos/ReactiveX/RxJava/issues/222,[],148,0,ReactiveX_RxJava_pull_222.diff
ReactiveX/RxJava,Error Handling Improvements - User Provided Observers/Functions,"Improve error handling as per discussion in issue https://github.com/Netflix/RxJava/issues/216

This is by no means exhaustive in the search for places needing this protection but gets the most obvious ones entering via `subscribe` and `forEach`.

The intention is to protect against exceptions being thrown and ensure onNext/onError/onCompleted contract compliance.
",2013-04-01 23:10:21,2013-04-02 05:30:04,https://api.github.com/repos/ReactiveX/RxJava/issues/221,[],393,98,ReactiveX_RxJava_pull_221.diff
ReactiveX/RxJava,TakeWhile protect calls to predicate,"Per RX guideline 6.4, calls to selector functions passed in to the operator should be caught and fed through to the subscribed observer. Operator TakeWhile doesn't do this with the passed in predicate.
",2013-04-01 05:56:42,2013-04-01 17:18:57,https://api.github.com/repos/ReactiveX/RxJava/issues/220,[],38,1,ReactiveX_RxJava_pull_220.diff
ReactiveX/RxJava,Implement ReplaySubject with infinite history,,2013-03-31 06:50:22,2013-04-18 20:21:49,https://api.github.com/repos/ReactiveX/RxJava/issues/218,[],790,125,ReactiveX_RxJava_pull_218.diff
ReactiveX/RxJava,Manual Merge of Pull Request #212,"Manual merge of https://github.com/Netflix/RxJava/pull/212 with small reorganization of 1 file/package.
",2013-03-31 02:53:47,2013-03-31 02:54:17,https://api.github.com/repos/ReactiveX/RxJava/issues/215,[],664,134,ReactiveX_RxJava_pull_215.diff
ReactiveX/RxJava,Merge of Pull #212 for Take/TakeWhile Fixes,"This is a manual merge of https://github.com/Netflix/RxJava/pull/212
",2013-03-31 02:44:34,2013-03-31 02:45:24,https://api.github.com/repos/ReactiveX/RxJava/issues/214,[],1698,139,ReactiveX_RxJava_pull_214.diff
ReactiveX/RxJava,More formal support for Scala,"- This allows for type safety in statically-typed languages
  - This prevents dynamically-typed languages from hooking into rxjava-core.
    -- See #204 for details on code generation for dynamic languages
  - Added Scala implicits into rx.lang.scala.RxImplicits
  - Added tests of most methods on Observable using Scala functions
  - Fixed Scala Gradle/ScalaTest build
",2013-03-28 22:07:41,2013-05-20 21:25:36,https://api.github.com/repos/ReactiveX/RxJava/issues/213,[],629,1254,ReactiveX_RxJava_pull_213.diff
ReactiveX/RxJava,Operation take leaks errors,"The take() operator improperly propagates an error from its source after the count has been exhausted.

Test cases exhibiting the bug attached.
",2013-03-28 04:52:36,2013-03-31 02:54:19,https://api.github.com/repos/ReactiveX/RxJava/issues/212,[],671,141,ReactiveX_RxJava_pull_212.diff
ReactiveX/RxJava,Remove use of JSR 305 and dependency on com.google.code.findbugs,"fixes https://github.com/Netflix/RxJava/issues/192

The library and annotations were being used for trivial reasons so removing the usage so we don't have the dependency.
",2013-03-27 23:31:12,2013-03-27 23:31:20,https://api.github.com/repos/ReactiveX/RxJava/issues/211,[],7,13,ReactiveX_RxJava_pull_211.diff
ReactiveX/RxJava,Implement cache operator,"Returns an Observable that repeats the original Observable sequence to all subscribers.
The source Observable is subscribed to at most once.

When looking into integrating Hystrix and RxJava, the need for this operator became apparent. It appears to be of general use, so should be considered for RxJava core.
",2013-03-27 04:30:37,2013-04-19 03:53:28,https://api.github.com/repos/ReactiveX/RxJava/issues/209,[],470,0,ReactiveX_RxJava_pull_209.diff
ReactiveX/RxJava,Implemented combineLatest semantics,"... at least if I understand them correctly...

This is an attempt at resolving #29
",2013-03-25 19:54:27,2013-03-27 23:18:46,https://api.github.com/repos/ReactiveX/RxJava/issues/207,[],152,103,ReactiveX_RxJava_pull_207.diff
ReactiveX/RxJava,Observable.toList breaks with multiple subscribers,"``` clojure
(let [i1 (Subject/create)
        out (Observable/toList i1)]
    (.subscribe out (partial prn ""first observer""))
    (.subscribe out (partial prn ""second observer""))
    (.subscribe out (partial prn ""third observer""))
    (.onNext i1 1)
    (.onNext i1 2)
    (.onNext i1 3)
    (.onNext i1 4)
    (.onNext i1 5)
    (.onNext i1 6)
    (.onCompleted i1))
```

Output: 

```
""first observer"" [1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 6 6 6]
""second observer"" [1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 6 6 6]
""third observer"" [1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 6 6 6]
```

Should be:

```
""first observer"" [1 2 3 4 5 6]
""second observer"" [1 2 3 4 5 6]
""third observer"" [1 2 3 4 5 6]
```
",2013-03-24 19:26:08,2013-03-27 04:48:52,https://api.github.com/repos/ReactiveX/RxJava/issues/206,[],24,1,ReactiveX_RxJava_pull_206.diff
ReactiveX/RxJava,"Reimplementation of Concat, improved handling of Observable<Observable<T...","...>>.

The old version required all of the Observable<T>s to be generated and buffered
before the concat could begin.  If the outer Observable was asynchronous, items
could be dropped (test added).  The new version passes the test, and does the
best job I could (after examining several possible strategies) of achieving
clear and consistent semantics in accordance with the principle of least
surprise.

(My attempt to fix issue #202)
",2013-03-22 23:26:32,2013-04-18 17:47:51,https://api.github.com/repos/ReactiveX/RxJava/issues/205,[],366,163,ReactiveX_RxJava_pull_205.diff
ReactiveX/RxJava,All Operation Implemented,"Closes issue #21.
",2013-03-21 13:35:00,2013-03-26 20:12:09,https://api.github.com/repos/ReactiveX/RxJava/issues/203,[],195,0,ReactiveX_RxJava_pull_203.diff
ReactiveX/RxJava,Synchronize Observer on OperationMerge,"fix for Merge serialization bug reported in https://github.com/Netflix/RxJava/issues/200

This is necessary because by definition Merge is subscribing to multiple sequences in parallel and is supposed to serialize them into a single Observable.
",2013-03-19 23:22:56,2013-04-02 05:56:16,https://api.github.com/repos/ReactiveX/RxJava/issues/201,[],95,3,ReactiveX_RxJava_pull_201.diff
ReactiveX/RxJava,SubscribeOn/ObserveOn Implementation,"Implementation SubscribeOn #11 and ObserveOn #12 alongside with basic Schedulers implementation #19.
",2013-03-19 18:16:44,2013-04-05 04:34:55,https://api.github.com/repos/ReactiveX/RxJava/issues/199,[],1031,26,ReactiveX_RxJava_pull_199.diff
ReactiveX/RxJava,TakeWhile observables do not properly complete,"See failing test case for an example.

This slipped through the tests because Observable.toObservable uses
Subscription.EMPTY, which means the onCompleted call after all three items
are produced calls the onComplete on the takeWhile observable, which already requested to be unsubscribed. The
undesired behaviour is shown with Observables that use subscriptions
(such as Subject) or inifinite Observables (which is how I ran into
this bug). 

Similar bugs might exist elsewhere for other operations, because most
tests use Observable.toObservable rather than an Observable that uses
subscriptions.

The fix follows Rx.Net
",2013-03-17 21:30:21,2013-03-26 20:08:43,https://api.github.com/repos/ReactiveX/RxJava/issues/197,[],34,2,ReactiveX_RxJava_pull_197.diff
ReactiveX/RxJava,New operation Finally (issue #43),"Hi,

I was looking around for some fun stuff to do for the Netflix Cloud Prize, and I figured I might start by contributing some enhancements to RxJava.

I did my best to match your existing style and practices, but I've doubtless made some mistakes.  If you have time to take a quick look and give me some feedback, I'll accept it gratefully. 

Cheers,
--abliss
",2013-03-17 12:52:21,2013-04-03 18:40:48,https://api.github.com/repos/ReactiveX/RxJava/issues/196,[],148,0,ReactiveX_RxJava_pull_196.diff
ReactiveX/RxJava,Add pointer regarding unit tests as inner classes,"@benjchristensen - If I hadn't stumbled over your respective [pointer](https://github.com/Netflix/RxJava/issues/154#issuecomment-14544894) by chance, I would have asked the same question as Matt Bishop when encountering this README.

Your reasoning for embedding unit tests as inner classes is inspiring (thanks much) and a helpful explanation for those who disagree regardless, so I suggest to promote it accordingly.
",2013-03-14 22:35:05,2013-03-15 02:14:30,https://api.github.com/repos/ReactiveX/RxJava/issues/194,[],8,5,ReactiveX_RxJava_pull_194.diff
ReactiveX/RxJava,Where alias to filter,"PR for #101
",2013-03-13 23:04:06,2013-03-15 17:01:32,https://api.github.com/repos/ReactiveX/RxJava/issues/191,[],92,0,ReactiveX_RxJava_pull_191.diff
ReactiveX/RxJava,update dematerialize so can chain correctly,"Just noticed this when I actually had to chain it.

``` java
Observable<File> saveResult = ....;
```

current:

``` java
Observable<Notification<File>> a = saveResult.materialize().dematerialize();
```

expected:

``` java
Observable<File> a = saveResult.materialize().dematerialize();
```

here is what is happening

``` java
Observable<File> x = saveResult;
Observable<Notification<File>> y = x.materialize();
Observable<Notification<File>> currentResult = y.dematerialize();
Observable<File> expectedResult = Observable.dematerialize(y);
```

workaround is to use static method to get the expected result.

With this change you can chain correctly. Added unit test.

``` java
Observable<Integer> obs = Observable.just(1);
Observable<Integer> chained = obs.materialize().dematerialize();
```

This will be a breaking change. But I think this is the expected way.
",2013-03-13 20:40:56,2013-03-13 20:55:14,https://api.github.com/repos/ReactiveX/RxJava/issues/190,[],15,2,ReactiveX_RxJava_pull_190.diff
ReactiveX/RxJava,Handful of Improvements,"Some improvements made while reviewing code.
- add error handling to VideoExample.groovy so it's a better representation of how onError is used
- handle errors from Func1 failures when subscribe happens
- handle null Subscriptions on 'trusted' functions, not just untrusted
",2013-03-13 05:36:17,2013-03-13 05:36:45,https://api.github.com/repos/ReactiveX/RxJava/issues/189,[],75,18,ReactiveX_RxJava_pull_189.diff
ReactiveX/RxJava,Subscriptions cleanup,"Some things I missed in previous commit and am cleaning up related to https://github.com/Netflix/RxJava/issues/173
",2013-03-12 21:58:21,2013-03-12 21:58:36,https://api.github.com/repos/ReactiveX/RxJava/issues/188,[],22,21,ReactiveX_RxJava_pull_188.diff
ReactiveX/RxJava,Confusing Javadoc for `toObservable(Future)` methods,"https://github.com/Netflix/RxJava/issues/148
",2013-03-12 20:55:25,2013-03-12 20:55:39,https://api.github.com/repos/ReactiveX/RxJava/issues/187,[],4,2,ReactiveX_RxJava_pull_187.diff
ReactiveX/RxJava,Add 'Fragment-Host' to submodules for OSGi,"Based on discussion on issue https://github.com/Netflix/RxJava/issues/154
",2013-03-12 16:50:54,2013-03-12 20:26:54,https://api.github.com/repos/ReactiveX/RxJava/issues/186,[],4,0,ReactiveX_RxJava_pull_186.diff
ReactiveX/RxJava,toIterable() consistent wrapping of errors,"toIterable() now wraps errors reported through the Observable in a (newly created) ObservedException. This allows a catch block to handle only the exceptions that came through the Observable, not catching exceptions thrown by RxJava itself.
",2013-03-12 05:40:35,2013-03-28 17:57:59,https://api.github.com/repos/ReactiveX/RxJava/issues/185,[],102,15,ReactiveX_RxJava_pull_185.diff
ReactiveX/RxJava,Convert 'last' from non-blocking to blocking to match Rx.Net,"Merging pull request https://github.com/Netflix/RxJava/pull/167 which needed manual merging.

Did some other cleanup while in there and added a missing generic 'Object' override.

Thank you @mairbek for doing this work.
",2013-03-12 04:24:24,2013-03-12 04:24:40,https://api.github.com/repos/ReactiveX/RxJava/issues/184,[],113,116,ReactiveX_RxJava_pull_184.diff
ReactiveX/RxJava,Groovy VideoExample improvements,"- Make VideoExample more idiomatic for Groovy based on feedback
- Use the new BooleanSubscription object
",2013-03-12 04:10:30,2013-03-12 04:10:34,https://api.github.com/repos/ReactiveX/RxJava/issues/183,[],20,28,ReactiveX_RxJava_pull_183.diff
ReactiveX/RxJava,Subscriptions utility class and rx.subscriptions package,"https://github.com/Netflix/RxJava/issues/173
",2013-03-12 03:57:26,2013-03-12 03:59:18,https://api.github.com/repos/ReactiveX/RxJava/issues/182,[],110,67,ReactiveX_RxJava_pull_182.diff
ReactiveX/RxJava,Add OSGi manifest headers,"https://github.com/Netflix/RxJava/issues/154

I can't confirm that these work but submitting based on discussion on issue #154.
",2013-03-12 03:31:32,2013-03-12 03:58:33,https://api.github.com/repos/ReactiveX/RxJava/issues/181,[],49,1,ReactiveX_RxJava_pull_181.diff
ReactiveX/RxJava,Formatting and cleanup,,2013-03-12 03:20:39,2013-03-12 03:20:44,https://api.github.com/repos/ReactiveX/RxJava/issues/180,[],436,248,ReactiveX_RxJava_pull_180.diff
ReactiveX/RxJava,Operator GroupBy Pull Request - Review and Refactor,"Refactored version of pull request https://github.com/Netflix/RxJava/pull/176 for issue https://github.com/Netflix/RxJava/issues/51

I would like to avoid delegation if possible since it will mean it needs to be kept in sync with Observable.

This refactored approach allows inheritance without delegation by composing the Observable  inside another operator function. 
",2013-03-11 23:40:31,2013-03-12 03:00:51,https://api.github.com/repos/ReactiveX/RxJava/issues/179,[],290,1,ReactiveX_RxJava_pull_179.diff
ReactiveX/RxJava,Review and Refactor of GetIterator,"Review of pull request https://github.com/Netflix/RxJava/pull/169 for issue https://github.com/Netflix/RxJava/issues/50 along with a simple refactoring to reduce code in Observable.java.
",2013-03-11 21:29:33,2013-03-11 21:30:09,https://api.github.com/repos/ReactiveX/RxJava/issues/178,[],156,58,ReactiveX_RxJava_pull_178.diff
ReactiveX/RxJava,Operator: Dematerialize - review and manual merge,"Manual merge of pull request https://github.com/Netflix/RxJava/pull/174 for issue https://github.com/Netflix/RxJava/issues/37
",2013-03-11 21:14:12,2013-03-11 21:15:10,https://api.github.com/repos/ReactiveX/RxJava/issues/177,[],138,0,ReactiveX_RxJava_pull_177.diff
ReactiveX/RxJava,Implemented GroupBy,"For issue #51.
",2013-03-11 19:45:54,2013-03-12 03:00:52,https://api.github.com/repos/ReactiveX/RxJava/issues/176,[],518,21,ReactiveX_RxJava_pull_176.diff
ReactiveX/RxJava,Dematerialize,"PR for #37

Someone might want to help me with proper unit tests :)
",2013-03-09 17:41:58,2013-03-11 21:14:39,https://api.github.com/repos/ReactiveX/RxJava/issues/174,[],136,0,ReactiveX_RxJava_pull_174.diff
ReactiveX/RxJava,Implemented Defer Operation,"For issue #35.
",2013-03-05 11:27:00,2013-03-11 21:36:46,https://api.github.com/repos/ReactiveX/RxJava/issues/171,[],129,30,ReactiveX_RxJava_pull_171.diff
ReactiveX/RxJava,Implemented GetIterator,"For issue #50.
",2013-03-04 21:07:56,2013-03-11 21:30:00,https://api.github.com/repos/ReactiveX/RxJava/issues/169,[],27,8,ReactiveX_RxJava_pull_169.diff
ReactiveX/RxJava,Implemented Most Recent,"For issue #64.
",2013-03-04 20:58:13,2013-03-11 23:14:41,https://api.github.com/repos/ReactiveX/RxJava/issues/168,[],224,21,ReactiveX_RxJava_pull_168.diff
ReactiveX/RxJava,Reimplemented Last operation,"For issue #57.
",2013-03-04 19:21:15,2013-03-12 04:24:41,https://api.github.com/repos/ReactiveX/RxJava/issues/167,[],93,118,ReactiveX_RxJava_pull_167.diff
ReactiveX/RxJava,Review of Next Operation,"Some changes I made while reviewing https://github.com/Netflix/RxJava/pull/163
",2013-03-01 23:57:06,2013-03-02 21:51:11,https://api.github.com/repos/ReactiveX/RxJava/issues/166,[],399,0,ReactiveX_RxJava_pull_166.diff
ReactiveX/RxJava,Fixed bug in ranges,"Fixed issue #164.
",2013-03-01 19:58:51,2013-03-01 20:00:15,https://api.github.com/repos/ReactiveX/RxJava/issues/165,[],16,1,ReactiveX_RxJava_pull_165.diff
ReactiveX/RxJava,Implemented Next Operation,"New implementation of #66.
",2013-03-01 18:51:59,2013-03-02 07:44:03,https://api.github.com/repos/ReactiveX/RxJava/issues/163,[],288,0,ReactiveX_RxJava_pull_163.diff
ReactiveX/RxJava,Test build of pull request,,2013-02-28 21:28:37,2013-02-28 21:38:48,https://api.github.com/repos/ReactiveX/RxJava/issues/162,[],2,0,ReactiveX_RxJava_pull_162.diff
ReactiveX/RxJava,Added build status badges,"I'm not wild about the icons that CloudBees provides, but it looks fairly straightforward to change them if needed.
",2013-02-28 20:34:06,2013-02-28 20:38:09,https://api.github.com/repos/ReactiveX/RxJava/issues/161,[],8,0,ReactiveX_RxJava_pull_161.diff
ReactiveX/RxJava,Manual merge of mairbek/single Pull #157,"Merging https://github.com/Netflix/RxJava/pull/157 which had conflicts and needed a manual merge.
",2013-02-28 20:33:03,2013-02-28 20:33:24,https://api.github.com/repos/ReactiveX/RxJava/issues/160,[],275,0,ReactiveX_RxJava_pull_160.diff
ReactiveX/RxJava,Implemented LastOrDefault Operator,"For issue #58
",2013-02-28 13:21:39,2013-02-28 19:51:39,https://api.github.com/repos/ReactiveX/RxJava/issues/159,[],148,0,ReactiveX_RxJava_pull_159.diff
ReactiveX/RxJava,Travis CI Configuration,"The project would benefit by having Continuous Integration configured.

I've configured travis-ci for my fork, it could be found at https://travis-ci.org/mairbek/RxJava
",2013-02-28 11:56:48,2013-02-28 21:50:51,https://api.github.com/repos/ReactiveX/RxJava/issues/158,[],6,1,ReactiveX_RxJava_pull_158.diff
ReactiveX/RxJava,Implemented single and singleOrDefault,"For issue #77.
",2013-02-27 21:52:14,2013-02-28 20:33:37,https://api.github.com/repos/ReactiveX/RxJava/issues/157,[],260,0,ReactiveX_RxJava_pull_157.diff
ReactiveX/RxJava,Implemented ToIterable Operation,"For issue #18.

This would allow to implement other blocking methods like `single`, `lastOrDefault` next.
",2013-02-27 16:15:40,2013-02-27 20:29:46,https://api.github.com/repos/ReactiveX/RxJava/issues/156,[],163,8,ReactiveX_RxJava_pull_156.diff
ReactiveX/RxJava,Change target compatibility from 1.5 to 1.6,"https://github.com/Netflix/RxJava/issues/153
",2013-02-22 22:29:03,2013-02-27 05:30:01,https://api.github.com/repos/ReactiveX/RxJava/issues/155,[],1,2,ReactiveX_RxJava_pull_155.diff
ReactiveX/RxJava,Implemented Next Operation,"Fixes issue #66
",2013-02-19 15:54:31,2013-02-27 20:34:24,https://api.github.com/repos/ReactiveX/RxJava/issues/152,[],461,52,ReactiveX_RxJava_pull_152.diff
ReactiveX/RxJava,Implemented TakeUntil operation,"Fixes issue #86
",2013-02-19 13:24:20,2013-03-11 20:38:30,https://api.github.com/repos/ReactiveX/RxJava/issues/151,[],309,23,ReactiveX_RxJava_pull_151.diff
ReactiveX/RxJava,Cleaned up copy-paste in OperationMerge code,,2013-02-19 08:07:35,2013-02-19 18:24:47,https://api.github.com/repos/ReactiveX/RxJava/issues/150,[],2,26,ReactiveX_RxJava_pull_150.diff
ReactiveX/RxJava,Single/SingleOrDefault Operator Implemented,"Fix for issue #77
",2013-02-18 22:44:25,2013-02-19 21:19:40,https://api.github.com/repos/ReactiveX/RxJava/issues/149,[],163,4,ReactiveX_RxJava_pull_149.diff
ReactiveX/RxJava,Operator: forEach,"Issue https://github.com/Netflix/RxJava/issues/45

Related to Pull https://github.com/Netflix/RxJava/pull/131
",2013-02-14 22:58:47,2013-02-15 21:27:54,https://api.github.com/repos/ReactiveX/RxJava/issues/147,[],127,4,ReactiveX_RxJava_pull_147.diff
ReactiveX/RxJava,Merge of Pull #125 for Issue #87 Operator TakeWhile,"Manually merging https://github.com/Netflix/RxJava/pull/125 from @mairbek 
",2013-02-14 21:37:01,2013-02-14 21:41:16,https://api.github.com/repos/ReactiveX/RxJava/issues/146,[],213,22,ReactiveX_RxJava_pull_146.diff
ReactiveX/RxJava,Support 'provided' dependencies in IntelliJ Idea build,"This adds support to the Gradle builds for IntelliJ to import the project and have classpaths set correctly. 

Gradle documentation for these changes: http://www.gradle.org/docs/current/dsl/org.gradle.plugins.ide.idea.model.IdeaModule.html
",2013-02-14 20:25:02,2013-02-14 20:25:09,https://api.github.com/repos/ReactiveX/RxJava/issues/145,[],58,26,ReactiveX_RxJava_pull_145.diff
ReactiveX/RxJava,Used mockito's inOrder to verify ordering instead of hand-written stub,,2013-02-14 16:52:02,2013-02-14 17:19:17,https://api.github.com/repos/ReactiveX/RxJava/issues/144,[],4,35,ReactiveX_RxJava_pull_144.diff
ReactiveX/RxJava,RxJava ErrorHandler Plugin,"https://github.com/Netflix/RxJava/issues/141 Error Handler Plugin
https://github.com/Netflix/RxJava/issues/139 Plugin System
",2013-02-13 00:10:14,2013-02-13 00:10:21,https://api.github.com/repos/ReactiveX/RxJava/issues/142,[],261,5,ReactiveX_RxJava_pull_142.diff
ReactiveX/RxJava,Implemented TakeLast operator,"Fixes issue #85.
",2013-02-12 23:19:45,2013-02-12 23:34:45,https://api.github.com/repos/ReactiveX/RxJava/issues/140,[],205,0,ReactiveX_RxJava_pull_140.diff
ReactiveX/RxJava,Implemented SequenceEqual Operator,"Fixes issue #76

Since there is no direct analogue of `IEqualityComparer` in Java, `Func2<T, T, Boolean>` has been used.
",2013-02-12 22:32:47,2013-02-12 23:25:00,https://api.github.com/repos/ReactiveX/RxJava/issues/138,[],57,0,ReactiveX_RxJava_pull_138.diff
ReactiveX/RxJava,Implemented range operator. Fixes issue #68,,2013-02-10 19:10:54,2013-02-11 17:14:16,https://api.github.com/repos/ReactiveX/RxJava/issues/137,[],122,0,ReactiveX_RxJava_pull_137.diff
ReactiveX/RxJava,Add examples for jbundler and sbt,,2013-02-10 12:43:23,2013-02-11 17:14:55,https://api.github.com/repos/ReactiveX/RxJava/issues/136,[],16,2,ReactiveX_RxJava_pull_136.diff
ReactiveX/RxJava,Idiomatic usage of import in ns macro in rx-examples.,"Reference: [clojure.core docs](http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/ns). 

Thanks!
",2013-02-09 19:37:55,2013-02-09 20:43:05,https://api.github.com/repos/ReactiveX/RxJava/issues/135,[],1,1,ReactiveX_RxJava_pull_135.diff
ReactiveX/RxJava,Adapt Groovy VideoExample to Clojure,"Seems to work.
",2013-02-09 05:42:04,2013-02-09 06:59:43,https://api.github.com/repos/ReactiveX/RxJava/issues/134,[],161,0,ReactiveX_RxJava_pull_134.diff
ReactiveX/RxJava,Various fixes,"- restore performance optimization to reduce wrapping 
- restoring null check removed in recent commit 
",2013-02-08 07:59:27,2013-02-08 07:59:33,https://api.github.com/repos/ReactiveX/RxJava/issues/133,[],221,216,ReactiveX_RxJava_pull_133.diff
ReactiveX/RxJava,Refactoring language tests and examples layout,"- removed rxjava-examples as it was not working having all languages in the same project
- started convention of having /src/examples/ in language-adaptors with first implementation being rxjava-groovy and rxjava-clojure (though the clojure one isn't compiling correctly yet)
- moved language unit tests to actual language rather than via Java to language parsers
",2013-02-08 07:21:18,2013-02-08 07:21:41,https://api.github.com/repos/ReactiveX/RxJava/issues/132,[],358,341,ReactiveX_RxJava_pull_132.diff
ReactiveX/RxJava,Implemented: ForEach,"implement #45.
",2013-02-08 06:35:53,2013-02-15 21:28:40,https://api.github.com/repos/ReactiveX/RxJava/issues/131,[],418,0,ReactiveX_RxJava_pull_131.diff
ReactiveX/RxJava,Code cleanup,"Cleaned up some warnings highlighted by Intellij Idea
",2013-02-07 17:04:00,2013-02-07 17:37:41,https://api.github.com/repos/ReactiveX/RxJava/issues/129,[],6,11,ReactiveX_RxJava_pull_129.diff
ReactiveX/RxJava,Update README,,2013-02-07 07:47:27,2013-02-07 17:37:12,https://api.github.com/repos/ReactiveX/RxJava/issues/127,[],1,1,ReactiveX_RxJava_pull_127.diff
ReactiveX/RxJava,Implemented: TakeWhile,,2013-02-07 00:26:14,2013-02-14 21:40:03,https://api.github.com/repos/ReactiveX/RxJava/issues/125,[],175,17,ReactiveX_RxJava_pull_125.diff
ReactiveX/RxJava,trivial syntax clean-up in scala adaptor,,2013-02-06 23:13:49,2013-02-06 23:15:17,https://api.github.com/repos/ReactiveX/RxJava/issues/124,[],1,1,ReactiveX_RxJava_pull_124.diff
ReactiveX/RxJava,Examples Cleanup,"Some cleanup on builds, particularly rxjava-examples.

I can't add Scala support while retaining Groovy and have it work in Eclipse as the plugins collide. Gradle handles it fine for builds from command-line but editing via text editors and not IDEs is not ideal.

Perhaps the examples should go in the /src/test/ folder (or /src/examples/) of each of the rxjava-[language] projects instead of rxjava-examples?
",2013-02-06 07:09:07,2013-02-06 07:09:16,https://api.github.com/repos/ReactiveX/RxJava/issues/122,[],96,29,ReactiveX_RxJava_pull_122.diff
ReactiveX/RxJava,Minor cleanup of Clojure example.,"Cleaned up some formatting and spacing. Used future-cancel. Future
subscriptions were not being returned properly. Replaced use of #_ with
comment form. Fixed rest args usage for hello example.
",2013-02-06 04:38:49,2013-02-06 05:02:18,https://api.github.com/repos/ReactiveX/RxJava/issues/121,[],144,137,ReactiveX_RxJava_pull_121.diff
ReactiveX/RxJava,Fixing javadocs,"https://github.com/Netflix/RxJava/issues/119
- added correct links to external images
- cleaned up some of the text
- improved some function memoization that was missed
",2013-02-05 21:48:26,2013-02-05 21:48:36,https://api.github.com/repos/ReactiveX/RxJava/issues/120,[],535,635,ReactiveX_RxJava_pull_120.diff
ReactiveX/RxJava,Aligning with internal infrastructure.,,2013-02-02 19:33:43,2013-02-04 17:32:04,https://api.github.com/repos/ReactiveX/RxJava/issues/117,[],9,9,ReactiveX_RxJava_pull_117.diff
ReactiveX/RxJava,Refactor,,2013-01-31 21:26:59,2013-01-31 21:27:04,https://api.github.com/repos/ReactiveX/RxJava/issues/116,[],648,1354,ReactiveX_RxJava_pull_116.diff
ReactiveX/RxJava,more examples,,2013-01-31 18:35:08,2013-01-31 18:35:14,https://api.github.com/repos/ReactiveX/RxJava/issues/115,[],234,2,ReactiveX_RxJava_pull_115.diff
ReactiveX/RxJava,Examples,"Start of ""How to Use"" examples in Clojure, Groovy and Java.
",2013-01-29 21:47:13,2013-01-29 21:47:20,https://api.github.com/repos/ReactiveX/RxJava/issues/114,[],535,14,ReactiveX_RxJava_pull_114.diff
ReactiveX/RxJava,Concat,,2013-01-29 19:49:35,2013-01-31 18:28:19,https://api.github.com/repos/ReactiveX/RxJava/issues/113,[],346,0,ReactiveX_RxJava_pull_113.diff
ReactiveX/RxJava,Examples Submodule,"new submodule for showing examples in various languages
",2013-01-25 06:24:11,2013-01-25 06:24:16,https://api.github.com/repos/ReactiveX/RxJava/issues/112,[],66,5,ReactiveX_RxJava_pull_112.diff
ReactiveX/RxJava,IDE Support,,2013-01-25 04:50:47,2013-01-25 04:50:53,https://api.github.com/repos/ReactiveX/RxJava/issues/111,[],15,1,ReactiveX_RxJava_pull_111.diff
ReactiveX/RxJava,Build fix,"Getting RxJava to build all of the LanguageAdaptor sub modules correctly.

Upgraded to Gradle 1.3 and made changes to rxjava-scala build file.
",2013-01-25 04:22:27,2013-01-25 04:22:34,https://api.github.com/repos/ReactiveX/RxJava/issues/110,[],21,2,ReactiveX_RxJava_pull_110.diff
ReactiveX/RxJava,Creating toObservable for Future,"simple wrapper that turns a future into a observable.
",2013-01-23 20:32:50,2013-01-31 18:08:37,https://api.github.com/repos/ReactiveX/RxJava/issues/109,[],143,0,ReactiveX_RxJava_pull_109.diff
ReactiveX/RxJava,Adding a draft of Subject class,"https://github.com/Netflix/RxJava/issues/19
",2013-01-23 20:29:55,2013-01-31 18:09:16,https://api.github.com/repos/ReactiveX/RxJava/issues/108,[],170,5,ReactiveX_RxJava_pull_108.diff
ReactiveX/RxJava,Performance: Reduce synchronization,"Performance changes as part of https://github.com/Netflix/RxJava/issues/104 and is an extension of work done in pull https://github.com/Netflix/RxJava/pull/106.

This code was used to test the performance:

``` java
    public void runCompositionTest(Integer[] values) {
        System.out.println(""runCompositionTest"");

        final AtomicInteger onNextSum = new AtomicInteger(0);
        final long start = System.nanoTime();

        MathFunction m = new MathFunction();
        // 50 levels of composition (same function so that's not the cost)
        Observable.from(values)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)
                .subscribe(new TestObserver(onNextSum, start));
    }
```

Before it took:

```
Sum: 710082754 Time: 60.605ms
```

By reducing the nested synchronization (eliminating most of it) it is now running at:

```
Sum: 710082754 Time: 22.429ms
```
",2013-01-22 23:48:48,2013-01-22 23:49:16,https://api.github.com/repos/ReactiveX/RxJava/issues/107,[],893,712,ReactiveX_RxJava_pull_107.diff
ReactiveX/RxJava,Performance optimizations for dynamic function execution.,"- memoize dynamic function constructions so executions are statically typed after a single dynamic lookup instead of dynamic on every execution

https://github.com/Netflix/RxJava/issues/104
",2013-01-22 03:07:00,2013-01-22 03:12:38,https://api.github.com/repos/ReactiveX/RxJava/issues/106,[],491,144,ReactiveX_RxJava_pull_106.diff
ReactiveX/RxJava,Performance optimizations.,"- memoize dynamic function constructions so executions are statically typed after a single dynamic lookup instead of dynamic on every execution
- use chained observable to reduce composition costs (execute list of functions rather than compositionally invoking onNext)
",2013-01-21 22:24:31,2013-01-22 03:07:30,https://api.github.com/repos/ReactiveX/RxJava/issues/105,[],491,144,ReactiveX_RxJava_pull_105.diff
ReactiveX/RxJava,Scala adaptor,,2013-01-17 01:11:46,2013-01-17 01:12:16,https://api.github.com/repos/ReactiveX/RxJava/issues/27,[],226,1,ReactiveX_RxJava_pull_27.diff
ReactiveX/RxJava,Refactoring,"- convert to rx.\* package names
  - rx.observables
  - rx.observables.operations (private package from javadocs)
  - rx.util
  - rx.lang
  - rx.concurrency (placeholder for schedulers)
- change Func order to have return type at end => T, R instead of R, T
  - this matches the C# and Guava conventions
- added Action as Func without return value
  - added overload subscribe methods with Action typed arguments
- added from() alias methods in Observable
",2013-01-16 20:33:59,2013-01-16 20:34:20,https://api.github.com/repos/ReactiveX/RxJava/issues/6,[],573,342,ReactiveX_RxJava_pull_6.diff
ReactiveX/RxJava,Support multiple class types for language adaptors,,2013-01-15 20:40:30,2013-01-15 21:47:27,https://api.github.com/repos/ReactiveX/RxJava/issues/5,[],29,24,ReactiveX_RxJava_pull_5.diff
ReactiveX/RxJava,remove 'wrap' functionality,"We no longer need this as we've merged the interface and abstract classes together and don't need to ensure we have the abstract class.
",2013-01-12 19:21:52,2013-01-12 19:22:01,https://api.github.com/repos/ReactiveX/RxJava/issues/4,[],31,57,ReactiveX_RxJava_pull_4.diff
ReactiveX/RxJava,Clojure adaptor,,2013-01-11 19:08:30,2013-01-11 19:08:36,https://api.github.com/repos/ReactiveX/RxJava/issues/3,[],148,10,ReactiveX_RxJava_pull_3.diff
ReactiveX/RxJava,Language adaptors,"Includes Groovy and JRuby
",2013-01-11 00:26:29,2013-01-11 00:26:34,https://api.github.com/repos/ReactiveX/RxJava/issues/2,[],1344,241,ReactiveX_RxJava_pull_2.diff
ReactiveX/RxJava,Refactoring conventions,,2013-01-10 21:33:28,2013-01-10 21:33:34,https://api.github.com/repos/ReactiveX/RxJava/issues/1,[],4589,4650,ReactiveX_RxJava_pull_1.diff
